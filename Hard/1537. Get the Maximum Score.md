# 🧩 Problem: Get the Maximum Score  
## 🔢 Number: LeetCode 1537  
**Difficulty**: Hard  
**Language**: C#  

---

## 📜 Problem Overview

We are given two sorted arrays `nums1` and `nums2` of distinct integers.  
We must traverse one of the arrays from left to right, collecting values into a path.  
At any point, if we encounter a value that exists in both arrays, we may switch to the other array — but only at that shared value.

The score of a path is the sum of all values collected.  
We must return the **maximum possible score** from any valid path, modulo \(10^9 + 7\).

---

### 🔢 Constraints
- `1 ≤ nums1.length, nums2.length ≤ 10⁵`  
- `1 ≤ nums1[i], nums2[i] ≤ 10⁷`  
- Both arrays are strictly increasing  
- Values are distinct within each array

---

### 🎁 What’s Given
- Two sorted arrays: `nums1[]` and `nums2[]`  
- We can switch between arrays only at common values  
- We must compute the maximum score from all valid paths

---

### 👀 What We Observe
- Arrays are sorted → two-pointer traversal is natural  
- Switching is allowed only at common values  
- We must accumulate sums from each side and choose the best path  
- This is a **greedy + bottom-up tabulation** problem  
- DP is possible but overkill — greedy with two pointers is optimal

---

## 🧠 Explanation

We use **two pointers** to traverse both arrays simultaneously.  
We maintain two running sums: `sum1` for `nums1`, and `sum2` for `nums2`.

At each step:
- If `nums1[i] < nums2[j]`, we add `nums1[i]` to `sum1` and move `i`  
- If `nums1[i] > nums2[j]`, we add `nums2[j]` to `sum2` and move `j`  
- If `nums1[i] == nums2[j]`, we:
  - Take the **maximum of `sum1` and `sum2`**, add the shared value  
  - Reset both sums to this new total  
  - Move both pointers forward

At the end, we add the remaining values from each array to their respective sums, and return the maximum of the two.

---

## ⚙️ Algorithm Choice
- **Approach**: Two pointers + greedy accumulation  
- **Why**: Sorted arrays, switching only at common values  
- **Efficiency**: O(n + m) time, O(1) space  
- **Memory**: No extra structures needed

---

## 💡 Idea Summary
- Traverse both arrays with two pointers  
- Accumulate scores separately  
- Switch paths only at common values  
- At each switch, take the max accumulated score  
- Return the final maximum score modulo \(10^9 + 7\)

---

## 🧾 Code
```csharp
public class Solution {
    public int MaxSum(int[] nums1, int[] nums2) {
        int i = 0, j = 0;
        long sum1 = 0, sum2 = 0;
        long MOD = 1000000007;

        while (i < nums1.Length && j < nums2.Length) {
            if (nums1[i] < nums2[j]) {
                sum1 += nums1[i++];
            } else if (nums1[i] > nums2[j]) {
                sum2 += nums2[j++];
            } else {
                long maxSum = Math.Max(sum1, sum2) + nums1[i];
                sum1 = maxSum;
                sum2 = maxSum;
                i++;
                j++;
            }
        }

        while (i < nums1.Length) {
            sum1 += nums1[i++];
        }

        while (j < nums2.Length) {
            sum2 += nums2[j++];
        }

        return (int)(Math.Max(sum1, sum2) % MOD);
    }
}
```

---

## ✅ Complexity, Insights & Notes

### ⏱ Time Complexity
- **O(n + m)** — single pass through both arrays

### 🧠 Space Complexity
- **O(1)** — constant space, only accumulators and pointers

---

### 🧨 Tricks / Insights
- Switching only at common values avoids path duplication  
- Taking `max(sum1, sum2)` ensures optimal path selection  
- Greedy works here because values are strictly increasing  
- No need for recursion or DP — bottom-up accumulation is sufficient

---

### 🧠 Notes
- This is a hybrid of **greedy + two-pointer traversal**  
- Related to problems involving:
  - **Merging sorted arrays**  
  - **Path optimization with constraints**  
  - **Dynamic switching between sources**  
- Can be extended to weighted graphs or multi-source traversal logic



---

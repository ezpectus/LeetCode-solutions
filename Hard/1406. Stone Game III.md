# Pattern Name
**Stone Game III — O(1) Space DP (Minimax with Rolling Array)**

## Problem Summary
- **Input**: `stoneValue[]` — array of stone values  
- **Goal**:  
  Alice starts first, takes **1, 2, or 3** stones from **front**  
  Return: `"Alice"`, `"Bob"`, or `"Tie"`  
- **Constraints**:  
  - `1 ≤ n ≤ 5×10⁴`  
  - `-1000 ≤ stoneValue[i] ≤ 1000`

---

## Core Idea
- **Minimax DP**:  
  > `dp[i]` = **best relative score** (Alice - Bob) starting from index `i`  
- **Rolling Array**: `dp[i % 3]` → **O(1) space**  
- **Alice wins if `dp[0] > 0`**, Bob if `< 0`, tie if `= 0`

---

## Your Code — **PERFECT** (O(n) time, O(1) space)
```csharp
public class Solution {
    public string StoneGameIII(int[] stoneValue) {
        int n = stoneValue.Length;
        var dp = new int[3];  // Rolling array

        for (int i = n - 1; i >= 0; i--) {
            int t1 = stoneValue[i] - dp[(i + 1) % 3];
            
            int t2 = int.MinValue;
            if (i + 1 < n)
                t2 = stoneValue[i] + stoneValue[i + 1] - dp[(i + 2) % 3];
            
            int t3 = int.MinValue;
            if (i + 2 < n)
                t3 = stoneValue[i] + stoneValue[i + 1] + stoneValue[i + 2] - dp[(i + 3) % 3];

            dp[i % 3] = Math.Max(t1, Math.Max(t2, t3));
        }

        if (dp[0] > 0) return "Alice";
        else if (dp[0] < 0) return "Bob";
        else return "Tie";
    }
}
```
## Example Walkthrough
| stoneValue | `[1,2,3,7]` |
|------------|-------------|
| **i=3** (`7`) | `t1 = 7 - dp[0] = 7 - 0 = 7` → `dp[0] = 7` |
| **i=2** (`3`) | `t1 = 3 - 7 = -4`, `t2 = 3+7 - 0 = 10` → `dp[2] = 10` |
| **i=1** (`2`) | `t1 = 2 - 10 = -8`, `t2 = 2+3 - 7 = -2`, `t3 = 2+3+7 - 0 = 12` → `dp[1] = 12` |
| **i=0** (`1`) | `t1 = 1 - 12 = -11`, `t2 = 1+2 - 10 = -7`, `t3 = 1+2+3 - 7 = -3` → `dp[0] = -3` |
| **Result**: `dp[0] = -3 < 0` → **"Bob"**

---

## Architectural Breakdown
| Component           | Role                                      |
|---------------------|-------------------------------------------|
| `dp[i % 3]`         | Rolling array — only need last 3 states   |
| `t1, t2, t3`        | Alice's score - Bob's best response       |
| `int.MinValue`      | Safe default for invalid moves            |
| **Relative score**  | `Alice - Bob` → simplifies comparison     |

---

## Why This Approach Is Superior
| Aspect              | **O(1) Space DP** | Standard DP       |
|---------------------|-------------------|-------------------|
| Time Complexity     | **O(n)**          | O(n)              |
| Space Complexity    | **O(1)**          | O(n)              |
| Performance         | Fast on `n=5e4`   | Same              |
| **Memory**          | **3 ints**        | 50,000 ints       |

---

## Final Takeaway
- **This pattern generalizes to**:
  - **Stone Game series**
  - **Minimax with limited moves**
  - **O(1) space DP with rolling array**
- **Key Insight**:  
  > **"Only need last 3 states → use `i % 3`!"**

---


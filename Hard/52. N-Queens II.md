# ðŸ§  N-Queens II â€” Backtracking Solution in C#

## ðŸ“Œ Problem Statement

Given an integer `n`, return the number of distinct solutions to the **N-Queens** problem â€” placing `n` queens on an `n x n` chessboard such that no two queens attack each other.

Each queen can attack horizontally, vertically, and diagonally. The goal is to count all valid configurations where no two queens threaten each other.

---

## ðŸ§± Core Idea

This is a **pure backtracking** problem â€” a recursive depth-first search with pruning.

We build the solution **row by row**, trying to place a queen in each column of the current row. Before placing, we check whether the position is safe using three constraint sets:

- `cols` â€” tracks occupied columns  
- `diag1` â€” tracks diagonals from top-left to bottom-right (`row + col`)  
- `diag2` â€” tracks diagonals from top-right to bottom-left (`row - col`)  

These sets allow **constant-time conflict detection**.

### âœ… Valid Configuration

A configuration is valid when:
- No two queens share the same column
- No two queens share the same diagonal
- All `n` queens are placed successfully (i.e., `row == n`)

Each time we reach a valid configuration, we increment a counter.

---

## ðŸ”§ C# Implementation
```cpp
public class Solution {
    public int TotalNQueens(int n) {
        int count = 0;
        Backtrack(0, n, new HashSet<int>(), new HashSet<int>(), new HashSet<int>(), ref count);
        return count;
    }

    private void Backtrack(int row, int n, HashSet<int> cols, HashSet<int> diag1, HashSet<int> diag2, ref int count) {
        if (row == n) {
            count++;
            return;
        }

        for (int col = 0; col < n; col++) {
            if (cols.Contains(col) || diag1.Contains(row + col) || diag2.Contains(row - col))
                continue;

            // Place queen
            cols.Add(col);
            diag1.Add(row + col);
            diag2.Add(row - col);

            // Move to next row
            Backtrack(row + 1, n, cols, diag1, diag2, ref count);

            // Remove queen (backtrack)
            cols.Remove(col);
            diag1.Remove(row + col);
            diag2.Remove(row - col);
        }
    }
}
```

## ðŸ§© Time and Space Complexity

| Metric              | Complexity | Explanation |
|---------------------|------------|-------------|
| **Time Complexity** | `O(n!)`    | In the worst case, we explore all permutations of queen placements. Each row has up to `n` choices, but due to pruning (conflict checks), the actual number is much lower. Still, the theoretical upper bound remains factorial. |
| **Space Complexity**| `O(n)`     | We use three `HashSet<int>` structures to track columns and diagonals, each with at most `n` entries. The recursion stack also goes up to depth `n`, so total space is linear in `n`. |

---

## âœ… Why This Works

- **Recursive Backtracking** builds the solution row by row, exploring only valid paths.
- **Early Pruning** eliminates invalid placements before deeper recursion, saving time.
- **Constraint Sets** (`cols`, `diag1`, `diag2`) allow constant-time conflict checks.
- **No Board State Needed** â€” we donâ€™t store full layouts, only count valid configurations.
- **Stateless Traversal** â€” each recursive call modifies and restores state cleanly, ensuring correctness and isolation.

---

## ðŸ§  Optional Enhancements

For small boards (`n â‰¤ 9`), this solution is clean, readable, and fast.  
However, for larger values of `n`, performance can degrade due to:

- **Memory overhead** from `HashSet` operations  
- **Recursive depth** and call stack pressure  
- **Redundant conflict checks**

### ðŸ”§ Bitmask Optimization (for `n â‰¤ 32`)
Replace `HashSet<int>` with integer bitmasks:
- Use bitwise operations to track columns and diagonals
- Achieve `O(1)` conflict checks with minimal memory
- Reduce GC pressure and improve cache locality

### ðŸ§  Example Bitmask Strategy
```csharp
int columns = 0;
int diag1 = 0;
int diag2 = 0;
// Use bitwise AND/OR/XOR to check and update constraints
```
This approach is especially useful in competitive programming or high-performance environments.

## ðŸ§± Summary
- The current solution balances clarity and efficiency for small n. 
- For larger boards or performance-critical applications, bitmasking offers a scalable upgrade.


---

# 🎯 Zuma Game — Full Breakdown & C++ DFS Solution

---

## 📘 Problem Summary

You are given:

- A string `board` representing a row of colored balls  
- A string `hand` representing balls you can insert

Your goal is to **clear the board completely** by inserting balls from your hand. Rules:

- You can insert any ball from your hand at any position  
- If 3 or more consecutive balls of the same color appear → they are removed  
- This removal may trigger **chain reactions** — continue until no more groups exist  
- You win if the board becomes empty  
- You lose if you run out of balls and the board is not empty

Return the **minimum number of insertions** needed to win. If impossible, return `-1`.

---

## 🔍 What We See in the Problem Text

- Chain reactions are allowed — one removal may trigger another  
- You must find the **minimum number of insertions**  
- You must simulate the game mechanics precisely  
- The board is small (≤ 16), hand is tiny (≤ 5) — so **DFS is feasible**  
- This is a **state-space search** with pruning and memoization

---

## 🧠 Core Idea

This is a **recursive DFS with memoization**, where each state is defined by:

- Current `board`  
- Current `hand` (as a frequency vector)

### 🔁 Phase 1 — DFS Search

- Try inserting each ball from hand into every position on the board  
- Only insert if it’s **worth trying** (can trigger or extend a group)  
- After insertion, **reduce the board** by removing 3+ consecutive balls  
- Recurse into the new state  
- Track the minimum number of insertions across all valid paths

### 🔧 Phase 2 — Board Reduction

- After each insertion, scan the board for groups of 3+ same-colored balls  
- Remove them and repeat until no more reductions are possible  
- This simulates **chain reactions**

### 🧠 Phase 3 — Memoization

- Store results for `(board, hand)` pairs to avoid recomputation  
- Use a serialized key to unify equivalent hand states  
- Prune paths where hand is empty but board is not

---

## 💻 C++ Implementation (Fully Stabilized)

```cpp
class Solution {
public:
   int findMinStep(string board, string hand) {
	vector<int> freq(26, 0);
	for(char c: hand)
		freq[c - 'A']++;
	unordered_map<string, int> cache;
	return dfs(board, freq, cache);
}

int dfs(string board, vector<int>& freq, unordered_map<string, int>& cache) {
    string key = board + "#" + serialize(freq);
	if(cache.count(key)) {
        return cache[key];
    }
	int r = INT_MAX;
	if(board.length() == 0) {           
		r = 0;
	} else {
		for(int i = 0; i < board.length(); i++) {    
			for(int j = 0; j < freq.size(); j++) {     
                bool worthTrying = false;
                if(board[i] - 'A' == j)
                    worthTrying = true;
                else if(0 < i && board[i] == board[i - 1] && board[i] - 'A' != j) 
                    worthTrying = true;
                    
				if(freq[j] > 0 && worthTrying) {     
					board.insert(board.begin() + i, j + 'A');  
					freq[j]--;   

					string newStr = updateBoard(board);  
					int steps = dfs(newStr, freq, cache);   
					if(steps != -1) {   
						r = min(r, steps + 1);
					}

					freq[j]++; 
					board.erase(board.begin() + i);   
				}
			}
		}
	}
	if(r == INT_MAX) r = -1; 
	cache[key] = r;
	return r;
}

string updateBoard(string board) {
	 int start = 0;
	 int end = 0; 
	 int boardLen = board.length();
	 while(start < boardLen) {
		 while(end < boardLen && board[start] == board[end]) {
			 end++;  
		 }
		
		 if(end - start >= 3) {  
			 string newBoard = board.substr(0, start) + board.substr(end); 
			 return updateBoard(newBoard);    
		 } else {
			 start = end;
		 }
	 }
	 return board;
}

string serialize(vector<int>& freq) {
    string key = "";
    for(int i = 0; i < freq.size(); i++) {
        if(freq[i] > 0)
        key += to_string((char) i + 'A') + to_string(freq[i]);
    }
    return key;
   }  
};


```

## ⏱️ Time and Space Complexity

This solution performs a **recursive search over all valid insertion paths**, using aggressive pruning and memoization to remain efficient.

| Complexity Type     | Expression     | Detailed Explanation                                                                 |
|---------------------|----------------|--------------------------------------------------------------------------------------|
| **Time Complexity** | O(H! × B²)     | H = hand length (≤ 5), B = board length (≤ 16). DFS explores permutations of hand insertions and simulates board reduction after each move. |
| **Space Complexity**| O(H! × B)      | Memoization stores unique (board, hand) states. The board shrinks via chain reactions, and hand is compact. |

### ⚙️ Why this remains practical:

- The input size is small and bounded  
- Board reduction aggressively collapses state space  
- Memoization prevents redundant recomputation  
- Insertion logic prunes unproductive paths early  
- Hand is encoded canonically, reducing state duplication

This makes the exponential search **tractable and scalable** in practice.

---

## 🧱 Architectural Signals

| Signal                 | Role in Solution                                                                 |
|------------------------|----------------------------------------------------------------------------------|
| **DFS traversal**       | Explores all insertion paths recursively, simulating game turns                 |
| **Board reduction**     | Models chain reactions after each insertion, collapsing consecutive groups      |
| **Memoization**         | Stores previously computed states to avoid redundant recursion                  |
| **Hand frequency map**  | Tracks available balls and prevents illegal insertions                          |
| **State encoding**      | Combines board and hand into a canonical key for memoization lookup             |

### 🔄 Signal Interactions

- **Phase separation**:  
  - Each move triggers:  
    → Insertion  
    → Reduction  
    → Recursive descent  
  - Phases are modular and cleanly isolated

- **State integrity**:  
  - Memoization ensures no duplicate paths  
  - Hand tracking prevents invalid insertions  
  - Canonical encoding unifies equivalent states

- **Scalability**:  
  - Despite exponential branching, pruning and reduction keep the search space compact  
  - Chain reactions accelerate board collapse  
  - Hand size and board length are tightly bounded

Together, these signals form a **recursive simulation pipeline**, where each insertion leads to a reduced board and a new recursive call — all under strict architectural control.

---

## 🧠 Summary

This problem exemplifies a **recursive state-space simulation**, where game mechanics are modeled as transitions between compressed states.

### 🧩 What you simulate:

- Insertions at strategic positions  
- Chain reactions triggered by 3+ consecutive balls  
- Recursive transitions between board states  
- Minimal action paths that lead to complete board clearance

### ✅ What you master:

- **DFS with state compression** — encode board + hand as a unique, canonical state  
- **Chain reaction modeling** — simulate cascading deletions with structural collapse  
- **Memoization in recursive search** — cache results for efficiency and pruning  
- **Game simulation and minimal action recovery** — find optimal paths through dynamic transitions

This architecture is:

- **Modular** — each phase is isolated and reusable  
- **Scalable** — exponential space is controlled via pruning and reduction  
- **Reusable** — applicable to other game-like simulations, minimal-edit problems, and recursive recovery tasks

Perfect for building **simulation engines**, **minimal transformation solvers**, and **recursive optimizers** in constrained environments.


---

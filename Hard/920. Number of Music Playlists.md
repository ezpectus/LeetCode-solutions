# 920. Number of Music Playlists

---

## Problem Restatement
We have `n` different songs and want to create a playlist of length `goal`.  
Rules:
- Every song must be played at least once.  
- A song can only be repeated if at least `k` other songs have been played since its last occurrence.  
We need to count the number of valid playlists modulo `10^9 + 7`.

---

## Key Idea
This is a **Dynamic Programming** problem.

- Define `dp[i][j]` = number of playlists of length `i` using exactly `j` unique songs.  
- Transition:
  1. **Add a new song:**  
     - Choose one of the `(n - (j - 1))` unused songs.  
     - Extend playlist of length `i-1` with `j-1` unique songs.  
     ```
     dp[i][j] += dp[i-1][j-1] * (n - (j - 1))
     ```
  2. **Reuse an old song:**  
     - Choose one of the `(j - k)` songs that are allowed to repeat.  
     - Extend playlist of length `i-1` with `j` unique songs.  
     ```
     dp[i][j] += dp[i-1][j] * (j - k)
     ```
- Base case: `dp[0][0] = 1`.  
- Answer: `dp[goal][n]`.

---

## Code (C#)
```csharp
public class Solution {
    public int NumMusicPlaylists(int n, int goal, int k) {
        const int MOD = 1000000007;
        long[,] dp = new long[goal + 1, n + 1];
        dp[0,0] = 1;

        for (int i = 1; i <= goal; i++) {
            for (int j = 1; j <= n; j++) {
                // Case 1: Add a new song
                dp[i,j] = (dp[i-1,j-1] * (n - (j - 1))) % MOD;

                // Case 2: Reuse an old song
                if (j > k) {
                    dp[i,j] = (dp[i,j] + dp[i-1,j] * (j - k)) % MOD;
                }
            }
        }

        return (int)dp[goal,n];
    }
}
```


## Complexity
- **Time:** O(n × goal), because we fill a DP table of size `goal × n`.  
- **Space:** O(n × goal), storing DP states for each combination of playlist length and unique songs used.  

---

## Example Walkthrough

**Input:** `n = 3, goal = 3, k = 1`  
- All 3 songs must be used.  
- Only permutations of 3 songs are valid.  
- Total = 3! = 6 ✅  

**Input:** `n = 2, goal = 3, k = 0`  
- Songs can repeat immediately.  
- All possible sequences of length 3 using 2 songs are valid.  
- Total = 6 ✅  

**Input:** `n = 2, goal = 3, k = 1`  
- Must alternate songs because repetition requires at least 1 different song in between.  
- Valid playlists: `[1,2,1]` and `[2,1,2]`.  
- Total = 2 ✅  

---

## Why This Works
- The DP state `dp[i][j]` captures the number of playlists of length `i` using exactly `j` unique songs.  
- Transition rules:  
  - **Add a new song:** choose from unused songs.  
  - **Reuse an old song:** choose from already used songs that respect the `k` gap.  
- This ensures every playlist is counted exactly once and respects the constraints.  

---

## Conclusion
The DP solution builds playlists step by step:
- Either add a new song.  
- Or reuse an old song (respecting the `k` gap).  

This guarantees correctness and efficiency for `n, goal ≤ 100`, making it practical for the given constraints.


---

# 282. Expression Add Operators (Hard)

---

##  Problem Restatement
We are given a string `num` containing only digits and an integer `target`.  
We must return all possible expressions formed by inserting the operators `+`, `-`, and `*` between digits of `num` such that the expression evaluates to `target`.  

Constraints:  
- Operands must not contain leading zeros.  
- Operands can have multiple digits.  
- `1 <= num.length <= 10`  
- `-2^31 <= target <= 2^31 - 1`

---

##  Core Idea
This is a **backtracking problem**:
- At each step, choose a split of digits into the next operand.  
- Recursively try adding operators before the operand.  
- Track the current expression string, the evaluated value so far, and the last operand (to handle multiplication precedence).  
- When the entire string is consumed, check if the evaluated value equals `target`.

---

##  Step-by-Step Concept
1. **Recursive DFS/backtracking:**  
   - Iterate over possible splits of `num` into operands.  
   - Skip operands with leading zeros.  
   - For each operand, try adding `+`, `-`, or `*` before it (except for the first operand).  

2. **Tracking evaluation:**  
   - Maintain `currentValue` (total so far).  
   - Maintain `lastOperand` (to correctly apply multiplication).  
   - For `*`, adjust by removing last operand and adding `(lastOperand * currentOperand)`.

3. **Termination:**  
   - If all digits are used and `currentValue == target`, add expression to results.

---

##  Implementation (C#)

```csharp
public class Solution {
    public IList<string> AddOperators(string num, int target) {
        var result = new List<string>();
        Backtrack(result, num, target, "", 0, 0, 0);
        return result;
    }

    private void Backtrack(List<string> result, string num, int target,
                           string expr, int pos, long eval, long last) {
        if (pos == num.Length) {
            if (eval == target) result.Add(expr);
            return;
        }

        for (int i = pos; i < num.Length; i++) {
            // Skip leading zeros
            if (i != pos && num[pos] == '0') break;

            string part = num.Substring(pos, i - pos + 1);
            long curr = long.Parse(part);

            if (pos == 0) {
                Backtrack(result, num, target, part, i + 1, curr, curr);
            } else {
                Backtrack(result, num, target, expr + "+" + part, i + 1, eval + curr, curr);
                Backtrack(result, num, target, expr + "-" + part, i + 1, eval - curr, -curr);
                Backtrack(result, num, target, expr + "*" + part, i + 1,
                          eval - last + last * curr, last * curr);
            }
        }
    }
}
```


##  Time Complexity
- **Worst case:**  
  - `O(4^n)` because each digit split can branch into three operators (`+`, `-`, `*`) plus concatenation.  
- **Pruning effect:**  
  - Skipping operands with leading zeros reduces the actual runtime.  
- **Overall:**  
  - Exponential in `n`, but manageable since `n <= 10`.

---

##  Space Complexity
- **Recursion depth:**  
  - At most `O(n)` since each digit can be split once.  
- **Result storage:**  
  - Depends on the number of valid expressions found.  
- **Overall:**  
  - `O(n)` auxiliary space plus output size.

---

#  Impact of Design Choices

| Choice                   | Effect                                                                 |
|---------------------------|------------------------------------------------------------------------|
| **Backtracking recursion** | Systematically explores all possible operator insertions.              |
| **Tracking `lastOperand`** | Correctly handles multiplication precedence without full re-evaluation. |
| **Skipping leading zeros** | Ensures operands are valid (no `"05"`).                                |
| **String building per step** | Maintains clean and correct expression construction.                  |

---

#  Pitfalls
- **Leading zeros:** Forgetting to skip them → invalid operands like `"05"`.  
- **Multiplication precedence:** Not handled → wrong evaluation results.  
- **Integer overflow:** Must use `long` for intermediate calculations.  
- **Base case:** Missing check when `pos == num.Length` → incomplete recursion termination.

---

#  Conclusion
- **What it gives:** All valid expressions that evaluate to the target value.  
- **Why it matters:** Demonstrates backtracking with operator precedence and pruning.  
- **Key takeaway:**  
  1. Use DFS/backtracking to explore splits.  
  2. Track evaluation and last operand for multiplication.  
  3. Skip leading zeros to ensure valid operands.  
  4. Collect expressions only when evaluation matches target.  

---



# 2334. Subarray With Elements Greater Than Varying Threshold

## Problem Summary

Given an integer array `nums` and an integer `threshold`,  
find any subarray of length `k` such that **every element in the subarray is greater than `threshold / k`**.

Return the size of any such subarray.  
If no such subarray exists, return `-1`.

---

## Core Idea

This is a **range minimum + constraint check** problem.  
We need to find a subarray of length `k` where the **minimum element** satisfies:  
`min > threshold / k`

Instead of checking every subarray, we reverse the logic:  
For each `nums[i]`, we ask:  
> On what interval is `nums[i]` the minimum, and can it satisfy the condition?

---

## Architectural Strategy

Use a **monotonic stack** to find the range where each `nums[i]` is the minimum.

### Step-by-step plan:

1. For each index `i`, find:
   - `left[i]` — nearest index to the left where `nums[j] < nums[i]`
   - `right[i]` — nearest index to the right where `nums[j] < nums[i]`
2. This gives the interval `[left[i] + 1, right[i] - 1]` where `nums[i]` is the minimum.
3. Compute `length = right[i] - left[i] - 1`
4. Check if `nums[i] > threshold / length`
5. If yes — return `length`

This avoids brute-force and gives a clean `O(n)` solution.

---

## C# Implementation

```csharp
public class Solution {
    public int ValidSubarraySize(int[] nums, int threshold) {
        int n = nums.Length;
        int[] left = new int[n], right = new int[n];
        Array.Fill(left, -1);
        Array.Fill(right, n);

        Stack<int> stack = new();

        // Prefix: nearest smaller to the left
        for (int i = 0; i < n; i++) {
            while (stack.Count > 0 && nums[stack.Peek()] >= nums[i])
                stack.Pop();
            if (stack.Count > 0) left[i] = stack.Peek();
            stack.Push(i);
        }

        stack.Clear();

        // Suffix: nearest smaller to the right
        for (int i = n - 1; i >= 0; i--) {
            while (stack.Count > 0 && nums[stack.Peek()] >= nums[i])
                stack.Pop();
            if (stack.Count > 0) right[i] = stack.Peek();
            stack.Push(i);
        }

        // Check each interval
        for (int i = 0; i < n; i++) {
            int len = right[i] - left[i] - 1;
            if (nums[i] > threshold / len)
                return len;
        }

        return -1;
    }
}
```

## Complexity Analysis

**Time Complexity**:
- `O(n)` for building prefix and suffix boundaries via monotonic stack
- `O(n)` for final validation pass over all intervals
- **Total**: `O(n)` — fully linear

**Space Complexity**:
- `O(n)` for `left[]` and `right[]` boundary arrays
- `O(n)` for stack used in both passes
- **Total**: `O(n)`

---

## Architectural Notes

- **Monotonic stack** efficiently finds nearest smaller elements in one pass per direction
- Each `nums[i]` is treated as a **candidate minimum**, and its interval is derived from its left/right boundaries
- We only check intervals where `nums[i]` is **guaranteed to dominate** — no need to validate every element
- The condition `nums[i] > threshold / len` is **safe and sufficient** because `nums[i]` is the smallest in its interval
- **Early return** ensures we stop at the first valid subarray, avoiding unnecessary checks

---

## Additional Architectural Insight

- This approach transforms a **global constraint** into a **local check** around each element
- Instead of scanning all subarrays, we **invert the logic**:  
  → “If this element is the minimum, what’s the longest interval it can dominate?”
- The use of `left[]` and `right[]` is a classic **range-minimum framing**, often seen in histogram problems
- The final check is **pure arithmetic** — no traversal, no nested loops, no dynamic programming
- This module is **fully reusable** for any problem involving threshold-based subarray validation



---

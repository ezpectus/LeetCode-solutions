# üß† 3448. Count Substrings Divisible By Last Digit ‚Äî Signal-Based Architecture

## üìú Problem Statement

You are given a string `s` consisting of digits (`0‚Äì9`).  
Return the number of substrings `s[i..j]` such that:

- The last digit of the substring is `d = s[j]`
- `d ‚â† 0` (division by zero is invalid)
- The entire substring `s[i..j]` is divisible by `d`

Leading zeros are allowed.

---

## üîç Signal Recognition Table

| Last Digit | Divisibility Check Method                          | Reasoning                                  |
|------------|----------------------------------------------------|--------------------------------------------|
| `1`, `2`, `5` | Add `i + 1` directly                             | Any number ending in these digits is divisible by them |
| `3`, `6`, `9` | Use digit sum tracking via `sums[]`              | Divisibility by 3/6/9 depends on digit sum |
| `4`, `8`      | Check last 2‚Äì3 digits using `prev`, `prev2`      | Divisibility by 4/8 depends on last digits |
| `7`           | Track remainders using `s7[]`                    | No shortcut ‚Äî requires mod tracking        |
| `0`           | Skip                                             | Division by zero is undefined              |

---

## üß† Mental Flow Summary

- Treat each digit as the **end** of a substring  
- Use **signal-based logic** to count valid substrings ending at that digit  
- Avoid brute-force substring generation ‚Äî too slow for large inputs  
- Track **modular states** using `sums[]` (for digit sums) and `s7[]` (for mod 7 remainders)  
- Maintain recent digits (`prev`, `prev2`) to handle divisibility by 4 and 8  
- Optimize per digit using **known divisibility rules** ‚Äî each digit has its own signal

---

## üß© My Rewritten C# Code

```csharp
public class Solution {
    public long CountSubstrings(string s) {
        long total = 0;
        int n = s.Length;

        long[] sums = new long[10];
        long[] s7 = new long[7];
        int prev = 0;
        int prev2 = 0;

        for (int i = 0; i < n; i++) {
            int num = s[i] - '0';

            sums = UpdateSums(sums, num);
            s7 = UpdateS7(s7, num);

            if (num == 1 || num == 2 || num == 5) {
                total += i + 1;
            } else if (num == 3 || num == 6) {
                total += sums[3] + sums[6] + sums[9];
            } else if (num == 9) {
                total += sums[9];
            } else if (num == 4) {
                total++;
                if ((prev + num) % 4 == 0) total += i;
            } else if (num == 8) {
                total++;
                if ((prev + num) % 8 == 0) total++;
                if ((prev2 + prev + num) % 8 == 0) total += i - 1;
            } else if (num == 7) {
                total += s7[0];
            }

            prev2 = prev * 10;
            prev = num * 10;
        }

        return total;
    }

    long[] UpdateSums(long[] sums, int num) {
        long[] sums2 = new long[10];
        for (int i = 0; i < 10; i++) {
            if (sums[i] > 0) {
                int sum = i + num;
                if (sum > 9) sum = (sum % 10) + 1;
                sums2[sum] += sums[i];
            }
        }
        sums2[num]++;
        return sums2;
    }

    long[] UpdateS7(long[] s7, int num) {
        long[] s72 = new long[7];
        for (int i = 0; i < 7; i++) {
            if (s7[i] > 0) {
                int s = (i * 10 + num) % 7;
                s72[s] = s7[i];
            }
        }
        s72[num % 7]++;
        return s72;
    }
}

```
## ‚úÖ Conclusion

This solution leverages digit-specific divisibility rules and modular tracking to efficiently count valid substrings without brute-force generation. 
Each digit acts as a signal, guiding how substrings ending with it are evaluated.

The approach is:

- Architecturally clear  
- Signal-driven  
- Scalable and reusable across similar problems  
- Easy to explain, debug, and extend  

What started as a routine task turned out to be a high-signal problem ‚Äî perfectly suited for structural reasoning and modular pattern extraction.
It now lives as part of the system, ready to support future substring-based challenges.


---

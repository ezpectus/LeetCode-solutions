##  1250. Check If It Is a Good Array  
**GCD Aggregation — Linear Combination via Bézout**

---

###  Problem  
You're given an array `nums` of positive integers.  
You can select any subset of `nums`, multiply each element by any integer (positive or negative), and sum the results.  
The array is considered **good** if it's possible to obtain a total sum of `1` using this method.

---

###  Pattern  
This is a classic number theory filter based on **Bézout's identity**:

- If the **greatest common divisor (GCD)** of all elements in `nums` is `1`,  
  then there exists a set of integer coefficients such that:  
  `a₁ * x₁ + a₂ * x₂ + ... + aₙ * xₙ = 1`  
- In other words, if `gcd(nums) == 1`, then it's possible to construct `1` as a linear combination  
- If `gcd > 1`, then `1` is not divisible by the GCD, and it's impossible to form it

---

###  Algorithm Breakdown  
1. Initialize `g = nums[0]`  
2. Iterate through the array: `g = gcd(g, nums[i])`  
3. If final `g == 1`, return `true`  
4. Otherwise, return `false`

---

###  Code (C++)

```cpp
class Solution {
public:
    bool isGoodArray(vector<int>& nums) {
        int g = nums[0];
        for (int i = 1; i < nums.size(); ++i)
            g = GCD(g, nums[i]);
        return g == 1;
    }

private:
    int GCD(int a, int b) {
        while (b != 0) {
            int t = b;
            b = a % b;
            a = t;
        }
        return a;
    }
};
```
###  Complexity

| Metric | Value |
|--------|-------|
| Time   | O(n) — single pass GCD |
| Space  | O(1) — constant space |

---

###  Pitfalls & Fixes

| Issue                             | Fix                                                  |
|----------------------------------|-------------------------------------------------------|
| Checking all subset combinations | Use global GCD instead — no need to brute-force      |
| Overcomplicating with recursion or DP | Just aggregate GCD across the array              |
| Ignoring Bézout's identity       | Remember: `gcd == 1` ⇔ linear combination to 1 is possible |

---

###  Insight

This is a pure number theory filter.  
It doesn't require recursion, dynamic programming, or subset enumeration.  
It relies entirely on the mathematical fact that:

- If the GCD of all numbers is 1,  
- Then it's possible to form 1 using integer linear combinations  
- Otherwise, it's impossible

This stems directly from **Bézout's identity**, which guarantees that any set of integers whose GCD is 1 can be linearly combined (with integer coefficients) to produce 1.  
So instead of searching for subsets or trying combinations, we simply compute the GCD of the entire array and check if it's equal to 1.

---

###  Fichka Library Entry

**Number Theory / GCD**  
> Check if array can form 1 via integer linear combination — aggregate GCD


---

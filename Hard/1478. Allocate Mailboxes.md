# 1478. Allocate Mailboxes  
*O(n² × k) — Classic Dynamic Programming on Sorted Positions*

---

## Problem Statement

You are given an array `houses` of distinct integers representing house positions on a street, and an integer `k` (number of mailboxes to place).

Place **exactly k** mailboxes on the street (at any integer positions) to minimize the **total distance** from each house to its **nearest** mailbox.

Return this **minimum total distance**.

**Examples**:

**Example 1**: houses = [1,4,8,10,20], k = 3  
Output: **5**  
Optimal: mailboxes at 3, 9, 20  
Distances: |1-3| + |4-3| + |8-9| + |10-9| + |20-20| = 2+1+1+1+0 = 5

**Example 2**: houses = [2,3,5,12,18], k = 2  
Output: **9**  
Optimal: mailboxes at 3, 14  
Distances: |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 1+0+2+2+4 = 9

**Constraints**:
- 1 ≤ k ≤ houses.length ≤ 100
- 1 ≤ houses[i] ≤ 10⁴
- All houses[i] are **unique**

---

## Core Idea — DP on Sorted Houses + Optimal Mailbox Placement

**Key insights**:
- Sort the houses first (order matters, positions are on a line)
- Optimal mailbox positions are always at **house positions** (median minimizes sum of distances)
- For a group of houses from index i to j, the **optimal single mailbox** is at the **median** house → cost is sum of |house[x] - median|
- Problem reduces to **partitioning** the sorted houses into **k non-empty contiguous groups**, minimizing sum of costs of each group

**DP state**:
- `dp[i][j]` = minimum cost to cover first `i` houses using exactly `j` mailboxes

**Recurrence**:
```dp[i][j] = min over m (j-1 ≤ m < i): dp[m][j-1] + cost(m+1 to i)```
where `cost(l to r)` = cost of placing one mailbox optimally for houses[l..r] (0-based)

**Cost function**:
- For a range [l, r], place mailbox at median house → sum |houses[x] - houses[median]| for x in [l,r]
- Since n ≤ 100, we can precompute all possible range costs in O(n²)

**Total time**: O(n² × k) ≈ 100² × 100 = 1 million operations — very fast

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MinDistance(int[] houses, int k) {
        int n = houses.Length;
        Array.Sort(houses);

        // Precompute cost[l][r] = min cost to cover houses[l..r] with 1 mailbox
        int[,] cost = new int[n, n];
        for (int l = 0; l < n; l++) {
            for (int r = l; r < n; r++) {
                int median = houses[(l + r) / 2];
                int sum = 0;
                for (int i = l; i <= r; i++) {
                    sum += Math.Abs(houses[i] - median);
                }
                cost[l, r] = sum;
            }
        }

        // DP: dp[i][j] = min cost to cover first i houses with j mailboxes
        int[,] dp = new int[n + 1, k + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                dp[i, j] = int.MaxValue / 2;
            }
        }

        dp[0, 0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= Math.Min(i, k); j++) {
                for (int m = j - 1; m < i; m++) {
                    // Place j-th mailbox to cover houses[m..i-1]
                    if (dp[m, j - 1] != int.MaxValue / 2) {
                        dp[i, j] = Math.Min(dp[i, j], dp[m, j - 1] + cost[m, i - 1]);
                    }
                }
            }
        }

        return dp[n, k];
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n² × k)**         | Precomputing all possible range costs: O(n³) but n ≤ 100 → ~1 million operations  
DP transitions: O(n² × k) ≈ 100² × 100 = 1 million operations  
Total: **~2 million operations** — very fast in practice |
| **Space Complexity**  | **O(n²)**             | Cost table: O(n²) ≈ 10,000 entries  
DP table: O(n × k) ≈ 10,000 entries  
Total: ~20,000 integers — very small memory footprint |

**Optimal** — polynomial time and quadratic space — perfectly acceptable and very efficient given n ≤ 100 and k ≤ 100.

---

## Why This Works — Example Walkthrough

**Example 1**: houses = [1,4,8,10,20], k = 3

After sorting: [1,4,8,10,20]

**Optimal placement** (found by DP):
- Mailbox 1 covers houses [1,4] → placed at median 4, cost = |1-4| + |4-4| = **3**
- Mailbox 2 covers houses [8,10] → placed near median (9), cost = |8-9| + |10-9| = **2**
- Mailbox 3 covers house [20] → placed at 20, cost = **0**

Total cost = 3 + 2 + 0 = **5** → correct

**How DP finds it**:
- DP tries **all possible ways** to partition the sorted array into exactly 3 contiguous groups
- For each group [l..r], it uses the **precomputed optimal cost** (placing mailbox at median)
- It selects the partitioning that gives the minimum total cost
- The optimal split turns out to be: [0..1], [2..3], [4..4] → cost 3+2+0 = 5

**Correct** —  
After sorting, the problem reduces to **partitioning the sorted positions into k contiguous segments**.  
Each segment is optimally covered by placing one mailbox at its **median** (minimizes sum of absolute deviations).  
DP efficiently finds the best partitioning by trying all possible split points.

---

## Key Takeaway

This is a **classic dynamic programming + optimal median placement** problem:

* **Sort** the house positions first (essential for contiguous grouping on a line)
* **Precompute** cost[l][r] = minimum cost to cover houses[l..r] with **one** mailbox  
  (place at median → sum of absolute deviations from median)
* **DP[i][j]** = minimum cost to cover the **first i houses** using **exactly j mailboxes**
* **Transition**:  
  dp[i][j] = min over m (j-1 ≤ m < i): dp[m][j-1] + cost[m][i-1]
* Final answer = **dp[n][k]**

**Pure, clean, optimal** — O(n² × k) time, O(n²) space, extremely fast for n ≤ 100 and k ≤ 100, very elegant once the median insight is seen.

---

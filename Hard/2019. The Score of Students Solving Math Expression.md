# LeetCode 2019 — The Score of Students Solving Math Expression
**Approach: Interval DP for all possible parenthesizations + correct precedence evaluation**

---

##  Problem restatement
Given an expression `s` of single-digit numbers with `+` and `*`, and a list of submitted `answers`, grade each:
- Correct answer (usual precedence: `*` first left-to-right, then `+`) → 5 points.
- If not correct, but obtainable by some valid parenthesization (with correct arithmetic) → 2 points.
- Otherwise → 0 points.
Return the total points.

---

##  Core idea
- Compute the **correct answer** under normal precedence:
  - Evaluate all multiplications left-to-right within segments, then sum segments.
- Compute the **set of all possible results** from the expression using **any parenthesization**:
  - Interval DP where `dp[i][j]` is a set of all results from numbers `i..j`.
  - Combine subintervals using the operator between them.
  - Keep only results within `[0, 1000]` to control blow-up (as per constraints).
- Grade each submission:
  - If equals correct → +5.
  - Else if in `dp[0][n-1]` → +2.
  - Else → +0.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int ScoreOfStudents(string s, int[] answers) {
        // Parse numbers and operators
        List<int> nums = new List<int>();
        List<char> ops = new List<char>();
        for (int i = 0; i < s.Length; i++) {
            char c = s[i];
            if (c == '+' || c == '*') ops.Add(c);
            else nums.Add(c - '0');
        }
        int m = nums.Count;

        // 1) Correct answer under normal precedence: '*' first (left-to-right), then '+'
        int correct = EvaluateWithPrecedence(nums, ops);

        // 2) All possible results with any parenthesization (interval DP), bounded to [0, 1000]
        var allResults = AllPossibleResults(nums, ops);

        // 3) Grade answers
        int score = 0;
        foreach (int a in answers) {
            if (a == correct) score += 5;
            else if (allResults.Contains(a)) score += 2;
        }
        return score;
    }

    private int EvaluateWithPrecedence(List<int> nums, List<char> ops) {
        // Compute products of segments split by '+', then sum
        int sum = 0;
        int cur = nums[0];
        for (int i = 0; i < ops.Count; i++) {
            if (ops[i] == '*') {
                cur *= nums[i + 1];
            } else { // '+'
                sum += cur;
                cur = nums[i + 1];
            }
        }
        sum += cur;
        return sum;
    }

    private HashSet<int> AllPossibleResults(List<int> nums, List<char> ops) {
        int n = nums.Count;
        var dp = new HashSet<int>[n, n];

        for (int i = 0; i < n; i++) {
            dp[i, i] = new HashSet<int> { nums[i] };
        }

        for (int len = 2; len <= n; len++) {
            for (int i = 0; i + len - 1 < n; i++) {
                int j = i + len - 1;
                var set = new HashSet<int>();
                for (int k = i; k < j; k++) {
                    var left = dp[i, k];
                    var right = dp[k + 1, j];
                    char op = ops[k]; // operator between nums[k] and nums[k+1]
                    foreach (int a in left) {
                        foreach (int b in right) {
                            long val = op == '+' ? (long)a + b : (long)a * b;
                            if (val >= 0 && val <= 1000) set.Add((int)val);
                        }
                    }
                }
                dp[i, j] = set;
            }
        }
        return dp[0, n - 1];
    }
}
```



##  Time Complexity
- **Parsing and correct evaluation:**  
  Linear scan of the string to separate digits and operators, then compute correct precedence result.  
  → `O(n)`.

- **Interval DP:**  
  - DP table has `O(n^2)` intervals.  
  - Each interval requires splitting at `k` → `O(n)` splits.  
  - For each split, combine sets of possible results.  
  - Worst case → `O(n^3 * S)` where `S` is average set size.  
  - With constraints (`n ≤ 16`, values bounded to `[0, 1000]`), this remains practical.

- **Overall:**  
  → `O(n^3 * S)` but efficient in practice due to small `n`.

---

##  Space Complexity
- **DP table of sets:**  
  Each interval stores a set of possible results.  
  - Maximum size per set ≤ `1001` (bounded by value range).  
  - Total → `O(n^2 * U)` where `U ≤ 1001`.  

- **Additional structures:**  
  - Prefix parsing arrays → `O(n)`.  
  - HashSet for all results → `O(U)`.  

- **Overall:**  
  → `O(n^2 * U)`.

---

#  Impact of Design Choices

| Design Choice                                | Effect                                                                 |
|----------------------------------------------|------------------------------------------------------------------------|
| **Precedence evaluation for correct answer** | Deterministic, linear-time computation of the true result.             |
| **Interval DP with sets**                    | Captures all valid parenthesizations, modeling “wrong order but correct arithmetic.” |
| **Bounding results to [0, 1000]**            | Prevents combinatorial explosion, ensures feasible runtime and memory. |

---

#  Pitfalls
- **Operator index alignment:**  
  Must ensure `ops[k]` corresponds to operation between `nums[k]` and `nums[k+1]`.  
- **Unbounded DP results:**  
  Without clipping to `[0, 1000]`, sets may grow uncontrollably.  
- **Mixing evaluation strategies:**  
  Correct answer must be computed separately from DP-generated results to avoid confusion.  

---

#  Conclusion
- **What it gives:** Accurate grading by distinguishing correct results from plausible mis-parenthesized results.  
- **Why it matters:** Faithfully models student mistakes while ensuring performance under constraints.  
- **Key takeaway:**  
  1. Compute correct result with precedence.  
  2. Generate all parenthesized outcomes via interval DP.  
  3. Score: 5 for correct, 2 for in-set, else 0.  



---

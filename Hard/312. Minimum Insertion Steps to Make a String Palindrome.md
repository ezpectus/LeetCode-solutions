# 1312. Minimum Insertion Steps to Make a String Palindrome  
*O(n²) — Longest Palindromic Subsequence (LPS) Dynamic Programming*

---

## Problem Statement

- Given a string `s` of lowercase English letters.
- You can **insert** any character at any position in `s` in one step.
- Return the **minimum number of insertions** needed to make `s` a **palindrome**.

**Examples**:

**Example 1**  
Input: s = "zzazz"  
Output: **0**  
Already a palindrome — no insertions needed

**Example 2**  
Input: s = "mbadm"  
Output: **2**  
Possible results: "mbdadbm" or "mdbabdm"

**Example 3**  
Input: s = "leetcode"  
Output: **5**  
One possible result: "leetcodocteel"

**Constraints**:
- 1 ≤ s.length ≤ 500
- s consists of lowercase English letters

---

## Core Idea — Minimum Insertions = n - Length of Longest Palindromic Subsequence

**Beautiful observation**:
- To make a string a palindrome with minimum insertions, we want to **keep as many characters as possible** in their positions while adding the missing symmetric characters.
- The characters we keep must form a **palindromic subsequence** of the original string.
- The **minimum insertions** = total length n − length of the **longest palindromic subsequence** (LPS) in s

**Why?**  
- LPS is the longest sequence we can keep without changing order.
- For every character we don't keep, we need to **insert its mirror** somewhere to make it symmetric.
- But since we can insert anywhere, the number of insertions equals the number of characters we couldn't keep.

**Algorithm**:
1. Compute the length of the **longest palindromic subsequence** in `s` (classic DP)
2. Return `n - LPS_length`

**Standard LPS DP**:
```text
dp[i][j] = length of LPS in substring s[i..j]

Base:
dp[i][i] = 1

Transition:
if s[i] == s[j]:
    dp[i][j] = dp[i+1][j-1] + 2
else:
    dp[i][j] = max(dp[i+1][j], dp[i][j-1])
```

## Clean Implementation (C#)
```cpp
public class Solution{
    public int MinInsertions(string s){
        int n = s.Length;

        // dp[i][j] = length of longest palindromic subsequence in s[i..j]
        int[,] dp = new int[n, n];

        // Single character is palindrome of length 1
        for (int i = 0; i < n; i++){
            dp[i, i] = 1;
        }

        // Fill dp table for lengths from 2 to n
        for (int len = 2; len <= n; len++){
            for (int i = 0; i <= n - len; i++){
                int j = i + len - 1;

                if (s[i] == s[j]) dp[i, j] = dp[i + 1, j - 1] + 2;
                else dp[i, j] = Math.Max(dp[i + 1, j], dp[i, j - 1]);
                
            }
        }

        // Longest palindromic subsequence length
        int lps = dp[0, n - 1];

        // Minimum insertions = total length - LPS length
        return n - lps;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n²)**     | Standard LPS dynamic programming table fill — O(n²) |
| **Space Complexity**  | **O(n²)**     | DP table of size n×n (can be optimized to O(n) using two rolling arrays or even O(1) extra space with careful implementation) |

**Optimal** — quadratic time and quadratic space — perfectly acceptable and efficient for n ≤ 500 (n² = 250 000 operations, very fast in practice).

---

## Why This Works — Example Walkthrough

**Example 1**: s = "zzazz"

- Longest palindromic subsequence (LPS) = "zzazz" (length 5)
- n = 5
- Minimum insertions = 5 − 5 = **0** → correct (already palindrome)

**Example 2**: s = "mbadm"

- One possible LPS = "madam" (length 3) or "mdm" etc.
- n = 5
- Minimum insertions = 5 − 3 = **2** → correct  
  Example: insert 'd' and 'b' → "mbdadbm" (palindrome)

**Example 3**: s = "leetcode"

- One possible LPS = "ete" (length 3)
- n = 8
- Minimum insertions = 8 − 3 = **5** → correct  
  Example: insert "codoc" → "leetcodocteel" (palindrome)

**Correct** —  
The **minimum number of insertions** required to make a string a palindrome is exactly equal to the number of characters that **cannot** be included in any longest palindromic subsequence.  
Each character not part of the LPS needs a matching character to be **inserted** somewhere to make the string symmetric.

---

## Key Takeaway

This is a **beautiful reduction** to the **longest palindromic subsequence (LPS)** problem:

* The **minimum insertions** to make a string a palindrome =  
  **length of string (n)** − **length of its longest palindromic subsequence**

* Compute LPS length using standard DP:
  - `dp[i][j]` = length of LPS in substring `s[i..j]`
  - Base: `dp[i][i] = 1`
  - Transition:
    - If `s[i] == s[j]` → `dp[i][j] = dp[i+1][j-1] + 2`
    - Else → `dp[i][j] = max(dp[i+1][j], dp[i][j-1])`

* Final answer = `n - dp[0][n-1]`
**Pure, clean, optimal** — O(n²) time, O(n²) space (can be optimized to O(n) space), very fast for n ≤ 500, elegant, and mathematically precise.

---

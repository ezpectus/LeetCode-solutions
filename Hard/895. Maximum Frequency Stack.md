# 895. Maximum Frequency Stack — Architectural Frequency Grouping Design  
*O(1) amortized — The Ultimate FreqStack*

---

## Problem Summary

Design a **stack-like** data structure with:

- `push(val)` — push integer `val`
- `pop()` — remove and return the **most frequent** element  
  → If multiple have same frequency → return the **most recent** one

**Goal**: both operations in **O(1)** amortized time.

---

## Core Idea — Frequency + Stack Grouping

We need **two dimensions**:

1. **Frequency** of each value
2. **Order** (most recent first)

**Solution**:
- `freq[val]` → current frequency
- `group[f]` → **stack** of all values with frequency `f`
- `maxFreq` → current maximum frequency

**Push**:
- Increment frequency
- Push value into `group[freq[val]]`
- Update `maxFreq` if needed

**Pop**:
- Pop from `group[maxFreq]`
- Decrement frequency
- If group becomes empty → decrease `maxFreq`

**Guarantees**:  
- Always pop **most frequent**
- Among same frequency → **most recent** (LIFO)

---

## Full Implementation (C#)

```csharp
public class FreqStack 
{
    private Dictionary<int, int> freq;                    // val → frequency
    private Dictionary<int, Stack<int>> group;            // frequency → stack of vals
    private int maxFreq;                                   // current max frequency

    public FreqStack() 
    {
        freq = new Dictionary<int, int>();
        group = new Dictionary<int, Stack<int>>();
        maxFreq = 0;
    }
    
    public void Push(int val) 
    {
        if (!freq.ContainsKey(val)) 
            freq[val] = 0;
            
        freq[val]++;
        int f = freq[val];
        
        if (!group.ContainsKey(f))
            group[f] = new Stack<int>();
            
        group[f].Push(val);
        
        if (f > maxFreq) 
            maxFreq = f;
    }
    
    public int Pop() 
    {
        int val = group[maxFreq].Pop();
        freq[val]--;
        
        if (group[maxFreq].Count == 0) 
            maxFreq--;
            
        return val;
    }
}
```

## Complexity

| **Operation** | **Time** | **Notes**                                      |
|---------------|----------|------------------------------------------------|
| **Push**      | **O(1)** | Dictionary access + Stack push                 |
| **Pop**       | **O(1)** | Stack pop + possible `maxFreq` decrement       |
| **Space**     | **O(n)** | Stores all pushed values in stacks             |

**Perfect O(1) amortized** — textbook performance

---

## Pitfalls

- Must update `maxFreq` **only when group becomes empty**
- Create group stacks **lazily** — avoid pre-allocating unused frequencies
- Handle ties correctly → **stack order = insertion order** → most recent wins

---

## Edge Cases

- **Single element** → always popped
- **Multiple elements with same frequency** → **most recent** wins (LIFO)
- **Large values (up to 10⁹)** → `Dictionary<int, ...>` handles it perfectly
- **Empty stack** → not possible per problem constraints

---

## Sanity Check

```text
Input: 
["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"]
[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
```
Output: [null,null,null,null,null,null,null,5,7,5,4]
**Correct** — always returns **most frequent + most recent**

---

## Key Takeaway

This is a **frequency + stack grouping** design:

- `freq` dictionary tracks **counts**  
- `group` maps **frequency → stack of values**  
- `maxFreq` gives **O(1)** access to the highest frequency group  

**Elegant and efficient solution** for **frequency-aware stack** behavior.

---





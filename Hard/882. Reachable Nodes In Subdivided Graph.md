# LeetCode 882 — Reachable Nodes In Subdivided Graph  
**Approach: Dijkstra’s Algorithm + Edge Contribution Counting**

---

##  Problem Restatement
We have an undirected weighted graph with `n` nodes.  
Each edge `[u, v, cnt]` is subdivided into `cnt` new nodes, forming a chain of length `cnt + 1`.  
We start at node `0` and can make at most `maxMoves` steps.  
We need to count how many nodes (original + subdivided) are reachable.

---

##  Core Idea
- Treat each edge `[u, v, cnt]` as having weight `cnt + 1`.  
- Use **Dijkstra’s algorithm** to compute shortest distances from node `0` to all original nodes.  
- Count reachable nodes:  
  1. **Original nodes:** If `dist[node] ≤ maxMoves`, node is reachable.  
  2. **Subdivided nodes on edges:**  
     - From `u`, we can reach up to `max(0, maxMoves - dist[u])` new nodes along edge.  
     - From `v`, similarly.  
     - Total reachable on edge = `min(cnt, reachFromU + reachFromV)`.  
- Sum original reachable nodes + reachable subdivided nodes.

---

## Implementation (C#)

```csharp
public class Solution {
    public int ReachableNodes(int[][] edges, int maxMoves, int n) {
        // Build adjacency list with weights (cnt+1)
        var graph = new List<(int,int)>[n];
        for (int i = 0; i < n; i++) graph[i] = new List<(int,int)>();
        foreach (var e in edges) {
            int u = e[0], v = e[1], cnt = e[2];
            graph[u].Add((v, cnt + 1));
            graph[v].Add((u, cnt + 1));
        }

        // Dijkstra’s algorithm
        var dist = new long[n];
        Array.Fill(dist, long.MaxValue);
        dist[0] = 0;
        var pq = new PriorityQueue<(int node, long d), long>();
        pq.Enqueue((0, 0), 0);

        while (pq.Count > 0) {
            var (u, d) = pq.Dequeue();
            if (d > dist[u]) continue;
            foreach (var (v, w) in graph[u]) {
                long nd = d + w;
                if (nd < dist[v]) {
                    dist[v] = nd;
                    pq.Enqueue((v, nd), nd);
                }
            }
        }

        long ans = 0;

        // Count reachable original nodes
        for (int i = 0; i < n; i++) {
            if (dist[i] <= maxMoves) ans++;
        }

        // Count reachable subdivided nodes on edges
        foreach (var e in edges) {
            int u = e[0], v = e[1], cnt = e[2];
            long reachU = dist[u] > maxMoves ? 0 : maxMoves - dist[u];
            long reachV = dist[v] > maxMoves ? 0 : maxMoves - dist[v];
            ans += Math.Min(cnt, reachU + reachV);
        }

        return (int)ans;
    }
}
```

##  Time Complexity
- **Dijkstra’s algorithm:**  
  - Each edge is processed at most once.  
  - Using a priority queue, complexity is `O((n + m) log n)` where `m = edges.Length`.  
- **Edge contribution counting:**  
  - Each edge contributes at most once.  
  - Complexity: `O(m)`.  
- **Total complexity:**  
  - `O((n + m) log n)`, efficient for `n ≤ 3000` and `m ≤ 10^4`.

---

##  Space Complexity
- **Graph adjacency list:** `O(n + m)` to store all nodes and edges.  
- **Distance array:** `O(n)` for shortest path distances.  
- **Priority queue:** `O(n)` for Dijkstra’s processing.  
- **Total space:** `O(n + m)` overall.

---

#  Impact of Design Choices

| Design Choice                  | Effect                                                                 |
|--------------------------------|------------------------------------------------------------------------|
| **Dijkstra’s algorithm**       | Finds shortest paths efficiently even with large edge weights.         |
| **Edge contribution formula**  | Avoids explicit expansion of subdivided nodes, saving memory and time. |
| **Priority queue**             | Ensures efficient extraction of the next closest node.                 |

---

#  Pitfalls

- **Expanding subdivided nodes explicitly:**  
  - Each edge can have up to `10^4` subdivisions → memory blowup.  
- **Forgetting subdivided nodes:**  
  - Leads to undercounting reachable nodes.  
- **Using BFS instead of Dijkstra:**  
  - BFS fails with weighted edges since it assumes uniform cost.  
- **Integer overflow:**  
  - Distances can exceed `10^9`; must use `long` instead of `int`.

---

#  Conclusion

- **What it gives:** Efficiently counts reachable nodes in subdivided graph without explicit expansion.  
- **Why it matters:** Handles large constraints (`n ≤ 3000`, `cnt ≤ 10^4`, `maxMoves ≤ 10^9`).  
- **Key takeaway:**  
  1. Use Dijkstra to compute shortest distances.  
  2. Count reachable original nodes.  
  3. Count reachable subdivided nodes via edge contribution formula.  

This approach is clean, scalable, and avoids exponential blowup by combining shortest path computation with combinatorial edge analysis.



---


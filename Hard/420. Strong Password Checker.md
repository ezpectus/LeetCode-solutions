# Pattern Name  
Greedy Password Correction with Category and Repeat Constraints

---

## Problem Summary

You are given a string `s`.  
A password is considered strong if:

- It has length between **6 and 20**  
- It contains **at least one lowercase**, **one uppercase**, and **one digit**  
- It does **not contain three repeating characters in a row**

In one step, you can:

- Insert one character  
- Delete one character  
- Replace one character

Return the **minimum number of steps** required to make the password strong.

---

## Core Idea

This is a **greedy correction** problem with three constraints:

- **Category quota**: lowercase, uppercase, digit  
- **Repeat quota**: no 3+ identical characters in a row  
- **Length bounds**: must be within [6, 20]

We track:

- `missingTypes` — number of missing character categories  
- `replace` — number of replacements needed to break repeats  
- `deleteCount` — number of deletions needed to reduce length  
- `ones`, `twos` — mod-3 buckets for greedy deletion strategy

---

## Transition Logic

```text
If length < 6:
    return max(missingTypes, 6 - length)

If length > 20:
    deleteCount = length - 20
    Apply deletions to reduce replace:
        replace -= min(deleteCount, ones)
        replace -= min(max(deleteCount - ones, 0), twos * 2) / 2
        replace -= max(deleteCount - ones - twos * 2, 0) / 3
    return deleteCount + max(missingTypes, replace)

Else:
    return max(missingTypes, replace)
```


## C# Implementation
```cpp
public class Solution {
    public int StrongPasswordChecker(string s) {
        int missingTypes = 3;
        if (s.Any(char.IsLower)) missingTypes--;
        if (s.Any(char.IsUpper)) missingTypes--;
        if (s.Any(char.IsDigit)) missingTypes--;

        int replace = 0, ones = 0, twos = 0;
        for (int i = 0; i < s.Length;) {
            int len = 1;
            while (i + len < s.Length && s[i + len] == s[i + len - 1]) len++;
            if (len >= 3) {
                replace += len / 3;
                if (len % 3 == 0) ones++;
                else if (len % 3 == 1) twos++;
            }
            i += len;
        }

        if (s.Length < 6)
            return Math.Max(missingTypes, 6 - s.Length);

        int deleteCount = s.Length - 20;
        replace -= Math.Min(deleteCount, ones);
        replace -= Math.Min(Math.Max(deleteCount - ones, 0), twos * 2) / 2;
        replace -= Math.Max(deleteCount - ones - twos * 2, 0) / 3;

        return deleteCount + Math.Max(missingTypes, replace);
    }
}
```


## Logic Explanation

We want to transform a given string into a strong password using the fewest possible steps.  
A strong password must satisfy three rules:

- Length between 6 and 20 characters  
- Contains at least one lowercase, one uppercase, and one digit  
- No three identical characters in a row

To solve this efficiently, we apply a greedy strategy:

1. **Category Check**  
   We scan the string to see which of the three required character types are missing.  
   Each missing type adds to the total number of required operations.

2. **Repeat Detection**  
   We scan for sequences of three or more identical characters.  
   Each such group requires replacements to break the repetition.  
   We classify these groups by their length modulo 3:
   - Groups of length `3k` → breaking them requires 1 deletion per group
   - Groups of length `3k+1` → breaking them requires 2 deletions per group
   - Groups of length `3k+2` → breaking them requires 3 deletions per group

3. **Short Passwords (<6 characters)**  
   We return the maximum of:
   - Number of missing character types  
   - Number of characters needed to reach length 6

4. **Long Passwords (>20 characters)**  
   We calculate how many deletions are needed to reduce the length to 20.  
   Then we apply deletions greedily to the repeat groups to reduce the number of required replacements.  
   We prioritize deletions in the following order:
   - First delete from `mod 0` groups (cheapest to reduce)
   - Then from `mod 1` groups  
   - Finally from `mod 2` groups

5. **Final Step Count**  
   After deletions, we return:
   - Total deletions  
   - Plus the maximum of:
     - Remaining replacements  
     - Missing character types

This strategy ensures we never overcount operations and always prioritize the cheapest fixes first.  
It avoids brute-force and handles all edge cases cleanly.

---

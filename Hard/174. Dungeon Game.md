## Problem: 174. Dungeon Game

### üìú Description
A knight must rescue a princess imprisoned in the bottom-right cell of a 2D dungeon grid.  
Each cell contains:
- A **negative** value ‚Üí damage from demons  
- A **positive** value ‚Üí healing from magic orbs  
- A **zero** ‚Üí empty room

The knight starts at the top-left and can only move **right** or **down**.  
If his health drops to **0 or below** at any point, he dies.  
Return the **minimum initial health** required to guarantee survival and reach the princess.

---

### üß© Constraints
- `1 <= m, n <= 200`
- `-1000 <= dungeon[i][j] <= 1000`

---

## üîç Observations
- Health must **never drop below 1**
- Knight can only move **right or down**
- Need to **minimize initial health**, not maximize final health
- Bottom-up DP is ideal ‚Üí start from princess cell and work backwards

---

## üí° Idea
- Use `dp[i][j]` to store the **minimum health needed to survive from cell (i,j) to the end**
- Traverse from bottom-right to top-left
- At each cell:
  - Compute required health from right and down
  - Add current cell value
  - Clamp to ‚â§ 0 (we only care about deficit)
- Final answer = `abs(dp[0][0]) + 1`

---

## üß± Code (C#)

```csharp
public class Solution {
    public int CalculateMinimumHP(int[][] dungeon) {
        int rows = dungeon.Length;
        int cols = dungeon[0].Length;
        int[,] dp = new int[rows, cols];

        for (int i = rows - 1; i >= 0; i--) {
            for (int j = cols - 1; j >= 0; j--) {
                if (i == rows - 1 && j == cols - 1) {
                    dp[i, j] = dungeon[i][j];
                } else if (i == rows - 1) {
                    dp[i, j] = dungeon[i][j] + dp[i, j + 1];
                } else if (j == cols - 1) {
                    dp[i, j] = dungeon[i][j] + dp[i + 1, j];
                } else {
                    dp[i, j] = dungeon[i][j] + Math.Max(dp[i + 1, j], dp[i, j + 1]);
                }

                dp[i, j] = Math.Min(dp[i, j], 0);
            }
        }

        return Math.Abs(dp[0, 0]) + 1;
    }
}
```

## ‚è±Ô∏è Complexity
- Time: O(m √ó n)
- Space: O(m √ó n)

## üß† Key Tricks
- Bottom-up DP ‚Üí avoids recursion
- Clamp health to ‚â§ 0 ‚Üí track only deficit
- Final health = abs(deficit) + 1 ‚Üí ensures survival

---

# 968. Binary Tree Cameras — Architectural Solution

## Problem Statement
Given the root of a binary tree, place the minimum number of cameras so that **every node** is monitored.

A camera at a node covers:
- itself
- its parent
- its direct children

Return the minimum number of cameras needed.

Constraints: 1 ≤ nodes ≤ 1000

## Core Idea
Greedy post-order DFS with **three states** per node:

| State | Meaning                         | Returned value |
|-------|----------------------------------|----------------|
| 0     | Not covered — **needs** camera  | 0              |
| 1     | Covered, no camera here         | 1              |
| 2     | Has camera                      | 2              |

**Greedy rules (bottom-up):**

- If **any** child returns 0 → **must** place camera here → return 2
- If **any** child returns 2 → this node is covered → return 1
- Otherwise → this node is not covered → return 0

After DFS, if root returns 0 → add one final camera.

This guarantees **optimal** placement — no camera is wasted.

## Implementation (C#) — Clean & Classic

```csharp

public class Solution {
    private int cameras = 0;

    public int MinCameraCover(TreeNode root) {
        // If root needs camera after DFS, add one
        if (DFS(root) == 0) cameras++;
        
        return cameras;
    }

    // Return states:
    // 0 = needs camera, 1 = covered, 2 = has camera
    private int DFS(TreeNode node) {
        if (node == null) return 1; // null is covered

        int left = DFS(node.left);
        int right = DFS(node.right);

        if (left == 0 || right == 0) {
            cameras++;
            return 2; // place camera here
        }

        if (left == 2 || right == 2) return 1; // covered by child camera
        return 0; // needs camera
    }
}
```

## Complexity Analysis

* Time Complexity: **O(n)** — each node is visited exactly once  
* Space Complexity: **O(h)** — recursion stack height (worst-case O(n) for a skewed tree)

## Pitfalls & Edge Cases

* Single node → correctly returns 1 camera  
* Root has no parent → must check root state after DFS and add camera if needed  
* Leaf nodes → return 0 → forces parent to place a camera  
* All children have cameras → current node returns 1 (covered, no extra camera)  
* Tree fully covered by children cameras → root may return 1 → no final extra camera

## Conclusion
One of the most elegant greedy tree problems on LeetCode.

25 lines of code, three crystal-clear states, zero overthinking.

The pattern  
`0 = needs camera | 1 = covered | 2 = has camera`  
is a universal weapon — it solves not only Binary Tree Cameras, but dozens of similar “minimum devices / guards / dominators to cover tree” problems.

Learned once — owned forever.

---

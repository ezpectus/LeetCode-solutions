# 3640. Trionic Array II  
*O(n) — Greedy Linear Scan with Prefix Sums*

---

## Problem Statement

You are given an integer array `nums` of length `n` (4 ≤ n ≤ 10⁵, -10⁹ ≤ nums[i] ≤ 10⁹).

A **trionic subarray** is a contiguous segment `nums[l..r]` (l < r) that can be split into three parts with indices `l < p < q < r` such that:

- `nums[l..p]` is **strictly increasing**
- `nums[p..q]` is **strictly decreasing**
- `nums[q..r]` is **strictly increasing**

Return the **maximum sum** of any trionic subarray.

It is guaranteed that at least one such subarray exists.

---

## Core Idea — Greedy Linear Scan for Up-Down-Up Segments

**Key insight**:
- We want to find contiguous segments with shape **strictly up → strictly down → strictly up**
- To maximize the sum → we want the **longest possible** such segment (more elements → larger sum, especially with positive numbers)
- We scan the array linearly:
  - Extend increasing segment as long as possible
  - Then extend decreasing segment as long as possible
  - Then extend increasing segment again as long as possible
  - When we have all three parts (up-down-up) with valid lengths → compute sum
  - Skip duplicates and invalid short segments

**Algorithm**:
1. Compute **prefix sums** for O(1) range sum queries
2. Start from left (i = 0)
3. While i + 3 < n:
   - Skip duplicates (if nums[i] == nums[i+1] → cannot start increasing)
   - Extend increasing from i to p (strictly increasing)
   - Extend decreasing from p+1 to q (strictly decreasing)
   - Extend increasing from q+1 to r (strictly increasing)
   - If p > i and q > p and r > q (all parts non-empty) → valid trionic
   - Compute sum[l..r] using prefix
   - Update max
   - Jump i to q (next possible valley start)

**Optimization**:
- Skip equal consecutive elements (cannot be part of strict increase/decrease)
- Use prefix sums to compute range sum instantly

---

## Clean Implementation (C#) 

```csharp
public class Solution{
    long INF = (long)1e15;
    public long MaxSumTrionic(int[] nums){
        int n = nums.Length;
        long[] prefixSum = new long[n + 1];
        for (int k = 0; k < n; k++){
            prefixSum[k + 1] = prefixSum[k] + nums[k];
        }
        long ans = -INF;
        int i = 0;

        while (i + 3 < n){
            if (nums[i] == nums[i + 1]){
                i++;
                continue;
            }
            int l = i;
            int j = i + 1;
            while (j < n && nums[j] > nums[j - 1]) j++;
            int p = j - 1;
            while (j < n && nums[j] < nums[j - 1]) j++;
            int q = j - 1;
            while (j < n && nums[j] > nums[j - 1]) j++;
            int r = j - 1;
            // check valid trionic
            if (p != l && q != p && r != q){
                long sum = prefixSum[r + 1] - prefixSum[l];
                long min = 0;
                for (int k = l; k + 1 < p; k++){
                    min = Math.Min(min, prefixSum[k + 1] - prefixSum[l]);
                }
                sum -= min;
                min = 0;

                for (int k = r; k - 1 > q; k--){
                    min = Math.Min(min, prefixSum[r + 1] - prefixSum[k]);
                }
                sum -= min;
                ans = Math.Max(ans, sum);
            }

            i = q;
        }

        return ans;
    }
}

```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single linear pass with inner while loops — each index is visited at most a constant number of times (pointer j always increases) |
| **Space Complexity**  | **O(n)**      | Prefix sum array O(n) + constant extra space   |

**Optimal** — linear time scan, ideal for n ≤ 10⁵ constraints.

---

## Why This Works — Example Walkthrough

**Example 1**: `nums = [0, -2, -1, -3, 0, 2, -1]`

- i=0 (0): next is -2 < 0 → decreasing → skip (cannot start strict increase)
- i=1 (-2): start increasing → j moves to 2 (-1 > -2) → p=2
- Decrease → j to 3 (-3 < -1) → q=3
- Increase → j to 5 (2 > 0) → r=5
- Valid: l=1, p=2, q=3, r=5 (all parts non-empty)
- Sum = -2 + (-1) + (-3) + 0 + 2 = **-4** → correct (matches example)

**Correct** — the greedy extension finds the longest possible **up → down → up** segment starting from each potential valley point.  
Prefix sums allow O(1) range sum computation.  
We jump to q after each valid segment (next possible valley start), ensuring no overlap and full coverage.

---

## Pitfalls & Edge Cases

- **Duplicates** → skipped correctly (cannot form strict increase/decrease)
- **No valid trionic subarray** → problem guarantees at least one exists
- **Negative numbers** → handled correctly (sum can be negative)
- **Minimal n = 4** → at least one valid pattern possible
- **Large n (≤ 10⁵)** → O(n) single pass is efficient

All handled perfectly.

---

## Key Takeaway

This is a **beautifully greedy linear scan** problem for finding maximum sum **up-down-up** subarrays:

- Compute **prefix sums** for O(1) range sum queries
- Scan from left to right:
  - Skip duplicates (cannot start strict increase)
  - Extend **strictly increasing** segment to peak p
  - Extend **strictly decreasing** segment to valley q
  - Extend **strictly increasing** segment to r
  - If all three parts non-empty (p > l, q > p, r > q) → valid trionic subarray
  - Compute sum[l..r] using prefix → update global max
  - Jump i to q (next potential valley start)

**Pure, clean, optimal** — linear time discovery of maximum sum valley-shaped subarray.

---

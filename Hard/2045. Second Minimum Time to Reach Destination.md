# 2045. Second Minimum Time to Reach Destination

**Difficulty:** Hard  
**Topics:** Graph, BFS, Shortest Path with Constraints  

---

## ðŸ“– Problem Restatement
We have a graph with `n` vertices (1-indexed).  
- Each edge takes `time` minutes to traverse.  
- Each vertex has a traffic signal that alternates every `change` minutes (green â†” red).  
- You can leave a vertex only when the signal is green.  
- Start at vertex `1`, goal is vertex `n`.  
- Find the **second minimum time** to reach `n`.  

---

## ðŸ’¡ Core Idea
- This is essentially a **shortest path problem**, but we need both the shortest and the second shortest arrival times.  
- Use **BFS** (since all edges have equal weight = `time`).  
- Track for each node the **two smallest arrival times**.  
- When traversing edges, adjust for traffic lights:  
  - If current time is in a red phase, wait until next green.  
  - Then add `time` for edge traversal.  
- Stop once we reach destination with the second distinct arrival time.  

---

## âœ… C# Implementation
```csharp
public class Solution {
    public int SecondMinimum(int n, int[][] edges, int time, int change) {
        // Build adjacency list
        var graph = new List<int>[n+1];
        for (int i = 1; i <= n; i++) graph[i] = new List<int>();
        foreach (var e in edges) {
            graph[e[0]].Add(e[1]);
            graph[e[1]].Add(e[0]);
        }

        // For each node, store up to 2 arrival times
        var dist = new List<int>[n+1];
        for (int i = 1; i <= n; i++) dist[i] = new List<int>();

        var q = new Queue<(int node,int t)>();
        q.Enqueue((1,0));
        dist[1].Add(0);

        while (q.Count > 0) {
            var (node, curTime) = q.Dequeue();

            // Adjust for traffic light
            if ((curTime / change) % 2 == 1) {
                curTime = (curTime / change + 1) * change;
            }

            foreach (var nei in graph[node]) {
                int newTime = curTime + time;
                if (dist[nei].Count < 2 && (dist[nei].Count == 0 || dist[nei][^1] != newTime)) {
                    dist[nei].Add(newTime);
                    dist[nei].Sort();
                    q.Enqueue((nei,newTime));
                }
            }
        }

        return dist[n][1]; // second minimum
    }
}
```


# ðŸ“Š Complexity Analysis

### Time Complexity
- The algorithm uses **BFS** because all edges have equal weight (`time` minutes).  
- Each edge can be traversed at most twice per node (once for the shortest arrival time, once for the second shortest).  
- Therefore, the overall complexity is `O(n + edges)`.  
- This is efficient even for large graphs (up to 10^4 nodes and ~2Ã—10^4 edges).  

### Space Complexity
- We store an adjacency list for the graph â†’ `O(n + edges)`.  
- A queue for BFS states â†’ `O(n + edges)` in worst case.  
- An array `dist[node]` that keeps up to **two arrival times per node** â†’ `O(2n)`.  
- Total space usage is `O(n + edges)`.  

---

# âš ï¸ Pitfalls

- **Traffic light handling:**  
  - Signals alternate every `change` minutes.  
  - If you arrive during a red phase, you must wait until the next green.  
  - Forgetting this adjustment leads to incorrect timings.  

- **Two distinct times per node:**  
  - You cannot stop after finding the shortest path.  
  - Must track both shortest and second shortest arrival times for each node.  
  - This ensures you can compute the second minimum path correctly.  

- **Termination condition:**  
  - Stop only when the destination node has **two distinct arrival times**.  
  - Returning too early (after the first arrival) gives the wrong answer.  

---

# ðŸ”Ž Example Walkthrough

**Input:**  
```
n = 5
edges = [[1,2],[1,3],[1,4],[3,4],[4,5]]
time = 3
change = 5

```



**Stepâ€‘byâ€‘step:**  
- Start at node `1`, time = 0 (green).  
- Path `1 â†’ 4 â†’ 5`:  
  - Travel 1â†’4: +3 minutes â†’ time = 3.  
  - Travel 4â†’5: +3 minutes â†’ time = 6.  
  - Minimum arrival time = **6 minutes**.  

- Path `1 â†’ 3 â†’ 4 â†’ 5`:  
  - Travel 1â†’3: +3 minutes â†’ time = 3.  
  - Travel 3â†’4: +3 minutes â†’ time = 6.  
  - At node 4, signal is **red** (since 6/5 = 1 remainder â†’ red).  
  - Must wait until time = 10 (next green).  
  - Travel 4â†’5: +3 minutes â†’ time = 13.  
  - Second minimum arrival time = **13 minutes**.  

**Output:**  ```13```


---

# âœ… Key Takeaway

- This is a **BFS variant** designed to find both the shortest and second shortest arrival times.  
- **Traffic lights** add waiting time, but the BFS structure remains intact.  
- The trick is to store **up to 2 times per node** and stop once the destination has 2 distinct times.  
- Clean and efficient solution for constrained shortest path problems.  


---











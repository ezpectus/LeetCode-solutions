# 761. Special Binary String  
*O(n log n) — Recursive Decomposition + Greedy Sorting of Substrings*

---

## Problem Statement

**Special binary string** — binary string that satisfies two properties:
- Equal number of `0`s and `1`s
- In every prefix, number of `1`s ≥ number of `0`s (never negative balance)

You are given a **special binary string** `s`.

You can perform the following operation **any number of times**:
- Choose **two consecutive**, **non-empty**, **special** substrings of `s` and **swap** them

Return the **lexicographically largest** string you can get after performing any number of such operations.

**Constraints**:
- 1 ≤ s.length ≤ 50
- s consists only of `'0'` and `'1'`
- s is guaranteed to be a special binary string

---

## Core Idea — Recursive Structure + Greedy Sorting

**Beautiful observation**:
- Any special binary string always starts with `'1'` and ends with `'0'`
- Inside the outer `'1' ... '0'` there are zero or more **consecutive special substrings**
- These inner substrings are also special and can be independently maximized
- Swapping two consecutive special substrings allows **reordering** them arbitrarily
- To get the **lexicographically largest** result → we should sort these inner substrings in **descending** order

**Recursive algorithm**:
1. If string is empty → return `""`
2. Skip the leading `'1'`
3. Recursively decompose the inner part into consecutive special substrings
4. For each inner substring:
   - Recursively make it the **largest possible**
   - Wrap it back with `'1'` and `'0'`
5. Sort all these processed substrings in **descending lexicographical order**
6. Concatenate them and wrap with outer `'1'` and `'0'`

**Time**: O(n log n) in worst case (sorting at each level)  
**Space**: O(n) — recursion depth + string construction

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public string MakeLargestSpecial(string s){
        return MakeLargest(s);
    }

    private string MakeLargest(string s){
        if (string.IsNullOrEmpty(s)) return "";

        List<string> parts = new List<string>();
        int balance = 0;
        int start = 0;

        // The string must start with '1' (guaranteed by problem)
        balance = 1; // for the first '1'
        start = 1;

        for (int i = 1; i < s.Length; i++){
            if (s[i] == '1') balance++;
            else balance--;

            if (balance == 0){
                // Extract inner part (without outer '1' and '0')
                string inner = s.Substring(start, i - start);
                // Recursively make inner largest
                string processedInner = MakeLargest(inner);
                // Wrap it back
                parts.Add("1" + processedInner + "0");
                start = i + 1;
            }
        }

        // Sort in descending lexicographical order
        parts.Sort((a, b) => b.CompareTo(a));

        // Concatenate all parts
        return string.Join("", parts);
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)**| String decomposition and recursion: O(n) per level<br>Sorting substrings at each recursion level: O(k log k) where k is number of subparts<br>Overall worst-case: **O(n log n)** (skewed recursion tree) |
| **Space Complexity**  | **O(n)**      | Recursion stack depth: O(n) in worst case (skewed tree)<br>Temporary strings and lists during construction: O(n) |

**Optimal** — for n ≤ 50 it's blazing fast in practice (negligible runtime).

---

## Why This Works — Example Walkthrough

**Example 1**: s = "11011000"

**Decomposition steps**:

- Outer structure: `'1' … '0'`
- Inside content: "101100"
  - Splits into two irreducible special substrings: **"10"** and **"1100"**
  - "10" → no further split → remains "10"
  - "1100" → inner "10" → recursively remains "10" → wrapped back → "1100"
- Parts after recursive processing: **"1100"**, **"10"**
- Sort in **descending** lexicographical order: "1100" > "10"
- Reconstruct: `'1' + "1100" + "10" + '0'` = **"11100100"**

Result: **"11100100"** → lexicographically largest possible

**Correct** —  
The recursive decomposition identifies all **irreducible special components** (minimal special substrings).  
Sorting these components in **descending lexicographical order** pushes as many `'1'`s as early as possible, maximizing the string under the allowed swap operations.

---

## Key Takeaway

This is a **beautiful recursive decomposition + greedy lexicographical sorting** problem:

* Every special binary string has the form: `'1' + (special₁ + special₂ + … + specialₖ) + '0'`
* Recursively **maximize** each inner special substring using the same method
* **Sort** the resulting processed substrings in **descending** lexicographical order
* Reconstruct the final string: `'1' + sorted_substrings + '0'`

**Pure, clean, optimal** — O(n log n) time, O(n) space, very elegant, works perfectly for small n (≤ 50), and produces the lexicographically largest possible result.

---

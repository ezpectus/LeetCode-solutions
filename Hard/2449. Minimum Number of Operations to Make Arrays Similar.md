# 🧠 Minimum Number of Operations to Make Arrays Similar — Parity-Aware Greedy Matching (LeetCode 2449)

---

## 📜 Origin & Motivation

We are given two arrays `nums` and `target` of equal length.  
In one operation, we can increment one element by `+2` and decrement another by `-2`.  
The goal is to transform `nums` into a multiset equal to `target` using the **minimum number of operations**.

Key constraint:  
- Each operation preserves **parity** — even numbers stay even, odd stay odd  
- Therefore, we must match **even-to-even** and **odd-to-odd** values

---

## 🧩 Use Cases

- 🧠 Parity-preserving transformations  
- 📊 Multiset matching with minimal cost  
- 🧪 Greedy delta aggregation  
- 🧱 Frequency-aware array morphing

---

## 🧱 Core Architecture

### 🎯 Triggers

| Condition                        | Action in Code           |
|----------------------------------|--------------------------|
| Element is even                  | Add to even group        |
| Element is odd                   | Add to odd group         |
| nums[i] < target[i]              | Accumulate positive delta|
| nums[i] > target[i]              | Ignore — handled symmetrically |

---

### 🔧 Algorithm Steps

1. Split `nums` and `target` into even and odd groups  
2. Sort each group independently  
3. For each index `i` in even and odd groups:
   - If `nums[i] < target[i]`, compute `delta = target[i] - nums[i]`  
   - Each operation moves 2 units, so `delta / 2` operations needed  
4. Sum all such operations

---

## 🚀 C# Implementation

```csharp
public class Solution {
    public long MakeSimilar(int[] nums, int[] target) {
        List<int> evenNums = new(), oddNums = new();
        List<int> evenTarget = new(), oddTarget = new();

        foreach(int x in nums){
            if(x % 2 == 0) evenNums.Add(x);
            else oddNums.Add(x);
        }

      foreach(int x in target){
            if(x % 2 == 0) evenTarget.Add(x);
            else oddTarget.Add(x);
        }

         evenNums.Sort();
         evenTarget.Sort();
         oddNums.Sort();
         oddTarget.Sort();
         long ops =0;


        for(int i =0; i < evenNums.Count;i++){
            if(evenNums[i] < evenTarget[i]){
                ops += (evenTarget[i] - evenNums[i]) /2;
            }
        }
        for(int i =0; i < oddNums.Count;i++){
            if(oddNums[i] < oddTarget[i]){
                ops+=(oddTarget[i] - oddNums[i])/2;
            }
        }
    
    return ops;
    }
}
```
## ⏱️ Complexity Analysis  
- Splitting by parity: O(n) — single pass  
- Sorting: O(n·log n) — four group sorts  
- Delta aggregation: O(n) — linear scan  
**Total time complexity**: O(n·log n)  
**Space complexity**: O(n) — for parity groups

## ⚠️ Pitfalls  
- 🧠 Must split by parity — operations preserve even/odd status  
- 📊 Sorting is essential — greedy matching requires positional alignment  
- ⚠️ Only count positive deltas — negative ones are handled symmetrically  
- 🧩 Each operation moves 2 units — divide deltas by 2  
- 🔁 Do not simulate operations — greedy delta sum is sufficient

## ✅ Conclusion  
This is a parity-aware greedy matching problem:

- 🔁 Split arrays by parity  
- 📊 Sort and align values  
- 🧠 Accumulate positive deltas  
- 🏆 Elegant and optimal without simulation

👉 **Key takeaway**: When operations preserve parity, sort and match by parity — fast, clean, and robust.



---



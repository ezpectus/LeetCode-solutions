# ðŸ§  Minimum Number of Operations to Make Arrays Similar â€” Parity-Aware Greedy Matching (LeetCode 2449)

---

## ðŸ“œ Origin & Motivation

We are given two arrays `nums` and `target` of equal length.  
In one operation, we can increment one element by `+2` and decrement another by `-2`.  
The goal is to transform `nums` into a multiset equal to `target` using the **minimum number of operations**.

Key constraint:  
- Each operation preserves **parity** â€” even numbers stay even, odd stay odd  
- Therefore, we must match **even-to-even** and **odd-to-odd** values

---

## ðŸ§© Use Cases

- ðŸ§  Parity-preserving transformations  
- ðŸ“Š Multiset matching with minimal cost  
- ðŸ§ª Greedy delta aggregation  
- ðŸ§± Frequency-aware array morphing

---

## ðŸ§± Core Architecture

### ðŸŽ¯ Triggers

| Condition                        | Action in Code           |
|----------------------------------|--------------------------|
| Element is even                  | Add to even group        |
| Element is odd                   | Add to odd group         |
| nums[i] < target[i]              | Accumulate positive delta|
| nums[i] > target[i]              | Ignore â€” handled symmetrically |

---

### ðŸ”§ Algorithm Steps

1. Split `nums` and `target` into even and odd groups  
2. Sort each group independently  
3. For each index `i` in even and odd groups:
   - If `nums[i] < target[i]`, compute `delta = target[i] - nums[i]`  
   - Each operation moves 2 units, so `delta / 2` operations needed  
4. Sum all such operations

---

## ðŸš€ C# Implementation

```csharp
public class Solution {
    public long MakeSimilar(int[] nums, int[] target) {
        List<int> evenNums = new(), oddNums = new();
        List<int> evenTarget = new(), oddTarget = new();

        foreach(int x in nums){
            if(x % 2 == 0) evenNums.Add(x);
            else oddNums.Add(x);
        }

      foreach(int x in target){
            if(x % 2 == 0) evenTarget.Add(x);
            else oddTarget.Add(x);
        }

         evenNums.Sort();
         evenTarget.Sort();
         oddNums.Sort();
         oddTarget.Sort();
         long ops =0;


        for(int i =0; i < evenNums.Count;i++){
            if(evenNums[i] < evenTarget[i]){
                ops += (evenTarget[i] - evenNums[i]) /2;
            }
        }
        for(int i =0; i < oddNums.Count;i++){
            if(oddNums[i] < oddTarget[i]){
                ops+=(oddTarget[i] - oddNums[i])/2;
            }
        }
    
    return ops;
    }
}
```
## â±ï¸ Complexity Analysis  
- Splitting by parity: O(n) â€” single pass  
- Sorting: O(nÂ·logâ€¯n) â€” four group sorts  
- Delta aggregation: O(n) â€” linear scan  
**Total time complexity**: O(nÂ·logâ€¯n)  
**Space complexity**: O(n) â€” for parity groups

## âš ï¸ Pitfalls  
- ðŸ§  Must split by parity â€” operations preserve even/odd status  
- ðŸ“Š Sorting is essential â€” greedy matching requires positional alignment  
- âš ï¸ Only count positive deltas â€” negative ones are handled symmetrically  
- ðŸ§© Each operation moves 2 units â€” divide deltas by 2  
- ðŸ” Do not simulate operations â€” greedy delta sum is sufficient

## âœ… Conclusion  
This is a parity-aware greedy matching problem:

- ðŸ” Split arrays by parity  
- ðŸ“Š Sort and align values  
- ðŸ§  Accumulate positive deltas  
- ðŸ† Elegant and optimal without simulation

ðŸ‘‰ **Key takeaway**: When operations preserve parity, sort and match by parity â€” fast, clean, and robust.



---



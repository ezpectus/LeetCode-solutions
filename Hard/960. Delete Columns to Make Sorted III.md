# 960. Delete Columns to Make Sorted III — Architectural Longest Non-Decreasing Column Subsequence DP  
*O(n × m²) — Optimal LIS-Style DP on Columns*

---

## Problem Statement

Given `n` strings `strs` of equal length `m`.

Delete some columns (same for all rows).

After deletions:
- **Every remaining row** must be **non-decreasing** (lexicographically sorted)

Return **minimum number** of columns to delete.

---

## Core Idea — Longest Increasing Subsequence on Columns

**Key insight**:
- We want **maximum number of columns** to **keep**
- Kept columns must satisfy: for **every row**, characters are **non-decreasing**

This is equivalent to finding the **longest subsequence** of columns where:
- For all rows i: `strs[i][col_j] >= strs[i][col_k]` for k < j

**DP**:
- `dp[j]` = length of longest valid subsequence **ending** at column j
- `dp[j] = 1 + max(dp[k])` for all k < j where column j can follow k
  - i.e., `strs[i][j] >= strs[i][k]` for **all rows i**

Max over `dp` → max keep → `m - maxKeep` = min delete

---

##  Implementation (C++)

```cpp
class Solution {
public:
    int minDeletionSize(vector<string>& strs) {
        int n = strs.size();
        int m = strs[0].size();
        vector<int> dp(m, 1); // max length ending at column j

        for (int j = 1; j < m; j++) {
            for (int k = 0; k < j; k++) {
                bool can = true;
                for (int i = 0; i < n; i++) {
                    if (strs[i][j] < strs[i][k]) {
                        can = false;
                        break;
                    }
                }
                if(can)  dp[j] = max(dp[j], dp[k] + 1);  
            }
        }
        int maxKeep = 0;
        for (int len : dp) maxKeep = max(maxKeep, len);

        return m - maxKeep;
    }
};
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n × m²)**         | For each pair of columns, check all rows        |
| **Space Complexity**  | **O(m)**              | DP array of size m                             |

**Optimal** — n,m ≤ 100 → 10⁶ operations → fine.

---

## Why This Works — Example Walkthrough

**Input**: `strs = ["baabab"]`

Columns: 0:'b', 1:'a', 2:'a', 3:'b', 4:'a', 5:'b'

- `dp[0] = 1`
- j=1 'a' → 'a' < 'b' → cannot extend → `dp[1]=1`
- j=2 'a' → can extend from j=1 → `dp[2]=2`
- j=3 'b' → can extend from j=2 → `dp[3]=3`
- j=4 'a' → 'a' < 'b' → cannot extend from j=3 → `dp[4]=1`
- j=5 'b' → can extend from j=3 → `dp[5]=4`

→ maxKeep = **4** → delete = 6 - 4 = **2**

**Correct** — keep columns 1,2,3,5 → "aabb"

**Input**: `["edcba"]`

- Each next char smaller → no extension possible
- maxKeep = **1** → delete **4**

**Correct**.

**Input**: `["ghi","def","abc"]`

- All rows increasing → can extend every column
- maxKeep = m → delete **0**

**Correct**.

---

## Pitfalls & Edge Cases

- **Single row** → reduces to standard LIS (non-decreasing)
- **Decreasing rows** → delete many columns
- **Already sorted** → delete 0
- **Single column** → delete 0 or 1
- **Mixed order** → DP finds optimal subsequence of columns

All handled perfectly.

---

## Key Takeaway

This is a **classic LIS variant** on columns:

- **DP on columns** → longest valid keep sequence
- **Check all rows** → ensure non-decreasing per row
- **O(n m²)** → acceptable for small constraints

**No greedy shortcut** — full DP required for optimality.
**Pure, clean, optimal** — one of the best Hard greedy/DP hybrid problems.

---

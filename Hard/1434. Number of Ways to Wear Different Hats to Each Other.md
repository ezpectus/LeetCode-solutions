# LeetCode 1434: Number of Ways to Wear Different Hats to Each Other

## Problem Description

You are given:

- n people (1 ≤ n ≤ 10)
- 40 types of hats labeled from 1 to 40
- hats[i]: list of hats person i is willing to wear

Return the number of ways to assign distinct hats to each person such that:

- Each person gets exactly one hat
- No two people wear the same hat
- Each person only wears a hat they like
- Return the result modulo 10⁹ + 7.

## How the Idea Was Formed

## Constraints Analysis
- n ≤ 10 → small number of people → we can use bitmask to represent assigned people
- hat ∈ [1..40] → large number of hats → we loop over hats, not people
- Each person has up to 40 preferences → we invert the mapping: for each hat, store who likes it

## Key Insight

- We treat this as a state transition problem:
- State = current hat index + bitmask of assigned people
- Transition = assign current hat to one of the people who like it and are still unassigned

## Why Bitmask
- Each person can be either assigned or unassigned → binary state
- We use an integer mask of n bits to represent the assignment state
- mask = 0b000...000 → no one assigned
- mask = 0b111...111 → all assigned → base case

## Why We Loop Over Hats (Not People)
- Hats: 40 total → manageable loop
- People: 10 total → exponential combinations
- By looping over hats, we reduce branching and avoid redundant permutations

## DP State Definition
```csharp
dp[hat][mask] = number of ways to assign hats [hat..40] to people in state `mask`
```
- hat ∈ [1..40]
- mask ∈ [0..(1 << n) - 1]
- Base case: if hat > 40, return 1 if mask == allMask, else 0

## C# Code with Comments
```csharp
public class Solution {
    private const int MOD = 1000000007;
    private List<int>[] preferredBy;
    private int[,] dp;
    private int allMask;

    public int NumberWays(IList<IList<int>> hats) {
        int n = hats.Count;
        allMask = (1 << n) - 1;

        // Invert mapping: for each hat, store list of people who like it
        preferredBy = new List<int>[41];
        for (int i = 0; i < 41; i++) preferredBy[i] = new List<int>();
        for (int person = 0; person < n; person++)
            foreach (int hat in hats[person])
                preferredBy[hat].Add(person);

        // Initialize DP table with -1
        dp = new int[41, 1 << n];
        for (int i = 0; i < 41; i++)
            for (int j = 0; j < (1 << n); j++)
                dp[i, j] = -1;

        return CountWays(1, 0);
    }

    private int CountWays(int hat, int mask) {
        if (hat > 40) return mask == allMask ? 1 : 0;
        if (dp[hat, mask] != -1) return dp[hat, mask];

        // Option 1: skip this hat
        int ans = CountWays(hat + 1, mask);

        // Option 2: assign this hat to someone who likes it and is unassigned
        foreach (int person in preferredBy[hat]) {
            if ((mask & (1 << person)) != 0) continue; // already assigned
            ans += CountWays(hat + 1, mask | (1 << person));
            ans %= MOD;
        }

        return dp[hat, mask] = ans;
    }
}
```

## Pruning Logic
```csharp
if ((mask & (1 << person)) != 0) continue;
```
This skips people who already have a hat assigned, avoiding invalid states.

## Complexity
- Time: O(40 × 2ⁿ × n)
- 40 hats
- 2ⁿ possible masks
- Up to n people per hat
- Space: O(40 × 2ⁿ) for DP table

## Architectural Conclusion

- This is a classic bitmask DP problem with:
- State compression via bitmask
- Transition logic based on hat-to-person mapping
- Pruning to avoid invalid assignments
- Memoization to cache subproblem results


----

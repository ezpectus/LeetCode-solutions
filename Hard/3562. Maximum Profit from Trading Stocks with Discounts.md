# 3562. Maximum Profit from Trading Stocks with Discounts — Architectural Tree Knapsack DP  
*O(n × budget²) — Optimal Tree DP with Discount Propagation*

---

## Problem Statement

Company hierarchy as **tree** (root = employee 1).

Each employee `i`:
- `present[i]` — buy price
- `future[i]` — sell price tomorrow

**Discount rule**:
- If **direct boss** buys → employee buys at `floor(present[i]/2)`

**Goal**:
- Maximize **total profit** = Σ (future - buy_price)
- Total buy cost ≤ `budget`

**Constraints**:
- `n ≤ 160`
- `budget ≤ 160`
- Tree structure (no cycles)

---

## Core Idea — Tree DP with Two States (Buy / Not Buy)

**Key insight**:
- Decision at parent **affects children's cost**
- For each subtree → two DP arrays:
  - `dp0[c]` = max profit **not buying** current employee
  - `dp1[c]` = max profit **buying** current employee (full price)

**Children**:
- If parent **buys** → children can use **half price**
- If parent **not buys** → children use **full price**

**Merge** children using **knapsack-style convolution**.

---

##  Implementation (C#)

```csharp
public class Solution{
    public int MaxProfit(int n, int[] present, int[] future, int[][] hierarchy, int budget) {
        List<int>[] g = new List<int>[n];
        for (int i = 0; i < n; i++) g[i] = new List<int>();
        foreach (var e in hierarchy) g[e[0] - 1].Add(e[1] - 1);

        (int[] dp0, int[] dp1, int size) Dfs(int u) {
            int cost = present[u];
            int dCost = present[u] / 2;
            int profit = future[u];

            int[] dp0 = new int[budget + 1];
            int[] dp1 = new int[budget + 1];

            // Initial: no children
            for (int i = 0; i <= budget; i++) {
                dp0[i] = 0; // not buy
                if (i >= cost) dp1[i] = profit - cost; // buy full
            }

            int uSize = cost; // min cost if buy full

            // Merge children
            foreach (int v in g[u]) {
                var (childDp0, childDp1, vSize) = Dfs(v);
                uSize += vSize;

                int[] newDp0 = new int[budget + 1];
                int[] newDp1 = new int[budget + 1];
                Array.Fill(newDp0, int.MinValue / 2);
                Array.Fill(newDp1, int.MinValue / 2);

                for (int i = 0; i <= budget; i++)  {
                    // Not buy current
                    for (int j = 0; j <= i; j++) {
                        // Child uses full price (parent not buy)
                        int childMax = Math.Max(childDp0[j], childDp1[j]);
                        newDp0[i] = Math.Max(newDp0[i], dp0[i - j] + childMax);
                    }

                    // Buy current → children get discount
                    if (i >= cost) {
                        for (int j = 0; j <= i - cost; j++) {
                            // Child can use half price if buys
                            int childHalf = childDp1[j] + (profit - dCost) - (profit - cost); // adjust
                            int childMax = Math.Max(childDp0[j], childHalf);
                            newDp1[i] = Math.Max(newDp1[i], dp1[i - cost] + childMax + (profit - cost));
                        }
                    }
                }

                dp0 = newDp0;
                dp1 = newDp1;
            }

            return (dp0, dp1, uSize);
        }

        var (rootDp0, rootDp1, _) = Dfs(0);

        int ans = 0;
        for (int i = 0; i <= budget; i++) {
            ans = Math.Max(ans, Math.Max(rootDp0[i], rootDp1[i]));
        }

        return ans;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n × budget²)**    | Tree DP with knapsack merge on children         |
| **Space Complexity**  | **O(n × budget)**     | DP arrays per node (two states)                |

**Optimal** — standard tree knapsack DP. Given constraints (n≤160, budget≤160), n×budget² ≈ 4e6 → completely fine.

---

## Key Takeaway

This is a **classic tree knapsack DP with conditional cost**:

- **Two states per node**:
  - `dp0` — max profit **not buying** current employee
  - `dp1` — max profit **buying** current employee (full price)

- **Parent decision affects child cost**:
  - If parent buys → children can buy at **half price**
  - If parent not buys → children pay **full price**

- **Knapsack merge** for subtree combination:
  - Children’s DP arrays are convolved with current decision
  - Standard tree DP merge pattern


---


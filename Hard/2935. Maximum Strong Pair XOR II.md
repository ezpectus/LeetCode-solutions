# Pattern Name  
Bitwise Greedy with Prefix Filtering for Constrained XOR

---

## Problem Overview

Given an integer array `nums` of size up to 50,000, where each element is in the range [1, 2^20 − 1]. A pair `(x, y)` is considered a **strong pair** if it satisfies the condition `|x − y| ≤ min(x, y)`. The goal is to select any two integers (possibly equal) such that they form a strong pair and their bitwise XOR `x ^ y` is maximized.

Brute-force pair checking is infeasible due to O(n²) complexity. Instead, we use a **bitwise greedy strategy**, building the result bit-by-bit from the top down, and filtering valid prefixes using arithmetic constraints derived from the strong pair condition.

---

## Constraints and Implications

| Parameter     | Range                          |
|---------------|---------------------------------|
| `nums.length` | 1 to 50,000                     |
| `nums[i]`     | 1 to 1,048,575 (i.e., 2^20 − 1) |

Implications:

- Brute-force is unacceptable due to ~2.5B pair checks.
- We need a solution in **O(n log M)** where M = 20 (bit length).
- Strong pair condition gives a **bounded relation** between `x` and `y`, enabling prefix-based filtering.

---

## Problem Anatomy

The strong pair condition `|x − y| ≤ min(x, y)` implies that `x` and `y` must be close in value, and the smaller one must not be too far from the larger. Instead of checking all pairs, we build the XOR result greedily from the highest bit down. At each bit level `i`, we group numbers by their `i`-bit prefix (`num >> i`) and track the min and max values in each group.

To test whether we can set bit `i` in the result, we check whether there exists a pair of prefixes `x` and `y = (candidate ^ 1) ^ x` such that:

- `x ≥ y`  
- `pref[x] ≤ pref2[y] * 2` — this ensures the strong pair condition holds

If such a pair exists, we set bit `i` in the result.

---

## Solution Strategy

1. Initialize result to 0.
2. Iterate from bit 20 down to 0.
3. For each bit `i`:
   - Shift result left by 1.
   - Group numbers by prefix `num >> i`.
   - Track min and max values for each prefix.
   - Try to set bit `i` in result by checking if any prefix pair satisfies the strong pair condition.
4. Return the final result.

This avoids explicit pair checking and uses **bitwise prefix filtering** to simulate XOR maximization under constraints.

---

## C# Implementation

```csharp
public class Solution {
    public int MaximumStrongPairXor(int[] nums) {
        int res = 0;

        for (int i = 20; i >= 0; i--) {
            res <<= 1;
            Dictionary<int, int> prefMin = new(), prefMax = new();

            foreach (var num in nums) {
                int prefix = num >> i;

                if (!prefMin.ContainsKey(prefix)) {
                    prefMin[prefix] = num;
                    prefMax[prefix] = num;
                }

                prefMin[prefix] = Math.Min(prefMin[prefix], num);
                prefMax[prefix] = Math.Max(prefMax[prefix], num);
            }

            int candidate = res ^ 1;

            var valid = from x in prefMin.Keys
                        let y = candidate ^ x
                        where x >= y && prefMin.ContainsKey(y) && prefMin[x] <= prefMax[y] * 2
                        select x;

            if (valid.Any()) res |= 1;
        }

        return res;
    }
}

```




## Time and Space Complexity

| Metric           | Value      | Explanation                                                  |
|------------------|------------|--------------------------------------------------------------|
| Time Complexity  | O(n log M) | 21 bit levels × O(n) prefix grouping and filtering           |
| Space Complexity | O(n)       | Prefix maps store up to n entries in worst case              |

This solution avoids pair enumeration entirely. Instead, it builds the XOR result greedily and filters valid prefix pairs using arithmetic constraints.

---

## Generalization to Other Problems

This pattern applies to problems where:

- You need to **maximize XOR** under pair constraints.
- You can **group numbers by prefix** or bitwise signature.
- You want to **avoid explicit pair checking** and use arithmetic filtering.

---

## Examples of Similar Problems

| Problem Type                  | Description                                      |
|------------------------------|--------------------------------------------------|
| Maximum XOR of Two Numbers   | Greedy bitwise construction without constraints  |
| XOR Queries with Constraints | Filtered XOR search with bounds                  |
| Bitmask Pair Optimization    | Maximize bitwise metric under structural rules   |

---

## Final Takeaway

This problem is solved using:

- **Bitwise greedy construction** — build result top-down by testing each bit.
- **Prefix filtering** — group numbers by bitwise prefix and track min/max.
- **Arithmetic constraint enforcement** — simulate strong pair condition without explicit pair checks.

The result is a clean **O(n log M)** solution that avoids brute-force and leverages bitwise structure.  
This pattern is reusable for any task involving **bitwise metric optimization under pair constraints**.


---

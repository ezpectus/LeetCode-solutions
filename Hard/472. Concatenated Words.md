# 472. Concatenated Words

---

##  Problem Restatement
You are given an array of strings `words` (all unique).  
A **concatenated word** is defined as a string that is comprised entirely of at least two shorter words from the array.  
Return all concatenated words in the list.

Constraints:  
- 1 ≤ words.length ≤ 10^4  
- 1 ≤ words[i].length ≤ 30  
- sum of lengths ≤ 10^5  

---

##  Core Idea
- We need to check if each word can be formed by concatenating other words in the dictionary.  
- Use **DFS + memoization** or **DP word break** approach.  
- Store all words in a `HashSet` for O(1) lookup.  
- For each word, temporarily remove it from the set (to avoid using itself directly), then check if it can be broken into valid smaller words.  
- If yes → add to result.

---

##  Step‑by‑Step
1. Insert all words into a `HashSet`.  
2. For each word:  
   - Remove it from the set.  
   - Run DFS/DP to check if it can be split into ≥2 words from the set.  
   - If true → add to result.  
   - Add word back to the set.  
3. Return the list of concatenated words.

---

##  Code (C#)
```csharp
public class Solution {
    public IList<string> FindAllConcatenatedWordsInADict(string[] words) {
        var set = new HashSet<string>(words);
        var result = new List<string>();
        var memo = new Dictionary<string, bool>();

        foreach (var word in words) {
            set.Remove(word);
            if (CanForm(word, set, memo)) {
                result.Add(word);
            }
            set.Add(word);
        }
        return result;
    }

    private bool CanForm(string word, HashSet<string> dict, Dictionary<string, bool> memo) {
        if (memo.ContainsKey(word)) return memo[word];

        for (int i = 1; i < word.Length; i++) {
            string prefix = word.Substring(0, i);
            string suffix = word.Substring(i);

            if (dict.Contains(prefix)) {
                if (dict.Contains(suffix) || CanForm(suffix, dict, memo)) {
                    memo[word] = true;
                    return true;
                }
            }
        }
        memo[word] = false;
        return false;
    }
}
```

## Complexity
- **Time:** O(N * L^2)  
  - N = number of words  
  - L = maximum length of a word (≤ 30)  
  - Each word is checked with substring splits.  
- **Space:** O(N * L) due to memoization and recursion stack.

---

## Pitfalls
- Must remove the word itself from the dictionary during check, otherwise trivial match occurs.  
- Memoization is critical; without it, repeated suffix checks cause TLE.  
- Edge case: very short words (length 1) cannot be concatenated.  
- Ensure at least two words are used, not just one.  

---

## Conclusion
This problem reduces to **word break with dictionary lookup**.  
By storing words in a set and using DFS + memoization, we efficiently detect concatenated words.  
Result: clean O(N * L^2) solution, robust for N ≤ 10^4 and sum of lengths ≤ 10^5.

---

## Generalization
- This pattern applies to **string decomposition problems** such as word break, compound word detection, and dictionary segmentation.  
- Useful in **natural language processing**, spell checking, and compound word recognition.  
- Core technique: combine **set lookup** with **DP/DFS memoization** to avoid redundant checks.

---

# 1224. Maximum Equal Frequency  
*O(n) — Optimal Frequency of Frequencies with Clever Tricks*

---

## Problem Statement

- Given an array `nums` of positive integers (2 ≤ length ≤ 10⁵, 1 ≤ nums[i] ≤ 10⁵).
- Find the **longest prefix** `nums[0..len-1]` such that after removing **exactly one** element from this prefix:
- Every number that appears in the remaining prefix has the **same frequency**
- If the prefix becomes empty after removal — it's still valid (all frequencies = 0)
- Return the maximum such prefix length.

---

## Core Idea — Maintain Frequency Map + Frequency of Frequencies

We use two counters:

- `freqs[num]` — how many times `num` appears in current prefix
- We also track how many numbers have each frequency (implicitly via tricks)

We keep:
- `distinctFreqs` — number of **different frequency values** in the current prefix
- `max` — current maximum frequency
- Special array `nums` reused as `freqOfFreq` (nums[f] = how many numbers have frequency f)

At each step (after adding nums[i]):
- Update frequency of nums[i]
- Update `distinctFreqs` (number of distinct frequencies)
- Update `max` (max frequency)
- Check if after removing **one** element we can make all frequencies equal:
  - Either only **1 or 2 distinct frequencies** exist
  - And one of them is 1 (can remove to make all 1)
  - Or max frequency has only one number (`nums[max] == 1`)
  - Or after removing from max-1 we balance everything

If condition holds → update answer = i+1

This is a very optimized, tricky version of frequency-of-frequencies tracking.

---

## Clean Implementation (C#) 

```csharp
public class Solution {
    public int MaxEqualFreq(int[] nums) {
        Dictionary<int, int> freqs = new Dictionary<int, int>();
        int distinctFreqs = 0;
        int max = -1;
        int result = int.MinValue;

        for (int i = 0; i < nums.Length; i++)  {
            int index = System.Runtime.InteropServices.CollectionsMarshal
                .GetValueRefOrAddDefault(freqs, nums[i], out bool exists)++;

            if (!exists || --nums[index - 1] > 0)  distinctFreqs++;

            if (index > max) {
                nums[index] = 1;
                max = index;
            }
            else if (nums[index]++ > 0) 
                distinctFreqs--;

            if (distinctFreqs <= 2 && 
                (max == 0 || nums[0] == 1 || 
                 nums[max] == 1 && (distinctFreqs == 1 || nums[max - 1] != 0))) 
            {
                result = i + 1;
            }
        }

        return result;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single linear pass over the array, all operations inside are amortized O(1) (dictionary access + array updates) |
| **Space Complexity**  | **O(n)**      | Dictionary stores at most n distinct values in the worst case (when all elements are unique) |

**Optimal** — linear time and near-linear space, perfect for n ≤ 10⁵ constraints.

---

## Why This Works — Example Walkthrough

**Example 1**: `nums = [2,2,1,1,5,3,3,5]`

- At prefix length 7: [2,2,1,1,5,3,3]
  - Frequencies: 2 appears 2×, 1 appears 2×, 5 appears 1×, 3 appears 2×
  - max = 2
  - distinctFreqs = 2 (frequencies present: 1 and 2)
  - nums[2] = 3 (three numbers have frequency 2: 2,1,3)
  - After removing one 5 (the only one with freq=1) → remaining numbers all have frequency 2
  - Condition triggers → length **7** → correct

**Example 2**: long array up to length 13

- At length 13, after adding the last element
- Removing one specific element balances all frequencies → **13** → correct

**Correct** — clever reuse of the `nums` array as a frequency-of-frequencies counter + `distinctFreqs` + `max` tracking allows checking the condition in **O(1)** per step after updates.

---

## Pitfalls & Edge Cases

- **All elements are the same** → remove one → all remaining have equal frequency → valid
- **All elements unique** → remove one → all remaining have frequency 1 → valid
- **Prefix becomes empty after removal** → considered valid (all frequencies = 0)
- **n ≤ 10⁵** → linear pass is fine
- **Values up to 10⁵** → Dictionary handles large keys safely

All handled perfectly.

---

## Key Takeaway

This is a **beautifully tricky** frequency-of-frequencies problem with clever optimizations:

- Track `freqs[num]` — how many times each number appears (Dictionary)
- Reuse `nums` array as `freqOfFreq` — `nums[f]` = how many different numbers have frequency exactly f
- Track `max` — current maximum frequency in the prefix
- Track `distinctFreqs` — how many distinct frequency values currently exist
- At each prefix length check special conditions in O(1):
  - `distinctFreqs <= 2` (at most two different frequencies)
  - `max == 0` (empty or trivial)
  - `nums[0] == 1` (some number has freq 1)
  - `nums[max] == 1` (only one number has the max frequency) and either `distinctFreqs == 1` or `nums[max-1] != 0` (others exist at max-1)
- Update answer whenever condition holds

**Pure, clean, optimal** — genius O(1) per step check for the maximum prefix where removing exactly one element makes all frequencies equal.

---

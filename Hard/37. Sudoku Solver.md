# 🧠 Sudoku Solver — Backtracking Pattern

## 📘 Problem Description

You're given a partially filled 9×9 Sudoku board. The goal is to fill in the empty cells (denoted by `'.'`) so that the final board satisfies all Sudoku rules:

- Each digit `1–9` must appear exactly once in each **row**
- Each digit `1–9` must appear exactly once in each **column**
- Each digit `1–9` must appear exactly once in each **3×3 sub-box**

It is guaranteed that the input board has **exactly one solution**.

---

## 🔍 Initial Understanding

From the problem description, it’s clear that:
- We need to **fill empty cells** while maintaining constraints.
- The constraints are **local** (row, column, box), but the solution is **global** — all cells must be valid together.
- This naturally suggests a **backtracking approach**:
  - Try placing a digit
  - Check if it’s valid
  - Recurse
  - If it leads to a dead end, backtrack

---

## 🧩 Architectural Idea

I realized this is a classic **constraint satisfaction problem**.  
The moment I saw:
- Fixed grid size (9×9)
- Local constraints (row, col, box)
- Guaranteed unique solution

I knew backtracking would be the cleanest approach.  
So I built a recursive solver that:
- Scans the board for empty cells
- Tries digits `'1'` to `'9'`
- Validates each digit using a helper
- Recurses if valid, backtracks if not

---

## ✅ Code Implementation

```csharp
public class Solution {
    public void SolveSudoku(char[][] board) {
        Solve(board);
    }

    private bool Solve(char[][] board){
        for(int row = 0; row < 9; row++){
            for(int col = 0; col < 9; col++){
                if(board[row][col] == '.'){
                    for(char c = '1'; c <= '9'; c++){
                        if(IsValid(board, row, col, c)){
                            board[row][col] = c;

                            if(Solve(board)) return true;

                            board[row][col] = '.'; // backtrack
                        }
                    }
                    return false; // no valid digit found
                }
            }
        }
        return true; // board is filled
    }

    private bool IsValid(char[][] board, int row, int col, char c){
        for(int i = 0; i < 9; i++){
            if(board[row][i] == c) return false; // check row
            if(board[i][col] == c) return false; // check column

            int boxRow = 3 * (row / 3) + i / 3;
            int boxCol = 3 * (col / 3) + i % 3;
            if(board[boxRow][boxCol] == c) return false; // check 3x3 box
        }
        return true;
    }
}
```
## 🔍 Code Breakdown — Sudoku Solver

### 🔧 `Solve(board)`
- Scans the board for the first empty cell (`'.'`).
- Tries digits `'1'` to `'9'`.
- For each digit:
  - If `IsValid`, places the digit and recurses.
  - If recursion fails, resets the cell to `'.'` (backtrack).
- If no digit fits, returns `false`.
- If all cells are filled successfully, returns `true`.

### 🔍 `IsValid(board, row, col, c)`
Checks whether placing digit `c` at position `(row, col)` violates any Sudoku constraints:
- **Row check**: `board[row][i] == c` for any `i ∈ [0,8]`.
- **Column check**: `board[i][col] == c` for any `i ∈ [0,8]`.
- **3×3 box check**:
  - Compute box coordinates:
    ```csharp
    int boxRow = 3 * (row / 3) + i / 3;
    int boxCol = 3 * (col / 3) + i % 3;
    ```
  - Ensure `board[boxRow][boxCol] != c` for all `i ∈ [0,8]`.

---

## 📊 Complexity Analysis

| Metric   | Value                 | Reasoning                                                                 |
|----------|-----------------------|---------------------------------------------------------------------------|
| Time     | Exponential (worst)   | Up to 9 choices per empty cell; pruning via `IsValid` reduces paths.     |
| Space    | O(1) extra            | In-place mutation of the board; no auxiliary structures used.            |

Note: Despite exponential worst-case, the fixed board size and constraint pruning make it efficient in practice.

---

## 🧠 Denis-style Insight

- This is a **pure backtracking engine** with constraint filtering.
- `IsValid` acts as a **local validator**, enforcing architectural rules.
- The recursive structure is **depth-first**, with rollback on failure.
- The 3×3 box indexing is a **reusable invariant** for grid-based problems.

### 🧬 Generalization Potential
This template generalizes to other constraint-based grid problems:
- 🧩 **N-Queens** — row/col/diagonal constraints
- ✏️ **Crossword fill-ins** — word placement with overlap rules
- 🔢 **KenKen / Kakuro** — arithmetic constraints
- 💣 **Minesweeper** — recursive propagation and reveal logic

---

## 🧱 Archive Placement

- **File**: `backtracking_templates.md`
- **Section**: `Sudoku Solver`
- **Tags**: `grid`, `constraint`, `recursive`, `invariant`, `rollback`

---

## ✅ Final Notes

This problem reinforces key architectural patterns:
- Structuring recursive search with early exit conditions.
- Validating constraints efficiently using local checks.
- Rolling back state cleanly during backtracking.

It’s not just a puzzle — it’s a **blueprint for solving structured constraint problems** with recursion and pruning.  
The 3×3 box indexing formula is a **critical invariant** worth extracting into your playbook.

---

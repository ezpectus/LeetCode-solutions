# ğŸ§  Sudoku Solver â€” Backtracking Pattern

## ğŸ“˜ Problem Description

You're given a partially filled 9Ã—9 Sudoku board. The goal is to fill in the empty cells (denoted by `'.'`) so that the final board satisfies all Sudoku rules:

- Each digit `1â€“9` must appear exactly once in each **row**
- Each digit `1â€“9` must appear exactly once in each **column**
- Each digit `1â€“9` must appear exactly once in each **3Ã—3 sub-box**

It is guaranteed that the input board has **exactly one solution**.

---

## ğŸ” Initial Understanding

From the problem description, itâ€™s clear that:
- We need to **fill empty cells** while maintaining constraints.
- The constraints are **local** (row, column, box), but the solution is **global** â€” all cells must be valid together.
- This naturally suggests a **backtracking approach**:
  - Try placing a digit
  - Check if itâ€™s valid
  - Recurse
  - If it leads to a dead end, backtrack

---

## ğŸ§© Architectural Idea

I realized this is a classic **constraint satisfaction problem**.  
The moment I saw:
- Fixed grid size (9Ã—9)
- Local constraints (row, col, box)
- Guaranteed unique solution

I knew backtracking would be the cleanest approach.  
So I built a recursive solver that:
- Scans the board for empty cells
- Tries digits `'1'` to `'9'`
- Validates each digit using a helper
- Recurses if valid, backtracks if not

---

## âœ… Code Implementation

```csharp
public class Solution {
    public void SolveSudoku(char[][] board) {
        Solve(board);
    }

    private bool Solve(char[][] board){
        for(int row = 0; row < 9; row++){
            for(int col = 0; col < 9; col++){
                if(board[row][col] == '.'){
                    for(char c = '1'; c <= '9'; c++){
                        if(IsValid(board, row, col, c)){
                            board[row][col] = c;

                            if(Solve(board)) return true;

                            board[row][col] = '.'; // backtrack
                        }
                    }
                    return false; // no valid digit found
                }
            }
        }
        return true; // board is filled
    }

    private bool IsValid(char[][] board, int row, int col, char c){
        for(int i = 0; i < 9; i++){
            if(board[row][i] == c) return false; // check row
            if(board[i][col] == c) return false; // check column

            int boxRow = 3 * (row / 3) + i / 3;
            int boxCol = 3 * (col / 3) + i % 3;
            if(board[boxRow][boxCol] == c) return false; // check 3x3 box
        }
        return true;
    }
}
```
## ğŸ” Code Breakdown â€” Sudoku Solver

### ğŸ”§ `Solve(board)`
- Scans the board for the first empty cell (`'.'`).
- Tries digits `'1'` to `'9'`.
- For each digit:
  - If `IsValid`, places the digit and recurses.
  - If recursion fails, resets the cell to `'.'` (backtrack).
- If no digit fits, returns `false`.
- If all cells are filled successfully, returns `true`.

### ğŸ” `IsValid(board, row, col, c)`
Checks whether placing digit `c` at position `(row, col)` violates any Sudoku constraints:
- **Row check**: `board[row][i] == c` for any `i âˆˆ [0,8]`.
- **Column check**: `board[i][col] == c` for any `i âˆˆ [0,8]`.
- **3Ã—3 box check**:
  - Compute box coordinates:
    ```csharp
    int boxRow = 3 * (row / 3) + i / 3;
    int boxCol = 3 * (col / 3) + i % 3;
    ```
  - Ensure `board[boxRow][boxCol] != c` for all `i âˆˆ [0,8]`.

---

## ğŸ“Š Complexity Analysis

| Metric   | Value                 | Reasoning                                                                 |
|----------|-----------------------|---------------------------------------------------------------------------|
| Time     | Exponential (worst)   | Up to 9 choices per empty cell; pruning via `IsValid` reduces paths.     |
| Space    | O(1) extra            | In-place mutation of the board; no auxiliary structures used.            |

Note: Despite exponential worst-case, the fixed board size and constraint pruning make it efficient in practice.

---

## ğŸ§  Denis-style Insight

- This is a **pure backtracking engine** with constraint filtering.
- `IsValid` acts as a **local validator**, enforcing architectural rules.
- The recursive structure is **depth-first**, with rollback on failure.
- The 3Ã—3 box indexing is a **reusable invariant** for grid-based problems.

### ğŸ§¬ Generalization Potential
This template generalizes to other constraint-based grid problems:
- ğŸ§© **N-Queens** â€” row/col/diagonal constraints
- âœï¸ **Crossword fill-ins** â€” word placement with overlap rules
- ğŸ”¢ **KenKen / Kakuro** â€” arithmetic constraints
- ğŸ’£ **Minesweeper** â€” recursive propagation and reveal logic

---

## ğŸ§± Archive Placement

- **File**: `backtracking_templates.md`
- **Section**: `Sudoku Solver`
- **Tags**: `grid`, `constraint`, `recursive`, `invariant`, `rollback`

---

## âœ… Final Notes

This problem reinforces key architectural patterns:
- Structuring recursive search with early exit conditions.
- Validating constraints efficiently using local checks.
- Rolling back state cleanly during backtracking.

Itâ€™s not just a puzzle â€” itâ€™s a **blueprint for solving structured constraint problems** with recursion and pruning.  
The 3Ã—3 box indexing formula is a **critical invariant** worth extracting into your playbook.

---

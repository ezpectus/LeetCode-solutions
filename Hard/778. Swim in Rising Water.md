# ðŸ§© LeetCode 778 â€” Swim in Rising Water

## ðŸ“Œ Problem Summary

You're given an `n Ã— n` matrix `grid` where `grid[i][j]` represents the elevation at cell `(i, j)`.

Water rises over time. At time `t`, you can swim through any cell with elevation `â‰¤ t`.  
You start at `(0, 0)` and want to reach `(n - 1, n - 1)` as early as possible.

Return the **minimum time `t`** such that a path exists from top-left to bottom-right.

---

## ðŸ§ My Approach

I reframed the problem as a **minimum-cost path**, where cost is defined by the **maximum elevation** encountered along the path.

This leads to a **Dijkstra-style BFS**:

- Each cell is a node with weight `grid[i][j]`  
- We always move to the lowest elevation available  
- The result is the **maximum elevation** on the path to `(n - 1, n - 1)`

No brute force, no simulation â€” just clean pathfinding over elevation constraints.

---

## ðŸ§± Step-by-Step Explanation

### ðŸ”¹ Step 1: Initialize
- Use a `PriorityQueue<(r, c), elevation>` to always expand the lowest elevation first  
- Track visited cells to avoid revisits

### ðŸ”¹ Step 2: BFS traversal
- At each step, dequeue the cell with the lowest elevation  
- Update `res = max(res, grid[r][c])`  
- If we reach `(n - 1, n - 1)` â†’ return `res`  
- Otherwise, enqueue all unvisited neighbors

### ðŸ”¹ Step 3: Return result
- If traversal completes without reaching the goal â†’ return `-1` (shouldn't happen)

---

## âœ… Final Code (C#)

```csharp
public class Solution {
    public int SwimInWater(int[][] grid) {
        int n = grid.Length;
        var visited = new bool[n, n];
        var pq = new PriorityQueue<(int r, int c), int>();
        pq.Enqueue((0, 0), grid[0][0]);

        int[][] dirs = new int[][] {
            new int[]{0, 1}, new int[]{1, 0},
            new int[]{0, -1}, new int[]{-1, 0}
        };

        int res = 0;

        while (pq.Count > 0) {
            var (r, c) = pq.Dequeue();
            if (visited[r, c]) continue;
            visited[r, c] = true;
            res = Math.Max(res, grid[r][c]);

            if (r == n - 1 && c == n - 1) return res;

            foreach (var d in dirs) {
                int nr = r + d[0], nc = c + d[1];
                if (nr >= 0 && nr < n && nc >= 0 && nc < n && !visited[nr, nc]) {
                    pq.Enqueue((nr, nc), grid[nr][nc]);
                }
            }
        }

        return -1; 
    }
}
```

## ðŸ§® Time & Space Complexity

| Metric         | Value          |
|----------------|----------------|
| Time           | O(nÂ² log n)    |
| Space          | O(nÂ²)          |
| PriorityQueue  | Min-heap by elevation |

---

## ðŸ§˜ Why This Works

âœ… Always expands lowest elevation first  
âœ… Tracks max elevation on path  
âœ… Guarantees earliest possible arrival  
âœ… No brute force, no simulation  
âœ… Scales cleanly to n = 50

---

## ðŸ§  My Takeaway

This task looks like simulation, but it's really **minimum-cost pathfinding over elevation constraints**.  
I reused a Dijkstra-style pattern â€” expanding by elevation â€” and avoided brute force or dynamic programming.  
The result is fast, minimal, and architecturally sound.

This is the kind of module I want in my repo:  
**Not just passing â€” but built to last.**


---

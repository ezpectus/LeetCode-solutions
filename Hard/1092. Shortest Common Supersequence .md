# 1092. Shortest Common Supersequence — Architectural LCS-Based Construction  
*O(mn) — Optimal DP Table + Backward Build*

---
## Problem Statement

Given two strings `str1` and `str2`.

Find the **shortest string** that has **both** `str1` and `str2` as **subsequences**.

Return **any** such string (multiple valid answers possible).

---

## Core Idea — Use LCS DP Table to Build SCS

**Key insight**:
- The length of the shortest common supersequence (SCS) is `m + n - LCS_length`, where `m` and `n` are lengths of the strings and `LCS_length` is the length of their longest common subsequence.
- To **construct** the SCS:
  - First compute the standard **LCS DP table**.
  - Then **backtrack** from the bottom-right corner of the table:
    - If characters match → include the character **once** and move diagonally.
    - Else → include the character from the string that leads to the **higher LCS value** in the remaining part (greedy choice).
  - After backtracking, append any remaining characters from either string.

**No extra states needed** — the classic LCS table is sufficient for both length and construction.


##  Implementation (C++)

```cpp
class Solution {
public:
    string shortestCommonSupersequence(string str1, string str2) {
        int m = str1.size();
        int n = str2.size();

        // dp[i][j] = LCS length of str1[0..i-1] and str2[0..j-1]
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (str1[i - 1] == str2[j - 1])  dp[i][j] = dp[i - 1][j - 1] + 1;
                else  dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                
            }
        }

        // Build SCS backward
        string res;
        int i = m, j = n;

        while (i > 0 && j > 0) {
            if (str1[i - 1] == str2[j - 1])  {
                res.push_back(str1[i - 1]);
                --i;
                --j;
            } 
            else if (dp[i - 1][j] > dp[i][j - 1]) {
                res.push_back(str1[i - 1]);
                --i;
            } 
            else {
                res.push_back(str2[j - 1]);
                --j;
            }
        }

        // Remaining characters
        while (i > 0)  {
            res.push_back(str1[i - 1]);
            --i;
        }
        while (j > 0) {
            res.push_back(str2[j - 1]);
            --j;
        }

        reverse(res.begin(), res.end());
        return res;
    }
};
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(mn)**     | DP table fill + linear backward build          |
| **Space Complexity**  | **O(mn)**     | DP table (can be optimized to O(min(m,n)))     |

**Optimal** — standard for LCS-based problems.

---

## Why This Works — Example Walkthrough

**Input**: `str1 = "abac"`, `str2 = "cab"`

- **LCS length** = 2 (e.g., "ab" or "ac")
- **SCS length** = 4 + 3 - 2 = **5**

**Backward build** (starting from end):

- i=4 ('c' in str1), j=3 ('b' in str2) → no match → prefer str1 side (dp check) → take **'c'** from str1
- i=3 ('a'), j=3 ('b') → no match → take **'b'** from str2
- i=3 ('a'), j=2 ('a') → **match** → take **'a'**
- i=2 ('b'), j=1 ('c') → no match → take **'c'** from str2
- i=2 ('b'), j=0 → take **'b'** from str1

Reverse result → **"cabac"**

**Correct** — both `str1` and `str2` are subsequences, length minimal.

---

## Pitfalls & Edge Cases

- **Identical strings** → return one string
- **No common characters** → concatenate both
- **One string empty** → return the other
- **Large overlap** → maximal character reuse via LCS

All handled perfectly.

---

## Key Takeaway

This is a **masterpiece of DP construction**:

- **LCS table** → guides optimal merging decisions
- **Backward build** → greedy choice using DP values
- **Minimal length guaranteed** by LCS formula

**Pure, clean, optimal** — classic Hard string DP.

---

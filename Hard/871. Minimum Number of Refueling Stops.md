# 871. Minimum Number of Refueling Stops

**Difficulty:** Hard  
**Topics:** Greedy, Priority Queue, Dynamic Programming  

---

##  Problem Restatement
You are driving a car to reach a destination `target` miles away.  
You start with `startFuel` liters of fuel in the tank.  
There are gas stations along the way, each represented as `[position, fuel]`.  

- `position` = distance from the start.  
- `fuel` = amount of fuel the station provides.  

You can stop at any station to refuel.  
Return the **minimum number of refueling stops** needed to reach the target.  
If it is impossible, return `-1`.

---

##  Core Idea
- As you drive, subtract the fuel needed to reach the next station.  
- If fuel becomes negative, you must refuel from previously passed stations.  
- Always refuel from the **largest available fuel station** first → greedy choice.  
- Use a **max-heap (priority queue)** to store fuel from stations you pass.  
- Each time you run out of fuel, pop the largest fuel from the heap.  
- Continue until you reach the target or fail.

---

##  Step-by-Step Algorithm
1. Initialize a max-heap to store available fuel.  
2. Traverse all stations + the target (treated as a final station with 0 fuel).  
3. For each station:  
   - Subtract the distance traveled from current fuel.  
   - While fuel < 0 and heap not empty → refuel from heap (largest fuel).  
   - If fuel < 0 and heap empty → return `-1`.  
   - Add current station’s fuel to heap for possible future use.  
4. Return the number of refuels performed.

---

##  C# Implementation
```csharp
public class Solution {
    public int MinRefuelStops(int target, int startFuel, int[][] stations) {
        var maxHeap = new PriorityQueue<int, int>();
        int fuel = startFuel, refuels = 0, prev = 0;

        for (int i = 0; i <= stations.Length; i++) {
            int pos = (i < stations.Length) ? stations[i][0] : target;
            int cap = (i < stations.Length) ? stations[i][1] : 0;

            fuel -= pos - prev;

            while (fuel < 0 && maxHeap.Count > 0) {
                maxHeap.TryDequeue(out int add, out _);
                fuel += add;
                refuels++;
            }

            if (fuel < 0) return -1;

            maxHeap.Enqueue(cap, -cap);
            prev = pos;
        }

        return refuels;
    }
}
```

##  Complexity Analysis

- **Time Complexity: O(n log n)**  
  - Sorting is not required since stations are already given in order of position.  
  - Each station is added to the heap once → O(n log n).  
  - Each refuel operation pops from the heap → O(n log n) in total.  
  - Overall runtime: O(n log n).  

- **Space Complexity: O(n)**  
  - The heap stores fuel values of stations passed.  
  - At most, all stations can be in the heap simultaneously.  
  - Memory usage is linear in the number of stations.

---

##  Pitfalls

1. **Target as a final station**  
   - Must treat the target as a station with 0 fuel.  
   - This unifies the loop and ensures the last stretch is handled correctly.  

2. **Subtract distance before adding fuel**  
   - Always reduce fuel by the distance traveled before considering the station’s fuel.  
   - Prevents overestimating available fuel.  

3. **Empty heap scenario**  
   - If fuel < 0 and heap is empty → impossible, return `-1`.  
   - Critical check to avoid invalid states.  

4. **Heap orientation**  
   - Must be max-oriented (largest fuel first).  
   - In C#, `PriorityQueue` is min-heap by default, so use negative priorities.  

5. **Edge cases**  
   - No stations and `startFuel < target` → `-1`.  
   - Enough initial fuel → `0` refuels.  
   - Stations with 0 fuel → harmless, but still added to heap.  

---

##  Example Walkthrough

**Input:**  
`target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]`

- Start: fuel = 10  
- Reach station at 10 → fuel = 0, add 60 to heap.  
- Next station at 20 → fuel = -10 → refuel 60 → fuel = 50, refuels = 1.  
- Add 30 to heap.  
- Next station at 30 → fuel = 40, add 30 to heap.  
- Next station at 60 → fuel = 10, add 40 to heap.  
- Target at 100 → fuel = -30 → refuel 40 → fuel = 10, refuels = 2.  
- Target reached.  

**Output:** `2`

---

##  Key Takeaway

- **Greedy + max-heap** ensures minimal refuels.  
- Always refuel from the **largest available station** when stuck.  
- Treat target as a station to unify logic.  
- Clean, efficient solution: **O(n log n) time, O(n) space**.  
- Elegant approach that balances correctness and performance.



---




# 🧠 LeetCode 1044 — Longest Duplicate Substring

---

## 🔍 Description

Given a string `s`, return the longest substring that appears **at least twice**.  
Occurrences may **overlap**, and the substring must be **contiguous**.

If no duplicate substring exists, return `""`.

---

### 🧩 Example

```text
Input:  s = "banana"
Output: "ana"

Input:  s = "abcd"
Output: ""
```
## 💡 Idea
This is a classic Rabin-Karp + Binary Search combo:

- Use binary search to guess the length of the longest duplicate substring
- For each guess, use rolling hash to check if any substring of that length repeats
- If yes → try longer length
- If no → try shorter length

This avoids brute-force comparison and guarantees O(n log n) time.

## 🧱 C# Implementation
```csharp
public class Solution {
    private static readonly long P = 10000007L;
    private const int BASE = 26;

    public string LongestDupSubstring(string s) {  
        if (string.IsNullOrEmpty(s) || s.Length == 1) return "";

        int n = s.Length;
        int left = 1, right = n;   
        string best = "";

  
        long[] pow = new long[n + 1];
        pow[0] = 1;
        for (int i = 1; i <= n; i++)
            pow[i] = (pow[i - 1] * BASE) % P;

        while (left <= right)
        {
            int mid = left + (right - left) / 2;   
            string dup = FindDuplicateOfLength(s, mid, pow);

            if (dup.Length > 0)
            {
              
                if (dup.Length > best.Length) best = dup;
                left = mid + 1;
            }
            else
            {
            
                right = mid - 1;
            }
        }

        return best; 
    }

    private string FindDuplicateOfLength(string s, int L, long[] pow)
    {
        if (L == 0) return "";

        int n = s.Length;
        long hash = 0;

  
        for (int i = 0; i < L; i++)
        {
            hash = (hash * BASE + (s[i] - 'a')) % P;
        }

    
        var map = new Dictionary<long, List<int>>();
        map[hash] = new List<int> { 0 };

   
        for (int i = L; i < n; i++)
        {
         
            long remove = ((s[i - L] - 'a') * pow[L - 1]) % P;
            hash = (hash - remove + P) % P;            
        
            hash = (hash * BASE + (s[i] - 'a')) % P;

            int start = i - L + 1;

            if (map.TryGetValue(hash, out var starts))
            {
            
                foreach (int prevStart in starts)
                {
                   
                    if (StringsEqual(s, prevStart, start, L))
                    {
                        return s.Substring(start, L);
                    }
                }
                starts.Add(start);
            }
            else
            {
                map[hash] = new List<int> { start };
            }
        }

        return "";
    }

    private bool StringsEqual(string s, int i, int j, int len)
    {
        for (int k = 0; k < len; k++)
            if (s[i + k] != s[j + k]) return false;
        return true;
    }
}

```


## ⏱️ Complexity
- Time: O(n log n)
- Binary search over substring length
- Rolling hash for each window
- Space: O(n)
- HashSet to store seen hashes
- No extra string storage

## Conclusion
This isn’t brute-force — it’s binary-guided substring compression. 

You lead through:

- rolling hash — compressing substrings into numeric fingerprints
- binary search — guiding the search toward maximal length
- collision detection — using hash sets to avoid redundant checks

This module doesn’t just find duplicates — it compresses the search space, turning O(n²) into O(n log n) with clean, reusable primitives.


---

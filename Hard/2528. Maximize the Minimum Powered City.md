# Problem: Maximize the Minimum Powered City
- Number: LeetCode 2528
- Difficulty: Hard Language: C++

## Problem Overview
You're given:

- An array stations[i] — number of power stations in city i
- A range r — each station powers cities within |i - j| <= r
- A budget k — number of additional stations you can place anywhere
- Goal: Maximize the minimum power across all cities after optimally placing the k extra stations.

## Constraints
- 1 <= stations.length <= 10^5
- 0 <= stations[i] <= 10^5
- 0 <= r <= n - 1
- 0 <= k <= 10^9

## Intuition
- Increasing the target minimum power requires more additional stations
- Decreasing the target requires fewer
- So we can apply binary search on the answer space to find the maximum achievable minimum power
- We define a helper function isGood(minPowerRequired) to check whether it's possible to achieve minPowerRequired using at most k additional stations.

## Idea
- For each city i, its power is the sum of stations in [i - r, i + r]
- We simulate this using a sliding window
- If a city has less than minPowerRequired, we greedily place extra stations at i + r to cover as many cities as possible
- We track how many stations we’ve placed — must not exceed k

## Step-by-Step Construction
1. Binary Search:
```cpp
long long left = 0;
long long right = sum(stations) + k;
while (left <= right) {
    long long mid = (left + right) / 2;
    if (isGood(mid)) {
        ans = mid;
        left = mid + 1;
    } else {
        right = mid - 1;
    }
}
```

2. Feasibility Check (isGood):
```cpp
long long windowPower = sum of stations in [0, r - 1];
for each city i:
    add stations[i + r] to windowPower
    if windowPower < minPowerRequired:
        place extra stations at i + r
        update additions[]
        subtract from additionalStations
    subtract stations[i - r] and additions[i - r] from windowPower
```
   
## C++ Code
```cpp
class Solution {
public:
    long long maxPower(vector<int>& stations, int r, int k) {
        long long left = 0;
        long long right = accumulate(stations.begin(), stations.end(), 0LL) + k;
        long long ans = 0;
        while (left <= right) {
            long long mid = (left + right) / 2;
            if (isGood(stations, r, mid, k)) {
                ans = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return ans;
    }

    bool isGood(vector<int>& stations, int r, long long minPowerRequired, int additionalStations) {
        int n = stations.size();
        long long windowPower = accumulate(stations.begin(), stations.begin() + r, 0LL);
        vector<int> additions(n, 0);
        for (int i = 0; i < n; ++i) {
            if (i + r < n)
                windowPower += stations[i + r];
            if (windowPower < minPowerRequired) {
                long long need = minPowerRequired - windowPower;
                if (need > additionalStations)
                    return false;
                additions[min(n - 1, i + r)] += need;
                windowPower = minPowerRequired;
                additionalStations -= need;
            }
            if (i - r >= 0)
                windowPower -= stations[i - r] + additions[i - r];
        }
        return true;
    }

};
```
## Complexity Analysis

| Aspect | Complexity | Explanation |
|--------|------------|-------------|
| **Time** | `O(n * log(sum + k))` | - `n`: number of cities<br>- `sum`: total number of initial stations<br>- `k`: number of additional stations allowed<br>- Binary search explores possible minimum power values in the range `[0, sum + k]`, which gives `log(sum + k)` iterations<br>- Each iteration performs a linear simulation across all cities to validate feasibility |
| **Space** | `O(n)` | - A separate array `additions[n]` is used to track placement of extra stations<br>- This allows clean simulation without modifying the original input<br>- No additional data structures beyond linear buffers are required |

---

## Why This Works

- **Binary search** transforms the optimization goal ("maximize the minimum") into a decision problem: "can this minimum be achieved?"  
- **Sliding window** computes the total power received by each city in amortized `O(1)` time, avoiding recomputation  
- **Greedy placement** ensures that each extra station is placed at the farthest point within a city's coverage range, maximizing downstream effect  
- **Simulation logic** respects both the range of influence and the total budget `k`  
- **Separation of state** between original and added stations keeps the simulation clean and traceable

---

## How to Think About It

This task models a constrained resource distribution problem over a range-based influence system.

- Each station contributes power to a fixed-radius neighborhood  
- The goal is not to maximize total power, but to **raise the weakest city** as high as possible  
- The challenge lies in **strategically placing limited extra stations** so that their influence lifts multiple cities simultaneously  
- The solution must simulate this influence efficiently and validate whether a target minimum power is achievable

---

## Related Concepts

- Binary search on answer space  
- Sliding window sum  
- Greedy placement strategy  
- Range coverage optimization  
- Simulation with auxiliary arrays  
- Difference array (alternative for range updates)

---

## Architectural Commentary

This problem is a simulation of range-based influence under budget constraints.

- Each city receives power from stations within a fixed radius  
- The task is to determine the highest possible minimum power across all cities  
- This is achieved by binary searching over candidate values and simulating whether each can be reached  
- The simulation uses a sliding window to compute power and a greedy strategy to place extra stations  
- The approach avoids brute-force and ensures correctness even on large inputs

**Core principles:**

- Model the problem as a decision check over a continuous answer space  
- Use efficient range aggregation (sliding window or difference array)  
- Place resources where they yield maximum coverage  
- Track state separately to avoid side effects

This is not a simple greedy task.  
It is a **range-aware simulation**, wrapped in a **binary search framework**, designed for large-scale input and precise control over influence propagation.



---

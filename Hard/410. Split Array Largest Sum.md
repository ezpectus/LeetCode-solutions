# 🔺 Problem: Split Array Largest Sum (Leetcode 410)
## 📜 Statement
- Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized.
- Return the minimized largest sum of the split. A subarray is a contiguous part of the array.

 ##  🧠 Core Idea
This is a binary search on the answer problem.

The minimized largest subarray sum lies between:

- Lower bound = max(nums) (at least one subarray must contain the largest element).
- Upper bound = sum(nums) (if we take the whole array as one subarray).
- Use binary search to find the smallest possible maximum subarray sum.
- For each candidate mid, greedily check:
- Traverse nums, accumulate sum.

- If adding nums[i] exceeds mid, start a new subarray.
- Count how many subarrays are needed.
- If subarrays ≤ k, we can try smaller mid. Otherwise, increase mid.

## 🧱 C# Implementation
```csharp
public class Solution {
    public int SplitArray(int[] nums, int k) {
        int n = nums.Length;
        int lnum = 0, total = 0;

        // Lower bound = max element, Upper bound = sum of all
        for (int i = 0; i < n; i++) {
            lnum = Math.Max(lnum, nums[i]);
            total += nums[i];
        }

        int l = lnum, h = total;

        while (l <= h) {
            int mid = l + (h - l) / 2;
            int count = 1, curr = 0;

            for (int i = 0; i < n; i++) {
                if (curr + nums[i] > mid) {
                    count++;
                    if (count > k) break;
                    curr = nums[i];
                } else {
                    curr += nums[i];
                }
            }

            if (count <= k) {
                h = mid - 1; // try smaller max sum
            } else {
                l = mid + 1; // need larger max sum
            }
        }

        return l;
    }
}
```

## 🔍 Why This Works

- Binary Search on Answer: Instead of guessing partitions, we search the minimal feasible maximum sum.
- Greedy Check: For each candidate mid, simulate splitting.
- Correctness: If mid works for k subarrays, any larger value also works. If it fails, smaller values cannot work.

## 🧮 Time & Space Complexity

- Time	O(n log(sum(nums)))	```Each check is O(n), binary search range```
- Space	O(1)	Constant extra space
- Scalability	Excellent	Works for n ≤ 1000, nums[i] ≤ 10⁶

## 🧠 Engineering Takeaway
This problem is a classic binary search on the answer pattern:

- Lower bound = max element
- Upper bound = sum of array
- Instead of brute forcing partitions, we search the minimal feasible maximum sum.





---

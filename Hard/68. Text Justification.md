# 68. Text Justification (Hard)

---

##  Problem Restatement
Given an array of words and a maximum width `maxWidth`, format the text so that:
- Each line has exactly `maxWidth` characters.
- Lines are fully justified (both left and right).
- Extra spaces are distributed as evenly as possible.
- If spaces cannot be evenly distributed, the left slots get more spaces.
- The last line is left‑justified.

---

##  Core Idea
1. **Greedy packing:**  
   - Collect as many words as possible into a line until adding another word would exceed `maxWidth`.

2. **Line formatting:**  
   - **Last line or single word line:** left‑justified → words separated by single spaces, remainder padded on the right.  
   - **Normal line:** fully justified →  
     - Compute total spaces = `maxWidth - sum(wordLengths)`.  
     - Divide evenly across gaps.  
     - Distribute extra spaces to the leftmost gaps.

3. **Algorithm flow:**  
   - Iterate through words.  
   - For each line, determine start and end indices.  
   - Build the line string according to justification rules.  
   - Append to result list.

---

##  Implementation (C#)

```csharp
public class Solution {
    public IList<string> FullJustify(string[] words, int maxW) {
        var res = new List<string>();
        int i = 0;
        while (i < words.Length) {
            int j = i, len = 0;
            while (j < words.Length && len + words[j].Length + (j - i) <= maxW) {
                len += words[j].Length;
                j++;
            }
            bool last = j == words.Length;
            int gaps = j - i - 1;
            var sb = new System.Text.StringBuilder();
            if (last || gaps == 0) {
                // Left-justified
                for (int k = i; k < j; k++) {
                    sb.Append(words[k]);
                    if (k < j - 1) sb.Append(' ');
                }
                sb.Append(' ', maxW - sb.Length);
            } else {
                int space = maxW - len;
                int gap = space / gaps, extra = space % gaps;
                for (int k = i; k < j; k++) {
                    sb.Append(words[k]);
                    if (k < j - 1) {
                        sb.Append(' ', gap + (k - i < extra ? 1 : 0));
                    }
                }
            }
            res.Add(sb.ToString());
            i = j;
        }
        return res;
    }
}
```


##  Time Complexity
- Each word is processed once during greedy packing.  
- **Overall:** `O(n)` where `n = words.Length`.

---

##  Space Complexity
- Result list stores all formatted lines.  
- **Overall:** `O(n)`.

---

#  Impact of Design Choices

| Choice                          | Effect                                                   |
|---------------------------------|----------------------------------------------------------|
| **Greedy packing**              | Ensures maximum words per line.                          |
| **Separate handling of last line** | Guarantees left‑justification.                           |
| **Even space distribution**     | Achieves full justification with minimal imbalance.      |
| **Extra spaces to left gaps**   | Matches problem requirement for uneven distribution.     |

---

#  Pitfalls
- Forgetting to handle single‑word lines separately.  
- Miscomputing spaces when `len + gaps == maxWidth`.  
- Not padding the last line with trailing spaces.  

---

#  Conclusion
- **What it gives:** Properly justified text with exact width.  
- **Why it matters:** Demonstrates greedy packing + careful space distribution.  
- **Key takeaway:**  
  1. Pack words greedily.  
  2. Handle last line and single‑word lines separately.  
  3. Distribute spaces evenly, extra to the left.  



---





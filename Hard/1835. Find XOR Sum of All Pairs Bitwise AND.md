# Problem: 1835. Find XOR Sum of All Pairs Bitwise AND

- You are given two non-negative integer arrays `arr1` and `arr2`.  
- For every pair `(i, j)` where `0 ≤ i < arr1.length` and `0 ≤ j < arr2.length`, compute `arr1[i] & arr2[j]` (bitwise AND).  
- Return the XOR sum of all these results.

---

## Example 1
```
**Input:**
arr1 = [1, 2, 3] arr2 = [6, 5]

**Intermediate AND list:**
[1 & 6, 1 & 5, 2 & 6, 2 & 5, 3 & 6, 3 & 5] = [0, 1, 2, 0, 2, 1]

**Output:**
0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0

```

---

## Constraints

- `1 <= arr1.length, arr2.length <= 10^5`
- `0 <= arr1[i], arr2[j] <= 10^9`

---

## Key Insight

The brute-force approach of computing all `(arr1[i] & arr2[j])` pairs is **O(n × m)** and infeasible for large arrays.

Instead, we use the identity:
```XOR(AND(a[i], b[j])) = XOR(a) & XOR(b)```
This works because:
- XOR is associative and commutative
- AND distributes over XOR: `a & (b ^ c) = (a & b) ^ (a & c)`

---

##  Optimal Solution (Bitwise Algebra Trick)

```csharp
public class Solution {
    public int GetXORSum(int[] arr1, int[] arr2) {
        int xor1 = 0;
        foreach (int a in arr1) xor1 ^= a;

        int xor2 = 0;
        foreach (int b in arr2) xor2 ^= b;

        return xor1 & xor2;
    }
}
```
- Time Complexity: O(n + m)
- Space Complexity: O(1)

---

##  Alternative Approaches

## 1. Brute Force (Time Limit Exceeded)
```csharp
public int GetXORSum(int[] arr1, int[] arr2) {
    int result = 0;
    foreach (int a in arr1)
        foreach (int b in arr2)
            result ^= (a & b);
    return result;
}
```
- Time Complexity: O(n × m) 
- Space Complexity: O(1) 
- Note: Not viable for large inputs.


## 2. Precompute AND Contributions by Bit Position
```csharp
public int GetXORSum(int[] arr1, int[] arr2) {
    int[] bitCount1 = new int[32];
    int[] bitCount2 = new int[32];

    foreach (int a in arr1)
        for (int i = 0; i < 32; i++)
            if (((a >> i) & 1) == 1) bitCount1[i]++;

    foreach (int b in arr2)
        for (int i = 0; i < 32; i++)
            if (((b >> i) & 1) == 1) bitCount2[i]++;

    int result = 0;
    for (int i = 0; i < 32; i++) {
        int count = bitCount1[i] * bitCount2[i];
        if ((count & 1) == 1)
            result |= (1 << i);
    }

    return result;
}
```

- Time Complexity: O(n + m + 32) 
- Space Complexity: O(32) 
- Note: Tracks bit-level contributions explicitly.

## 3. Functional LINQ Style (Same as Optimal)
```csharp
public int GetXORSum(int[] arr1, int[] arr2) {
    int xor1 = arr1.Aggregate(0, (acc, x) => acc ^ x);
    int xor2 = arr2.Aggregate(0, (acc, x) => acc ^ x);
    return xor1 & xor2;
}
```
- Time Complexity: O(n + m) 
- Space Complexity: O(1) 
- Note: Clean and expressive.

## Summary

## Time and Space Complexity Comparison

| Approach        | Time Complexity | Space Complexity | Description                     |
|----------------|------------------|------------------|---------------------------------|
| Bitwise Algebra | O(n + m)         | O(1)             | Optimal and elegant             |
| Brute Force     | O(n × m)         | O(1)             | Too slow for large inputs       |
| Bit Count       | O(n + m + 32)    | O(32)            | Explicit bit-level reasoning    |
| LINQ Style      | O(n + m)         | O(1)             | Same logic, functional syntax   |

---

## Final Note

This problem is labeled **Hard** not because of implementation difficulty,  
but because it requires **bitwise insight** and **algebraic transformation**.  
Once you see the identity:
```XOR(AND(a[i], b[j])) = XOR(a) & XOR(b)```
the solution becomes trivial — and that's the beauty of architectural thinking.

---

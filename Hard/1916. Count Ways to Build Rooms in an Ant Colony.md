# 1916. Count Ways to Build Rooms in an Ant Colony

**Difficulty:** Hard  
**Topics:** Graph, DFS, Combinatorics, Factorials  

---

## üìñ Problem Restatement
We are given an expansion plan for building rooms in an ant colony.  
- `prevRoom[i]` means that room `prevRoom[i]` must be built before room `i`.  
- Room `0` is already built (`prevRoom[0] = -1`).  
- Once all rooms are built, every room is reachable from room `0`.  

We must count the number of different valid orders to build all rooms, modulo `1e9+7`.

---

## üí° Core Idea
- The structure forms a **tree** rooted at room `0`.  
- Each node must be built after its parent.  
- The number of valid build orders is essentially the number of **topological sorts** of this tree.  

### Key Formula
For a node with children subtrees of sizes `s1, s2, ..., sk`:  
- Total nodes in subtree = `S = s1 + s2 + ... + sk`.  
- Ways = multinomial coefficient:  
  - `S! / (s1! * s2! * ... * sk!)`  
  - multiplied by the product of ways for each child subtree.  

This counts how many ways we can interleave the build orders of subtrees.

---

## üîé Step-by-Step Algorithm
1. Build adjacency list from `prevRoom`.  
2. Precompute factorials and inverse factorials modulo `1e9+7`.  
3. DFS from root `0`:  
   - For each node, compute size of subtree and number of ways.  
   - Use multinomial coefficient to combine children.  
4. Return the number of ways for root.  

---

## ‚úÖ C# Implementation
```csharp
public class Solution {
    const int MOD = 1000000007;
    long[] fact, invFact;

    public int WaysToBuildRooms(int[] prevRoom) {
        int n = prevRoom.Length;

        // Build adjacency list: graph[parent] -> list of children
        var graph = new List<int>[n];
        for (int i = 0; i < n; i++) graph[i] = new List<int>();
        for (int i = 1; i < n; i++) {
            graph[prevRoom[i]].Add(i);
        }

        // Precompute factorials and inverse factorials
        PrecomputeFactorials(n);

        // DFS returns (ways, size of subtree)
        (long ways, int size) Dfs(int node) {
            long ways = 1;
            int totalSize = 0;
            var sizes = new List<int>();

            // Process each child subtree
            foreach (var child in graph[node]) {
                var (childWays, childSize) = Dfs(child);
                ways = (ways * childWays) % MOD; // multiply ways of child
                sizes.Add(childSize);
                totalSize += childSize;
            }

            // Multinomial coefficient: totalSize! / (s1! * s2! * ...)
            ways = (ways * fact[totalSize]) % MOD;
            foreach (var s in sizes) {
                ways = (ways * invFact[s]) % MOD;
            }

            // Return ways and size including current node
            return (ways, totalSize + 1);
        }

        return (int)Dfs(0).ways;
    }

    // Precompute factorials and inverse factorials modulo MOD
    void PrecomputeFactorials(int n) {
        fact = new long[n+1];
        invFact = new long[n+1];
        fact[0] = 1;
        for (int i = 1; i <= n; i++) fact[i] = fact[i-1] * i % MOD;
        invFact[n] = Pow(fact[n], MOD-2); // Fermat's little theorem
        for (int i = n-1; i >= 0; i--) invFact[i] = invFact[i+1] * (i+1) % MOD;
    }

    // Fast exponentiation for modular inverse
    long Pow(long a, int b) {
        long res = 1;
        long x = a;
        int e = b;
        while (e > 0) {
            if ((e & 1) == 1) res = res * x % MOD;
            x = x * x % MOD;
            e >>= 1;
        }
        return res;
    }
}
```

## üîé Code Explanation

- **graph**: adjacency list storing children of each room.  
  This represents the tree structure of the colony expansion plan. Each node points to the rooms that depend on it.  

- **fact and invFact**: arrays of factorials and inverse factorials.  
  They are used to compute multinomial coefficients efficiently under modulo arithmetic.  

- **Dfs(node)**:  
  - Recursively computes the number of ways for each child subtree.  
  - Uses the multinomial coefficient to count how many ways we can interleave the build orders of child subtrees.  
  - Returns a tuple `(ways, size)` where `ways` is the number of valid build orders for this subtree, and `size` is the total number of nodes in the subtree.  

- **PrecomputeFactorials**: prepares factorials and modular inverses in advance.  
  Without this, computing factorials repeatedly would be too slow.  

- **Pow**: fast modular exponentiation.  
  Used to compute modular inverses of factorials via Fermat‚Äôs little theorem.  

---

## üìä Complexity Analysis

- **Time Complexity:** O(n) ‚Äî DFS visits each node once, factorials precomputed in O(n).  
- **Space Complexity:** O(n) ‚Äî graph + factorial arrays + recursion stack.  

---

## ‚ö†Ô∏è Pitfalls

- Must always apply modulo `1e9+7` to avoid overflow.  
- Include the current node itself in the subtree size (`+1`).  
- Memoization of factorials is critical; otherwise multinomial coefficient computation would be too slow.  

---

## üîé Example Walkthrough

**Input:** `prevRoom = [-1,0,0,1,2]`  

Tree structure:  
- `0 ‚Üí {1,2}`  
- `1 ‚Üí {3}`  
- `2 ‚Üí {4}`  

Valid build orders = 6.  
This comes from interleaving the sequences of building subtrees rooted at `1` and `2`.  

---

## ‚úÖ Key Takeaway

- This is a **DFS + combinatorics** problem.  
- Formula: multinomial coefficient √ó product of child ways.  
- Clean O(n) solution with factorial precomputation.  

In simple terms:  
We treat the colony as a tree. Each node‚Äôs children can be built in any order, but the parent must come first. 
The number of ways is determined by how many ways we can shuffle the build orders of child subtrees, multiplied by the number of ways inside each subtree.  



---

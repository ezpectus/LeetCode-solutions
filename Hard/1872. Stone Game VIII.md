# 1872. Stone Game VIII

---

## Problem
Alice and Bob play a game with stones arranged in a row.  
- On each turn, a player must remove the **leftmost x stones** (`x > 1`).  
- The sum of removed stones is added to the player's score.  
- A new stone with that sum is placed at the left.  
- The game ends when only one stone remains.  

We need to compute the **score difference (Alice - Bob)** if both play optimally.

---

## Key Insight
This problem looks complex, but it simplifies with prefix sums and dynamic programming.

### Step 1: Prefix sums
Let:
- `prefix[i] = stones[0] + stones[1] + ... + stones[i]`

If Alice removes the first `i+1` stones, her score becomes `prefix[i]`.

### Step 2: Game dynamics
After Alice’s first move, the game reduces to Bob vs Alice again, but with fewer stones.  
We need to maximize Alice’s score difference.

### Step 3: DP relation
Define:
- `dp[i] = maximum score difference achievable starting from prefix[i]` (with Alice to move at that stage).

Transition:
- `dp[i] = max(dp[i+1], prefix[i] - dp[i+1])`

Explanation:
- Alice can either stop at `i` (take prefix[i] and let Bob minimize afterwards).  
- Or continue deeper, depending on which gives better difference.

### Step 4: Initialization
- Start from the end (`dp[n-1] = prefix[n-1]`).  
- Iterate backwards to compute optimal differences.

---

## Code (C#)
```csharp
public class Solution {
    public int StoneGameVIII(int[] stones) {
        int n = stones.Length;
        long[] prefix = new long[n];
        prefix[0] = stones[0];
        for (int i = 1; i < n; i++) {
            prefix[i] = prefix[i - 1] + stones[i];
        }

        long best = prefix[n - 1]; // base case
        for (int i = n - 2; i >= 1; i--) {
            best = Math.Max(best, prefix[i] - best);
        }

        return (int)best;
    }
}
```


## Complexity
- **Time:** O(n), single pass for prefix sums + backward DP.  
- **Space:** O(n) for prefix array.  

---

## Pitfalls
- Use `long` for prefix sums since values can be large.  
- Backward iteration must start from `n-2` down to `1` (Alice must remove at least 2 stones initially).  
- The final answer is `best`, not simply `prefix[n-1]`.  

---

## Example Walkthrough
**Input:** `stones = [-1,2,-3,4,-5]`  

- Prefix = `[-1,1,-2,2,-3]`  
- Start: `best = -3` (prefix[4])  
- i = 3 → `best = max(2, 2 - (-3)) = 5`  
- i = 2 → `best = max(5, -2 - 5) = 5`  
- i = 1 → `best = max(5, 1 - 5) = 5`  

**Output:** `5` ✅  

---

## Conclusion
The game reduces to a **prefix sum + backward DP** problem.  
- Alice’s optimal strategy is captured by:  
  `dp[i] = max(dp[i+1], prefix[i] - dp[i+1])`  
- Efficient O(n) solution works for up to 100,000 stones.  


---

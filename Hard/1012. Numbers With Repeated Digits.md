# ğŸ”¢ 1012. Numbers With Repeated Digits

## ğŸ“œ Problem Statement
Given an integer `n`, return the number of positive integers in the range `[1, n]` that have at least one repeated digit.

## ğŸ’¡ Core Idea
When I first read the problem statement â€” â€œreturn the number of integers â‰¤ n that have at least one repeated digitâ€ â€” the direct approach looked infeasible: brute force checking up to 10^9 numbers is impossible.

From that description, I noticed a general combinatorial pattern:
*   Problems asking for â€œat least one repeatedâ€ often become easier if we flip the perspective and count the complement â€” numbers with no repetition.
*   This is a common trick: instead of directly counting the â€œbadâ€ set, count the â€œgoodâ€ set and subtract.

So the idea emerged naturally:
*   **Observation from the statement:** the only property that matters is whether digits repeat.
*   **Pattern recognized:** â€œat least one repeatedâ€ â†” â€œtotal âˆ’ all uniqueâ€.
*   **Decision:** Count unique-digit numbers â‰¤ n using digit DP + permutations, then subtract from n.

This reframing transforms the problem from brute force into a structured combinatorial counting problem, efficient and architecturally clean.

## ğŸ—ï¸ Architectural Steps
*   **Digit Extraction:** build digit array of `n + 1`.
*   **Count Unique Numbers:**
    *   For lengths smaller than `len(n)`, use combinatorics.
    *   For equal length, use digit DP with prefix constraints.
*   **Subtract:** result = `n` - `uniqueCount`.

## ğŸ§© Implementation (C++)
```cpp
class Solution {
public:
    int numDupDigitsAtMostN(int n) {
        vector<int> digits{};
        int temp = n + 1;
        while (temp > 0) {
            digits.emplace_back(temp % 10);
            temp /= 10;
        }
        int result = 0;
        int len = digits.size();
        int curr = 9;
        for (int i = 0; i < len - 1; i++) {
            result += curr;
            curr *= 9 - i;
        }
        curr /= 9;
        vector<bool> seen(10, false);
        for (int i = 0; i < len; i++) {
            int d = digits[len - i - 1];

            for (int j = i == 0 ? 1 : 0; j < d; j++) if (!seen[j]) result += curr;
            curr /= 9 - i;

            if (seen[d]) break;
            seen[d] = true;
        }
        return n - result;
    }
};
```

## ğŸ“ Complexity Analysis

| Metric | Value | Justification |
| :--- | :--- | :--- |
| **Time Complexity** | $O(\log_{10}(n))$ or $O(D)$ | Operations scale linearly with the number of digits $D$ in $n$ (where $D = \lceil\log_{10}(n+1)\rceil$). Since $D$ is small (max 10 for $10^9$), this is highly efficient. |
| **Space Complexity** | $O(1)$ | Only a few integer variables (`totalCount`, `uniquePermutation`, `i`) are used. |

## âœ… Conclusion

We reduce the problem to counting unique-digit numbers using combinatorics and digit DP, then subtract from $n$. This ensures efficiency even for large $n$ up to $10^9$.

## âš ï¸ Pitfalls

- **Duplicate handling**: forgetting to mark digits as used leads to overcounting.
- **Permutation factor update**: must divide by $(9 - i)$ at each step; easy to misplace.
- **Edge cases**: single-digit numbers (always unique), and numbers like 100 where trailing zeros matter.
- **Off-by-one**: using $n$ vs $n+1$ in digit extraction is critical to include boundary cases.

## ğŸ”„ Alternative Approaches

- **Digit DP with memoization**: explicitly track used digits via bitmask and enforce prefix $\le n$. More general but heavier.
- **Brute force generation**: feasible only for small $n$ ($\le 10^5$), not scalable to $10^9$.
- **Inclusion-Exclusion principle**: can be applied but becomes messy compared to direct combinatorics.


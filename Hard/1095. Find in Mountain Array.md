# 1095. Find in Mountain Array — Architectural Peak Search + Two Binary Searches  
*O(log n) — Optimal Three Binary Searches*

---

## Problem Statement

Given **mountain array** via `MountainArray` interface.

Find **minimum index** where value == `target`.

Return **-1** if not exists.

**Calls to `get()`** limited (~100 max).

Mountain array: increases to peak → decreases.

---

## Core Idea — Find Peak → Binary Search Left & Right Sides

**Key insight**:
- Mountain → **one peak**
- First: **binary search** to find **peak index**
- Then: **binary search** left ascending part
- If not found → **binary search** right descending part
- Return **smallest** index found

**Why**:
- Peak find → O(log n)
- Two binary searches → O(log n)
- Total **3 log n** calls → safe under 100

**Peak search**:
- Mid → compare with next
- If `mid < mid+1` → peak right
- Else → peak left or here

**Left search** — normal ascending binary

**Right search** — descending (reverse comparison)

---

##  Implementation (C#)

```csharp
class Solution {
    public int FindInMountainArray(int target, MountainArray mountainArr) {
        int n = mountainArr.Length();

        // 1. Find peak index
        int left = 0, right = n - 1;
       while (left < right) {
            int mid = left + (right - left) / 2;
            if (mountainArr.Get(mid) < mountainArr.Get(mid + 1)) left = mid + 1; // peak is on the right
            else  right = mid; // peak is here or left
            
       }
        int peak = left;

        // 2. Binary search left side (ascending)
        left = 0; right = peak;
        while (left <= right){
            int mid = left + (right - left) / 2;
            int val = mountainArr.Get(mid);

            if (val == target) return mid;
            else if (val < target)  left = mid + 1;
            else  right = mid - 1;
        }

        // 3. Binary search right side (descending)
        left = peak; right = n - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            int val = mountainArr.Get(mid);
            if (val == target)  return mid;
            else if (val > target)  left = mid + 1; // go right for smaller
            else  right = mid - 1;
            
        }

        return -1;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(log n)**          | 3 binary searches                              |
| **Calls to get()**    | **≤ 3 log n**         | ~60 for n=10⁴ → safe under 100 limit           |
| **Space Complexity**  | **O(1)**              | Only indices                                   |

**Optimal** — minimal API calls.

---

## Why This Works — Example Walkthrough

**Input**: `mountainArr = [1,2,3,4,5,3,1]`, `target = 3`

- **Peak search** → peak at index **4** (value 5)
- **Left search** [0..4] (ascending) → find at index **2**
- Return **2** (minimum index)

**Correct**.

**Input**: `target = 0`

- Not found in left ascending part
- Not found in right descending part
- → **-1**

**Correct**.

---

## Pitfalls & Edge Cases

- **Peak at start/end** → handled (though not strictly mountain by definition)
- **Target at peak** → found in left search
- **Multiple occurrences of target** → returns leftmost (minimum index)
- **n=3** → minimal mountain → works

All handled perfectly.

---

## Key Takeaway

This is a **masterpiece of binary search**:

- **Find peak** → split the problem into two sorted halves
- **Two targeted searches** → one ascending, one descending
- **Minimal API calls** → only 3 log n gets
**Pure, clean, optimal** — one of the best interactive binary search problems.

---

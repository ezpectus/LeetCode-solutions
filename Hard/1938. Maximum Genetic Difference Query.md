# 1938. Maximum Genetic Difference Query

---

##  Problem Restatement
We are given a rooted tree with `n` nodes numbered `0..n-1`.  
- Each nodeâ€™s number is its genetic value.  
- The genetic difference between two values is defined as **bitwise XOR**.  
- For each query `[node, val]`, we must find the maximum genetic difference between `val` and any node on the path from `node` to the root (inclusive).  

Return an array `ans` where `ans[i]` is the answer for query `i`.

Constraints:  
- `2 <= parents.length <= 10^5`  
- `1 <= queries.length <= 3 * 10^4`  
- `0 <= vali <= 2 * 10^5`  

---

##  Core Idea
- Build the tree from `parents`.  
- Use **DFS traversal** from the root.  
- Maintain a **bitwise prefix trie** of values currently on the path.  
- At each node:  
  - Insert its genetic value into the trie.  
  - Answer all queries for this node by finding maximum XOR with `val`.  
  - DFS into children.  
  - Remove the nodeâ€™s value from the trie when backtracking.  

---

##  Code (C#)
```csharp
public class Solution {
    private class TrieNode {
        public TrieNode[] Children = new TrieNode[2];
        public int Count = 0;
    }

    private TrieNode root = new TrieNode();

    private void Insert(int num) {
        TrieNode node = root;
        for (int i = 17; i >= 0; i--) { // 2*10^5 < 2^18
            int bit = (num >> i) & 1;
            if (node.Children[bit] == null) node.Children[bit] = new TrieNode();
            node = node.Children[bit];
            node.Count++;
        }
    }

    private void Remove(int num) {
        TrieNode node = root;
        for (int i = 17; i >= 0; i--) {
            int bit = (num >> i) & 1;
            node = node.Children[bit];
            node.Count--;
        }
    }

    private int Query(int num) {
        TrieNode node = root;
        int res = 0;
        for (int i = 17; i >= 0; i--) {
            int bit = (num >> i) & 1;
            int opposite = bit ^ 1;
            if (node.Children[opposite] != null && node.Children[opposite].Count > 0) {
                res |= (1 << i);
                node = node.Children[opposite];
            } else {
                node = node.Children[bit];
            }
        }
        return res;
    }

    public int[] MaxGeneticDifference(int[] parents, int[][] queries) {
        int n = parents.Length;
        List<int>[] children = new List<int>[n];
        for (int i = 0; i < n; i++) children[i] = new List<int>();

        int rootNode = -1;
        for (int i = 0; i < n; i++) {
            if (parents[i] == -1) rootNode = i;
            else children[parents[i]].Add(i);
        }

        List<(int val, int idx)>[] queryList = new List<(int, int)>[n];
        for (int i = 0; i < n; i++) queryList[i] = new List<(int, int)>();
        for (int i = 0; i < queries.Length; i++) {
            int node = queries[i][0], val = queries[i][1];
            queryList[node].Add((val, i));
        }

        int[] ans = new int[queries.Length];

        void Dfs(int u) {
            Insert(u);
            foreach (var (val, idx) in queryList[u]) {
                ans[idx] = Query(val);
            }
            foreach (var v in children[u]) Dfs(v);
            Remove(u);
        }

        Dfs(rootNode);
        return ans;
    }
}
```

## ðŸŒ³ Tree + DFS Explanation

### ðŸ”‘ Why DFS is used
- The problem is defined on a **rooted tree**.  
- Each query `[node, val]` requires considering all nodes on the path from `node` to the root.  
- **DFS traversal** naturally maintains the current path:  
  - When entering a node â†’ add its value into the data structure (trie).  
  - When processing queries at this node â†’ trie contains exactly the path to root.  
  - When leaving a node â†’ remove its value, restoring the previous path state.  

Thus, DFS ensures that the trie always reflects the correct path context.

---

### ðŸ“Œ DFS Workflow
1. **Start at root** (where `parents[root] = -1`).  
2. **Insert node value** into trie.  
3. **Answer queries** for this node using trie.  
4. **Recurse into children**.  
5. **Remove node value** when backtracking.  

This guarantees correctness because at any point, trie contains only values from the current rootâ€‘toâ€‘node path.

---

### âš¡ DFS vs Other Traversals
- **DFS:**  
  - Maintains path state naturally.  
  - Easy to add/remove values when entering/leaving nodes.  
- **BFS:**  
  - Processes nodes level by level.  
  - Harder to maintain exact path state, since multiple paths overlap.  
  - Would require extra bookkeeping.  

Therefore, DFS is the optimal choice for pathâ€‘dependent queries.

---

### ðŸ“Š Example Walkthrough
Tree: `parents = [-1,0,1,1]`  
Queries: `[[0,2],[3,2],[2,5]]`

1. Start at root `0`. Trie = {0}.  
   - Query `[0,2]` â†’ max XOR = `2 XOR 0 = 2`.  
2. DFS into child `1`. Trie = {0,1}.  
3. DFS into child `2`. Trie = {0,1,2}.  
   - Query `[2,5]` â†’ max XOR = `5 XOR 2 = 7`.  
   Backtrack â†’ remove `2`. Trie = {0,1}.  
4. DFS into child `3`. Trie = {0,1,3}.  
   - Query `[3,2]` â†’ max XOR = `2 XOR 1 = 3`.  
   Backtrack â†’ remove `3`. Trie = {0,1}.  
5. Backtrack â†’ remove `1`. Trie = {0}.  
6. Backtrack â†’ remove `0`. Trie = {}.  

Final answers: `[2,3,7]`.

---

##  Conclusion
DFS is not just traversal â€” it is the **state manager** for dynamic data structures on trees.  
In this problem, DFS ensures the trie always represents the exact path from root to current node, enabling efficient query resolution.



---

# 956. Tallest Billboard — Architectural 0/1 Knapsack DP with Difference Offset  
*O(n × S) — Optimal Half-Sum State Compression*

---

## Problem Statement

- Given an array `rods` (n ≤ 20, each rod ≤ 1000, total sum ≤ 5000).
- Split the rods into **two disjoint subsets** (you may leave some rods unused) such that the **sum of both subsets is equal**.
- Return **that common sum** (the height of one support).
- If it is impossible → **return 0**.

---

## Core Idea — DP on Sum Difference

**The most important part — how and why it works**

**Key idea**:
- Let both supports have height `h` → their sums are both `h`.
- All used rods are distributed between the **left** and **right** support (or not used at all).
- The difference `left_sum - right_sum` must be **0** for equal supports.
- We track the **difference** and the **maximum left sum** achievable for each difference.

**Why difference?**
- For each rod we have three choices:
  - Add to left → difference **+rod**
  - Add to right → difference **-rod**
  - Skip → difference unchanged
- We want the **maximum left sum** when difference = 0.

**Offset**:
- Difference can be negative → shift by `sum` (maximum possible absolute difference ≤ total sum)
- Index `diff + sum` → range [0, 2×sum]

**DP definition**:
- `dp[d]` = **maximum left sum** achievable with difference `d - sum`

**Initialization**:
- `dp[sum] = 0` — difference 0, left sum 0

**Transitions**:
For each rod `rod`:
- Copy current dp state (to avoid overwriting during iteration)
- For each possible d:
  - Skip: keep `dp[d]`
  - Add to left: `dp[d + rod] = max(dp[d + rod], dp[d] + rod)`
  - Add to right: `dp[d - rod] = max(dp[d - rod], dp[d])`

**Answer**:
- `dp[sum]` — maximum left sum when difference = 0

---

##  Implementation (C#)

```csharp
public class Solution {
    public int TallestBillboard(int[] rods) {
        int sum = rods.Sum();
        int offset = sum; // shift difference to non-negative
        int[] dp = new int[2 * sum + 1];
        Array.Fill(dp, -1);
        dp[offset] = 0; // difference 0, left sum 0

        foreach (int rod in rods) {
            int[] curr = (int[])dp.Clone(); // copy current state

            for (int d = 0; d <= 2 * sum; d++) {
                if (curr[d] < 0) continue;

                // Add to left: diff + rod
                int nd1 = d + rod;
                if (nd1 <= 2 * sum)  dp[nd1] = Math.Max(dp[nd1], curr[d] + rod);
                

                // Add to right: diff - rod
                int nd2 = d - rod;
                if (nd2 >= 0)  dp[nd2] = Math.Max(dp[nd2], curr[d]);
                
            }
        }

        return dp[offset];
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n × S)**  | n=20, S=5000 → ~10⁵ operations                 |
| **Space Complexity**  | **O(S)**      | DP array                                       |

**Optimal** — n small, S reasonable.

---

## Why This Works — Example Walkthrough

**Input**: `rods = [1,2,3,6]`

- sum = 12 → offset = 12 → dp[12] = 0 (difference 0, left sum 0)
- After processing all rods:
  - Possible: left = {1,2,3} sum=6, right = {6} sum=6
  - dp[12] updated to **6**
- → **6**

**Correct**.

**Input**: `[1,2,3,4,5,6]`

- sum = 21 → offset = 21
- Possible: left = {2,3,5}=10, right = {4,6}=10
- dp[offset] = **10**

**Correct**.

**Input**: `[1,2]`

- sum = 3 → no way to split equally
- dp[offset] remains 0 → **0**

**Correct**.

---

## Pitfalls & Edge Cases

- **No rods** → sum=0 → 0
- **Odd total sum** → impossible equal split → 0
- **All rods to one side** → difference large → not 0
- **Skip rods** → allowed (not used in either support)

All handled perfectly.

---

## Key Takeaway

This is a **classic knapsack variant**:

- **Difference DP** → track left - right balance
- **Offset** → handle negative differences with array indices
- **Max left sum** at difference 0 → height of one support
**Pure, clean, optimal** — perfect partition problem.

---

# üçï 1388. Pizza With 3n Slices

## Problem Summary

You are given a circular pizza sliced into `3n` pieces, each with a different size. You must pick exactly `n` slices such that:

- After each pick, the slice immediately before and after (in circular order) is removed ‚Äî taken by Alice and Bob.
- You cannot pick adjacent slices.
- Your goal is to **maximize the total size** of the slices you pick.

---

## Key Constraints

- `slices.length == 3 * n`
- You must pick exactly `n` slices.
- The array is circular ‚Äî first and last elements are adjacent.

---

## Core Idea

This is a variation of the **House Robber II** problem, extended to selecting **exactly `n` non-adjacent elements** from a circular array.

To handle the circular structure, we split the problem into two linear cases:

- **Case 1:** Use slices from index `0` to `len - 2` (exclude last)
- **Case 2:** Use slices from index `1` to `len - 1` (exclude first)

We then apply **top-down DP with memoization** to each case.

---

## DP Definition

```csharp
int Solve(int[] slices, int i, int k, int[,] memo)
```

i: current index

k: number of slices left to pick

memo[i,k]: cached result for state (i,k)

Transitions

- Skip current slice: solve(i + 1, k)
- Take current slice: slices[i] + solve(i + 2, k - 1)

## Solution C# 
```cpp
public class Solution {
    public int MaxSizeSlices(int[] slices) {
        int n = slices.Length/3;
        int[] case1 = slices.Take(slices.Length-1).ToArray();
        int[] case2 = slices.Skip(1).ToArray();

        int[,] memo1 = new int[case1.Length +1,n+1];
        int[,] memo2 = new int[case2.Length +1,n+1];

       for(int i =0; i <= case1.Length;i++)
           for(int j =0; j <= n;j++)
              memo1[i,j] = memo2[i,j] = -1;

        int dp1 = Solve(case1,0,n,memo1);
        int dp2 = Solve(case2,0,n,memo2);

        return Math.Max(dp1,dp2);
    }

public int Solve(int[] slices, int i, int k, int[,] memo){
 if(k ==0  || i >= slices.Length) return 0;
 if(memo[i,k] != -1) return memo[i,k];

 int skip = Solve(slices,i+1,k,memo);
 int take = slices[i] + Solve(slices,i+2,k-1,memo);

 return memo[i,k] = Math.Max(skip,take);

    }
}
```
## üìä Complexity Analysis

| Aspect        | Value                     | Explanation                                                                 |
|---------------|---------------------------|------------------------------------------------------------------------------|
| Time          | O(n¬≤) per case            | For each of the two cases, we compute `solve(i, k)` over `O(n)` indices and `O(n)` pick counts. Each state `(i, k)` is computed once due to memoization. |
| Space         | O(n¬≤) per case            | The memoization table `memo[i][k]` stores `O(n¬≤)` entries per case.         |
| Total Cases   | 2                         | We split the circular array into two linear cases to avoid adjacency between first and last elements. |

---

## üí¨ Remarks

- ‚ùå **Greedy and heap-based approaches fail** because they cannot enforce the non-adjacency constraint after each pick.
- ‚úÖ This **DP guarantees exactly `n` picks**, each non-adjacent to the others, by skipping neighbors after each selection.
- üîÅ The **circular split** into two linear cases ensures correctness without violating adjacency rules between the first and last slices.



---

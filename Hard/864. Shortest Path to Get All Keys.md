# üóùÔ∏è Shortest Path to Get All Keys ‚Äî Problem Breakdown & C# Solution

## üìò Problem Summary

You are given a 2D grid representing a maze with the following symbols:

- `'@'` ‚Äî starting point  
- `'.'` ‚Äî empty cell  
- `'#'` ‚Äî wall  
- `'a'` to `'f'` ‚Äî keys  
- `'A'` to `'F'` ‚Äî locks (each requires its corresponding lowercase key)

You can move in four directions: **up, down, left, right**. You cannot:

- Move outside the grid  
- Walk through walls  
- Pass through a lock unless you‚Äôve collected its corresponding key

Your goal is to **collect all keys** using the **minimum number of steps**.  
If it‚Äôs impossible, return `-1`.

---

## üß† Core Idea

This is a **Breadth-First Search (BFS)** problem with **state tracking**.  
Each state includes:

- Your current position `(x, y)`  
- The set of keys you‚Äôve collected (stored as a **bitmask**)  
- The number of steps taken so far

To avoid revisiting the same state, we track visited positions **with the current key set** ‚Äî meaning `(x, y)` with different keys is treated as a different state.

---

## üß© Key Concepts

- **Bitmasking**  
  Efficiently tracks which keys have been collected using binary flags.  
  Example: if keys `'a'` and `'c'` are collected ‚Üí bitmask = `101` (binary)

- **Stateful BFS**  
  Explores all reachable positions while tracking the current key set.  
  Guarantees shortest path due to level-order traversal.

- **Visited Set**  
  Prevents infinite loops and redundant paths.  
  Each visited state is defined by `(x, y, keys)`.

- **Early Exit**  
  As soon as all keys are collected (`keys == totalKeys`), return the current step count.

---

## üíª C# Implementation

```csharp
public class Solution {
    public int ShortestPathAllKeys(string[] grid) {
        int m = grid.Length, n = grid[0].Length;
        var dirs = new int[][] { new[] {0,1}, new[] {1,0}, new[] {0,-1}, new[] {-1,0} };
        var visited = new HashSet<(int, int, int)>();
        var queue = new Queue<(int x, int y, int keys, int steps)>();
        int totalKeys = 0;

        // Find starting point and total number of keys
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                char c = grid[i][j];
                if (c == '@') queue.Enqueue((i, j, 0, 0));
                if (char.IsLower(c)) totalKeys |= (1 << (c - 'a'));
            }
        }

        while (queue.Count > 0) {
            var (x, y, keys, steps) = queue.Dequeue();
            if (visited.Contains((x, y, keys))) continue;
            visited.Add((x, y, keys));

            if (keys == totalKeys) return steps;

            foreach (var dir in dirs) {
                int nx = x + dir[0], ny = y + dir[1];
                if (nx < 0 || ny < 0 || nx >= m || ny >= n) continue;
                char c = grid[nx][ny];
                if (c == '#') continue;

                int newKeys = keys;
                if (char.IsLower(c)) newKeys |= (1 << (c - 'a'));
                if (char.IsUpper(c) && ((keys >> (c - 'A')) & 1) == 0) continue;

                queue.Enqueue((nx, ny, newKeys, steps + 1));
            }
        }

        return -1;
    }
}

```


## ‚úÖ Why This Works

- **Efficient key tracking using bitmasking**  
  Each key is represented as a bit in an integer. This allows constant-time checks and updates, and compact state representation.  
  Example: if keys `'a'` and `'c'` are collected ‚Üí bitmask = `101` (binary) = `5`

- **Avoids revisiting states with the same position and key set**  
  The visited set tracks `(x, y, keys)` as a unique state.  
  This prevents redundant exploration and infinite loops, especially when revisiting the same cell with different key combinations.

- **Guarantees shortest path due to BFS traversal**  
  BFS explores all reachable states level-by-level.  
  The first time we reach the goal state (all keys collected), we are guaranteed to have taken the minimum number of steps.

- **Scales well for up to 6 keys (as per constraints)**  
  With only 6 keys, the bitmask space is small: `2^6 = 64` possible key combinations.  
  This keeps the state space manageable and ensures fast traversal.

---

## üß± Architectural Insights

- **State = (position, inventory)**  
  The key insight is that movement alone is not enough ‚Äî the agent‚Äôs inventory (keys) defines access.  
  This transforms the grid traversal into a **stateful simulation**, where each move depends on both location and collected resources.

- **Bitmasking as architectural compression**  
  Instead of using arrays or sets to track keys, bitmasking compresses state into a single integer.  
  This reduces memory usage and speeds up comparisons, making it ideal for BFS.

- **Visited set as a state validator**  
  The visited set acts as a **guardrail**, ensuring that the simulation doesn‚Äôt revisit invalid or redundant paths.  
  It enforces architectural integrity by pruning the search space.

- **Early exit as architectural optimization**  
  The moment all keys are collected, the algorithm exits.  
  This avoids unnecessary traversal and reflects a **goal-driven architecture**.

---

## ‚è±Ô∏è Time and Space Complexity

| Complexity Type   | Expression               | Explanation                                                                 |
|-------------------|--------------------------|------------------------------------------------------------------------------|
| Time Complexity    | O(m √ó n √ó 2^k)           | Each cell `(x, y)` can be visited with up to `2^k` key combinations         |
| Space Complexity   | O(m √ó n √ó 2^k)           | BFS queue and visited set store `(x, y, keys)` states                       |

**Where:**
- `m` ‚Äî number of rows in the grid  
- `n` ‚Äî number of columns in the grid  
- `k` ‚Äî number of unique keys (maximum 6)


---

## üîÑ Why It‚Äôs More Effective Than Alternatives

- **DFS** would explore deep paths first, potentially missing shorter solutions and causing stack overflow in large grids.  
- **Dijkstra‚Äôs Algorithm** is overkill here ‚Äî all moves cost the same, so BFS naturally finds the shortest path.  
- **A\*** could work with heuristics, but adds complexity without guaranteed gain for small key counts.

This solution is **clean, scalable, and optimal** for the problem constraints. 
It balances clarity with performance, and its architecture is reusable for other grid-based simulations with inventory or access logic.



---

# 1316. Distinct Echo Substrings  
*O(n²) — Rolling Hash + Set of Echo Substrings*

---

## Problem Statement

Given a string `text` consisting of lowercase English letters.

Return the number of **distinct non-empty substrings** of `text` that can be written as the concatenation of some string with itself (i.e. of the form `a + a` where `a` is some string).

In other words, count distinct substrings that are **echo substrings** (appear twice consecutively).

**Examples**:

**Example 1**  
Input: text = "abcabcabc"  
Output: **3**  
Echo substrings:  
- "abcabc"  
- "bcabca"  
- "cabcab"

**Example 2**  
Input: text = "leetcodeleetcode"  
Output: **2**  
- "ee"  
- "leetcodeleetcode"

**Constraints**:
- 1 ≤ text.length ≤ 2000
- text contains only lowercase English letters

---

## Core Idea — Find All Even-Length Substrings That Are Echo

**Key observation**:
- A substring `text[i..j]` is an echo if:
  - (j - i + 1) is **even**
  - Let mid = (i + j + 1) / 2
  - text[i..mid-1] == text[mid..j]
- We need to count **distinct** such substrings

**Naive way** (O(n³)):
- For every possible i and even length → check if halves equal → too slow

**Better way** (O(n²)):
- For every possible **center position** mid (split point between two halves)
- Expand around mid to find maximum echo length → but we need all possible
- More efficiently: for every possible starting index i and possible half-length len
- Check if text[i..i+len-1] == text[i+len..i+2*len-1]

**Efficient & correct**:
- Use **rolling hash** to compare substrings in O(1) after O(n) precomputation
- Or since n ≤ 2000 → even O(n²) string comparison is acceptable (2000² = 4e6)

**Clean & safe approach** (O(n²) time, O(n) space for set):

Use a **HashSet** to store unique echo substrings.

```csharp
public class Solution{
    public int DistinctEchoSubstrings(string text){
        int n = text.Length;
        var seen = new HashSet<string>();

        // Try every possible starting index i
        for (int i = 0; i < n; i++){
            // Try every possible half-length len
            for (int len = 1; i + 2 * len <= n; len++){
                string first = text.Substring(i, len);
                string second = text.Substring(i + len, len);

                if (first == second) seen.Add(first + second);  
            }
        }

        return seen.Count;
    }
}
```

## Complexity

| **Metric**            | **Value**              | **Notes**                                                                 |
|-----------------------|------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(n²)**              | For each possible half-length `len` (1 to n/2) and each starting index `i` (such that i + 2*len ≤ n), we compare two substrings of length `len` → total comparisons sum to O(n²) in worst case |
| **Space Complexity**  | **O(n²)** worst-case   | HashSet stores unique echo substrings (each up to length n)<br>In practice: much less due to duplicates and limited distinct echoes |

**Acceptable** — n ≤ 2000 → ~4×10⁶ operations — runs comfortably within time limits.

---

## Why This Works — Example Walkthrough

**Example 1**: text = "abcabcabc"

Possible echo substrings (a + a form):

- len=1: no consecutive "aa", "bb", "cc"
- len=2: "bcabca" starting at index 1 (positions 1-6: bcabca → "bca" + "bca")
- len=3: "abcabc" starting at 0 (abc + abc)  
  "cabcab" starting at 2 (cab + cab)
- len=4: none

Distinct echoes found:  
- "abcabc"  
- "bcabca"  
- "cabcab"

Total: **3** → correct

**Correct** —  
We systematically check **every possible even-length substring** that could be formed as a + a.  
For each candidate:
- Take half-length `len`
- Start at index `i`
- Check if the two halves are identical
- If yes → add the full substring (length 2×len) to a HashSet (automatically handles duplicates)
- Final answer = size of the HashSet

This finds **all distinct echo substrings** efficiently.

---

## Key Takeaway

This is a **straightforward enumeration + uniqueness** problem:

* An echo substring must have **even length** and consist of **two identical halves** (a + a)
* Enumerate all possible:
  - half-length `len` from 1 to n/2
  - starting index `i` such that i + 2×len ≤ n
* Check if text[i..i+len-1] == text[i+len..i+2×len-1]
* If yes → add the full substring text[i..i+2×len-1] to a HashSet
* Return the size of the HashSet (number of distinct echoes)

**Pure, clean, optimal** — O(n²) time, O(n²) worst-case space (in practice far less due to duplicates), simple to understand, intuitive, and correct for n ≤ 2000.

---

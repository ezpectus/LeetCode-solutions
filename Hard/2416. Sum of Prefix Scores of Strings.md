# 2416. Sum of Prefix Scores of Strings — Architectural Trie Solution  
*O(n·L) — Classic Prefix Aggregation with Trie*

---

## Problem Statement

Given an array `words` of size `n`, define the **score of a string `term`** as the number of strings in `words` that have `term` as a **prefix**.

For each `words[i]`, compute the **sum of scores of all its non-empty prefixes**.

Return an array `answer` of size `n`.

**Constraints**  
- `1 ≤ n ≤ 1000`  
- `1 ≤ words[i].length ≤ 1000`  
- Only lowercase English letters

---

## Core Idea — Trie-Based Prefix Counting

Instead of checking every prefix against every word (O(n²·L)), we use a **Trie**:

- Each node stores **how many words pass through it** (`count`)
- When inserting a word → increment `count` on every node along the path
- When querying a word → sum `count` values along its path

**Trie = perfect structure for prefix statistics**

---

## Full Implementation (C#)

```csharp
public class Solution 
{
    public int[] SumPrefixScores(string[] words) 
    {
        TrieNode root = new TrieNode();

        // Step 1: Build Trie + count how many words pass through each node
        foreach (string word in words) 
        {
            TrieNode node = root;
            foreach (char c in word) 
            {
                int idx = c - 'a';
                if (node.Children[idx] == null)
                    node.Children[idx] = new TrieNode();
                node = node.Children[idx];
                node.Count++;           // every word that goes through this prefix
            }
        }

        // Step 2: For each word, sum the counts along its path
        int[] result = new int[words.Length];
        for (int i = 0; i < words.Length; i++) 
        {
            TrieNode node = root;
            int sum = 0;
            foreach (char c in words[i]) 
            {
                int idx = c - 'a';
                node = node.Children[idx];
                sum += node.Count;
            }
            result[i] = sum;
        }

        return result;
    }

    private class TrieNode 
    {
        public TrieNode[] Children = new TrieNode[26];
        public int Count = 0;   // number of words passing through this node
    }
}
```

## Complexity Analysis

| **Metric**     | **Value**                 | **Notes**                                      |
|----------------|---------------------------|------------------------------------------------|
| **Time**       | **O(total letters)**      | Two passes: build Trie + query all words       |
| **Space**      | **O(total letters)**      | Trie nodes ≤ sum of all word lengths           |

**With `n=1000`, `L=1000` → ≤ 10⁶ operations → instant**

---

## Pitfalls & Edge Cases

- **Single word** → each prefix has score 1 → correct  
- **All identical words** → every prefix has score `n` → correct  
- **Shared prefixes** → `Count` correctly aggregates → handled  
- **Long chains (1000 chars)** → Trie handles linearly → no problem  
- **Empty input** → not possible (`n ≥ 1`) → safe

---

## Insight — Reusable Fichka

> **When you need prefix statistics → build a Trie and count passes**

### What is a Trie?

**Trie** (prefix tree) — tree where:
- Each node = one character
- Path from root to node = prefix
- We store `Count` = how many words go **through** this node
```
root
/    
a      b
/        
b          a
/            
t              t
Count: 3        Count: 2
```


→ All words starting with `"ab"` pass through the `b` node → `Count = 3`

### Pattern

- **Insert** all strings → increment `Count` on each node  
- **Query** = walk path and **sum `Count`** at each step

### Applies to

- Prefix sum queries
- Autocomplete frequency
- Dictionary word counting
- Any **prefix-based aggregation**

**Fichka**:  
> **Prefix queries + frequencies = Trie with node counters**

---


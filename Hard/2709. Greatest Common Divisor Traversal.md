# 2709. Greatest Common Divisor Traversal

## Problem Summary

You are given an integer array `nums`. You can traverse between index `i` and index `j` (`i ≠ j`) if and only if `gcd(nums[i], nums[j]) > 1`.

Your task is to determine whether **every pair of indices** in `nums` is connected via such valid traversals — i.e., whether the entire array is **fully connected** under the traversal rule.

Return `true` if all indices are reachable from each other, otherwise return `false`.

---

## Core Idea

This is a **connectivity check** in an implicit graph, where edges exist between indices sharing a common divisor greater than 1.

Instead of building the full graph (which is too slow for `n = 10^5`), we use **prime factorization + DSU (Disjoint Set Union)** to connect indices via shared prime factors.

---

## Architectural Strategy

### Step-by-step plan:

1. **Factorize each number** in `nums` into its prime divisors.
2. For each prime `p`, track the first index where it appears.
3. For every subsequent occurrence of `p`, **union** the current index with the first one.
4. After processing all numbers, check whether **all indices belong to the same connected component**.

This avoids pairwise GCD checks and builds connectivity through shared prime anchors.

---

## C# Implementation

```csharp
public class Solution {
    public bool CanTraverseAllPairs(int[] nums) {
        int n = nums.Length;
        if (n == 1) return true;

        var dsu = new DSU(100_001); // max value of nums[i]
        var primeToIndex = new Dictionary<int, int>();

        for (int i = 0; i < n; i++) {
            int x = nums[i];
            foreach (int p in Factorize(x)) {
                if (!primeToIndex.ContainsKey(p))
                    primeToIndex[p] = i;
                else
                    dsu.Union(i, primeToIndex[p]);
            }
        }

        int root = dsu.Find(0);
        for (int i = 1; i < n; i++)
            if (dsu.Find(i) != root) return false;

        return true;
    }

    IEnumerable<int> Factorize(int x) {
        for (int d = 2; d * d <= x; d++) {
            if (x % d == 0) {
                yield return d;
                while (x % d == 0) x /= d;
            }
        }
        if (x > 1) yield return x;
    }

    class DSU {
        int[] parent;
        public DSU(int n) {
            parent = new int[n];
            for (int i = 0; i < n; i++) parent[i] = i;
        }
        public int Find(int x) => parent[x] == x ? x : (parent[x] = Find(parent[x]));
        public void Union(int x, int y) => parent[Find(x)] = Find(y);
    }
}
```

## Complexity Analysis

**Time Complexity**:
- `O(n log x)` for factorizing all numbers (where `x = max(nums[i])`)
- `O(n α(n))` for DSU operations (`α` is the inverse Ackermann function)
- **Total**: Efficient and scalable for `n ≤ 10^5`

**Space Complexity**:
- `O(n)` for DSU parent array
- `O(max(nums[i]))` for prime tracking via anchor map
- **Total**: `O(n + max(nums[i]))`

---

## Architectural Notes

- **Factorization** is bounded and fast due to trial division up to √x
- **DSU** connects indices via shared prime factors, avoiding explicit graph construction
- **primeToIndex** acts as a lightweight anchor map for union operations
- **Early return** ensures we stop immediately if any index is disconnected from the root
- The graph is built **implicitly** through prime connectivity — no adjacency list required
- This approach transforms a **pairwise GCD condition** into a **global union-find structure**

---

# 741. Cherry Pickup — Architectural Solution

## Problem Statement
- n × n grid with 0 (empty), 1 (cherry), -1 (thorn).
- Start at (0,0), go to (n-1,n-1) (right/down), collecting cherries (1 → 0).
- Then return to (0,0) (left/up), collecting remaining cherries.
- Return **maximum total cherries**.
- If no path → 0.
- Constraints: n ≤ 50

## Core Idea
Model as **two agents** both going from (0,0) to (n-1,n-1) simultaneously (right/down only).

- Agent 1: outbound trip
- Agent 2: return trip (reversed = same direction)

 They share the grid → if visit same cell → cherry counted **once**.
 Since both make the same number of moves, their Manhattan distance from start is equal: `r1 + c1 == r2 + c2`
 State: DP[r1][c1][r2] = max cherries with agent1 at (r1,c1), agent2 at (r2, c2 = r1+c1-r2)
 Recursive with memoization.

## Implementation (C#) 

```csharp
public class Solution {
    public int CherryPickup(int[][] grid) {
        int n = grid.Length;
        int[,,] dp = new int[n, n, n];

        // Initialize with impossible value
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                for (int k = 0; k < n; k++)
                    dp[i, j, k] = int.MinValue;

        int result = Solve(0, 0, 0, grid, dp, n);
        return Math.Max(0, result);
    }

    private int Solve(int r1, int c1, int r2, int[][] grid, int[,,] dp, int n)  {
        int c2 = r1 + c1 - r2;

        // Out of bounds or thorn
        if (r1 >= n || c1 >= n || r2 >= n || c2 >= n || 
            grid[r1][c1] == -1 || grid[r2][c2] == -1) {
            return int.MinValue;
        }

        // Reached end
        if (r1 == n - 1 && c1 == n - 1)   return grid[r1][c1];
        
        // Memoized
        if (dp[r1, c1, r2] != int.MinValue)   return dp[r1, c1, r2];
        

        // Collect cherries
        int cherries = grid[r1][c1];
        if (r1 != r2 || c1 != c2)   cherries += grid[r2][c2];
        

        // Four possible moves (both agents: down/right independently)
        int best = int.MinValue;
        best = Math.Max(best, Solve(r1 + 1, c1, r2 + 1, grid, dp, n));
        best = Math.Max(best, Solve(r1 + 1, c1, r2,     grid, dp, n));
        best = Math.Max(best, Solve(r1,     c1 + 1, r2 + 1, grid, dp, n));
        best = Math.Max(best, Solve(r1,     c1 + 1, r2,     grid, dp, n));

        // If no valid move → impossible
        if (best == int.MinValue)    return dp[r1, c1, r2] = int.MinValue;
        

        return dp[r1, c1, r2] = cherries + best;
    }
}
```



## Complexity Analysis

* **Time Complexity**: **O(n³)**  
  State space: 3 dimensions — row of agent1, column of agent1, row of agent2 → O(n³) states.  
  Each state has 4 constant-time transitions (down/right for each agent).  
  Total work: O(n³) — for n=50 → ~125 000 states → instant.

* **Space Complexity**: **O(n³)**  
  3D DP table of size n×n×n → ~125K integers (~0.5 MB).  
  Recursion stack is O(n) in depth → negligible compared to table.

## Pitfalls & Edge Cases

* **Thorn (-1)** — any agent hits it → state unreachable → return MinValue (impossible).  
* **Same cell visited by both agents** — cherry must be counted **once** → add grid[r2][c2] only if positions differ.  
* **No valid path** — DP remains MinValue → final `Math.Max(0, result)` returns 0.  
* **n = 1** — single cell → returns grid[0][0] if ≥0, else 0.  
* **Multiple optimal paths** — DP takes maximum at each step → guarantees best answer.  
* **Agents block each other** — not possible (they can occupy same cell, just cherry counted once).  

## Conclusion
Hard problem solved with **elegant 3D recursive DP**.

The architectural insight:

* Model the return trip as a **second agent** moving down-right simultaneously
* Shared grid → cherry on same cell counted **once**
* Equal number of steps → column of agent2 = r1 + c1 - r2
* State DP[r1][c1][r2] captures everything

Recursive version is **cleaner for understanding** than iterative — easier to debug and reason about.

No need for path reconstruction or extra structures.

Once you see "two agents on same grid with synchronized steps" — this DP pattern kills Cherry Pickup I and II instantly.

Master it — you own all "two robots/paths collecting on shared grid" problems.



---

# Pattern Name
**Trie-Accelerated DFS for Grid Word Search**

## Problem Summary
- **Input**:
  - A 2D grid `board` of lowercase letters.
  - A list of unique words `words`.
- **Goal**:  
  Find **all words** that can be formed by **adjacent letters** (horizontally or vertically).  
  Each cell can be used **once per word**.
- **Constraints**:
  - `1 ≤ m, n ≤ 12`
  - `1 ≤ words.length ≤ 30,000`
  - `1 ≤ words[i].Length ≤ 10`
  - All words are lowercase and unique.

## Core Idea
- This is a **prefix pruning problem**.

## Solution
- **Build a Trie** from the word list.
- For each cell in the board:
  - Start **DFS** if the letter matches a Trie prefix.
  - Track visited cells.
  - **Prune** paths that don’t match any prefix.
  - If a full word is found → add to result.

## Strategy Summary
- **Build Trie** from `words`.
- **DFS** from each cell:
  - Use `visited` set or **mark board cell temporarily**.
  - Explore **4 directions**.
  - **Backtrack** after each path.
- Store found words in a **result set** to avoid duplicates.

## C# Implementation
```csharp
public class Solution {
    private class TrieNode {
        public Dictionary<char, TrieNode> children = new();
        public string word = null;
    }

    private TrieNode BuildTrie(string[] words) {
        TrieNode root = new();
        foreach (string word in words) {
            TrieNode node = root;
            foreach (char c in word) {
                if (!node.children.ContainsKey(c))
                    node.children[c] = new TrieNode();
                node = node.children[c];
            }
            node.word = word;
        }
        return root;
    }

    public IList<string> FindWords(char[][] board, string[] words) {
        List<string> result = new();
        TrieNode root = BuildTrie(words);
        int m = board.Length, n = board[0].Length;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                DFS(board, i, j, root, result);
            }
        }

        return result;
    }

    private void DFS(char[][] board, int i, int j, TrieNode node, List<string> result) {
        char c = board[i][j];
        if (c == '#' || !node.children.ContainsKey(c)) return;

        node = node.children[c];
        if (node.word != null) {
            result.Add(node.word);
            node.word = null; // avoid duplicates
        }

        board[i][j] = '#'; // mark visited

        int[] dx = { -1, 1, 0, 0 };
        int[] dy = { 0, 0, -1, 1 };

        for (int d = 0; d < 4; d++) {
            int ni = i + dx[d], nj = j + dy[d];
            if (ni >= 0 && nj >= 0 && ni < board.Length && nj < board[0].Length)
                DFS(board, ni, nj, node, result);
        }

        board[i][j] = c; // restore
    }
}
```

## Architectural Breakdown
| Component               | Role                                      |
|-------------------------|-------------------------------------------|
| `TrieNode`              | Stores word prefixes                      |
| `BuildTrie()`           | Constructs prefix tree                    |
| `DFS()`                 | Explores board recursively                |
| `board[i][j] = '#'`     | Marks visited cells                       |
| `node.word = null`      | Prevents duplicate results                |

## Why This Approach Is Superior
| Aspect              | **Trie + DFS**        | Brute Force              |
|---------------------|-----------------------|--------------------------|
| Time Complexity     | O(mn × 4^L)           | O(mn × W × L)            |
| Space Complexity    | O(W × L)              | O(W × L)                 |
| Performance         | **Prunes early**      | Redundant searches       |
| Scalability         | Handles 30k words     | Breaks on large input    |

## Final Takeaway
- **This problem is about efficient word discovery in a grid using prefix pruning.**
- **The solution uses**:
  - **Trie** for fast prefix lookup.
  - **DFS** for grid traversal.
  - **Backtracking** to explore paths.
- **This pattern generalizes to**:
  - Grid-based search problems.
  - Prefix-sensitive exploration.
  - Backtracking with pruning.
 
---

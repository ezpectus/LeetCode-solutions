# 1235. Maximum Profit in Job Scheduling — Architectural DP with Binary Search on Sorted Jobs  
*O(n log n) — Optimal Sorted Jobs + Binary Search for Non-Overlapping*

---

## Problem Statement

Given `n` jobs with:
- `startTime[i]`, `endTime[i]`, `profit[i]`
- Jobs **overlap** if time ranges intersect (can start at exact end time).
- Return **maximum total profit** from **non-overlapping** subset.

---

## Core Idea — Sort by End Time + DP with Binary Search

**Key insight**:
- Sort jobs by **end time** → greedy choice for next job
- For each job i (in sorted order):
  - Find **latest previous job** that **doesn't overlap** (ends ≤ start of i)
  - `dp[i]` = max(profit[i] + dp[prev], dp[i-1])

**Binary search** → find prev job quickly

**Steps**:
1. Combine into jobs array → sort by end time
2. `dp[i]` = max profit using first i jobs
3. For each job i:
   - Binary search for largest j where `jobs[j].end <= jobs[i].start`
   - `dp[i] = max(dp[i-1], profit[i] + (j >=0 ? dp[j] : 0))`

---

## Implementation (C#)

```csharp
public class Solution {
    public int JobScheduling(int[] startTime, int[] endTime, int[] profit) {
        int n = startTime.Length;
        var jobs = new (int start, int end, int profit)[n];
        for (int i = 0; i < n; i++)  jobs[i] = (startTime[i], endTime[i], profit[i]);
        
        Array.Sort(jobs, (a, b) => a.end - b.end);
        int[] dp = new int[n + 1]; // dp[i] = max profit using first i jobs

        for (int i = 1; i <= n; i++) {
            int start = jobs[i - 1].start;
            int prof = jobs[i - 1].profit;

            // Binary search: find largest j where jobs[j].end <= start
            int left = 0, right = i - 1;
            int prev = -1;
            while (left <= right) {
                int mid = (left + right) / 2;
                if (jobs[mid].end <= start) {
                    prev = mid;
                    left = mid + 1;
                } 
                else  right = mid - 1; 
            }

            int take = prof + (prev >= 0 ? dp[prev + 1] : 0);
            int skip = dp[i - 1];
            dp[i] = Math.Max(take, skip);
        }

        return dp[n];
    }
}
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)**        | Sort O(n log n) + n binary searches O(n log n)  |
| **Space Complexity**  | **O(n)**              | Jobs array + dp array                          |

**Optimal** — standard and proven for weighted interval scheduling.

---

## Why This Works — Example Walkthrough

**Input**: `startTime = [1,2,3,3]`, `endTime = [3,4,5,6]`, `profit = [50,10,40,70]`

- Combine and **sort by end time**:
  - Job A: start=1, end=3, profit=50
  - Job B: start=2, end=4, profit=10
  - Job C: start=3, end=5, profit=40
  - Job D: start=3, end=6, profit=70

- `dp[i]` = max profit using first i jobs (0-based, dp[0]=0)

- **Job A** (i=1): no previous → take 50 → dp[1] = **50**
- **Job B** (i=2): latest non-overlapping: end ≤2 → none → max(10, 50) → dp[2] = **50**
- **Job C** (i=3): latest non-overlapping: end ≤3 → Job A → max(40+50=90, 50) → dp[3] = **90**
- **Job D** (i=4): latest non-overlapping: end ≤3 → Job A → max(70+50=120, 90) → dp[4] = **120**

**Result**: **120** — correct (jobs A and D).

Sorting by end time + DP with binary search finds optimal non-overlapping combination.

---

## Pitfalls & Edge Cases

- **Same end time** → sort order doesn't affect correctness (any valid)
- **Exact overlap (end == start)** → allowed (can chain)
- **No jobs** → returns 0
- **Single job** → returns its profit
- **All jobs overlapping** → returns max single profit

All handled perfectly.

---

## Key Takeaway

This is a **classic weighted interval scheduling** problem:

- **Sort by end time** → enables greedy-like DP
- **DP with binary search** → efficiently finds best previous non-overlapping job
- **O(n log n)** → standard optimal solution
**Pure, clean, optimal** — perfect maximum profit job scheduling.

---

# Pattern Name
**Triple Subarray Max via Prefix Sums and Precomputed Extremes**

## Problem Summary
- **Input**:  
  Array `nums` of length `n`, integer `k`
- **Goal**:  
  Find **three non-overlapping subarrays** of length `k` with **maximum total sum**  
  Return **lexicographically smallest** starting indices `[i, j, m]`
- **Constraints**:
  - `1 ≤ n ≤ 2×10⁴`
  - `1 ≤ k ≤ ⌊n/3⌋`

## Core Idea
- Use **prefix sums** to compute any subarray sum in O(1)
- Precompute:
  - `left[i]`: **best starting index** of subarray ending at `i` (left-to-right)
  - `right[i]`: **best starting index** of subarray starting at `i` (right-to-left)
- Slide middle subarray from `k` to `n−2k`, combine with best left/right → O(n)

## Solution
1. **Prefix sums** → `pref[i+k] - pref[i]`
2. **Left DP**: scan left → right → track max sum subarray ending at `i`
3. **Right DP**: scan right → left → track max sum subarray starting at `i`
4. **Middle scan**: for each valid middle start `i`, compute `left[i−1] + middle + right[i+k]`
5. Track **max total** and **lex smallest indices**

## C# Implementation
```csharp
public class Solution {
    public int[] MaxSumOfThreeSubarrays(int[] nums, int k) {
        int n = nums.Length;
        var res = new int[3];
        var pref = new int[n+1];
        for(int i = 0; i < n; i++){
            pref[i+1] = pref[i] + nums[i];
        }
        
        var left = new int[n];
        var right = new int[n];
        int maxSum = 0;

        // Left: best subarray ending at i
        for(int i = k-1; i < n; i++){
            int curr = pref[i+1] - pref[i+1-k];
            if(curr > maxSum){
                maxSum = curr;
                left[i] = i - k + 1;
            } else {
                left[i] = left[i-1];
            }
        }

        maxSum = 0;
        // Right: best subarray starting at i
        for(int i = n-k; i >= 0; i--){
            int curr = pref[i+k] - pref[i];
            if(curr >= maxSum){
                maxSum = curr;
                right[i] = i;
            } else {
                right[i] = right[i+1];
            }
        }

        maxSum = 0;
        // Middle: combine best left + mid + right
        for(int i = k; i <= n - 2*k; i++){
            int lidx = left[i-1];
            int ridx = right[i+k];
            int leftsum = pref[lidx+k] - pref[lidx];
            int midsum = pref[i+k] - pref[i];
            int rightsum = pref[ridx+k] - pref[ridx];
            int total = leftsum + midsum + rightsum;

            if(total > maxSum){
                maxSum = total;
                res[0] = lidx;
                res[1] = i;
                res[2] = ridx;
            }
        }
        return res;
    }
}
```

## Example Walkthrough
| nums | `[1,2,1,2,6,7,5,1]` | `k=2` |
|------|---------------------|------|
| **Subarray sums** | `[3,3,8,12,10,6]` |
| **left[i]** | Best ending at `i`: `[0,0,3,3,3,3]` |
| **right[i]** | Best starting at `i`: `[0,3,3,3,3,5]` |
| **Middle scan** | `i=2`: `left[1]=0`, `mid=8`, `right[4]=3` → `3+8+12=23` → best |
| **Result** | `[0,3,5]` |

## Architectural Breakdown
| Component           | Role                                      |
|---------------------|-------------------------------------------|
| `pref[]`            | O(1) subarray sum queries                 |
| `left[]`            | Best subarray **ending** at `i`           |
| `right[]`           | Best subarray **starting** at `i`         |
| **Three-phase scan**| Precompute → combine → O(n) total         |
| **Lex order**       | `>=` in right scan → favors smaller index |

## Why This Approach Is Superior
| Aspect              | **Prefix + Precompute** | Brute Force / DP         |
|---------------------|--------------------------|---------------------------|
| Time Complexity     | **O(n)**                 | O(n³) or O(n²)            |
| Space Complexity    | **O(n)**                 | O(n) or more              |
| Performance         | Linear, cache-friendly   | TLE on large inputs       |
| Clarity             | **Modular phases**       | Nested loops, hard to debug |

## Final Takeaway
- **This pattern generalizes to**:
  - **k non-overlapping subarrays**
  - **Max sum with fixed-length segments**
  - **Precompute extremes + combine**
- **Key Insight**:  
  > **"Precompute best left/right, then slide middle — avoid O(n²)."**
  
  ---

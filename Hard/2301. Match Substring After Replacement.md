# Pattern Name  
Substring Matching with One-Time Character Replacement via Mapping Table

---

## Problem Summary

You're given:

- A string `s` — the target string  
- A string `sub` — the pattern you want to match  
- A list of character mappings `mappings`, where each pair `[a, b]` means you can replace character `a` in `sub` with character `b`

Constraints:

- Each character in `sub` can be replaced **at most once**  
- After replacements, `sub` must appear as a **contiguous substring** of `s`  
- Return `true` if this is possible, otherwise `false`

---

## Core Idea

This is a substring search problem with flexible character matching.  
Each character in `sub` can match itself or one of its mapped replacements.  
We scan `s` for all possible substrings of length `sub.Length`, and check if any of them match `sub` under the allowed mappings.

---

## Strategy Summary

1. Build a mapping table: for each character in `sub`, store all allowed replacements (including itself)  
2. Iterate over all substrings of `s` with length equal to `sub`  
3. For each position, check character-by-character whether `sub[j]` can match `s[i + j]` via the mapping  
4. If a full match is found, return `true`  
5. If no match is found after scanning all positions, return `false`

---

## C# Implementation

```csharp
public class Solution {
    public bool MatchReplacement(string s, string sub, char[][] mappings) {
        var map = new Dictionary<char, HashSet<char>>();

        // Build mapping table
        foreach (var pair in mappings) {
            char from = pair[0], to = pair[1];
            if (!map.ContainsKey(from)) map[from] = new HashSet<char>();
            map[from].Add(to);
        }

        // Each character can match itself
        foreach (char c in sub) {
            if (!map.ContainsKey(c)) map[c] = new HashSet<char>();
            map[c].Add(c);
        }

        // Try every starting position in s
        for (int i = 0; i <= s.Length - sub.Length; i++) {
            bool match = true;
            for (int j = 0; j < sub.Length; j++) {
                char a = sub[j], b = s[i + j];
                if (!map[a].Contains(b)) {
                    match = false;
                    break;
                }
            }
            if (match) return true;
        }

        return false;
    }
}
```

##  Architectural Breakdown

| Component       | Role                                                  |
|----------------|--------------------------------------------------------|
| `map`           | Stores allowed replacements for each character in `sub` |
| `Add(c)`        | Ensures each character can match itself               |
| Outer loop      | Scans all possible substrings of `s`                  |
| Inner loop      | Validates character-by-character match with mapping   |

---

##  Why This Approach Is Superior

| Aspect               | This Approach                          | Alternative Approach                     |
|----------------------|----------------------------------------|------------------------------------------|
| Replacement Logic    | HashSet lookup per character           | Manual nested loops or string rebuild    |
| Matching Strategy    | Sliding window over `s`                | Full enumeration or regex simulation     |
| Code Clarity         | Modular and readable                   | Entangled or stateful matching           |
| Performance          | Linear scan with constant-time checks  | Potential quadratic overhead             |
| Generalizability     | Easily adapts to other mapping rules   | Hardcoded or fragile logic               |

---

##  Final Takeaway

This problem is not about rigid string comparison — it's about **flexible character matching with one-time replacements**.  
The solution uses:

- Preprocessing of mappings into a `Dictionary<char, HashSet<char>>`  
- Linear scan of all substrings in `s`  
- Per-character validation using set membership

This pattern generalizes to any task involving:

- Substring search with flexible character rules  
- One-time replacement constraints  
- Efficient matching via precomputed lookup tables

This module now lives in my repo as:

> **Substring Matching with One-Time Character Replacement via Mapping Table**



---

# 780. Reaching Points — Architectural Backward Modulo Reduction  
*O(log max(tx,ty)) — Clean Reverse Simulation*

---

## Problem Statement

Given start `(sx, sy)` and target `(tx, ty)`.

Allowed moves:
- `(x, y)` → `(x, x+y)`
- `(x, y)` → `(x+y, y)`

Return `true` if you can reach target from start.

**Constraints**: values up to `10⁹` → forward simulation impossible.

---

## Core Idea — Work Backwards with Modulo

Forward moves **increase** coordinates → too many paths.

Backward:
- From `(tx, ty)` reduce the **larger** coordinate using modulo
- Equivalent to undoing multiple additions

**Why modulo works**:
- `(x + k*y, y)` → reduce x by `k*y` → `x % y`

Continue until we **can't reduce further** or match start.

---

##  Implementation (C#)

```csharp
public class Solution {
    public bool ReachingPoints(int sx, int sy, int tx, int ty) {
        
        while (tx > sx && ty > sy) {
            if (tx > ty)  tx %= ty;
            else ty %= tx;  
        }
        if (tx == sx && ty == sy) return true;
        if (tx == sx && ty >= sy && (ty - sy) % tx == 0) return true;
        if (ty == sy && tx >= sx && (tx - sx) % ty == 0) return true;

        return false;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(log max(tx,ty))** | Modulo reductions like Euclidean algorithm     |
| **Space Complexity**  | **O(1)**              | Only variables                                 |

**Optimal** — fastest possible.

---

## Why This Works

- **Reverse simulation** → only **one path** backwards
- **Modulo** → efficiently undo **multiple additions** in one step
- Loop stops when we **can't reduce** without going below start
- Final check → did we hit **exactly** `(sx,sy)`?

**Mathematical guarantee**: all reachable points are covered — every forward move has a unique reverse via modulo.

---

## Pitfalls & Edge Cases

- `tx == sx, ty == sy` → true (already there)
- One coordinate matches, other reducible → handled by loop
- Target smaller than start → false (loop exits early)
- Large numbers → modulo safe (no overflow)

All covered.

---

## Key Takeaway

This is a **brilliant reverse-thinking** problem:

- Forward = explosion of states
- Backward = **single path** with modulo reduction
- **No recursion, no BFS** — just loop

**One of the most elegant Hard problems** — solved with **pure math**.

---

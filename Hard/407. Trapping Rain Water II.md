## 🧫 LeetCode 407 — Trapping Rain Water II

### 📜 Problem Summary

You're given an `m x n` grid `heightMap`, where each cell represents elevation.  
After raining, water can be trapped in lower areas surrounded by higher terrain.  
Return the **total volume of trapped water**.

---

### 🧠 Core Insight

This is not a brute-force simulation — it's a **priority-driven flood-fill**.

You don't simulate water from the top.  
Instead, you build a **boundary wall** and let water flow inward, always expanding from the **lowest elevation**.

This is a classic **min-heap BFS pattern**, where the outer boundary expands inward, and water is trapped when a neighbor is lower than the current boundary.

---

### 🔍 Architectural Triggers

- `"Water is trapped between blocks"` → requires comparing elevation differences  
- `"Boundary controls flow"` → process cells in order of elevation  
- `"Each cell can trap water only if surrounded by higher terrain"` → BFS with elevation awareness  
- `"Priority matters"` → use a min-heap to always expand from the lowest boundary

---

### 🔧 Architectural Strategy

#### 🔹 Core Structures

- `seen[m,n]` — boolean matrix to track visited cells and avoid reprocessing  
- `PriorityQueue<(r, c, h), h>` — min-heap to process boundary cells by elevation  
- `dirs` — 4-directional movement: up, down, left, right

#### 🔹 Initialization Phase

- Add all **boundary cells** (edges of the grid) to the priority queue  
- Mark them as `seen` — they form the initial containment wall  
- These cells act as the outer shell through which water cannot escape

#### 🔹 BFS Expansion Phase

While the priority queue is not empty:

1. **Pop the lowest boundary cell**  
   - This ensures we always expand from the lowest elevation

2. **For each neighbor (up/down/left/right)**:
   - If the neighbor is **within bounds** and **not seen**:
     - Mark it as `seen`
     - If the neighbor's height is **lower than current boundary**:
       - Water is trapped:  
         ```
         res += h - heightMap[nr][nc]
         ```
     - Push the neighbor into the queue with updated height:  
       ```
       max(heightMap[nr][nc], h)
       ```

> This ensures that water only flows inward from higher terrain, and trapped volume is computed incrementally as the BFS expands.

---

## 🚀 C# Implementation 
```cpp
public class Solution {
    public int TrapRainWater(int[][] heightMap) {
        int m = heightMap.Length;
        int n = heightMap[0].Length;
        if (m <= 2 || n <= 2) return 0; // No room to trap water

        bool[,] seen = new bool[m, n];
        var pq = new PriorityQueue<(int r, int c, int h), int>();

        //  Add boundary cells to the priority queue
        for (int i = 0; i < m; i++) {
            pq.Enqueue((i, 0, heightMap[i][0]), heightMap[i][0]);
            pq.Enqueue((i, n - 1, heightMap[i][n - 1]), heightMap[i][n - 1]);
            seen[i, 0] = seen[i, n - 1] = true;
        }

        for (int j = 1; j < n - 1; j++) {
            pq.Enqueue((0, j, heightMap[0][j]), heightMap[0][j]);
            pq.Enqueue((m - 1, j, heightMap[m - 1][j]), heightMap[m - 1][j]);
            seen[0, j] = seen[m - 1, j] = true;
        }

        //  Directions for BFS
        int[][] dirs = new int[][] {
            new int[] {1, 0}, new int[] {-1, 0},
            new int[] {0, 1}, new int[] {0, -1}
        };

        int res = 0;

        //  BFS with priority queue
        while (pq.Count > 0) {
            var cell = pq.Dequeue();
            int r = cell.r;
            int c = cell.c;
            int h = cell.h;

            foreach (var d in dirs) {
                int nr = r + d[0];
                int nc = c + d[1];

                if (nr >= 0 && nr < m && nc >= 0 && nc < n && !seen[nr, nc]) {
                    seen[nr, nc] = true;

                    //  If neighbor is lower → trap water
                    if (heightMap[nr][nc] < h) {
                        res += h - heightMap[nr][nc];
                    }

                    // Push neighbor with updated boundary height
                    pq.Enqueue((nr, nc, Math.Max(heightMap[nr][nc], h)), Math.Max(heightMap[nr][nc], h));
                }
            }
        }

        return res;
    }
}
```
## ⏱️ Time and Space Complexity

| Metric | Complexity              | Explanation |
|--------|--------------------------|-------------|
| Time   | O(m × n × log(mn))       | Each cell is processed once. Priority queue operations (insert/dequeue) cost log(size), and the queue may contain up to m × n elements. |
| Space  | O(m × n)                 | The `seen` matrix tracks visited cells, and the priority queue may grow to include all cells in the grid. |

---

## 🧱 Minimal Recall Block

```text
Min-heap BFS from boundary
If neighbor is lower → trap water
Push neighbor with max(current height, neighbor height)
```

## 🧩 Generalization Pattern — Min-Heap Flood Fill

### 📌 Applicable Scenarios

This architectural pattern applies to problems involving:

- Terrain-based simulations with elevation constraints  
- Flow control based on boundary height  
- Priority-based expansion (e.g., Dijkstra, containment, pressure spread)

---

### 🔹 Core Idea

- **Start from the boundary**  
  Treat outer cells as the initial containment wall

- **Expand inward using a min-heap**  
  Always process the lowest elevation first

- **Trap water when neighbor is lower than current boundary**  
  Water volume = current boundary height − neighbor height

- **Update boundary height**  
  Push neighbor with `max(current height, neighbor height)` to maintain containment

---

### 🧠 Engineering Takeaways

- **Priority queue** guarantees correct expansion order — lowest elevation first  
- **BFS traversal** ensures full coverage without revisiting  
- **Water trapping is local** — based on elevation difference, not global simulation  
- **Reusable pattern** for terrain modeling, containment zones, pressure-based systems

> You don’t simulate water — you control its flow by elevation.  
> You don’t guess — you expand from the lowest boundary.

---

## ✅ Solution Summary

This solution uses a **min-heap BFS** to simulate water flow from the outer boundary inward.  
By always expanding from the lowest elevation, it ensures that water is only trapped when a neighbor is lower than the current boundary.

The use of a priority queue and elevation-aware traversal makes this approach both **efficient and scalable**.

This pattern is highly reusable and forms the basis for many terrain and containment problems.  
It’s not just a solution — it’s an **architectural engine** for elevation-driven simulations.


---


---

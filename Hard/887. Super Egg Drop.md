# 887. Super Egg Drop — Architectural DP with Binary Search Optimization  
*O(k × n log n) or O(k × n) — Optimal Minimax Moves*

---

## Problem Statement

Given `k` eggs and `n` floors.

Find **minimum number of moves** in the **worst case** to determine the exact critical floor `f` (0 ≤ f ≤ n), where:
- Egg dropped from floors **1 to f** does **not break**
- Egg dropped from floors **f+1 to n** **breaks**

You can reuse unbroken eggs.

Return the **minimum moves** needed to guarantee finding `f`.

---

## Core Idea — DP: Min Moves for k Eggs, n Floors

**Key insight**:
- `dp[k][n]` = minimum moves needed with `k` eggs and `n` floors
- For a drop at floor `x`:
  - If egg **breaks** → `dp[k-1][x-1]` moves left (k-1 eggs, x-1 floors below)
  - If egg **survives** → `dp[k][n-x]` moves left (k eggs, n-x floors above)
- Worst-case moves for this drop = `1 + max(broke, survived)`
- We choose `x` to **minimize** this worst-case value

**Mathematical formulation**:
```dp[k][n] = min over x=1 to n of (1 + max(dp[k-1][x-1], dp[k][n-x]))```

**Naive approach**: try all `x` → O(k × n²) — too slow for larger constraints

**Optimized**:
- The function `max(broke(x), survived(x))` is **unimodal** → binary search on `x` finds optimal drop point → O(k × n log n)

**Even better** O(k × n):
- Reframe DP as `dp[eggs][moves]` = **maximum floors** solvable with `eggs` eggs and `moves` moves
- Recurrence: `dp[e][m] = dp[e-1][m-1] + dp[e][m-1] + 1`
  - Meaning: one drop + floors below (if breaks) + floors above (if survives)
- Increase `m` until `dp[k][m] >= n`

---

##  Implementation (C#) - O(k × n)

```csharp
public class Solution {
    public int SuperEggDrop(int k, int n) {
        int[][] dp = new int[k + 1][];
        for (int i = 0; i <= k; i++) {
            dp[i] = new int[n + 1];
        }

        int m = 0;
        while (dp[k][m] < n) {
            m++;
            for (int e = 1; e <= k; e++) {
                dp[e][m] = dp[e - 1][m - 1] + dp[e][m - 1] + 1;
            }
        }

        return m;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(k × n)**          | k ≤ 100, n ≤ 10⁴ → ~10⁶ operations             |
| **Space Complexity**  | **O(k × n)**          | DP table (can optimize to O(n))                |

**Optimal** — best known for general k,n.

---

## Why This Works — Example Walkthrough

**Input**: `k=2`, `n=6`

- m=1: dp[2][1] = **1**
- m=2: dp[2][2] = 1 + 3 = **4**
- m=3: dp[2][3] = 1 + 6 = **7** ≥ 6 → **3 moves**

**Correct**.

**Input**: `k=1`, `n=2`

- With 1 egg → linear search → **2 moves**

**Correct**.

---

## Pitfalls & Edge Cases

- **k=1** → must do linear search → n moves
- **n=1** → 1 move
- **Large k** → can solve many floors quickly
- **Overflow** → not issue (n≤10⁴)

All handled.

---

## Key Takeaway

This is a **masterpiece of minimax DP**:

- **Reframe** as floors solvable per moves
- **Linear recurrence** → O(k n)
- **No binary search needed**
**Pure, clean, optimal** — one of the best egg drop solutions.

---

# 801. Minimum Swaps To Make Sequences Increasing — Architectural DP with Two States  
*O(n) — Optimal Linear DP with Swap/No-Swap Tracking*

---

## Problem Statement

- You are given two integer arrays `nums1` and `nums2` of the same length.
- In one operation, you can **swap** `nums1[i]` with `nums2[i]` for any index `i`.
- Return the **minimum number of swaps** needed to make **both** arrays **strictly increasing**.
- It is guaranteed that it is always possible.

---

## Core Idea — DP with Two States (No Swap / Swap at Current Position)

**Key insight**:
- We need both arrays to be strictly increasing:  
  `nums1[0] < nums1[1] < ... < nums1[n-1]`  
  `nums2[0] < nums2[1] < ... < nums2[n-1]`
- At each position `i`, we have two choices:
  - Keep original (no swap at i)
  - Swap at i
- We track the **minimum swaps** to reach position `i` in two states:
  - `noSwap[i]` = min swaps to make first `i+1` elements increasing **without** swapping at position `i`
  - `swap[i]` = min swaps to make first `i+1` elements increasing **with** swapping at position `i`

**Transitions**:
- For `noSwap[i]`:
  - Previous could be no-swap or swap, but **current must not swap** → check both arrays stay increasing
- For `swap[i]`:
  - Previous could be no-swap or swap, but **current must swap** → check swapped values are increasing

**Base**:
- `noSwap[0] = 0`
- `swap[0] = 1`

**Final answer**: `min(noSwap[n-1], swap[n-1])`

---

## Full Optimal Implementation (C#)

```csharp
public class Solution {
    public int MinSwap(int[] nums1, int[] nums2) {
        int n = nums1.Length;

        // noSwap[i] = min swaps to make first i+1 elements increasing without swapping at i
        // swap[i] = min swaps with swapping at i
        int noSwap = 0;
        int swap = 1;  // swap at position 0

        for (int i = 1; i < n; i++) {
            int noSwapPrev = noSwap;
            int swapPrev = swap;

            noSwap = int.MaxValue;
            swap = int.MaxValue;

            // Case 1: no swap at current position i
            if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) noSwap = noSwapPrev;
            if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1])  noSwap = Math.Min(noSwap, swapPrev);
            

            // Case 2: swap at current position i
            if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) swap = noSwapPrev + 1;
            if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) swap = Math.Min(swap, swapPrev + 1);
            
        }

        return Math.Min(noSwap, swap);
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single linear pass over the array              |
| **Space Complexity**  | **O(1)**      | Only two variables to track previous states    |

**Optimal** — linear time, constant extra space.

---

## Why This Works — Example Walkthrough

**Example 1**: `nums1 = [1,3,5,4]`, `nums2 = [1,2,3,7]`

- At position i=3: nums1[3]=4, nums2[3]=7
- Without swap at i=3: check nums1: 5 → 4? No (5 > 4 false)
- With swap at i=3: nums1 becomes 7, nums2 becomes 4
  - Check nums1: 5 → 7 (5 < 7 true)
  - Check nums2: 3 → 4 (3 < 4 true)
- So swap at i=3 is valid → minimum swaps = **1**

**Correct**.

**Example 2**: `nums1 = [0,3,5,8,9]`, `nums2 = [2,1,4,6,9]`

- At i=1: nums1[1]=3, nums2[1]=1
- Without swap: nums1: 0 → 3 (ok), nums2: 2 → 1 (2 > 1 false) → invalid
- With swap: nums1 becomes 1, nums2 becomes 3
  - nums1: 0 → 1 (ok)
  - nums2: 2 → 3 (ok)
- One swap needed at i=1 → total **1** → correct

The DP maintains two states at each position:
- `noSwap` — min swaps so far without swapping at current index
- `swap` — min swaps so far with swapping at current index

Transitions ensure both arrays remain strictly increasing after each decision.

---

## Pitfalls & Edge Cases

- **n = 2** → either 0 or 1 swap (simple check)
- **Already both strictly increasing** → return **0** (no swaps needed)
- **Impossible without swaps** → DP will find minimum needed swaps
- **Large n (≤10⁵)** → O(n) is very efficient
- **Need early swaps** → DP correctly carries minimum cost forward

All handled perfectly.

---

## Key Takeaway

This is a **beautifully clean** DP problem:

- **Two states** per position: no-swap and swap at current index
- **Transitions** carefully check if both arrays remain strictly increasing after the decision
- **O(n) time, O(1) space** — extremely efficient and elegant

**Pure, clean, optimal** — perfect minimum swaps to make both sequences strictly increasing.

---

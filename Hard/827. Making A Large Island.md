# üìò Problem: 827. Making A Large Island

## üß© Problem Description  
Given an `n x n` binary matrix `grid`, where `1` represents land and `0` represents water, return the size of the **largest possible island** after changing **at most one `0` to `1`**.  
An island is a group of `1`s connected **4-directionally** (up, down, left, right).

---

## üí° Core Idea  
This is a **two-phase grid traversal** problem:

1. **Phase 1**: Traverse the grid to identify and label all existing islands.  
   - Assign each island a unique ID  
   - Record the area of each island in a map

2. **Phase 2**: For every `0` cell, simulate flipping it to `1` and calculate the potential area by summing the areas of **distinct neighboring islands**.  
   - Track the maximum area across all such flips

---

## ‚öôÔ∏è Algorithm Overview

### Phase 1: DFS Labeling  
- Traverse the grid  
- For each unvisited `1`, launch DFS  
- Assign a unique ID to the island  
- Record its area in `Dictionary<int, int>`

### Phase 2: Maximize Area  
- For each `0` cell:
  - Check its 4 neighbors  
  - Collect unique island IDs  
  - Sum their areas + 1 (the flipped cell)  
  - Update `maxArea` if larger

### Edge Case  
- If no `0` exists, return total grid area or max from Phase 1

---

## üß† Combined Techniques

| Component           | Technique Used                  |
|--------------------|----------------------------------|
| Grid Traversal      | Nested loops over `n x n`        |
| Island Labeling     | DFS with unique ID assignment    |
| Area Tracking       | Dictionary mapping `id ‚Üí area`   |
| Max Calculation     | HashSet to avoid double-counting |
| Signal Propagation  | Recursive DFS return values      |

---

## üß™ Constraints

- `1 <= n <= 500`  
- `grid[i][j]` is either `0` or `1`  
- Grid is square and surrounded by water  
- Time complexity: `O(n^2)`  
- Space complexity: `O(n^2)` for DFS stack and area map

---


## üß± Code Implementation

```csharp
public class Solution {
    public int LargestIsland(int[][] grid) {
        int n = grid.Length;
        var areaMap = new Dictionary<int, int>();
        int id = 2;
        int maxArea = 0;

        // Phase 1: Label islands and record their areas
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    int area = DFS(grid, i, j, id);
                    areaMap[id] = area;
                    maxArea = Math.Max(maxArea, area);
                    id++;
                }
            }
        }

        // Phase 2: Try flipping each 0 and compute potential area
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    var seen = new HashSet<int>();
                    int area = 1;

                    foreach (var (dx, dy) in new[] { (0,1), (1,0), (0,-1), (-1,0) }) {
                        int ni = i + dx;
                        int nj = j + dy;

                        if (ni >= 0 && nj >= 0 && ni < n && nj < n) {
                            int neighID = grid[ni][nj];
                            if (neighID > 1 && seen.Add(neighID)) {
                                area += areaMap[neighID];
                            }
                        }
                    }

                    maxArea = Math.Max(maxArea, area);
                }
            }
        }

        return maxArea;
    }

    int DFS(int[][] grid, int i, int j, int ID) {
        int n = grid.Length;

        if (i < 0 || j < 0 || i >= n || j >= n || grid[i][j] != 1) return 0;

        grid[i][j] = ID;

        return 1 +
            DFS(grid, i + 1, j, ID) +
            DFS(grid, i - 1, j, ID) +
            DFS(grid, i, j + 1, ID) +
            DFS(grid, i, j - 1, ID);
    }
}
```

## ‚úÖ Summary

This solution uses a **two-pass DFS strategy** to compute the largest possible island size after a single cell flip.

### Architectural signals:
- DFS assigns unique IDs and returns area  
- Grid is mutated to store island IDs  
- Area map tracks component sizes  
- HashSet ensures distinct neighbor merging  
- Second pass simulates flips and maximizes area

### Debugging insights:
- DFS must return `int` to accumulate area  
- Grid mutation must avoid ID collision (`id ‚â• 2`)  
- Neighbor merging must avoid double-counting via `HashSet`

This implementation is modular, efficient, and ideal for training **multi-phase grid traversal**, **component labeling**, and **dynamic maximization** strategies.




---

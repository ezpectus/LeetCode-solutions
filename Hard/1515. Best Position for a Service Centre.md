# 1515. Best Position for a Service Centre 
*O(n × iterations) — Optimal Weiszfeld's Algorithm with Improved Precision*

---

## Problem Statement

- Given an array `positions` where `positions[i] = [xi, yi]` are customer coordinates (n ≤ 50, 0 ≤ xi,yi ≤ 100).
- Find a point `(xcentre, ycentre)` that **minimizes** the **sum of Euclidean distances** to all customers.
- Return this **minimum sum** (double). Answers within **10⁻⁵** of the actual value are accepted.
- This is the **geometric median** problem.

---

## Core Idea — Weiszfeld's Iterative Algorithm 

**Key insight**:
- No closed-form solution for general n
- Weiszfeld's algorithm iteratively approximates the geometric median
- Start from centroid → update as weighted average (weights = 1/distance)
- Converges quickly to optimal point
- Use **very small EPS** (1e-10) for convergence check
- Handle **dist == 0** case properly (already optimal → return current sum)
- Increase **MAX_ITER** to 300 for safety on edge cases
- Use **double** everywhere for precision

---

## Implementation (C#)

```csharp
public class Solution 
{
    public double GetMinDistSum(int[][] positions) 
    {
        int n = positions.Length;
        if (n == 1) return 0.0;

        // Step 1: Compute centroid as starting point
        double cx = 0.0, cy = 0.0;
        foreach (int[] p in positions) 
        {
            cx += p[0];
            cy += p[1];
        }
        cx /= n;
        cy /= n;

        // Step 2: Weiszfeld's algorithm
        const double EPS = 1e-10;
        const int MAX_ITER = 300;

        for (int iter = 0; iter < MAX_ITER; iter++) 
        {
            double numX = 0.0, numY = 0.0, den = 0.0;
            bool coincided = false;

            foreach (int[] p in positions) 
            {
                double dx = cx - p[0];
                double dy = cy - p[1];
                double distSq = dx * dx + dy * dy;

                if (distSq < EPS * EPS) 
                {
                    // Coincides with a point — already optimal
                    coincided = true;
                    break;
                }

                double dist = Math.Sqrt(distSq);
                numX += p[0] / dist;
                numY += p[1] / dist;
                den += 1.0 / dist;
            }

            if (coincided) break;

            double newCx = numX / den;
            double newCy = numY / den;

            // Convergence check
            if (Math.Abs(newCx - cx) < EPS && Math.Abs(newCy - cy) < EPS) 
            {
                break;
            }

            cx = newCx;
            cy = newCy;
        }

        // Step 3: Compute final sum of distances
        double sum = 0.0;
        foreach (int[] p in positions) 
        {
            double dx = cx - p[0];
            double dy = cy - p[1];
            sum += Math.Sqrt(dx * dx + dy * dy);
        }

        return sum;
    }
}

```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n × iterations)** | iterations ≈ 30–100, n ≤ 50 → extremely fast   |
| **Space Complexity**  | **O(1)**              | Only a few variables                           |

**Optimal** — converges very quickly, error well within 10⁻⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: `positions = [[0,1],[1,0],[1,2],[2,1]]`

- Centroid ≈ (1, 1)
- Sum of distances to (1,1) = 1 + 1 + 1 + 1 = **4.00000** → correct

**Example 2**: `[[1,1],[3,3]]`

- Geometric median ≈ (2,2)
- Sum = √2 + √2 ≈ **2.82843** → correct

**Correct** — the algorithm converges to the true geometric median, which minimizes the sum of Euclidean distances.

---

## Pitfalls & Edge Cases

- **n = 1** → sum = **0** (handled)
- **All points coincide** → sum = **0**
- **Points collinear** → converges correctly
- **Numerical stability** → EPS = 1e-10 + coincidence check prevents division by zero
- **Large coordinates** → double precision sufficient (coordinates ≤ 100)

All handled perfectly.

---

## Key Takeaway

This is a **classic geometric median** problem:

- No closed-form solution for general n
- **Weiszfeld's algorithm** — simple iterative weighted average → converges fast to optimal point
- **O(n × iterations)** with iterations ~30–100 → very fast for n ≤ 50

**Pure, clean, optimal** - perfect minimum sum of Euclidean distances.

---

# 2851. String Transformation — C# Solution

---

##  Problem Restatement
We are given:
- Two strings `s` and `t` of equal length `n`.
- An integer `k`.

Operation allowed:
- Remove a suffix of `s` of length `l` (`0 < l < n`) and append it at the start of `s`.

Goal:
- Count the number of ways to transform `s` into `t` in **exactly `k` operations**.
- Return the result modulo `10^9 + 7`.

---

##  Core Idea
- **Rotation equivalence:**  
  Every allowed operation is effectively a rotation of the string `s`.  
  Removing a suffix of length `l` and appending it to the front shifts the string by `n - l` positions.  
  Thus, after `k` operations, `s` must be rotated into `t`.

- **Detect valid rotations:**  
  Concatenate `s + s` and search for `t` inside using a robust method (double rolling hash or KMP).  
  Each match position corresponds to a rotation offset where `s` can equal `t`.

- **Transition modeling:**  
  From any rotation state, there are `n - 1` possible moves (choosing different suffix lengths).  
  This can be represented as a recurrence or a transition matrix describing how rotations evolve after each operation.

- **Counting sequences:**  
  We need the number of distinct operation sequences of length `k` that land exactly on a valid rotation offset.  
  Direct simulation is impossible for large `k` (up to `10^15`), so we rely on algebraic methods.

- **Matrix exponentiation:**  
  By exponentiating the transition matrix to power `k`, we can compute the number of ways to reach each rotation offset in exactly `k` steps.  
  This ensures logarithmic complexity in `k` and avoids brute force.

- **Final aggregation:**  
  Sum the counts for all valid rotation offsets that match `t`.  
  Return the result modulo `10^9 + 7`.

---

##  Code (C#)
```csharp
using System;
using System.Collections.Generic;

public class Solution {
    // Modulo constant for large number calculations
    const long mod = 1_000_000_007;

    public int NumberOfWays(string s, string t, long k) {
        // Initialize variables for hash computation
        long hash = 0;
        long mul = 1;   // Power for 26 (for normal hash)
        long mul2 = 1;  // Power for 27 (for second hash)
        long hash2 = 0; // Second hash for string t
        long sHash2 = 0; // Second hash for string s
        
        // Compute the hashes for string t
        foreach (char c in t) {
            mul = (mul * 26) % mod;
            mul2 = (mul2 * 27) % mod;
            hash = (hash * 26 + (c - 'a')) % mod;
            hash2 = (hash2 * 27 + (c - 'a')) % mod;
        }

        long sHash = 0; // Rolling hash for string s
        foreach (char c in s) {
            sHash = (sHash * 26 + (c - 'a')) % mod;
            sHash2 = (sHash2 * 27 + (c - 'a')) % mod;
        }

        // List to store the indices where the hashes of s match t
        List<int> index = new List<int>();
        int n = s.Length;

        // Rolling hash to check all possible rotations of s
        for (int i = 0; i < s.Length; ++i) {
            if (sHash == hash && sHash2 == hash2)
                index.Add((n - i) % n);

            sHash = (sHash * 26) % mod;
            sHash2 = (sHash2 * 27) % mod;

            long other = s[i] - 'a';
            long other2 = (other * mul) % mod;
            sHash = (sHash + mod - other2 + (s[i] - 'a')) % mod;

            other2 = (other * mul2) % mod;
            sHash2 = (sHash2 + mod - other2 + (s[i] - 'a')) % mod;
        }

        long result = 0;
        long[,] root = new long[,] { { 0, n - 1 }, { 1, n - 2 } };

        // Matrix exponentiation to compute the final answer
        long[,] pow = PowerExp(root, k);

        long a = (pow[0, 0] * 1) % mod;
        long b = (pow[1, 0] * 1) % mod;

        foreach (int num in index) {
            result = (result + (num == 0 ? a : b)) % mod;
        }

        return (int)result;
    }

    // Fast matrix exponentiation
    private long[,] PowerExp(long[,] mat, long pow) {
        var map = new Dictionary<long, long[,]>();
        long current = 1;
        long[,] val = mat;
        long[,] result = new long[mat.GetLength(0), mat.GetLength(0)];

        for (int i = 0; i < mat.GetLength(0); ++i) {
            result[i, i] = 1;
        }

        while (current <= pow) {
            map[current] = val;
            val = MultiplyMat(val, val);
            current *= 2;
        }

        while (current > 1) {
            current /= 2;
            if (pow >= current) {
                pow -= current;
                result = MultiplyMat(result, map[current]);
            }
        }

        return result;
    }

    // Matrix multiplication
    private long[,] MultiplyMat(long[,] mat1, long[,] mat2) {
        int rows = mat1.GetLength(0);
        int cols = mat2.GetLength(1);
        long[,] result = new long[rows, cols];

        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                long sum = 0;
                for (int k = 0; k < mat1.GetLength(1); ++k) {
                    sum = (sum + mat1[i, k] * mat2[k, j]) % mod;
                }
                result[i, j] = sum;
            }
        }
        return result;
    }
}
```


##  Complexity
- **Hash computation:** O(n)  
  Compute rolling hashes for `s` and `t` to detect rotations.  
- **Rotation check:** O(n)  
  Iterate through all possible rotations of `s` and compare with `t` using double hash.  
- **Matrix exponentiation:** O(log k)  
  Use fast exponentiation on the transition matrix to count ways after `k` operations.  
- **Total:** O(n + log k)  
- **Space:** O(n) for storing hashes and indices.  

---

##  Pitfalls
- **Hash collisions:**  
  Must use double hash (two different bases/moduli) to avoid false positives when checking rotations.  
- **Large k:**  
  Since `k` can be up to `10^15`, direct simulation is impossible. Fast exponentiation is required.  
- **Edge case — s == t:**  
  If `s` already equals `t`, multiple rotations may yield the same string. Must count all valid offsets.  
- **Modulo arithmetic:**  
  Always return the result modulo `10^9 + 7` to prevent overflow and match problem requirements.  

---

##  Example Walkthrough
**Input:**  
`s = "abcd"`, `t = "cdab"`, `k = 2`

**Step 1: Rotation detection**  
- Rotations of `s`: `"abcd"`, `"dabc"`, `"cdab"`, `"bcda"`.  
- `t = "cdab"` found at rotation offset = 2.  

**Step 2: Matrix exponentiation**  
- Transition matrix models how rotations evolve after each operation.  
- Exponentiate matrix to power `k = 2`.  
- Compute number of ways to reach offset 2 in exactly 2 steps.  

**Result:**  
Answer = 2.  

---

##  Conclusion
- The solution combines **rolling hash** for efficient rotation detection and **matrix exponentiation** for counting transformation sequences.  
- Handles very large `n` and extremely large `k` within constraints.  
- Guarantees correctness by avoiding hash collisions and applying modular arithmetic.  
- Final answer is the number of valid transformation sequences modulo `10^9 + 7`.  



---





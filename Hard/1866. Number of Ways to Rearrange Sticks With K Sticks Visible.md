# ðŸ§  1866. Number of Ways to Rearrange Sticks With K Sticks Visible

## ðŸ“œ Problem Restatement
We have `n` uniquely-sized sticks (lengths 1..n).  
We want to arrange them so that exactly `k` sticks are visible from the left.  
A stick is visible if no longer stick is to its left.  
Return the number of such arrangements modulo `10^9 + 7`.

---

## ðŸ§± Core Idea (Dynamic Programming)
This is a **classic DP recurrence** problem.

Let `dp[n][k]` = number of ways to arrange `n` sticks with exactly `k` visible.

### Recurrence:
- Place the **longest stick (length n)**:
  - If it is placed at the **leftmost position**, it is visible.  
    â†’ Remaining `n-1` sticks must have `k-1` visible.  
    â†’ Contribution: `dp[n-1][k-1]`.
  - If it is placed **not at the leftmost**, it is hidden by some longer stick to its left.  
    â†’ Remaining `n-1` sticks must have `k` visible.  
    â†’ Contribution: `(n-1) * dp[n-1][k]` (because longest stick can be placed in any of the other `n-1` positions).

So:
```dp[n][k] = dp[n-1][k-1] + (n-1) * dp[n-1][k]```

### Base cases:
- `dp[0][0] = 1` (empty arrangement).
- `dp[n][0] = 0` for n > 0.
- `dp[n][n] = 1` (only increasing order makes all visible).

---

## ðŸš€ Implementation (C#)

```csharp
public class Solution {
    private const int MOD = 1000000007;

    public int RearrangeSticks(int n, int k) {
        long[,] dp = new long[n+1, k+1];
        dp[0,0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
                dp[i,j] = (dp[i-1,j-1] + (i-1) * dp[i-1,j]) % MOD;
            }
        }

        return (int)dp[n,k];
    }
}
```
## â±ï¸ Complexity
- **Time:** O(n * k) â€” fill DP table  
- **Space:** O(n * k) (can optimize to O(k) with rolling array)  

---

## âš ï¸ Pitfalls
- Must use **long** for intermediate multiplication `(i-1) * dp[i-1][j]`  
- Donâ€™t forget **modulo** at each step  
- Base case `dp[0][0] = 1` is critical  
- `dp[n][n] = 1` naturally emerges from recurrence  

---

## âœ… Sanity Checks
- n = 3, k = 2 â†’ `dp[3][2] = 3` (matches example)  
- n = 5, k = 5 â†’ `dp[5][5] = 1` (only increasing order)  
- n = 20, k = 11 â†’ `dp[20][11] = 647427950` (mod 1e9+7)  

---

ðŸ‘‰ **Key takeaway:**  
This is a **DP recurrence problem** with a clean formula:  
`dp[n][k] = dp[n-1][k-1] + (n-1) * dp[n-1][k]`.  
Elegant, efficient, and scales to n = 1000 within constraints.


---

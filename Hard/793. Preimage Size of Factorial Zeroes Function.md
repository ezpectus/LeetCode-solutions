# 793. Preimage Size of Factorial Zeroes Function — Architectural Solution

---

## Problem Statement
We define `f(x)` as the number of trailing zeroes in `x!`.  
Given an integer `k`, return the number of non-negative integers `x` such that `f(x) = k`.

Constraints:  
- 0 ≤ k ≤ 10⁹  

---

## Core Idea
Trailing zeroes in factorials come from factors of 5.  
Formula for `f(x)`:
```f(x) = x/5 + x/25 + x/125 + ...```

(where `/` is integer division).

Key insight:
- The function `f(x)` is **non-decreasing** but has "gaps".  
- For most `k`, there are exactly **5 consecutive values of x** that yield `f(x) = k`.  
- For some `k`, there are **no values of x** (output = 0).  

So the answer is always either `0` or `5`.

Approach:
1. Use binary search to find the smallest `x` such that `f(x) ≥ k`.  
2. Use binary search to find the largest `x` such that `f(x) ≤ k`.  
3. If the range length is 5 → return 5. Otherwise → return 0.

---

## Implementation (C#)
```csharp
using System;

public class Solution {
    public int PreimageSizeFZF(int k) {
        long left = LowerBound(k);
        long right = LowerBound(k + 1);
        return (int)(right - left);
    }
    
    private long LowerBound(int k) {
        long low = 0, high = (long)5 * (k + 1);
        while (low < high) {
            long mid = low + (high - low) / 2;
            if (Zeroes(mid) < k) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }
    
    private long Zeroes(long x) {
        long res = 0;
        while (x > 0) {
            res += x / 5;
            x /= 5;
        }
        return res;
    }
}
```



## Complexity Analysis
- **Time Complexity:** O(log(k) * log(k)) ≈ O(log²(k))  
  Binary search is performed over the range up to `5*(k+1)`.  
  Each check computes trailing zeroes in O(log₅(x)) by repeatedly dividing by 5.  
- **Space Complexity:** O(1)  
  Only counters and a few variables are required; no extra data structures are used.

---

## Pitfalls & Edge Cases
- **Large k (up to 10⁹)**  
  Must use `long` to avoid overflow when computing bounds and factorial zero counts.  
- **Binary search bounds**  
  Upper bound must be `5*(k+1)` to guarantee coverage of all possible candidates.  
- **Return value**  
  The result is always either `0` or `5`, reflecting the structure of the factorial zeroes function.  
- **Edge case k=0**  
  Should correctly return `5` because `0!` through `4!` all have zero trailing zeroes.

---

## Conclusion
This solution leverages the monotonic nature of the factorial zeroes function and applies binary search to locate the range of `x` values that yield exactly `k` trailing zeroes.  

Architecturally, the design is clean:
- **Zeroes(x)** computes trailing zeroes efficiently.  
- **LowerBound(k)** finds the smallest `x` with `f(x) ≥ k`.  
- **Range difference** determines the count of valid `x`.  

The algorithm runs in **O(log²(k))** time with **O(1)** space, making it efficient, robust, and scalable for very large inputs.


---

# LeetCode 1655: Distribute Repeating Integers — Bitmask DP + DFS

## Problem Description
You are given:

- nums: array of integers (up to 10⁵ elements, but only 50 unique values)
- quantity[i]: number of identical integers requested by customer i
- Each customer must receive:
- Exactly quantity[i] integers
- All integers must be equal
- No two customers share the same integer group
- Return true if it's possible to satisfy all customers.

## Constraints
- 1 <= nums.length <= 10⁵
- 1 <= nums[i] <= 1000
- 1 <= quantity.length <= 10
- 1 <= quantity[i] <= 10⁵
- At most 50 unique values in nums

## How the Idea Was Formed

## Key Observations
- Only 50 unique values → we can treat each value as a resource pool
- Each customer wants a block of identical integers → we must assign values to customers
- Only 10 customers → we can use bitmask to represent assigned customers
- We need to check: can we assign each value to a subset of customers such that their demands are met?

## Strategy
- Count frequency of each unique value in nums
- Try assigning subsets of customers to each value
- Use DFS + memoization to explore all valid assignments
- Use bitmask to track which customers are already satisfied

## Bitmask Design
- mask: binary representation of satisfied customers
- mask = 0b000...000 → no one satisfied
- mask = 0b111...111 → all customers satisfied → base case

## DP State
```csharp
dp[valueIndex][mask] = true/false —
can we satisfy remaining customers using values[valueIndex..] and current mask
```


## C# Code with Comments
```csharp
public class Solution {
    public bool CanDistribute(int[] nums, int[] quantity) {
        // Step 1: Count frequency of each unique value
        var freqMap = new Dictionary<int, int>();
        foreach (int num in nums) {
            if (!freqMap.ContainsKey(num)) freqMap[num] = 0;
            freqMap[num]++;
        }

        // Step 2: Convert frequencies to array
        var freqList = freqMap.Values.ToList();
        int m = quantity.Length;
        int n = freqList.Count;

        // Step 3: Initialize memoization table
        var memo = new Dictionary<(int, int), bool>();

        // Step 4: Start DFS
        return DFS(0, 0);

        // Local function for DFS
        bool DFS(int i, int mask) {
            if (mask == (1 << m) - 1) return true; // all customers satisfied
            if (i == n) return false; // no more values to assign
            if (memo.ContainsKey((i, mask))) return memo[(i, mask)];

            // Option 1: skip current value
            if (DFS(i + 1, mask)) {
                memo[(i, mask)] = true;
                return true;
            }

            // Option 2: try assigning subsets of customers to current value
            for (int sub = 1; sub < (1 << m); sub++) {
                if ((sub & mask) != 0) continue; // skip already satisfied customers

                int total = 0;
                for (int j = 0; j < m; j++) {
                    if ((sub & (1 << j)) != 0) total += quantity[j];
                }

                if (total <= freqList[i]) {
                    if (DFS(i + 1, mask | sub)) {
                        memo[(i, mask)] = true;
                        return true;
                    }
                }
            }

            memo[(i, mask)] = false;
            return false;
        }
    }
}
```

## Pruning Logic
```csharp
if ((sub & mask) != 0) continue;
```
This skips subsets that include already satisfied customers.

```csharp
if (total > freqList[i]) continue;
```
This skips subsets that demand more than the available frequency.

## Complexity
- Time: O(n × 2^m × m)
- n = number of unique values (≤ 50)
- 2^m = number of customer subsets (≤ 1024)
- m = number of customers (≤ 10)
- Space: O(n × 2^m) for memoization

## Architectural Conclusion

This is a classic bitmask + DFS + memoization problem:

- Bitmask tracks satisfied customers
- DFS explores all value-to-subset assignments
- Memoization avoids recomputation
- Pruning ensures performance

The key insight is to loop over subsets of customers, not permutations, and to treat each value as a resource pool.


---

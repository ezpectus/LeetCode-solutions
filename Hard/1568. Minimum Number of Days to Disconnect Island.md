# 1568. Minimum Number of Days to Disconnect Island — Architectural Articulation Points & Island Counting  
*O(m × n) — Optimal DFS-Based Connectivity Check*

---

## Problem Statement

- Given `m × n` grid (1 ≤ m,n ≤ 30) with 0 (water) and 1 (land).
- An **island** = 4-connected group of 1s.
- Grid is **connected** if **exactly one island**.
- In one day — change **one 1 → 0**.
- Return **minimum days** to make grid **disconnected** (0 or ≥2 islands).
- If already disconnected → 0.


---

## Core Idea — Check 0, 1, or 2 Days

**Key insight**:
- m,n ≤30 → small → we can afford multiple DFS
- Maximum answer is **2** (articulation points or bridges)
- Cases:
  - **0 days**: already ≥2 islands or no land
  - **1 day**: exists a cell whose removal disconnects (articulation point)
  - **2 days**: otherwise (always possible for connected grid with ≥2 land cells)

**Steps**:
1. Count initial islands → if ≠1 → return 0
2. Try removing **each land cell** one by one:
   - Temporarily set to 0
   - Count islands
   - If ≠1 → return 1
   - Restore
3. If no single removal works → return 2

**Optimization**: actually, for connected grid, answer is:
- 0 if already disconnected
- 1 if has articulation point
- 2 otherwise

But brute force works fine.

---

##  Implementation (C#)

```csharp
public class Solution {
    private int m, n;
    private int[][] g;
    private bool[,] vis;

    public int MinDays(int[][] grid) {
        g = grid;
        m = grid.Length;
        n = grid[0].Length;

        // Case 0: already disconnected or no land
        int islands = CountIslands();
        if (islands != 1) return 0;

        // Case 1: try removing each land cell
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                if (g[r][c] == 0) continue;

                g[r][c] = 0;
                islands = CountIslands();
                g[r][c] = 1; // restore

                if (islands != 1) return 1;
            }
        }

        // Case 2: need 2 days
        return 2;
    }

    private int CountIslands() {
        vis = new bool[m, n];
        int cnt = 0;

        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                if (g[r][c] == 1 && !vis[r,c]) {
                    cnt++;
                    Dfs(r, c);
                }
            }
        }

        return cnt;
    }

    private void Dfs(int r, int c) {
        if (r < 0 || r >= m || c < 0 || c >= n || vis[r,c] || g[r][c] == 0) return;

        vis[r,c] = true;
        Dfs(r-1, c);
        Dfs(r+1, c);
        Dfs(r, c-1);
        Dfs(r, c+1);
    }
}
```

## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(m × n × (m × n))**        | Worst case: try removing each land cell × DFS per try → ~90,000 operations for 30×30 grid |
| **Space Complexity**  | **O(m × n)**                  | Visited array + recursion stack                |

**Optimal** — for m,n ≤ 30, this brute-force with pruning is perfectly acceptable and passes all tests.

---

## Why This Works — Example Walkthrough

**Example 1**: `grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]`

- Initial islands = **1** (the two columns of 1s are connected)
- Try removing each land cell one by one:
  - Remove (0,1) → still connected
  - Remove (0,2) → still connected
  - Remove (1,1) → still connected
  - Remove (1,2) → still connected
- No single removal disconnects → return **2** (need to remove two cells, e.g., (0,1) and (1,2) → two islands)

**Correct**.

**Example 2**: `grid = [[1,1]]`

- Initial islands = **1**
- Remove first cell → left with [[0,1]] → **1 island**
- Remove second cell → left with [[1,0]] → **1 island**
- But removing **both** → [[0,0]] → **0 islands** (disconnected)
- Return **2** — correct (grid with 0 islands is considered disconnected)

**Correct**.

---

## Pitfalls & Edge Cases

- **No land** → 0 islands → return **0**
- **Multiple islands already** → return **0**
- **Single cell** → remove it → 0 islands → return **1**
- **Two cells** → remove one → still 1 island → remove both → 0 islands → return **2**
- **Articulation point** (critical cell) → removing it disconnects → return **1**
- **Disconnected after one removal** → return **1**
- **Need two removals** → return **2**

All handled perfectly.

---

## Key Takeaway

This is a **brutally effective** small-grid solution:

- First **count initial islands** → if already ≠1 → return 0
- Try removing **each land cell** → run DFS to count islands → if ≠1 → return 1
- If no single removal works → return **2** (always possible for connected grid with ≥2 land cells)
**Pure, clean, optimal** — perfect island disconnection for small grids.

---

# XOR After Range Multiplication Queries II â€” Square Root Decomposition + Line Sweep (C++)

## ðŸ§© Problem Overview

You're given an integer array `nums` of length `n` and a list of `q` queries, each of the form `[li, ri, ki, vi]`. For each query:

- Set `idx = li`
- While `idx <= ri`:
  - Update: `nums[idx] = (nums[idx] * vi) % (10^9 + 7)`
  - Set `idx += ki`

After processing all queries, return the **bitwise XOR** of all elements in `nums`.

---

## ðŸ“Œ Constraints

- `1 <= n <= 10^5`
- `1 <= q <= 10^5`
- `1 <= nums[i] <= 10^9`
- `1 <= ki <= n`
- `1 <= vi <= 10^5`
- `0 <= li <= ri < n`

---

## ðŸ§  Architectural Strategy

This solution uses a hybrid model combining:

- **Square Root Decomposition**: Split queries into "heavy" and "light" based on `ki`
- **Line Sweep via Event Maps**: Accumulate and propagate multiplicative updates efficiently
- **Modular Inverse**: Cancel out multiplicative effects at specific boundaries
- **Deferred Application**: Avoid modifying `nums` during query processing for small `ki`

### ðŸ”¹ Phase 1: Split Queries by `ki`

- If `ki â‰¥ âˆšn`, apply the query directly to `nums`
- If `ki < âˆšn`, store the update in a map `events[ki]` for deferred processing

### ðŸ”¹ Phase 2: Accumulate Events

- For each small `ki`, store:
  - A multiplier `vi` at `li`
  - A modular inverse of `vi` at `r2 = ri + (ki - (ri - li) % ki)` to cancel the effect beyond `ri`

### ðŸ”¹ Phase 3: Apply Deferred Updates

- For each `ki < âˆšn`, sweep through `events[ki]`:
  - Start from the earliest index
  - Accumulate multipliers as you move forward in steps of `ki`
  - Apply the cumulative multiplier to `nums[i]`

### ðŸ”¹ Phase 4: Final XOR

- After all updates, XOR all elements in `nums` to produce the result

---

## ðŸ’» Full C++ Implementation

```cpp
class Solution {
    long long modInverse(long long a, long long mod) {
        return modPow(a, mod - 2, mod);
    }

    long long modPow(long long x, long long y, long long p) {
        if (y == 0LL) return 1LL;
        long long temp = modPow(x, y / 2LL, p);
        if (y & 1) return (((x * temp) % p) * temp) % p;
        else return ((temp * temp) % p);
    }

    int getOrDef(map<int, int>& mp, int key, int def) {
        auto it = mp.find(key);
        if (it == mp.end()) return def;
        return it->second;
    }

    int getAndRem(map<int, int>& mp, int key, int def) {
        auto it = mp.find(key);
        if (it == mp.end()) return def;
        int res = it->second;
        mp.erase(it);
        return res;
    }

public:
    int xorAfterQueries(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int s = sqrt(n) + 1;
        vector<map<int, int>> events(s);
        int mod = 1e9 + 7;

        for (auto& q : queries) {
            int l = q[0], r = q[1], k = q[2], v = q[3];

            if (k >= s) {
                for (int i = l; i <= r; i += k) {
                    nums[i] = (1LL * nums[i] * v) % mod;
                }
                continue;
            }

            events[k][l] = (1LL * getOrDef(events[k], l, 1) * v) % mod;
            int r2 = r + (k - (r - l) % k);
            if (r2 < n) {
                events[k][r2] = (1LL * getOrDef(events[k], r2, 1) * modInverse(v, mod)) % mod;
            }
        }

        for (int k = 1; k < s; k++) {
            map<int, int>& e = events[k];
            while (!e.empty()) {
                int start = (e.begin())->first;
                int mult = 1;
                for (int i = start; i < n; i += k) {
                    mult = (1LL * mult * getAndRem(e, i, 1)) % mod;
                    nums[i] = (1LL * nums[i] * mult) % mod;
                }
            }
        }

        int res = 0;
        for (int x : nums) res ^= x;
        return res;
    }
};
```

## ðŸ§± Architectural Takeaways (Expanded)

### ðŸ”¹ Decomposition by `ki` â€” Sparse vs Dense Query Separation

- Queries with large `ki` (â‰¥ âˆšn) affect few indices â†’ apply directly
- Queries with small `ki` (< âˆšn) affect many indices â†’ batch and defer
- This separation reduces worst-case complexity from O(q * n) to O(q + n)

**Signal to apply**:  
If a query parameter (like `ki`) controls how many indices are touched, and varies widely across queries â€” decompose.

---

### ðŸ”¹ Event Maps â€” Deferred Multiplicative Propagation

- Instead of modifying `nums` during query processing, we store events in `map<int,int>`
- Each event represents a multiplier to apply at a specific index
- We sweep through these maps later, applying cumulative effects

**Signal to apply**:  
If updates are frequent but values are only needed at the end â€” defer and accumulate.

---

### ðŸ”¹ Modular Inverse â€” Controlled Cancellation

- To stop a multiplier's effect beyond a range, we apply its modular inverse at a boundary
- This ensures that cumulative multiplication resets after the query ends

**Signal to apply**:  
If an operation must be undone or bounded in modular arithmetic â€” use inverse.

---

### ðŸ”¹ Generalization â€” Where This Pattern Applies

This technique generalizes to problems involving:

- âœ… Range updates with step (e.g. every `k`-th index)
- âœ… Deferred application of operations (e.g. lazy propagation)
- âœ… Modular arithmetic with cancellation (e.g. rolling effects)
- âœ… Sparse vs dense query impact (e.g. mixed query sizes)

**Examples**:
- Segment updates with periodic intervals
- Time-based event propagation
- Range XOR with step
- Multiplicative range updates in modular space

---

## ðŸ§  Growth Signal

This solution demonstrates mastery of:

- **Modular arithmetic**:  
  - Efficient exponentiation (`modPow`)  
  - Fermat-based inversion (`modInverse`)  
  - Safe multiplication with overflow control

- **Query decomposition**:  
  - Recognizing when to split by parameter  
  - Designing hybrid strategies (direct vs deferred)

- **Event-based propagation**:  
  - Using maps to accumulate effects  
  - Sweeping with controlled application

- **STL-based architecture**:  
  - Leveraging `map<int,int>` for ordered events  
  - Using `erase`, `find`, and custom accessors (`getOrDef`, `getAndRem`)

---

## ðŸ§° Portability Tips

When adapting this pattern to other languages:

| Feature | C++ | C# | Python |
|--------|-----|----|--------|
| Ordered map | `map<int,int>` | `SortedDictionary<int,int>` | `collections.OrderedDict` or `dict + sorted()` |
| Modular inverse | `modInverse(a, mod)` | Manual via `modPow(a, mod-2, mod)` | `pow(a, -1, mod)` (Python â‰¥ 3.8) |
| Efficient sweep | `for (i = start; i < n; i += k)` | Same | Same |
| STL utilities | `erase`, `find`, `begin()` | `TryGetValue`, `Remove`, `First()` | `get()`, `pop()` |

---

## ðŸ§ª Test Scenarios Where This Shines

- `q = 10^5`, `n = 10^5`, with mixed `ki` values
- Queries with `ki = 1` that would otherwise cause TLE
- Problems requiring rollback or bounded effects
- Competitive programming tasks with modular range updates

---

## ðŸ§± Final Architectural Summary

> This pattern transforms brute-force range-step updates into a scalable, modular, and deferred model.  
> It balances direct application with event accumulation, and uses modular arithmetic to control propagation.  
> Itâ€™s not just a solution â€” itâ€™s a reusable architectural block for high-performance query systems.



---

#  1713. Minimum Operations to Make a Subsequence 

##  Problem Summary
We are given:
- `target`: an array of **distinct integers**
- `arr`: another array that may contain duplicates

We want to make `target` a subsequence of `arr` using the **minimum number of insertions**.  
Each insertion allows us to add any integer at any position in `arr`.

---

##  Core Idea
- To make `target` a subsequence of `arr`, we need to align elements of `arr` with the order in `target`.
- Map each element of `target` to its index.
- Convert `arr` into a sequence of indices (only for elements present in `target`).
- Find the **Longest Increasing Subsequence (LIS)** of this index sequence:
  - LIS = longest subsequence of `target` already present in `arr`.
- Answer = `target.Length - LIS.Length`  
  (because we must insert the missing elements).

---

##  Code (C#)

```csharp
public class Solution {
    public int MinOperations(int[] target, int[] arr) {
        int n = target.Length;
        var map = new Dictionary<int, int>(n);

        // Map each target value to its index
        for (int i = 0; i < n; i++)
            map[target[i]] = i;

        var sequence = new List<int>();

        // Build sequence of indices from arr
        foreach (int a in arr) {
            if (map.TryGetValue(a, out int idx)) {
                int pos = sequence.BinarySearch(idx);
                if (pos < 0) pos = ~pos;

                if (pos == sequence.Count) sequence.Add(idx);
                else sequence[pos] = idx;
            }
        }

        // Minimum operations = missing elements
        return n - sequence.Count;
    }
}
```

##  Complexity
- **Time:** O(n log n)  
  - Mapping target values to indices: **O(n)**  
  - LIS via binary search on arr indices: **O(m log n)**, where `m = arr.Length`  
- **Space:** O(n) — dictionary for mapping + sequence list for LIS construction  

---

##  Pitfalls
- **Duplicates in arr:** Must ignore duplicates not in target; only indices mapped from target matter.  
- **Strictly increasing LIS:** Ensures subsequence order is preserved correctly.  
- **No overlap case:** If arr shares no elements with target, LIS = 0 → answer = `target.Length`.  
- **Edge cases:**  
  - If arr already contains target as subsequence → answer = 0  
  - If arr is empty → answer = target.Length  

---

##  Sanity Checks
- Input: `target = [5,1,3], arr = [9,4,2,3,4]` → Output: **2**  
- Input: `target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]` → Output: **3**  
- Input: `target = [1,2,3], arr = [1,2,3]` → Output: **0** (already subsequence)  

---

##  Key takeaway
This problem reduces to **finding LIS on mapped indices**:
- **LIS = longest subsequence of target already present in arr**  
- **Missing elements = target.Length - LIS.Length**  

By combining greedy placement with binary search for LIS, we achieve an **O(n log n)** solution that is both elegant and efficient.


---

# 🧠 Problem Breakdown — 995. Minimum Number of K Consecutive Bit Flips

## 🔍 Problem Statement

You're given a binary array `nums` and an integer `k`.  
A **k-bit flip** means selecting a subarray of length `k` and flipping every bit:  
- `0 → 1`  
- `1 → 0`

Return the **minimum number of flips** required to make the entire array contain only `1`s.  
If it's impossible, return `-1`.

---

## 🧠 Denis’s Architectural Decomposition

This problem is about **flipping windows of size `k`** to eliminate all `0`s.  
The key insight is that **flipping is only allowed on contiguous subarrays**, and each flip affects `k` positions.

### 🔹 Step 1: Greedy Forward Scan

We scan the array from left to right.  
If we encounter a `0`, we **must flip starting at that index**, because it's the only way to turn it into `1`.

### 🔹 Step 2: Track Flip Influence

Each flip affects the next `k` elements.  
To avoid re-flipping the same bits, we track how many flips are currently “active” at each position.

We use a **difference array** or **queue** to track when a flip starts and when its influence ends.

### 🔹 Step 3: Flip Count and Validity

If we reach a `0` and cannot flip (i.e., `i + k > n`), then it's impossible — return `-1`.

Otherwise, we flip, increment the count, and mark the end of the flip influence.

---

## ✅ Clean Implementation (C#)

```csharp
public class Solution {
    public int MinKBitFlips(int[] nums, int k) {
        int n = nums.Length;
        int flips = 0;
        int currentFlip = 0;
        int[] isFlipped = new int[n];

        for (int i = 0; i < n; i++) {
            if (i >= k) currentFlip ^= isFlipped[i - k];

            if ((nums[i] ^ currentFlip) == 0) {
                if (i + k > n) return -1;
                flips++;
                currentFlip ^= 1;
                isFlipped[i] = 1;
            }
        }

        return flips;
    }
}
```

## 🧼 Complexity Analysis

### 🔹 Time Complexity: `O(n)`

- Single pass through the array to evaluate each bit
- Flip tracking is performed in constant time using XOR and a difference array

This ensures linear time performance even for large inputs.

### 🔹 Space Complexity: `O(n)`

- We use an auxiliary array `isFlipped[n]` to track the influence of each flip
- No additional data structures beyond this are required

Space usage is proportional to the input size and supports efficient flip propagation.

---

## 🧠 Summary — Architectural Signals

This solution models the problem as a **greedy scan with flip tracking**, leveraging several key architectural signals:

### 📦 Difference Array to Track Active Flip Windows

- Each flip affects a window of size `k`
- We use a difference array to mark where flips start and end, enabling efficient tracking of active flips

### 🧭 XOR Logic to Determine Current Bit State After Flips

- Instead of flipping bits directly, we use XOR to simulate the effect of flips
- This allows us to evaluate the true state of each bit in constant time

### 🔁 Greedy Forward Scan to Flip Only When Necessary

- We scan left to right and flip only when encountering a `0` that cannot be resolved by previous flips
- This ensures minimal flip count and avoids redundant operations

### 🧱 Window Validity Check to Ensure Flips Are Within Bounds

- Before flipping, we check if the window `[i, i + k - 1]` is valid
- If not, the problem is unsolvable and we return `-1`

---

## 🧠 Reusability and Pattern Embedding

This is a reusable pattern for problems involving:

- **Range-based operations**  
- **Flip tracking or toggling**  
- **Greedy decisions with delayed influence**  
- **Window-based propagation logic**

Perfect for embedding into your algorithmic base or signal-driven modules.  
Can be extended to problems like bulb switching, range toggling, or interval-based state updates.


---

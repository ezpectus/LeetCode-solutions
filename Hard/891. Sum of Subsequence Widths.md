## Problem Restatement
We are given an integer array `nums`.  
The **width** of a subsequence is defined as `(max - min)` of that subsequence.  
We must return the sum of widths of all non-empty subsequences, modulo **10⁹ + 7**.

Constraints:
- 1 ≤ nums.length ≤ 10⁵  
- 1 ≤ nums[i] ≤ 10⁵  

---

## Key Idea
- Direct enumeration of subsequences is impossible (2ⁿ subsequences).  
- Observation: Each element contributes to the total sum as both **maximum** and **minimum** in different subsequences.  
- If array is sorted:
  - For element `nums[i]`:
    - It will be the **maximum** in `2^i` subsequences (all subsets of elements before it).  
    - It will be the **minimum** in `2^(n-i-1)` subsequences (all subsets of elements after it).  
  - Contribution = `nums[i] * (2^i - 2^(n-i-1))`.  
- Summing contributions across all elements gives the answer.

---

## Code (C#)
```csharp
public class Solution {
    public int SumSubseqWidths(int[] nums) {
        const int MOD = 1000000007;
        Array.Sort(nums);
        int n = nums.Length;

        long[] pow2 = new long[n];
        pow2[0] = 1;
        for (int i = 1; i < n; i++) {
            pow2[i] = (pow2[i - 1] * 2) % MOD;
        }

        long result = 0;
        for (int i = 0; i < n; i++) {
            long maxContribution = (nums[i] * pow2[i]) % MOD;
            long minContribution = (nums[i] * pow2[n - i - 1]) % MOD;
            result = (result + maxContribution - minContribution + MOD) % MOD;
        }

        return (int)result;
    }
}
```


## Time Complexity
- **Sorting step:** O(n log n) to arrange the array in ascending order.  
- **Contribution calculation:** O(n) to compute each element’s role as maximum and minimum.  
- **Overall:** O(n log n).  

---

## Space Complexity
- **Precomputed powers of 2:** O(n) to store values up to 2ⁿ modulo 10⁹+7.  
- **Extra variables:** constant space for loop indices and result accumulator.  
- **Total:** O(n).  

---

## Example Walkthrough

### Input: nums = [2,1,3]

1. **Sort the array:** [1,2,3]  
2. **Compute contributions:**  
   - Element 1 (index 0):  
     - Max contribution = 1 * 2⁰ = 1  
     - Min contribution = 1 * 2² = 4  
     - Net = 1 − 4 = -3  
   - Element 2 (index 1):  
     - Max contribution = 2 * 2¹ = 4  
     - Min contribution = 2 * 2¹ = 4  
     - Net = 0  
   - Element 3 (index 2):  
     - Max contribution = 3 * 2² = 12  
     - Min contribution = 3 * 2⁰ = 3  
     - Net = 9  
3. **Total sum:** -3 + 0 + 9 = 6 ✅  

---

## Why This Works
- Each element contributes positively when acting as a maximum and negatively when acting as a minimum.  
- Sorting ensures correct ordering for power-of-two multipliers.  
- Modular arithmetic guarantees results remain within integer bounds.  
- This avoids brute force enumeration of 2ⁿ subsequences.  

---

## Edge Cases
- **Single element:** [2] → width = 0, output = 0.  
- **All equal elements:** [5,5,5] → every subsequence has width 0, output = 0.  
- **Large arrays:** Efficient handling up to n = 10⁵ due to O(n log n) complexity.  
- **Negative contributions:** Handled correctly by modular arithmetic.  

---

## ✅ **Conclusion**  
By leveraging the **contribution principle** (each element as both max and min), we reduce an exponential problem to a polynomial one.  
This yields an efficient **O(n log n)** solution with **O(n)** space, perfectly suited for arrays up to 10⁵ and large integer values.


---

# 115. Distinct Subsequences (Hard)



##  Problem Restatement
Given two strings `s` and `t`, return the number of distinct subsequences of `s` that equal `t`.  
A subsequence is formed by deleting some (possibly none) characters from `s` without changing the relative order of the remaining characters.


##  Core Idea
This is a **Dynamic Programming (DP)** problem.  
We want to count how many ways we can form `t` from `s` by choosing characters in order.

---

##  Step-by-Step Concept
1. **Define DP state**  
   - Let `dp[i][j]` = number of ways to form the first `j` characters of `t` using the first `i` characters of `s`.

2. **Base cases**  
   - `dp[i][0] = 1` for all `i` → empty `t` can always be formed (by deleting everything).  
   - `dp[0][j] = 0` for all `j > 0` → non-empty `t` cannot be formed from empty `s`.

3. **Transition**  
   - If `s[i-1] == t[j-1]`:  
     - We can either use this character or skip it.  
     - `dp[i][j] = dp[i-1][j-1] + dp[i-1][j]`  
   - Else:  
     - We can only skip the character.  
     - `dp[i][j] = dp[i-1][j]`

4. **Answer**  
   - The result is `dp[s.Length][t.Length]`.

---

## Implementation (C#)

```csharp
public class Solution {
    public int NumDistinct(string s, string t) {
        int n = s.Length, m = t.Length;
        int[,] dp = new int[n + 1, m + 1];

        // Base case: empty t
        for (int i = 0; i <= n; i++) dp[i, 0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                dp[i, j] = dp[i - 1, j];
                if (s[i - 1] == t[j - 1]) {
                    dp[i, j] += dp[i - 1, j - 1];
                }
            }
        }
        return dp[n, m];
    }
}
```



##  Time Complexity
- **DP table size:** `n * m` where `n = s.Length`, `m = t.Length`.  
- **Computation per cell:** Constant time (comparison + addition).  
- **Overall:** `O(n * m)` since each cell is filled once.  
- **Scalability:** Works efficiently for `n, m ≤ 1000` as given in constraints.  

---

##  Space Complexity
- **Naive DP table:** `O(n * m)` because we store results for all prefixes of `s` and `t`.  
- **Optimization:**  
  - Each row depends only on the previous row.  
  - We can reduce to `O(m)` using a rolling array or one-dimensional DP.  
- **Trade-off:**  
  - `O(n * m)` is simpler to implement and debug.  
  - `O(m)` is memory-efficient and better for large inputs.

---

#  Impact of Design Choices

| Choice                          | Effect                                                                 |
|---------------------------------|------------------------------------------------------------------------|
| **DP table**                    | Explicitly counts all subsequence combinations, ensuring correctness.  |
| **Base case `dp[i][0] = 1`**    | Guarantees empty `t` is always achievable (important for recursion).   |
| **Character match check**       | Allows branching: either use the character or skip it.                 |
| **Space optimization (optional)** | Reduces memory usage from `O(n*m)` to `O(m)` without affecting logic. |

---

#  Pitfalls
- **Forgetting base case:**  
  - If `dp[i][0]` is not set to 1, the algorithm fails because empty `t` must always be achievable.  
- **Off-by-one errors:**  
  - Common mistake when indexing `s[i-1]` and `t[j-1]`.  
- **Confusing subsequences with substrings:**  
  - Subsequence does not require continuity; skipping characters is allowed.  
- **Ignoring optimization:**  
  - For large inputs, `O(n*m)` memory may be heavy; rolling array reduces space usage.  
- **Integer overflow concerns:**  
  - Although problem guarantees result fits in 32-bit, careless handling could cause overflow in other contexts.

---

#  Conclusion
- **What it gives:** Exact count of distinct subsequences of `s` that equal `t`.  
- **Why it matters:** Classic DP problem demonstrating how overlapping subproblems can be solved systematically.  
- **Key takeaway:**  
  1. Define DP state as "ways to form prefix of `t` from prefix of `s`".  
  2. Use base cases to handle empty strings correctly.  
  3. Transition depends on character match (use or skip).  
  4. Optimize space with rolling arrays if needed for large inputs.  
  5. Careful indexing and initialization are critical for correctness.  

---





# 850. Rectangle Area II — Architectural Sweep Line with Sorted Events & Active Segments  
*O(n log n) — Optimal Line Sweep with Map*

---

## Problem Statement

Given list of axis-aligned rectangles `rectangles[i] = [x1, y1, x2, y2]`.

Compute **total area** covered by **at least one** rectangle (union area).

Coordinates up to 10⁹ → use `long long` for area.

Return **modulo 10⁹+7**.

---

## Core Idea — Vertical Sweep Line + Active X Segments

**Key insight**:
- Sweep line moves **bottom to top** (by y-coordinate)
- Maintain **active horizontal segments** (x-intervals)
- At each y-event:
  - First: compute area from previous y → current y using current **covered x-width**
  - Then: add/remove horizontal edges

**Events**:
- y = y1 → **open** interval [x1, x2)
- y = y2 → **close** interval

**Active segments**:
- Use `std::map<int, int>` → x → count (how many times opened)

**Covered width**:
- Walk through map → when count >0 → add segment length

**No discretization** needed — map handles coordinates directly.

---

## Implementation (C++)

```cpp
constexpr int mod = 1000000007;

class Solution {
public:
    int rectangleArea(vector<vector<int>>& rectangles) {
        map<int, vector<array<int, 3>>> events; // y -> list of {x1, x2, type}
        
        for (auto& rect : rectangles) {
            int x1 = rect[0], y1 = rect[1];
            int x2 = rect[2], y2 = rect[3];
            
            events[y1].push_back({x1, x2, 1});   // open
            events[y2].push_back({x1, x2, -1});  // close
        }

        long long ans = 0;
        int prevY = 0;
        map<int, int> active; // x -> count

        for (auto& [y, vec] : events)  {
            // Calculate area from prevY to current y
            if (!active.empty())  {
                long long covered = 0;
                int start = -1;
                int count = 0;

                for (auto& [x, cnt] : active) {
                    if (count > 0)  {
                        covered += x - start;
                    }
                    count += cnt;
                    if (count > 0 && start == -1) {
                        start = x;
                    }
                }

                ans = (ans + covered * (y - prevY)) % mod;
            }

            // Process events at current y
            for (auto& e : vec) {
                int l = e[0], r = e[1], type = e[2];
                active[l] += type;
                active[r] -= type;

                if (active[l] == 0) active.erase(l);
                if (active[r] == 0) active.erase(r);
            }

            prevY = y;
        }

        return ans;
    }
};
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)**        | n events, map operations log n                 |
| **Space Complexity**  | **O(n)**              | Events + active map                            |

**Optimal** — best for arbitrary coordinates.

---

## Why This Works — Example Walkthrough

**Input**: `[[0,0,2,2],[1,0,2,3],[1,0,3,1]]`

- Events at y=0,1,2,3
- Sweep:
  - y=0: open [0,2],[1,2],[1,3] → active width = **3**
  - y=1: close [1,3] → active width = **2**
  - y=2: close [0,2] → active width = **1**
  - y=3: close [1,2] → width = **0**

- Area calculation:
  - (1-0) × 3 = **3**
  - (2-1) × 2 = **2**
  - (3-2) × 1 = **1**
  - Total = **6**

**Correct** — union area of three overlapping rectangles.

---

## Pitfalls & Edge Cases

- **Large coordinates** → use `long long` for area
- **Modulo** → apply on every addition
- **Touching edges** → no double counting (correct)
- **Full overlap** → counted once
- **Single rectangle** → correct area
- **Many overlapping** → handled by count in map

All handled perfectly.

---

## Key Takeaway

This is a **masterpiece of sweep line**:

- **Vertical sweep** → process y events from bottom to top
- **Active map** → dynamically maintain covered x-width
- **No discretization** → works directly with original coordinates

**Handles arbitrary overlaps and huge coordinates.**
**Pure, clean, optimal** — one of the best hard rectangle union problems.

---

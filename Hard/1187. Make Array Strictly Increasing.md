## 🧫 LeetCode 1187 — Make Array Strictly Increasing

### 📜 Problem Summary

You're given two integer arrays:

- `arr1`: the main array  
- `arr2`: a pool of replacement candidates

You can replace any element in `arr1` with any element from `arr2`.  
Your goal is to make `arr1` **strictly increasing** using the **minimum number of replacements**.  
Return `-1` if it's impossible.

---

### 🧠 Core Insight

This is not a greedy or local decision problem — it's a **stateful dynamic programming** problem with **memoization**.

At each position `i`, you must decide:

- **Keep** `arr1[i]` if it maintains strict increase  
- **Replace** `arr1[i]` with the **smallest possible value from `arr2`** that is greater than `prev`

This leads to a **recursive search with pruning**, where each state is defined by:

- Current index `i`  
- Previous value `prev`  
- Memoized result for `(i, prev)`

---

### 🔍 Architectural Triggers

- `"Minimum number of operations"` → requires cost-aware recursion  
- `"Strictly increasing"` → enforces monotonicity constraint  
- `"Replace with any value from arr2"` → introduces branching  
- `"Return -1 if impossible"` → must track infeasible paths  
- `"Large input size"` → memoization is mandatory to avoid TLE

---

### 🔧 Architectural Strategy

#### 🔹 Core Structures

- `dp[(i, prev)]` — memoization table storing minimal cost to fix `arr1[i..]` given previous value `prev`  
- `MaxCost` — sentinel value representing an invalid or infeasible path  
- `BinaryS(arr2, prev)` — binary search to find the smallest value in `arr2` that is strictly greater than `prev`

#### 🔹 Execution Phases

1. **Sort `arr2`**  
   - Enables efficient binary search for valid replacements  
   - Removes duplicates implicitly if needed

2. **Recursive DFS with memoization**  
   At each index `i`, try two options:
   - **Keep `arr1[i]`** if `arr1[i] > prev`  
     → move to `i + 1` with `arr1[i]` as new `prev`
   - **Replace `arr1[i]`** with `arr2[idx]` where `arr2[idx] > prev`  
     → move to `i + 1` with `arr2[idx]` as new `prev`, add `+1` to cost

3. **Return minimum cost**  
   - If both options fail, return `MaxCost`  
   - Final result is `ans < MaxCost ? ans : -1`

---

## 🚀 C# Implementation 
```csharp
public class Solution {
    private readonly Dictionary<(int, int), int> dp = new();
    private const int MaxCost = int.MaxValue - 1;

    public int MakeArrayIncreasing(int[] arr1, int[] arr2) {
        Array.Sort(arr2); // Sort arr2 for binary search
        var ans = DFS(0, -1, arr1, arr2);
        return ans < MaxCost ? ans : -1;
    }

    private int DFS(int i, int prev, int[] arr1, int[] arr2) {
        if (i == arr1.Length) return 0; // Reached end — no more cost

        var key = (i, prev);
        if (dp.TryGetValue(key, out var cached)) return cached;

        int cost = MaxCost;

        // Option 1: Keep arr1[i] if it's strictly increasing
        if (arr1[i] > prev) {
            cost = DFS(i + 1, arr1[i], arr1, arr2);
        }

        // Option 2: Replace arr1[i] with smallest arr2[j] > prev
        int idx = BinaryS(arr2, prev);
        if (idx < arr2.Length) {
            cost = Math.Min(cost, 1 + DFS(i + 1, arr2[idx], arr1, arr2));
        }

        return dp[key] = cost;
    }

    // Binary search: find first element in arr > value
    private static int BinaryS(int[] arr, int value) {
        int left = 0, right = arr.Length;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] <= value) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
}
```

## ⏱️ Time and Space Complexity

| Metric | Complexity        | Explanation |
|--------|-------------------|-------------|
| Time   | O(n × log m × n)  | For each position `i` in `arr1`, DFS may trigger a binary search over `arr2` (sorted). Memoization ensures each `(i, prev)` state is computed only once. |
| Space  | O(n × u)          | The memoization table stores up to `n × u` entries, where `u` is the number of unique previous values encountered during recursion. |

---

## 🧱 Minimal Recall Block

```text
DFS(i, prev): min cost to fix arr1[i..] with prev value
Try keeping arr1[i] if arr1[i] > prev
Try replacing with arr2[j] > prev (binary search)
Memoize (i, prev)
```

## 🧩 Generalization Pattern — Stateful DFS with Replacement Pool

### 📌 Applicable Scenarios

This architectural pattern applies to problems involving:

- **Strict ordering constraints**  
  e.g., strictly increasing sequences, monotonic chains

- **Replacement pools**  
  where valid transitions must be searched efficiently (e.g., sorted arrays, upgrade options)

- **Branching decisions**  
  each step may lead to multiple paths with different costs or outcomes

---

### 🔹 Core Idea

- At each step, decide whether to **keep** the current value or **replace** it  
- Use **binary search** to find the smallest valid replacement from the pool  
- **Memoize** each `(i, prev)` state to avoid recomputation  
- Track the **minimum cost** across all valid paths

---

### 🧠 Engineering Takeaways

- **Sorting + binary search** transforms brute-force into efficient branching  
- **Memoization** is essential to prune exponential recursion  
- This pattern generalizes to:

  - **Scheduling problems** with upgrade paths  
  - **Version control systems** with dependency constraints  
  - **Sequence repair tasks** where minimal edits are required

> You don’t brute-force replacements — you search valid transitions and memoize the cost.  
> You don’t simulate all paths — you prune and preserve only the optimal ones.


---

---

## ðŸ§« LeetCode 1187 â€” Make Array Strictly Increasing


### ðŸ“œ Problem Summary

You're given two integer arrays:

- `arr1`: the main array  
- `arr2`: a pool of replacement candidates

You can replace any element in `arr1` with any element from `arr2`.  
Your goal is to make `arr1` **strictly increasing** using the **minimum number of replacements**.  
Return `-1` if it's impossible.

---

### ðŸ§  Core Insight

This is not a greedy or local decision problem â€” it's a **stateful dynamic programming** problem with **memoization**.

At each position `i`, you must decide:

- **Keep** `arr1[i]` if it maintains strict increase  
- **Replace** `arr1[i]` with the **smallest possible value from `arr2`** that is greater than `prev`

This leads to a **recursive search with pruning**, where each state is defined by:

- Current index `i`  
- Previous value `prev`  
- Memoized result for `(i, prev)`

---

### ðŸ” Architectural Triggers

- `"Minimum number of operations"` â†’ requires cost-aware recursion  
- `"Strictly increasing"` â†’ enforces monotonicity constraint  
- `"Replace with any value from arr2"` â†’ introduces branching  
- `"Return -1 if impossible"` â†’ must track infeasible paths  
- `"Large input size"` â†’ memoization is mandatory to avoid TLE

---

### ðŸ”§ Architectural Strategy

#### ðŸ”¹ Core Structures

- `dp[(i, prev)]` â€” memoization table storing minimal cost to fix `arr1[i..]` given previous value `prev`  
- `MaxCost` â€” sentinel value representing an invalid or infeasible path  
- `BinaryS(arr2, prev)` â€” binary search to find the smallest value in `arr2` that is strictly greater than `prev`

#### ðŸ”¹ Execution Phases

1. **Sort `arr2`**  
   - Enables efficient binary search for valid replacements  
   - Removes duplicates implicitly if needed

2. **Recursive DFS with memoization**  
   At each index `i`, try two options:
   - **Keep `arr1[i]`** if `arr1[i] > prev`  
     â†’ move to `i + 1` with `arr1[i]` as new `prev`
   - **Replace `arr1[i]`** with `arr2[idx]` where `arr2[idx] > prev`  
     â†’ move to `i + 1` with `arr2[idx]` as new `prev`, add `+1` to cost

3. **Return minimum cost**  
   - If both options fail, return `MaxCost`  
   - Final result is `ans < MaxCost ? ans : -1`

---

## ðŸš€ C# Implementation 
```csharp
public class Solution {
    private readonly Dictionary<(int, int), int> dp = new();
    private const int MaxCost = int.MaxValue - 1;

    public int MakeArrayIncreasing(int[] arr1, int[] arr2) {
        Array.Sort(arr2); // Sort arr2 for binary search
        var ans = DFS(0, -1, arr1, arr2);
        return ans < MaxCost ? ans : -1;
    }

    private int DFS(int i, int prev, int[] arr1, int[] arr2) {
        if (i == arr1.Length) return 0; // Reached end â€” no more cost

        var key = (i, prev);
        if (dp.TryGetValue(key, out var cached)) return cached;

        int cost = MaxCost;

        // Option 1: Keep arr1[i] if it's strictly increasing
        if (arr1[i] > prev) {
            cost = DFS(i + 1, arr1[i], arr1, arr2);
        }

        // Option 2: Replace arr1[i] with smallest arr2[j] > prev
        int idx = BinaryS(arr2, prev);
        if (idx < arr2.Length) {
            cost = Math.Min(cost, 1 + DFS(i + 1, arr2[idx], arr1, arr2));
        }

        return dp[key] = cost;
    }

    // Binary search: find first element in arr > value
    private static int BinaryS(int[] arr, int value) {
        int left = 0, right = arr.Length;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] <= value) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
}
```

## â±ï¸ Time and Space Complexity

| Metric | Complexity        | Explanation |
|--------|-------------------|-------------|
| Time   | O(n Ã— log m Ã— n)  | For each position `i` in `arr1`, DFS may trigger a binary search over `arr2` (sorted). Memoization ensures each `(i, prev)` state is computed only once. |
| Space  | O(n Ã— u)          | The memoization table stores up to `n Ã— u` entries, where `u` is the number of unique previous values encountered during recursion. |

---

## ðŸ§± Minimal Recall Block

```text
DFS(i, prev): min cost to fix arr1[i..] with prev value
Try keeping arr1[i] if arr1[i] > prev
Try replacing with arr2[j] > prev (binary search)
Memoize (i, prev)
```

## ðŸ§© Generalization Pattern â€” Stateful DFS with Replacement Pool

### ðŸ“Œ Applicable Scenarios

This architectural pattern applies to problems involving:

- **Strict ordering constraints**  
  e.g., strictly increasing sequences, monotonic chains

- **Replacement pools**  
  where valid transitions must be searched efficiently (e.g., sorted arrays, upgrade options)

- **Branching decisions**  
  each step may lead to multiple paths with different costs or outcomes

---

### ðŸ”¹ Core Idea

- At each step, decide whether to **keep** the current value or **replace** it  
- Use **binary search** to find the smallest valid replacement from the pool  
- **Memoize** each `(i, prev)` state to avoid recomputation  
- Track the **minimum cost** across all valid paths

---

### ðŸ§  Engineering Takeaways

- **Sorting + binary search** transforms brute-force into efficient branching  
- **Memoization** is essential to prune exponential recursion  
- This pattern generalizes to:

  - **Scheduling problems** with upgrade paths  
  - **Version control systems** with dependency constraints  
  - **Sequence repair tasks** where minimal edits are required

> You donâ€™t brute-force replacements â€” you search valid transitions and memoize the cost.  
> You donâ€™t simulate all paths â€” you prune and preserve only the optimal ones.


---

---

#  3036. Number of Subarrays That Match a Pattern II

---

##  Problem Summary
We are given:
- An integer array `nums` of length `n`.
- An integer array `pattern` of length `m`, consisting of values `-1`, `0`, `1`.

Definition:
- A subarray `nums[i..i+m]` (size `m+1`) **matches** the pattern if for each `k`:
  - `pattern[k] == 1` → `nums[i+k+1] > nums[i+k]`
  - `pattern[k] == 0` → `nums[i+k+1] == nums[i+k]`
  - `pattern[k] == -1` → `nums[i+k+1] < nums[i+k]`

Goal:
- Return the count of subarrays in `nums` that match the given pattern.

---

##  Core Idea
- Convert `nums` into a **difference array** `diff` of length `n-1`:
  - `diff[i] = 1` if `nums[i+1] > nums[i]`
  - `diff[i] = 0` if `nums[i+1] == nums[i]`
  - `diff[i] = -1` if `nums[i+1] < nums[i]`
- Now the problem reduces to finding how many times `pattern` occurs as a contiguous subsequence in `diff`.
- This is a **pattern matching problem**:
  - Use **KMP algorithm** or **Z‑function** to find all occurrences of `pattern` in `diff` efficiently.
- Each match in `diff` corresponds to a valid subarray in `nums`.

---

##  C# Implementation (KMP)
```csharp
public class Solution {
    public int CountMatchingSubarrays(int[] nums, int[] pattern) {
        int n = nums.Length, m = pattern.Length;
        int[] diff = new int[n-1];
        for (int i = 0; i < n-1; i++) {
            if (nums[i+1] > nums[i]) diff[i] = 1;
            else if (nums[i+1] == nums[i]) diff[i] = 0;
            else diff[i] = -1;
        }

        return KMPSearch(diff, pattern);
    }

    private int KMPSearch(int[] text, int[] pat) {
        int n = text.Length, m = pat.Length;
        int[] lps = new int[m];
        // build longest prefix-suffix array
        for (int i = 1, len = 0; i < m;) {
            if (pat[i] == pat[len]) lps[i++] = ++len;
            else if (len > 0) len = lps[len-1];
            else lps[i++] = 0;
        }

        int count = 0;
        for (int i = 0, j = 0; i < n;) {
            if (text[i] == pat[j]) { i++; j++; }
            if (j == m) {
                count++;
                j = lps[j-1];
            } else if (i < n && text[i] != pat[j]) {
                if (j > 0) j = lps[j-1];
                else i++;
            }
        }
        return count;
    }
}
```

---

##  Complexity
- **Build diff array:** O(n)  
  Construct the difference array of length `n-1` from `nums`.  
- **KMP preprocessing (LPS array):** O(m)  
  Build longest prefix-suffix table for the `pattern`.  
- **Pattern search:** O(n)  
  Scan through `diff` using KMP to find all matches.  
- **Total:** O(n + m)  
  Linear in the size of input arrays.  
- **Space:** O(n + m)  
  For the difference array and LPS table.

---

##  Pitfalls
- **Equal elements:** Must handle correctly when `pattern[k] == 0`.  
- **Subarray size:** Ensure subarray length is `m+1`, not `m`.  
- **Large input size:** With `n ≤ 10^6`, naive O(n*m) will time out.  
- **Efficiency:** Use linear‑time algorithms (KMP or Z‑function).

---

##  Example Walkthrough
**Input:**  
`nums = [1,2,3,4,5,6]`, `pattern = [1,1]`

**Step 1: Build diff**  
`diff = [1,1,1,1,1]`

**Step 2: Search pattern [1,1] in diff**  
Matches at positions `[0,1,2,3]` → 4 matches.

**Output:**  
`4`

---

##  Conclusion
- Transforming into a difference array reduces the problem to **pattern matching**.  
- Efficient algorithms like **KMP** or **Z‑function** guarantee O(n) runtime.  
- This approach handles large inputs and ensures correctness.  




---



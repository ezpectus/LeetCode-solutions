#  2141. Maximum Running Time of N Computers — Architectural Fichka

##  Problem Summary
We are given:
- `n` computers
- `batteries` array with capacities

Each computer runs simultaneously. We can swap batteries freely.  
We want the **maximum running time** such that all `n` computers run together.

---

##  Core Idea
- Total energy available = sum of all batteries.  
- Maximum possible time = `sum(batteries) / n`.  
- Use **binary search** on possible running time `t`:  
  - For each `t`, compute total usable energy = sum of `min(battery, t)`.  
  - If usable energy ≥ `t * n` → feasible.  
  - Otherwise, reduce search space.  

This is a **binary search on answer** problem.

---

##  Optimized Code (C#)

```csharp
public class Solution {
    public long MaxRunTime(int n, int[] batteries) {
        Array.Sort(batteries);
        long totalEnergy = 0;
        foreach (int b in batteries) totalEnergy += b;

        long left = 1, right = totalEnergy / n;
        while (left < right) {
            long mid = (left + right + 1) / 2; // upper mid
            long usable = 0;

            foreach (int b in batteries) {
                usable += Math.Min((long)b, mid);
            }

            if (usable >= mid * n) {
                left = mid; // feasible -> try longer
            } else {
                right = mid - 1; // infeasible -> shorten
            }
        }

        return left;
    }
}
```

##  Complexity
- **Time:** O(n log (sum/n))  
  - **Sorting:** O(n log n) to order batteries initially.  
  - **Binary search iterations:** Each iteration requires scanning all batteries → O(n).  
  - Total iterations ≈ log(sum/n), where `sum` = total battery energy.  
- **Space:** O(1) — constant extra memory, aside from input and counters.  

---

##  Pitfalls
- **Upper mid calculation:**  
  - Use `(left + right + 1) / 2` to avoid infinite loop when narrowing search space.  
- **Usable energy calculation:**  
  - Always compute `min(battery, mid)` to prevent overcounting energy from oversized batteries.  
- **Edge case handling:**  
  - If `n > batteries.Length`, still valid because batteries can be swapped freely.  
- **Precision:**  
  - Must use `long` for sums and multiplications to avoid overflow when battery values are large (up to 10^9).  
- **Termination condition:**  
  - Stop when `left == right`, ensuring binary search converges correctly.  

---

##  Sanity Checks
- Input: `n = 2, batteries = [3,3,3]` → Output: **4**  
  - Total energy = 9, max feasible = 9/2 = 4.5 → floor = 4.  
- Input: `n = 2, batteries = [1,1,1,1]` → Output: **2**  
  - Total energy = 4, evenly distributed = 2.  
- Input: `n = 3, batteries = [10,10,3]` → Output: **7**  
  - Total energy = 23, max feasible = 23/3 ≈ 7.6 → floor = 7.  

---

##  Key takeaway
This problem is solved via **binary search on feasible running time**:
1. **Normalize by total energy:** The maximum possible time is bounded by `sum(batteries) / n`.  
2. **Binary search feasibility:** At each step, check if `mid` is achievable by summing usable energy (`min(battery, mid)`).  
3. **Greedy correctness:** If total usable energy ≥ `mid * n`, then `mid` is feasible, so we try longer times. Otherwise, shorten.  
4. **Elegant architecture:** Sorting + binary search + greedy feasibility check → clean O(n log n) solution.  

This approach ensures correctness, efficiency, and architectural clarity — a textbook example of **binary search on the answer**.


---

# 312. Burst Balloons

**Difficulty:** Hard  
**Topics:** Dynamic Programming, Interval DP  

---

## ðŸ“– Problem Restatement
You are given `n` balloons with values `nums[i]`.  
When you burst balloon `i`, you gain `nums[i-1] * nums[i] * nums[i+1]` coins.  
If `i-1` or `i+1` is out of bounds, treat it as `1`.  
Return the maximum coins you can collect by bursting all balloons optimally.

---

## ðŸ’¡ Core Idea
- Greedy doesnâ€™t work â€” order matters.  
- Trick: **think backwards** â€” the last balloon to burst in an interval.  
- Define DP:
```
 dp[left][right] = max coins from interval (left, right),
  excluding boundaries left and right

```

- Transition:  
```
dp[left][right] = max over k in (left+1..right-1):
dp[left][k] + dp[k][right] + arr[left]arr[k]arr[right]
```

- Add virtual balloons with value `1` at both ends.  
- Answer = `dp[0][n+1]`.

---

## ðŸ”Ž Step-by-Step Algorithm
1. Pad `nums` with `1` at both ends â†’ new length = `n+2`.  
2. Initialize DP table `dp[n+2][n+2] = 0`.  
3. Iterate over interval length from 2 to n+2.  
4. For each interval `(left,right)`, try bursting each balloon `k` inside.  
5. Update `dp[left][right]`.  
6. Return `dp[0][n+1]`.

---

## âœ… C# Implementation
```csharp
public class Solution {
  public int MaxCoins(int[] nums) {
      int n = nums.Length;
      int[] arr = new int[n + 2];
      arr[0] = 1;
      arr[n + 1] = 1;
      for (int i = 0; i < n; i++) arr[i + 1] = nums[i];

      int[,] dp = new int[n + 2, n + 2];

      for (int len = 2; len <= n + 2; len++) {
          for (int left = 0; left + len <= n + 1; left++) { 
              int right = left + len;
              for (int k = left + 1; k < right; k++) {
                  dp[left, right] = Math.Max(dp[left, right],
                      dp[left, k] + dp[k, right] + arr[left] * arr[k] * arr[right]);
              }
          }
      }

      return dp[0, n + 1];
   }
}
```

## ðŸ“Š Complexity Analysis

- **Time Complexity:** O(nÂ³) â€” triple loop (interval DP).  
- **Space Complexity:** O(nÂ²) â€” DP table.  

---

## âš ï¸ Pitfalls

- Must pad with `1` at both ends.  
- Donâ€™t think greedy â€” optimal order is not obvious.  
- Careful with boundaries:  
  - `right` must never exceed `n+1`.  
  - Final answer is `dp[0][n+1]`.  

---

## ðŸ”Ž Example Walkthrough

**Input:**  
`nums = [3,1,5,8]`  

**Pad:**  
`[1,3,1,5,8,1]`  

**Optimal bursting order yields:**  
`167`  

---

## âœ… Key Takeaway

- This is a **classic interval DP** problem.  
- **Pattern:** â€œChoose last element in intervalâ€ â†’ `dp[left][right]`.  
- Clean O(nÂ³) solution with O(nÂ²) space.  
- Boundary conditions are critical â€” off-by-one errors cause `IndexOutOfRangeException`.  



---


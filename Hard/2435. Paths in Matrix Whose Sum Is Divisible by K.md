# 2435. Paths in Matrix Whose Sum Is Divisible by K

---

##  Problem Restatement
We are given an `m x n` grid and an integer `k`.  
- Start at `(0,0)` and move only **down** or **right**.  
- Count the number of paths to `(m-1,n-1)` such that the **sum of values along the path is divisible by k**.  
- Return the result modulo `10^9+7`.

Constraints:  
- `1 <= m, n <= 5 * 10^4`  
- `1 <= m * n <= 5 * 10^4`  
- `0 <= grid[i][j] <= 100`  
- `1 <= k <= 50`  

---

##  Core Idea
- Use **dynamic programming with remainder states**.  
- `dp[i][j][r]` = number of ways to reach cell `(i,j)` with sum remainder `r`.  
- Transition:  
  - From top `(i-1,j)`  
  - From left `(i,j-1)`  
- Optimize memory:  
  - Only keep **current row** and **previous row**.  
  - Each cell stores an array of size `k`.  

---

##  Optimized Code (C#)
```csharp
public class Solution {
    const int MOD = 1_000_000_007;
    public int NumberOfPaths(int[][] grid, int k) {
        int m = grid.Length, n = grid[0].Length;

        // dp[j][r] = ways to reach cell (i,j) with remainder r
        int[][] dp = Create2D(n, k);
        int[][] prev = Create2D(n, k);

        for (int i = 0; i < m; i++) {
            // swap prev and dp
            var temp = prev;
            prev = dp;
            dp = temp;

            // clear dp row
            for (int j = 0; j < n; j++)
                Array.Clear(dp[j], 0, k);

            for (int j = 0; j < n; j++) {
                int val = grid[i][j] % k;

                if (i == 0 && j == 0) {
                    dp[0][val] = 1;
                    continue;
                }

                // from top
                if (i > 0) {
                    for (int r = 0; r < k; r++) {
                        if (prev[j][r] != 0) {
                            int newR = (r + val) % k;
                            dp[j][newR] = (dp[j][newR] + prev[j][r]) % MOD;
                        }
                    }
                }

                // from left
                if (j > 0) {
                    for (int r = 0; r < k; r++) {
                        if (dp[j - 1][r] != 0) {
                            int newR = (r + val) % k;
                            dp[j][newR] = (dp[j][newR] + dp[j - 1][r]) % MOD;
                        }
                    }
                }
            }
        }

        return dp[n - 1][0];
    }

    private int[][] Create2D(int rows, int cols) {
        int[][] arr = new int[rows][];
        for (int i = 0; i < rows; i++)
            arr[i] = new int[cols];
        return arr;
    }
}
```


---

##  Complexity
- **Time:** O(m * n * k)  
  - Each cell `(i,j)` processes up to `k` remainder states.  
  - Transition: from previous rowâ€™s remainders to current rowâ€™s remainders.  
- **Space:** O(n * k)  
  - Only two rows of DP are stored at a time (row compression).  
  - Each row has `n` columns Ã— `k` remainder states.  

This ensures scalability for `m * n â‰¤ 5 * 10^4` and `k â‰¤ 50`.


## ðŸŒ³ Visualization
````
Grid: 3x3, k=3

Start: (0,0)  remainder = 1
â†“
Path accumulates remainders:
(0,1): (1+2)%3 = 0
(1,1): (0+5)%3 = 2
(2,2): (2+9)%3 = 2

Final remainder = 2 â†’ not divisible by 3

````

---

##  Example Walkthrough
Suppose we have a grid `m=3, n=3, k=3`.  
Values in grid:  
```
1 2 3
4 5 6
7 8 9
```


### Step 1: Initialize
- DP[0][0][ (grid[0][0] % k) ] = 1  
- That is, remainder `1` is possible at start.  

### Step 2: Process row by row
- For each cell `(i,j)` and each remainder `r`:  
  - Compute new remainder `(r + grid[i][j]) % k`.  
  - Update DP state for `(i,j)` accordingly.  

### Step 3: Row compression
- After finishing row `i`, discard row `i-1`.  
- Keep only current row and previous row.  

### Step 4: Final check
- At bottom-right cell `(m-1,n-1)`, check if remainder `0` is reachable.  
- If yes â†’ path sum divisible by `k`.  

---

##  Pitfalls
- **Row clearing:**  
  - Must reset the DP row before reuse, otherwise old states leak into new computations.  
- **Modulo correctness:**  
  - Always compute new remainder as `(r + val) % k`.  
  - Forgetting `% k` leads to invalid states.  
- **Skip unnecessary loops:**  
  - If `prev[j][r] == 0` or `dp[j-1][r] == 0`, skip processing to save time.  
- **Large grids:**  
  - Memory optimization is critical.  
  - Without row compression, space would blow up to O(m * n * k).  

---

## Conclusion
This problem reduces to **DP with remainder states + row compression**.  
- Each cell tracks possible remainders of path sums modulo `k`.  
- Memory is optimized to O(n * k) by storing only two rows at a time.  
- Efficient enough for large grids within given constraints.  

---

##  Generalization
- **Pattern:** grid DP with modular constraints.  
- **Applications:**  
  - Counting paths with sum divisible by `k`.  
  - Modular DP in combinatorics (e.g., partitions, subset sums).  
  - Problems with constraints on path sums or modular arithmetic.  
- **Key insight:**  
  - Augment DP state with remainder dimension.  
  - Use row compression to keep memory manageable.  

---










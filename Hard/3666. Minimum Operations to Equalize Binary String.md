# 3666. Minimum Operations to Equalize Binary String  
*O(n + k²) — BFS on Number of Zeros (State Space = Remaining Zeros)*

---

## Problem Statement

- You are given a binary string `s` and an integer `k`.
- In one operation, you **must** select **exactly k distinct indices** and flip all of them ('0' → '1', '1' → '0').
- Return the **minimum number of operations** needed to make the entire string consist of only `'1'`s.  
- If impossible — return **-1**.

**Examples**:

**Example 1**  
Input: s = "110", k = 1  
Output: **1**  
Flip the single '0' → "111"

**Example 2**  
Input: s = "0101", k = 3  
Output: **2**  
One sequence: flip [0,1,3] → "1000", then flip [1,2,3] → "1111"

**Example 3**  
Input: s = "101", k = 2  
Output: **-1**  
Only one '0' — impossible to flip exactly 2 positions each time

**Constraints**:
- 1 ≤ s.length ≤ 10⁵
- s consists of '0' and '1'
- 1 ≤ k ≤ s.length

---

## Core Idea — BFS on Remaining Zeros Count

**Key insight**:
- Goal: reach **0 zeros** remaining
- Each operation flips **exactly k** positions
- Flipping a '0' → decreases zero count by 1
- Flipping a '1' → increases zero count by 1
- Let current zeros = m
- Suppose we flip **c** zeros in this operation → zeros become m - c
- We flip (k - c) ones → zeros become (m - c) + (k - c) = m + k - 2c
- c ranges from max(0, k - (n - m)) to min(k, m)

**Possible new zero counts** = m + k - 2c for feasible c  
→ arithmetic sequence from m + k - 2*maxC to m + k - 2*minC with step 2

**State** = current number of remaining '0's (0 to n)  
We model graph where nodes = possible zero counts  
Edge from m → m + k - 2c with cost 1 (one operation)

Use **BFS** to find shortest path from initial zeros count to 0.

**Optimization**:
- Since transitions are range [left, right] with step 2
- Use **SortedSet** per parity (even/odd zero count) to quickly find reachable states in range

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MinOperations(string s, int k) {
        int n = s.Length;
        int zeros = 0;
        foreach (char c in s) {
            if (c == '0') zeros++;
        }

        if (zeros == 0) return 0;

        int[] dist = new int[n + 1];
        for (int i = 0; i <= n; i++) dist[i] = int.MaxValue;

        var nodeSets = new List<SortedSet<int>> { new(), new() };
        for (int i = 0; i <= n; i++) {
            nodeSets[i % 2].Add(i);
        }

        Queue<int> q = new Queue<int>();
        q.Enqueue(zeros);
        dist[zeros] = 0;
        nodeSets[zeros % 2].Remove(zeros);

        while (q.Count > 0) {
            int m = q.Dequeue();

            // c = number of zeros flipped
            int c1 = Math.Max(k - (n - m), 0);  // min c
            int c2 = Math.Min(k, m);            // max c

            // new zeros = m + k - 2*c
            // c increases → new zeros decreases by 2
            int lnode = m + k - 2 * c2;   // smallest new zeros
            int rnode = m + k - 2 * c1;   // largest new zeros

            var nodeSet = nodeSets[lnode % 2];
            var toRemove = new List<int>();

            var view = nodeSet.GetViewBetween(lnode, rnode);
            foreach (var val in view) {
                toRemove.Add(val);
            }

            foreach (int m2 in toRemove) {
                dist[m2] = dist[m] + 1;
                q.Enqueue(m2);
                nodeSet.Remove(m2);
            }
        }

        return dist[0] == int.MaxValue ? -1 : dist[0];
    }
}
```

## Complexity

| **Metric**            | **Value**              | **Notes**                                                                 |
|-----------------------|------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(n + k²)** worst-case | Initial setup and zero counting: O(n)<br>BFS visits each state (0 to n) at most once: O(n)<br>Per state: range query on SortedSet + processing up to k transitions<br>SortedSet operations (GetViewBetween + Remove): amortized O(log n) per operation<br>Worst case total: O(n log n + k²) due to overlapping range queries and removals |
| **Space Complexity**  | **O(n)**               | dist array: O(n)<br>Two SortedSets (even/odd states): O(n)<br>Queue: O(n) in worst case |

**Optimal** — linear space, near-linear time with small constant factors — passes comfortably for n ≤ 10⁵.

---

## Why This Works — Core Logic

**State** = current number of remaining '0's (ranges from initial zeros down to 0)

**Transition**:
- From current state m (number of '0's):
  - Choose c = number of '0's to flip in this operation (0 ≤ c ≤ min(k, m))
  - Must flip (k - c) '1's → requires enough '1's: k - c ≤ n - m
  - Net change in zeros: -c (from flipped '0's) + (k - c) (from flipped '1's) = **k - 2c**
  - New state = m + k - 2c
- Feasible c range: max(0, k - (n - m)) ≤ c ≤ min(k, m)
- Thus new states form an **arithmetic sequence** from m + k - 2*maxC to m + k - 2*minC with step 2

**BFS**:
- Start from initial number of '0's
- Distance = number of operations (minutes)
- Use **two SortedSets** (one for even, one for odd state values) to quickly find all reachable next states in a range [left, right]
- When processing a state m:
  - Compute feasible range [lnode, rnode]
  - Query SortedSet for that parity → get all reachable states in O(log n + output size)
  - Enqueue them with distance +1 and remove from set (to avoid reprocessing)
- When we reach state 0 → return its distance
- If queue empties without reaching 0 → return -1

**Correct** —  
This accurately models the problem as a **shortest path** in the state graph where nodes are possible zero counts (0 to n) and edges correspond to valid operations (changing zero count by k - 2c for feasible c).  
BFS guarantees the minimum number of operations.

---

## Key Takeaway

This is a **clever state-space BFS** problem:

* State = current number of remaining '0's (0 to n)
* Each operation changes zero count to m + k - 2c for feasible c (c = zeros flipped)
* Possible next states form an arithmetic sequence with difference 2
* Use **BFS** to find shortest path from initial zeros count to 0
* Optimize range queries with **SortedSet per parity** (even/odd zero counts) to quickly find and remove reachable states
* If state 0 is unreachable → return -1

---

# 1687. Delivering Boxes from Storage to Ports

**Difficulty:** Hard  
**Tags:** Greedy, Sliding Window, Monotonic Queue  
**Status:** Solved  
**Source:** Leetcode  
**Author:** Denis (architectural adaptation based on peer code)

---

## 🧠 Problem Summary

You are given a list of boxes, each with a destination port and weight. A ship must deliver these boxes in order, subject to two constraints:

- It can carry at most `maxBoxes` boxes at once.
- It can carry at most `maxWeight` total weight at once.

The ship delivers boxes in the order they appear. For each delivery batch:

- It visits each required port (skipping duplicates).
- Then returns to storage to pick up the next batch.

Your task is to compute the **minimum number of trips** required to deliver all boxes.

---

## 📜 Constraints

- `1 <= boxes.length <= 10⁵`
- `1 <= portsCount, maxBoxes, maxWeight <= 10⁵`
- `1 <= boxes[i][0] <= portsCount`
- `1 <= boxes[i][1] <= maxWeight`

---

## 💡 Core Idea

Use a **sliding window** to simulate the current delivery batch. Maintain:

- `left` pointer for the start of the batch
- `weight` of the current batch
- `queue` to track minimal cost states

For each box `i`:

1. Expand the window while respecting `maxBoxes` and `maxWeight`.
2. Remove outdated states from the queue.
3. Compute delivery cost:
   - `+1` for return trip
   - `+1` if next box has same port (optimization)
4. Maintain queue monotonicity by removing worse states.
5. After processing all boxes, add `+1` for each port switch.

---

## 🧩 Code

```csharp
public class Solution {
    public int BoxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight){
        int n = boxes.Length;
        LinkedList<int[]> queue = new LinkedList<int[]>();
        queue.AddLast(new int[] { -1, 1 });
        int left = -1, weight = 0, currentCost = 0;

        for (int i = 0; i < n; i++) {
            weight += boxes[i][1];

            while (i - left > maxBoxes || weight > maxWeight) {
                left++;
                weight -= boxes[left][1];
            }

            while (queue.Count > 0 && queue.First.Value[0] < left) {
                queue.RemoveFirst();
            }

            currentCost = queue.First.Value[1] + 1;
            if (i < n - 1 && boxes[i][0] == boxes[i + 1][0]) {
                currentCost++;
            }

            while (queue.Count > 0 && queue.Last.Value[1] >= currentCost) {
                queue.RemoveLast();
            }

            queue.AddLast(new int[] { i, currentCost });
        }

        for (int i = 0; i < n - 1; i++) {
            if (boxes[i][0] != boxes[i + 1][0]) {
                currentCost++;
            }
        }

        return currentCost;
    }
}
```

## 🧪 Testcase

```csharp
Input:
boxes = [[1,1],[2,1],[1,1]]
portsCount = 2
maxBoxes = 3
maxWeight = 3

Expected Output:
4
```

## 🚢 Delivery Flow
- Ship takes all 3 boxes: [1,1] → [2,1] → [1,1]

Visits:

- Port 1 (for box 1)
- Port 2 (for box 2)
- Port 1 again (for box 3)

- Returns to storage

Total trips:

- 3 port deliveries
- 1 return to storage → 4 trips

## 📦 Constraints Respected
- maxBoxes = 3 → only 3 boxes loaded ✅
- maxWeight = 3 → total weight = 1 + 1 + 1 = 3 ✅
- Boxes delivered strictly in input order ✅

## ⚠️ Edge Case Covered

- Port switch between box 1 and 2
- Port switch again between box 2 and 3

Confirms that:

- Port-switch logic is correctly counted
- Return trip is always added after delivery batch


---

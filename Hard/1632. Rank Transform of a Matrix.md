# ðŸ§© LeetCode 1632 â€” Rank Transform of a Matrix

## ðŸ“Œ Problem Summary

You're given an `m Ã— n` integer matrix `grid`.  
You must return a new matrix `answer` where `answer[row][col]` is the **rank** of `grid[row][col]`.

### Rank Rules:
- Ranks start from 1
- If two elements `p` and `q` are in the same row or column:
  - If `p < q` â†’ `rank(p) < rank(q)`
  - If `p == q` â†’ `rank(p) == rank(q)`
  - If `p > q` â†’ `rank(p) > rank(q)`
- Ranks must be **as small as possible**
- The result is guaranteed to be unique

---

## ðŸ§ Approach

I reframed the problem as a **graph of constraints**:

- Elements with the same value in the same row or column must share the same rank  
- Elements with different values must respect the ordering constraints  
- This leads to a **Union-Find structure** for grouping equal elements  
- For each group, I assign the rank based on the **maximum rank seen so far** in its row or column

This avoids brute force and guarantees minimal ranks.

---

## ðŸ§± Step-by-Step Explanation

### ðŸ”¹ Step 1: Sort all cells by value
I collect all `(value, row, col)` triples and sort them in ascending order.

### ðŸ”¹ Step 2: Group equal-value cells using Union-Find
For each batch of equal-value cells, I union their row and column indices (offsetting columns by `+m`).

### ðŸ”¹ Step 3: Assign ranks to each group
For each connected component:
- I find the maximum rank among all rows and columns involved
- I assign `rank = max(rowMax, colMax) + 1` to all cells in the group
- I update `rowMax` and `colMax` accordingly

### ðŸ”¹ Step 4: Return the result
I build the final matrix using the assigned ranks.

---

## âœ… Final Code (C#)

```csharp
public class Solution {
    public int[][] MatrixRankTransform(int[][] matrix) {
        int m = matrix.Length, n = matrix[0].Length;
        var result = new int[m][];
        for (int r = 0; r < m; r++) result[r] = new int[n];

        var cells = new List<(int val, int row, int col)>();
        for (int r = 0; r < m; r++)
            for (int c = 0; c < n; c++)
                cells.Add((matrix[r][c], r, c));

        cells.Sort((a, b) => a.val.CompareTo(b.val));

        int[] rowMax = new int[m];
        int[] colMax = new int[n];

        int index = 0;
        while (index < cells.Count) {
            int groupStart = index;
            var uf = new UnionFind(m + n);
            var groups = new Dictionary<int, List<(int r, int c)>>();

            while (index < cells.Count && cells[index].val == cells[groupStart].val) {
                int r = cells[index].row, c = cells[index].col;
                uf.Union(r, c + m);
                index++;
            }

            for (int k = groupStart; k < index; k++) {
                int r = cells[k].row, c = cells[k].col;
                int root = uf.Find(r);
                if (!groups.ContainsKey(root))
                    groups[root] = new List<(int, int)>();
                groups[root].Add((r, c));
            }

            foreach (var group in groups.Values) {
                int rank = 1;
                foreach (var (r, c) in group)
                    rank = Math.Max(rank, Math.Max(rowMax[r], colMax[c]) + 1);
                foreach (var (r, c) in group) {
                    result[r][c] = rank;
                    rowMax[r] = rank;
                    colMax[c] = rank;
                }
            }
        }

        return result;
    }

    class UnionFind {
        private int[] parent;
        public UnionFind(int size) {
            parent = new int[size];
            for (int i = 0; i < size; i++) parent[i] = i;
        }

        public int Find(int x) {
            if (parent[x] != x)
                parent[x] = Find(parent[x]);
            return parent[x];
        }

        public void Union(int x, int y) {
            parent[Find(x)] = Find(y);
        }
    }
}
```

## ðŸ§® Time & Space Complexity

| Metric           | Value          |
|------------------|----------------|
| Sorting          | O(mn log mn)   |
| Union-Find ops   | O(Î±(m + n))    |
| Grouping         | O(mn)          |
| Total Time       | O(mn log mn)   |
| Space            | O(m + n)       |

---

## ðŸ§˜ Why This Works

âœ… Sorting guarantees correct rank order  
âœ… Union-Find groups equal elements across rows/columns  
âœ… Row/Col max tracking ensures minimal valid rank  
âœ… No revisits, no brute force, no dynamic programming

---

## ðŸ§  My Takeaway

This task looks symbolic, but it's really a **graph of constraints**.  
I reused a pattern from numeric grouping â€” Union-Find over rows and columns â€” and adapted it to symbolic rank assignment.  
The result is fast, minimal, and architecturally sound.

This is the kind of module I want in my repo:  
**Not just passing â€” but built to last.**


---

# 💹 123. Best Time to Buy and Sell Stock III

## 📜 Problem Statement
We are given an array `prices` where `prices[i]` is the price of a stock on day `i`.  
We may complete **at most two transactions** (buy → sell → buy → sell).  
We cannot hold multiple stocks at the same time (must sell before buying again).  

Return the **maximum profit** achievable.

**Constraints:**  
- 1 <= prices.length <= 100000  
- 0 <= prices[i] <= 100000  

---

## 💡 Idea and Approach
This is a **dynamic programming with state compression** problem.  
We track **four states** that represent the maximum profit at each stage:

1. **buy1** → maximum profit after the first buy  
   - Formula: `buy1 = max(buy1, -price)`

2. **sell1** → maximum profit after the first sell  
   - Formula: `sell1 = max(sell1, buy1 + price)`

3. **buy2** → maximum profit after the second buy  
   - Formula: `buy2 = max(buy2, sell1 - price)`

4. **sell2** → maximum profit after the second sell  
   - Formula: `sell2 = max(sell2, buy2 + price)`

👉 The answer is `sell2`.

### Why this works
- The dependencies enforce the valid order:  
  `buy1 → sell1 → buy2 → sell2`.  
- Each state either **keeps the previous best** or **performs the action today**.  
- This is equivalent to a full DP table `dp[day][transactions][holding]`, but compressed to **O(1)** space.

---

## 🚀 Implementation (C#)

```csharp
public class Solution {
    public int MaxProfit(int[] prices) {
        if (prices == null || prices.Length == 0) return 0;

        int buy1 = int.MinValue, sell1 = 0;
        int buy2 = int.MinValue, sell2 = 0;

        foreach (int p in prices) {
            buy1  = Math.Max(buy1, -p);        // first buy
            sell1 = Math.Max(sell1, buy1 + p); // first sell
            buy2  = Math.Max(buy2, sell1 - p); // second buy
            sell2 = Math.Max(sell2, buy2 + p); // second sell
        }

        return sell2;
    }
}
```
## ⏱ Complexity Analysis

- **Time Complexity:**  
  - We iterate through the `prices` array once.  
  - Each iteration updates 4 integer states (`buy1`, `sell1`, `buy2`, `sell2`).  
  - No nested loops or extra passes are required.  
  - **Total:** O(n), where n = number of days.

- **Space Complexity:**  
  - We only maintain 4 integer variables.  
  - No DP table or auxiliary arrays are needed.  
  - **Total:** O(1).

👉 This is a classic example of **state compression**: instead of a full DP table `dp[day][transactions][holding]`, we reduce everything to just 4 states.

---

## 🔎 Example Walkthrough

**Input:**  
`prices = [3,3,5,0,0,3,1,4]`

**Step-by-step reasoning:**
- Day 4: buy at 0, sell at 3 → profit = 3  
- Day 7: buy at 1, sell at 4 → profit = 3  
- Total profit = 3 + 3 = **6**

**Why not other choices?**  
- Buying earlier (at 3 or 5) gives less margin.  
- Skipping the second transaction would cap profit at 3.  
- The greedy DP states ensure we always keep the best possible option at each step.

✅ Final Answer: 6

---

## 🏁 Conclusion

This problem trains the ability to:
- Recognize when a **multi-transaction stock problem** can be reduced to a few states.  
- Apply **state compression** to avoid full DP tables.  
- Understand the strict sequence of actions: **buy → sell → buy → sell**.  

👉 **Key takeaway:**  
At most `k` transactions can be solved with `2k` states.  
For `k = 2`, we only need 4 states:  
- `buy1`  
- `sell1`  
- `buy2`  
- `sell2`


---

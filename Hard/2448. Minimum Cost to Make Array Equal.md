#  Minimum Cost to Make Array Equal — Weighted Median Strategy (LeetCode 2448)

---

##  Origin & Motivation

We are given two arrays `nums` and `cost`, both of length `n`.  
We can increment or decrement any `nums[i]` by 1, and each operation costs `cost[i]`.  
The goal is to make all elements in `nums` equal with **minimum total cost**.

This is a classic **weighted alignment** problem — we want to align all values to a single target, minimizing the total weighted distance.

---

##  Use Cases

-  Weighted median alignment  
-  Cost-aware transformation  
-  Greedy sweep over sorted values  
-  Prefix sum optimization

---

##  Core Architecture

###  Triggers

| Condition                        | Action in Code           |
|----------------------------------|--------------------------|
| Element appears                  | Pair with cost           |
| Sort by value                    | Enables prefix scan      |
| Total cost reaches half sum     | Lock median              |
| Compute cost to align to median | Use prefix sums          |

---

###  Algorithm Steps

1. Pair each `nums[i]` with `cost[i]`  
2. Sort pairs by `nums[i]`  
3. Compute total cost sum  
4. Sweep from left to right, accumulating cost  
5. Stop when cumulative cost ≥ totalCost / 2  
6. Use that `nums[i]` as target value  
7. Compute total cost to align all elements to target

---

##  C# Implementation

```csharp
public class Solution {
    public long MinCost(int[] nums, int[] cost) {
        int n = nums.Length;
        var pairs = new List<(int val,int weight)>();
        for(int i =0; i < n;i++){
            pairs.Add((nums[i],cost[i]));
        }
       pairs.Sort((a,b) => a.val.CompareTo(b.val));
       long total =0;
       foreach(var p in pairs) total += p.weight;
        
        long prefix =0;
        int target =0;

        foreach(var p in pairs){
            prefix += p.weight;

            if(prefix >= (total+1)/2){
                target = p.val;
                break;
            }
        }
     long res =0;
     foreach(var p in pairs){
        res += (long)Math.Abs(p.val - target) * p.weight;
     }

     return res;
    }
}
```

##  Complexity Analysis  
- Pairing: O(n) — zip `nums` and `cost`  
- Sorting: O(n·log n) — sort by value  
- Sweep: O(n) — prefix scan and cost aggregation  
- **Total time complexity**: O(n·log n)  
- **Space complexity**: O(n) — for paired list

##  Pitfalls  
-  Must sort by value — alignment depends on order  
 - Use weighted median — not arithmetic mean  
-  Do not simulate operations — compute total cost directly  
 - Median is locked when cumulative cost ≥ half  
 - Avoid brute-force — prefix scan is optimal

##  Conclusion  
This is a weighted alignment problem solved via greedy median scan:

 - Pair values with cost  
 - Sort and scan to find weighted median  
 - Compute total cost to align  
-  Optimal and scalable for large arrays

**Key takeaway**: When cost varies per element, align to weighted median — fast, clean, and robust.


---

# 🧠 Pattern: Total Manhattan Distance Over All Valid Piece Arrangements

## 📌 Problem Statement

Given integers `rows`, `cols`, and `k`, place `k` identical pieces on a `rows × cols` grid such that no cell contains more than one piece.  
Return the **sum of Manhattan distances** between every pair of pieces across **all valid arrangements**.  
Since the result may be large, return it modulo `1_000_000_007`.

---

## 📋 Constraints
```
1 ≤ rows, cols ≤ 100000
2 ≤ rows * cols ≤ 100000
2 ≤ k ≤ rows * cols
```


---

## 📐 Manhattan Distance Definition

For two cells `(x1, y1)` and `(x2, y2)`, the Manhattan distance is:
```
|x1 - x2| + |y1 - y2|
```


---

## ⚙️ Core Idea

### 🔁 Step 1: Precompute Distance Between All Cell Pairs

Instead of iterating over all valid arrangements, compute the **total distance between all unordered cell pairs** once, then multiply by the number of ways to choose `k` pieces that include those two cells.

---

### 🧮 Step 2: Count of Arrangements Including a Pair

For each pair of cells, the number of arrangements where both are selected among the `k` pieces is:
```
C(total_cells - 2, k - 2)
```

- This is the number of ways to choose the remaining `k - 2` pieces from the rest of the grid.

---

### 🧱 Step 3: Total Distance Over All Pairs

Split the Manhattan distance into two components:

- **Row contribution**: for each pair of rows `r1`, `r2`, the vertical distance is `|r1 - r2|`, and there are `cols * cols` combinations per row pair.
- **Column contribution**: for each pair of columns `c1`, `c2`, the horizontal distance is `|c1 - c2|`, and there are `rows * rows` combinations per column pair.

Sum both contributions:

```csharp
for (int r = 1; r <= rows; r++)
    rowSum += (r * r - r * (r + 1) / 2) * (cols * cols)

for (int c = 1; c <= cols; c++)
    colSum += (c * c - c * (c + 1) / 2) * (rows * rows)
```

## Then:
```
totalSum = (rowSum + colSum) * C(rows * cols - 2, k - 2)
```

## 🧮 Combinatorics Module
Precompute:

- fact[i] — factorial
- inv[i] — modular inverse
- factInv[i] — inverse factorial

Use Fermat’s Little Theorem for modular inverse:
```
inv[i] = MOD - (MOD / i) * inv[MOD % i] % MOD

Then:

C(n, k) = fact[n] * factInv[k] % MOD * factInv[n - k] % MOD
```

## 🧱Code (C#)

```csharp
public class Solution {
    const int MOD = 1_000_000_007;

    public int DistanceSum(int rows, int cols, int k) {
        long total = 0;
        var comb = new Comb(rows * cols, MOD);

        long dist = 0;
        for (int r = 1; r <= rows; r++) {
            long delta = (long)r * (r - 1) / 2;
            dist += delta * cols * cols % MOD;
            dist %= MOD;
        }

        for (int c = 1; c <= cols; c++) {
            long delta = (long)c * (c - 1) / 2;
            dist += delta * rows * rows % MOD;
            dist %= MOD;
        }

        long ways = comb.C(rows * cols - 2, k - 2);
        return (int)(dist * ways % MOD);
    }

    public class Comb {
        long[] fact, inv, factInv;
        long MOD;

        public Comb(int size, long mod) {
            MOD = mod;
            fact = new long[size + 1];
            inv = new long[size + 1];
            factInv = new long[size + 1];

            inv[1] = 1;
            for (int i = 2; i <= size; i++)
                inv[i] = MOD - MOD / i * inv[MOD % i] % MOD;

            fact[0] = factInv[0] = 1;
            for (int i = 1; i <= size; i++) {
                fact[i] = fact[i - 1] * i % MOD;
                factInv[i] = factInv[i - 1] * inv[i] % MOD;
            }
        }

        public long C(int n, int k) {
            if (n < 0 || k < 0 || n < k) return 0;
            return fact[n] * factInv[k] % MOD * factInv[n - k] % MOD;
        }
    }
}
```
## ✅ Why This Pattern Works

- Avoids brute-force over all arrangements
- Uses symmetry of grid to compute distances efficiently
- Combines geometry and combinatorics into a clean modular pipeline
- Scales to max constraints with precomputation and modular arithmetic

## 🔁 Reusability

This pattern generalizes to:

- Grid-based pairwise metrics (distance, cost, influence)
- Weighted combinatorial aggregation
- Modular arithmetic with factorials
- Geometry × combinatorics fusion problems
- Perfect for competitive programming, algorithmic modules, or teaching architectural decomposition.



---



# 3721. Longest Balanced Subarray II  
*O(n log n) — Segment Tree + Queues of Occurrences + Prefix Balance*

---

## Problem Statement

You are given an integer array `nums` of length `n` (1 ≤ n ≤ 10⁵, 1 ≤ nums[i] ≤ 10⁵).

A subarray is **balanced** if the number of **distinct even** numbers in it equals the number of **distinct odd** numbers.

Return the **length** of the **longest balanced subarray** (return 0 if none exists).

---

## Core Idea — Prefix Balance + Segment Tree for Rightmost Zero-Difference Search

We define a **prefix balance** array where:
- +1 — first occurrence of an **even** number
- -1 — first occurrence of an **odd** number
- 0 — any subsequent occurrence of the same number (does not change distinct count)

A subarray [L..R] is balanced if and only if:

**prefix[R+1] - prefix[L] = 0**

i.e. the balance change over [L..R] is zero — equal number of new distinct evens and odds were introduced.

**Algorithm in detail**:

1. **Build prefix balance and occurrence queues**:
   - prefix[0] = 0
   - For each position i (0-based):
     - sgn = (nums[i] % 2 == 0) ? 1 : -1
     - if nums[i] is seen for the first time → prefix[i+1] = prefix[i] + sgn
     - otherwise → prefix[i+1] = prefix[i]
     - enqueue position i into occurrences[nums[i]] (queue — FIFO)

2. **Build segment tree** on prefix[0..n]:
   - Supports **range add** (to remove contribution when a number is exhausted)
   - Supports **find rightmost** index j ≥ start where tree[j] == target value

3. **Main loop** (move left pointer i from 0 to n-1):
   - Query segment tree: find **rightmost** j ≥ i + current maxLen such that prefix[j+1] == prefix[i]
     → this gives balanced subarray [i..j]
   - If found → update maxLen = j - i + 1
   - Then remove nums[i] from future consideration:
     - Dequeue current position i from its queue
     - If queue is now empty (no more occurrences after i):
       - Add -sgn(nums[i]) to range [i+1 .. n] in segment tree
       - This removes the +1 or -1 contribution of this number from all future prefix calculations starting at i+1 or later

**Why this gives correct longest balanced**:
- prefix[j+1] - prefix[i] = 0 → equal number of **new** distinct evens and odds in [i..j]
- Removing exhausted numbers ensures future prefixes don't count them anymore
- Searching for **rightmost** j maximizes length for each left i
- Greedy update of maxLen gives global maximum

---

## Clean Implementation (C#)

```csharp
public class LazyTag {
    public int toAdd;

    public LazyTag() {
        this.toAdd = 0;
    }

    public LazyTag Add(LazyTag other) {
        this.toAdd += other.toAdd;
        return this;
    }

    public bool HasTag() {
        return this.toAdd != 0;
    }

    public void Clear() {
        this.toAdd = 0;
    }
}

public class SegmentTreeNode {
    public int minValue;
    public int maxValue;
    public LazyTag lazyTag;

    public SegmentTreeNode() {
        this.minValue = 0;
        this.maxValue = 0;
        this.lazyTag = new LazyTag();
    }
}

public class SegmentTree {
    private int n;
    private SegmentTreeNode[] tree;

    public SegmentTree(int[] data) {
        this.n = data.Length;
        this.tree = new SegmentTreeNode[this.n * 4 + 1];
        for (int i = 0; i < tree.Length; i++) {
            tree[i] = new SegmentTreeNode();
        }
        Build(data, 1, this.n, 1);
    }

    public void Add(int l, int r, int val) {
        LazyTag tag = new LazyTag();
        tag.toAdd = val;
        Update(l, r, tag, 1, this.n, 1);
    }

    public int FindLast(int start, int val) {
        if (start > this.n) {
            return -1;
        }
        return Find(start, this.n, val, 1, this.n, 1);
    }

    private void ApplyTag(int i, LazyTag tag) {
        tree[i].minValue += tag.toAdd;
        tree[i].maxValue += tag.toAdd;
        tree[i].lazyTag.Add(tag);
    }

    private void Pushdown(int i) {
        if (tree[i].lazyTag.HasTag()) {
            LazyTag tag = new LazyTag();
            tag.toAdd = tree[i].lazyTag.toAdd;
            ApplyTag(i << 1, tag);
            ApplyTag((i << 1) | 1, tag);
            tree[i].lazyTag.Clear();
        }
    }

    private void Pushup(int i) {
        tree[i].minValue =
            Math.Min(tree[i << 1].minValue, tree[(i << 1) | 1].minValue);
        tree[i].maxValue =
            Math.Max(tree[i << 1].maxValue, tree[(i << 1) | 1].maxValue);
    }

    private void Build(int[] data, int l, int r, int i) {
        if (l == r) {
            tree[i].minValue = tree[i].maxValue = data[l - 1];
            return;
        }

        int mid = l + ((r - l) >> 1);
        Build(data, l, mid, i << 1);
        Build(data, mid + 1, r, (i << 1) | 1);
        Pushup(i);
    }

    private void Update(int targetL, int targetR, LazyTag tag, int l, int r,
                        int i) {
        if (targetL <= l && r <= targetR) {
            ApplyTag(i, tag);
            return;
        }

        Pushdown(i);
        int mid = l + ((r - l) >> 1);
        if (targetL <= mid)
            Update(targetL, targetR, tag, l, mid, i << 1);
        if (targetR > mid)
            Update(targetL, targetR, tag, mid + 1, r, (i << 1) | 1);
        Pushup(i);
    }

    private int Find(int targetL, int targetR, int val, int l, int r, int i) {
        if (tree[i].minValue > val || tree[i].maxValue < val) {
            return -1;
        }

        if (l == r) {
            return l;
        }

        Pushdown(i);
        int mid = l + ((r - l) >> 1);

        if (targetR >= mid + 1) {
            int res = Find(targetL, targetR, val, mid + 1, r, (i << 1) | 1);
            if (res != -1)
                return res;
        }

        if (l <= targetR && mid >= targetL) {
            return Find(targetL, targetR, val, l, mid, i << 1);
        }

        return -1;
    }
}

public class Solution {
    public int LongestBalanced(int[] nums) {
        var occurrences = new Dictionary<int, Queue<int>>();

        int len = 0;
        int[] prefixSum = new int[nums.Length];
        prefixSum[0] = Sgn(nums[0]);
        if (!occurrences.ContainsKey(nums[0])) {
            occurrences[nums[0]] = new Queue<int>();
        }
        occurrences[nums[0]].Enqueue(1);

        for (int i = 1; i < nums.Length; i++) {
            prefixSum[i] = prefixSum[i - 1];
            if (!occurrences.ContainsKey(nums[i])) {
                occurrences[nums[i]] = new Queue<int>();
            }
            var occ = occurrences[nums[i]];
            if (occ.Count == 0) {
                prefixSum[i] += Sgn(nums[i]);
            }
            occ.Enqueue(i + 1);
        }

        var seg = new SegmentTree(prefixSum);
        for (int i = 0; i < nums.Length; i++) {
            len = Math.Max(len, seg.FindLast(i + len, 0) - i);

            int nextPos = nums.Length + 1;
            occurrences[nums[i]].Dequeue();
            if (occurrences[nums[i]].Count > 0) {
                nextPos = occurrences[nums[i]].Peek();
            }

            seg.Add(i + 1, nextPos - 1, -Sgn(nums[i]));
        }

        return len;
    }

    private int Sgn(int x) {
        return (x % 2) == 0 ? 1 : -1;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)**        | Prefix sum + occurrence queues construction: O(n)  
Segment tree build: O(n)  
n iterations, each with:  
• Query (FindLast): O(log n)  
• Possible range update (Add): O(log n)  
Total: O(n log n) |
| **Space Complexity**  | **O(n)**              | Segment tree ≈ 4n nodes  
Occurrence queues total size O(n)  
Prefix sum array O(n) |

**Efficient** — logarithmic factor comes from segment tree operations, fully acceptable and performant for n ≤ 10⁵.

---

## Detailed Algorithm Explanation & Key Tricks

### 1. Prefix Balance Construction

- prefix[0] = 0  
- For each position i from 0 to n-1:
  - sgn = (nums[i] % 2 == 0) ? +1 : -1
  - If nums[i] is appearing **for the first time** → prefix[i+1] = prefix[i] + sgn  
    (we count this as a new distinct even or odd)
  - Otherwise → prefix[i+1] = prefix[i]  
    (duplicate → no change in number of distinct values)
- Simultaneously:  
  - Store **every** position of nums[i] in a queue (FIFO) for that number

This prefix reflects only **first occurrences** — exactly what affects distinct counts.

### 2. Segment Tree Role

Built on prefix[0..n] with **min/max** values per node + lazy add tags.

Supports two crucial operations:
- **Range add** — add a value (usually -sgn) to a suffix of prefixes  
  → used to "remove" contribution of a number when we pass its last occurrence
- **Find rightmost** index j ≥ start such that prefix[j] == target  
  → finds longest possible balanced extension starting from current left

Search is optimized:
- Checks **right child first** → guarantees the **rightmost** (longest) valid position
- Early pruning: if current node min > val or max < val → skip whole subtree (very fast)

### 3. Main Loop (moving left pointer i from 0 to n-1)

For each possible left endpoint i:

- Query segment tree:  
  Find **rightmost** j ≥ i + current maxLen such that prefix[j+1] == prefix[i]  
  → this means subarray [i..j] has balance change = 0 → balanced  
  → length = j - i + 1

- If found → update maxLen

- Then process removal of nums[i]:
  - Dequeue current position i from occurrences[nums[i]]
  - If queue is now empty → this was the **last** occurrence of nums[i]
  - Add -sgn(nums[i]) to range [i+1 .. n] in segment tree  
    → removes the +1 or -1 contribution of this number from **all future** prefix values  
    → future windows starting at i+1 or later will not count it anymore

### 4. Why this correctly finds the longest balanced subarray

- prefix[j+1] - prefix[i] = 0 → exactly the same number of **new** distinct evens and odds were introduced in [i..j]
- When we pass the last occurrence of a number → we remove its contribution from future prefixes  
  → correct handling of duplicates (they don’t add new distinct values)
- Always searching for **rightmost** j maximizes length for each starting position i
- Greedy update of maxLen across all i gives the global maximum

### 5. Clever Tricks & Optimizations Inside the Code

- **Occurrence queues** — FIFO order ensures we always know the next future position  
  → when queue.Count == 0 after dequeue → safe to remove contribution
- **Range add to suffix** [i+1 .. n] — removes effect from all future left endpoints ≥ i+1
- **Right-first recursion** in Find method → always returns the longest possible extension
- **Early pruning** in Find:  
  if (tree[i].minValue > val || tree[i].maxValue < val) return -1;  
  → skips entire subtrees instantly — huge performance gain
- **No lazy for min/max propagation** — since only range add is used (no assignment), simple += on min/max is sufficient
- **Dynamic range in Add** — when last occurrence at i, we add to [i+1 .. n] (nextPos = n+1)

---

## Why This Is Advanced & Powerful

- Completely avoids sliding window pitfalls:
  - No wrong shrink condition
  - No missed intermediate balanced states
  - Handles duplicates perfectly
- Uses **segment tree** exactly for fast "find last balance point" queries
- Correctly tracks **multiple occurrences** via queues
- Time O(n log n) — stable, predictable, passes all tests
- Memory reasonable (segment tree ≈ 4n nodes)

This is one of the **most advanced** and **robust** solutions for this problem — perfect for practicing segment trees, prefix tricks, queues, and lazy propagation.
**Pure, clean, powerful** — segment tree + queues + prefix balance.

---

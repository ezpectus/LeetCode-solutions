# 2172. Maximum AND Sum of Array  
*DP with Base-3 Mask — Slot Assignment Optimization*

---

## Problem
Given:
- Array `A` of integers
- `ns` slots (indexed from 1 to `ns`)
- Each slot can hold **up to 2 numbers**

**Score** = sum of `(A[i] & slot_index)` for all assigned numbers

**Goal**: Distribute all numbers into slots to **maximize the score**

---

## Pattern
**State Compression DP with Base-3 Encoding**

- Each slot: **0, 1, or 2** numbers → **3 states**
- Use **base-3 mask** to represent slot usage
- Mask value: `0 to 3^ns - 1`
- Each digit in base-3 = number of elements in that slot

---

## Algorithm Breakdown

1. Max mask = `3^ns - 1`
2. `memo[mask]` = best score using current slot state
3. For each number `A[i]`:
   - Try placing it in **any slot with capacity** (`mask / 3^slot % 3 > 0`)
   - Update mask: `mask - 3^slot`
   - Recurse with `i-1`
4. Return `dp(n-1, full_mask)`

---

## Optimized Code (C++)

```cpp
class Solution {
public:
    int maximumANDSum(vector<int>& A, int ns) {
        int max_mask = 1;
        for (int i = 0; i < ns; ++i) max_mask *= 3;
        max_mask--;
        
        vector<int> memo(max_mask + 1, 0);
        return dp(A.size() - 1, max_mask, ns, memo, A);
    }
    
    int dp(int i, int mask, int ns, vector<int>& memo, vector<int>& A) {
        if (memo[mask] != 0) return memo[mask];
        if (i < 0) return 0;
        
        int res = 0;
        int bit = 1;
        for (int slot = 1; slot <= ns; ++slot, bit *= 3) {
            if (mask / bit % 3 > 0) {
                int score = (A[i] & slot) + dp(i - 1, mask - bit, ns, memo, A);
                if (score > res) res = score;
            }
        }
        return memo[mask] = res;
    }
};
```

## Complexity
| Metric | Value |
|-------|-------|
| **Time** | **O(n * 3ⁿˢ)** — `n` numbers, `3ⁿˢ` states |
| **Space** | **O(3ⁿˢ)** — memoization table |

> `ns ≤ 9` → `3⁹ = 19683` → **acceptable**

---

## Pitfalls & Fixes
| Issue | Fix |
|------|-----|
| Wrong base-3 encoding | Use `mask / bit % 3` to get slot count |
| Forgetting capacity limit | Only assign if `count > 0` |
| Exponential blow-up | **DP + memoization** avoids recomputation |
| `pow(3, ns)` precision | Use **loop** to compute `3ⁿˢ` |

---

## Insight
**Base-3 mask = natural fit for capacity 2**

> Instead of tracking sets or multisets per slot → **encode usage in mask**

**Classic DP pattern:**  
> *"When capacity is small → use base-k mask"*

---

## Fichka Library Entry
**Category:** `Dynamic Programming / State Compression`  
**Pattern:** `Slot assignment with base-3 mask — maximize AND sum efficiently`


---

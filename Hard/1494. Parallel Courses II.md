# 1494. Parallel Courses II  
*O(2ⁿ × n) — Classic Bitmask DP with Subset Enumeration*

---

## Problem Statement

- You have `n` courses labeled from 1 to n (n ≤ 15).  
- You are given an array `relations` where `relations[i] = [prevCoursei, nextCoursei]` means you must take course `prevCoursei` **before** taking course `nextCoursei`.  
- You can take **at most k** courses in any single semester, as long as all prerequisites for those courses have been completed in previous semesters.
- Return the **minimum number of semesters** needed to take all courses.  
- The test cases are generated such that it is always possible to take every course (the graph is a directed acyclic graph / DAG).

---

## Core Idea — Bitmask DP with Subset Enumeration

- Since n ≤ 15, we can represent the set of completed courses as a **bitmask** (2¹⁵ = 32,768 states — very manageable).
- **dp[mask]** = minimum number of semesters needed to complete **exactly** the courses represented by the mask (bit j set means course j+1 is completed).
- **Base case**: dp[0] = 0 (no courses taken yet)

**Transition**:
- From current mask (already completed courses)
- Find all courses that can be taken **now**:
  - All their prerequisites are already completed
  - The course itself is not yet taken
- Enumerate **all non-empty subsets** of these available courses with size ≤ k
- For each valid subset S:
  - new_mask = mask | (bitmask of S)
  - dp[new_mask] = min(dp[new_mask], dp[mask] + 1)

**Final answer**: dp[(1 << n) - 1] — min semesters to complete **all** courses

**Optimization trick** for subset enumeration:
- Use the famous `(s - 1) & can` loop to iterate over all subsets of `can` efficiently
- Check subset size ≤ k using `BitOperations.PopCount`

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MinNumberOfSemesters(int n, int[][] relations, int k)  {
        // dp[mask] = min semesters to complete exactly the courses in mask
        List<int> dp = new List<int>(new int[1 << n]);
        for (int i = 0; i < (1 << n); i++) 
            dp[i] = n;  // large value acting as infinity

        // pre[j] = bitmask of prerequisites for course j (0-based)
        List<int> pre = new List<int>(new int[n]);
        foreach (var x in relations) {
            --x[0];  // convert to 0-based
            --x[1];
            pre[x[1]] |= 1 << x[0];
        }

        dp[0] = 0;
        // Iterate over all possible masks (completed courses)
        for (int i = 0; i < (1 << n); i++) {
            // Skip unreachable states
            if (dp[i] == n) continue;

            // Find all courses we can take now (prereqs satisfied, not taken)
            int can = 0;
            for (int j = 0; j < n; j++) {
                if ((pre[j] & i) == pre[j]) can |= (1 << j);
            }

            // Remove already taken courses
            can &= ~i;

            // Enumerate all non-empty subsets of 'can'
            for (int s = can; Convert.ToBoolean(s); s = ((s - 1) & can)){
                // Only take subsets with size <= k
                if (System.Numerics.BitOperations.PopCount((uint)s) <= k) {
                    int newMask = i | s;
                    dp[newMask] = Math.Min(dp[newMask], dp[i] + 1);
                }
            }
        }

        return dp[(1 << n) - 1];
    }
}
```

## Complexity Time Complexity:
- O(3ⁿ) worst-case
- O(2ⁿ × n) in practiceFor each of 2ⁿ masks: enumerate subsets of available courses
- Total subset enumerations ~3ⁿ (classic SOS DP behavior)
- n=15 → 2¹⁵ × 15 ≈ 500,000 operations — runs in millisecondsSpace ComplexityO(2ⁿ)dp array of size 1 << n = 32,768 (~128 KB)
- Optimal for n ≤ 15 — exponential time with small base is fully acceptable and extremely fast in practice.

# How This Code Works — Step-by-Step Explanation
## 1. Preprocessing

- pre[j] — bitmask of all prerequisite courses for course j (0-based)
- Relations are converted from 1-based to 0-based indices
- Bits are set in pre[next] for each prerequisite prev

## 2. DP Initialization

- dp[mask] = minimum semesters needed to complete exactly the courses in mask
- dp[0] = 0 (nothing completed)
- All other states initialized to n (a large value acting as infinity)

## 3. Main DP Loop

- Iterate over every possible mask (completed courses)
- Skip if dp[mask] is still infinity (unreachable state)
- Compute can — bitmask of courses we can take right now:
- Course j not yet taken
- All prerequisites of j are already in the current mask
- Remove already taken courses from can: can &= ~i
- Enumerate all non-empty subsets of can using the efficient subset iteration trick:C#for (int s = can; Convert.ToBoolean(s); s = ((s - 1) & can))
  
For each subset s:
- If size of s ≤ k (checked with BitOperations.PopCount)
- Compute newMask = mask | s
- Update dp[newMask] = min(dp[newMask], dp[mask] + 1)


## 4. Final Answer

```dp[(1 << n) - 1] — minimum semesters to complete all courses```
Correctness guarantees:

- Every valid combination of parallel courses is considered
- Prerequisite constraints are enforced via bitmask subset check
- Limit of k courses per semester is strictly respected
- No cycles possible (input is guaranteed DAG)

---

## Key Takeaway
This is a classic bitmask DP solution for course scheduling with parallel constraints:

- State: bitmask of completed courses (2ⁿ states)
- Precompute prerequisite bitmask for each course
- dp[mask] = minimum semesters to reach exactly this mask
  
From each mask:
- Find available courses (prereqs satisfied, not taken)
- Enumerate all non-empty subsets of size ≤ k using subset enumeration trick
- Transition: dp[mask | subset] = min(..., dp[mask] + 1)
- Final answer = dp[(1<<n)-1]

- Pure, clean, optimal — O(3ⁿ) worst-case but O(2ⁿ × n) in practice for n=15, extremely fast, elegant, and correct.

---

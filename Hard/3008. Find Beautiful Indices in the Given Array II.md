# 3008. Find Beautiful Indices in the Given Array II — C# Solution

---

##  Problem Restatement
We are given:
- A string `s` (length ≤ 5 * 10^5).
- Two substrings `a` and `b`.
- An integer `k`.

Definition:
- An index `i` is **beautiful** if:
  - `s[i..i+|a|-1] == a`
  - There exists an index `j` such that `s[j..j+|b|-1] == b` and `|i - j| ≤ k`.

Goal:
- Return all beautiful indices in sorted order.

---

##  Core Idea
- **Step 1: Scan the string once.**
  - When we encounter substring `a`, check if there is a recent `b` within distance `k`.
  - If yes → add index `i` to result.
  - If no → enqueue `i` into `aQue` for later matching.
- **Step 2: Handle substring `b`.**
  - When we encounter substring `b`, check if there are pending `a` indices in `aQue` within distance `k`.
  - Flush those indices into result.
  - Enqueue `j` into `bQue` for future matches.
- **Step 3: Special case.**
  - If all characters in `s`, `a`, and `b` are identical, then every index where `a` fits is beautiful.
- **Step 4: Return result.**
  - The scan is left‑to‑right, so results are naturally sorted.

---

##  Code (C#)
```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class Solution {
    public IList<int> BeautifulIndices(string s, string a, string b, int k) {
        Queue<int> aQue = new(), bQue = new();
        int len = s.Length, aLen = a.Length, bLen = b.Length;
        List<int> res = new();
        if (len < aLen || len < bLen) return res;

        // trivial case: all chars identical
        HashSet<char> sSet = new(s), aSet = new(a), bSet = new(b);
        if (sSet.Count == 1 && aSet.Count == 1 && bSet.Count == 1 &&
            sSet.First() == aSet.First() && aSet.First() == bSet.First()) {
            return Enumerable.Range(0, len - aLen + 1).ToList();
        }

        for (int i = 0; i < len; i++) {
            if (s[i] == a[0] && i + aLen <= len && s.Substring(i, aLen) == a) {
                while (bQue.Count > 0 && i - bQue.Peek() > k) bQue.Dequeue();
                if (bQue.Count > 0) res.Add(i);
                else aQue.Enqueue(i);
            }
            if (s[i] == b[0] && i + bLen <= len && s.Substring(i, bLen) == b) {
                while (aQue.Count > 0 && i - aQue.Peek() > k) aQue.Dequeue();
                while (aQue.Count > 0) res.Add(aQue.Dequeue());
                bQue.Enqueue(i);
            }
        }
        return res;
    }
}

```


##  Complexity
- **Single pass scan:** O(n)  
  The algorithm traverses the string once, maintaining queues for `a` and `b`.  
- **Substring checks:** O(|a| + |b|) per match (due to `Substring` comparisons).  
- **Queue operations:** O(n)  
  Each index is enqueued and dequeued at most once.  
- **Total:** O(n * max(|a|, |b|)) worst case.  
- **Space:** O(n) for queues and result list.  

---

##  Pitfalls
- **Substring overhead:**  
  Using `Substring` repeatedly can be costly for very large inputs.  
- **Edge case — identical characters:**  
  When `a == b` and all characters are identical, every valid position is beautiful.  
- **Bounds checking:**  
  Must ensure `i + aLen <= len` and `i + bLen <= len` to avoid out‑of‑range errors.  
- **Sorted output:**  
  Indices are added in natural order because the scan is left‑to‑right.  

---

##  Example Walkthrough
**Input:**  
`s = "isawsquirrelnearmysquirrelhouseohmy"`, `a = "my"`, `b = "squirrel"`, `k = 15`

**Step 1: Occurrences**  
- `"my"` at indices [16, 33]  
- `"squirrel"` at indices [4, 18]  

**Step 2: Queue logic**  
- At i = 16 (`"my"`), nearest `"squirrel"` at 4 → distance 12 ≤ 15 → add 16.  
- At i = 33 (`"my"`), nearest `"squirrel"` at 18 → distance 15 ≤ 15 → add 33.  

**Result:**  
[16, 33]  

---

##  Conclusion
- This solution applies **queue‑based proximity tracking** to determine beautiful indices in a single pass.  
- Special handling for trivial identical‑character cases ensures correctness.  
- Results are naturally sorted by scanning left to right.  
- While not the most optimal (due to `Substring` checks), the approach is clear, correct, and passes constraints.  



---


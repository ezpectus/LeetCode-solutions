# 730. Count Different Palindromic Subsequences — Architectural Interval DP + Precomputed Next/Prev  
*O(n²) — Optimal DP with Precomputation*

---

## Problem Statement

- Given a string `s` consisting **only of characters** `'a'`, `'b'`, `'c'`, `'d'` (length ≤ 1000), count the number of **different non-empty palindromic subsequences**.
- Return the answer **modulo 10⁹ + 7**.

**Important note**:  
Subsequences are considered **different** if their **content** (sequence of characters) differs — even if they come from different positions in the string.

**Examples**:
- `"bccb"` → 6 palindromic subsequences: `'b'`, `'c'`, `'bb'`, `'cc'`, `'bcb'`, `'bccb'`
- Repeated content like `'bcb'` is counted **once**

---

## Core Idea — Interval DP with Next/Prev Optimization

**Standard interval DP**:
- `dp[i][j]` = number of distinct palindromic subsequences in substring `s[i..j]`

**Classic recurrence** (naive):
- If `s[i] == s[j]` → combine inner palindromes with outer pair
- Else → union of left and right subintervals (subtract overlap)
This leads to **O(n³)** time if implemented directly.

**Key insight** — the alphabet has **only 4 characters**!

We can **precompute** for every position `i`:
- `next[i][c]` — closest position **≥ i** with character `c`
- `prev[i][c]` — closest position **≤ i** with character `c`

Then, when processing interval `[i, j]` and `s[i] == s[j] == c`:
- Let `L = next[i][c]` (first `c` at or after `i`)
- Let `R = prev[j][c]` (last `c` at or before `j`)
- All palindromic subsequences starting and ending with `c` are:
  - `"c"` (the outer pair)
  - `"cc"` (outer pair + any inner `c`)
  - Plus **all** palindromic subsequences **strictly inside** `[L+1 .. R-1]`

This allows us to **jump directly** to the inner interval → **no need** to iterate over all characters.
**Result**: full DP in **O(n²)** time.


---

##  Implementation (C#)

```csharp
public class Solution {
    const int MOD = 1000000007;

    public int CountPalindromicSubsequences(string s) {
        int n = s.Length;
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = s[i] - 'a';

        int[,] next = new int[n, 4];
        int[,] prev = new int[n, 4];

        // init next with -1
        for (int i = 0; i < n; i++)
            for (int c = 0; c < 4; c++)
                next[i, c] = -1;

        // init prev with -1
        for (int i = 0; i < n; i++)
            for (int c = 0; c < 4; c++)
                prev[i, c] = -1;

        // build prev
        int[] last = new int[4];
        Array.Fill(last, -1);
        for (int i = 0; i < n; i++) {
            last[arr[i]] = i;
            for (int c = 0; c < 4; c++)
                prev[i, c] = last[c];
        }

        // build next
        Array.Fill(last, -1);
        for (int i = n - 1; i >= 0; i--) {
            last[arr[i]] = i;
            for (int c = 0; c < 4; c++)
                next[i, c] = last[c];
        }

        int[,] dp = new int[n, n];

        for (int len = 1; len <= n; len++) {
            for (int i = 0; i + len - 1 < n; i++) {
                int j = i + len - 1;

                long sum = 0;

                for (int c = 0; c < 4; c++) {
                    int L = next[i, c];
                    int R = prev[j, c];

                    if (L == -1 || L > j) continue;

                    if (L == R) {
                        sum += 1; // single char palindrome
                    } else if (L < R) {
                        sum += 2; // "c" and "cc"
                        if (L + 1 <= R - 1)
                            sum += dp[L + 1, R - 1];
                    }
                }

                dp[i, j] = (int)(sum % MOD);
            }
        }

        return dp[0, n - 1];
    }
}
```

## Complexity

| **Metric**     | **Value**   | **Notes**                          |
|----------------|-------------|------------------------------------|
| **Time**       | **O(n²)**   | DP fill + O(n) precomputation      |
| **Space**      | **O(n²)**   | DP table                           |

**Optimal** — cannot be faster than O(n²) for interval DP.

---

## Why This Works — Key Insight

When `s[i] == s[j] == c`:

- We find **next occurrence** of `c` after `i` → `L`
- **previous** occurrence before `j` → `R`

Then:
- All palindromic subsequences starting/ending with this `c` are:
  - `"c"` (the outer pair itself)
  - `"cc"` (outer pair + any single `c` inside)
  - Plus **all** palindromic subsequences **strictly inside** `L+1..R-1`

This **avoids double-counting** and gives **exact count** in constant time per character.

**4-char alphabet** allows precomputing next/prev in O(n).

---

## Key Takeaway

This is a **masterpiece of interval DP optimization**:

- Use **next/prev occurrence** precomputation
- **Collapse** recurrence using direct jumps to inner interval
- Handle duplicates perfectly with **4-char alphabet**

**One of the most elegant Hard DP problems** — combines:
- Interval DP
- Precomputation
- Careful counting
**Pure brilliance.**

---




# 782. Transform to Chessboard — Architectural Solution

---

## Problem Statement
We are given an `n x n` binary grid.  
Allowed moves:
- Swap any two rows.
- Swap any two columns.  

Goal: Transform the board into a valid **chessboard pattern** (no two equal values adjacent horizontally or vertically).  
Return the minimum number of moves required, or `-1` if impossible.

Constraints:  
- 2 ≤ n ≤ 30  
- board[i][j] ∈ {0,1}  

---

## Core Idea
The chessboard pattern has strict structural rules:
- Each row must be either identical to the first row or its bitwise inverse.  
- Each column must be either identical to the first column or its bitwise inverse.  
- The counts of 0s and 1s in each row/column must differ by at most 1.  

Steps:
1. **Validate structure**: Check that all rows are either equal to the first row or its inverse. Same for columns. If not, return `-1`.  
2. **Count mismatches**: For rows and columns, count how many positions differ from the ideal alternating pattern.  
3. **Compute moves**:  
   - If `n` is even → minimum mismatches between pattern starting with 0 or 1.  
   - If `n` is odd → only one valid starting pattern (must match majority).  
   - Moves = mismatches / 2.  

This reduces the problem to counting and validating patterns instead of simulating swaps.

---

## Implementation (C#)
```csharp
using System;

public class Solution {
    public int MovesToChessboard(int[][] board) {
        int n = board.Length;

        // Check row structure
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if ((board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) != 0) {
                    return -1;
                }
            }
        }

        // Count row and column sums
        int rowSum = 0, colSum = 0, rowMis = 0, colMis = 0;
        for (int i = 0; i < n; i++) {
            rowSum += board[0][i];
            colSum += board[i][0];
            if (board[i][0] == i % 2) colMis++;
            if (board[0][i] == i % 2) rowMis++;
        }

        // Validate counts
        if (rowSum < n/2 || rowSum > (n+1)/2) return -1;
        if (colSum < n/2 || colSum > (n+1)/2) return -1;

        // Adjust mismatches for odd/even n
        if (n % 2 == 1) {
            if (rowMis % 2 == 1) rowMis = n - rowMis;
            if (colMis % 2 == 1) colMis = n - colMis;
        } else {
            rowMis = Math.Min(rowMis, n - rowMis);
            colMis = Math.Min(colMis, n - colMis);
        }

        return (rowMis + colMis) / 2;
    }
}
```


## Complexity Analysis
- **Time Complexity:** O(n²)  
  Validation requires scanning all cells once to ensure structural consistency.  
- **Space Complexity:** O(1)  
  Only counters and a few variables are used; no extra data structures proportional to n.

---

## Pitfalls & Edge Cases
- **Invalid structure**  
  If any row or column is not equal to the first row/column or its inverse, the task is impossible → return `-1`.  
- **Odd vs even n**  
  For odd sizes, only one valid starting pattern exists; for even sizes, both alternating patterns are possible.  
- **Mismatches counting**  
  Must divide by 2 because each swap fixes two misplaced elements.  
- **Edge cases**  
  Small boards (2x2), boards already valid, or boards that cannot be transformed must be handled explicitly.

---

## Conclusion
This solution validates the chessboard structure by checking XOR consistency across rows and columns.  
It then counts mismatches against alternating patterns and computes the minimum swaps required.  

Architecturally, the design is clean:
- **Validation** ensures feasibility.  
- **Counting mismatches** quantifies the required moves.  
- **Adjustment for odd/even n** ensures correctness.  

The algorithm runs in **O(n²)** time with **O(1)** space, making it efficient and elegant for boards up to size 30.


---

## üß† Problem: Replace Non-Coprime Numbers in Array  
**LeetCode #2197**  
**Difficulty:** Hard  
**Tags:** Stack, GCD, LCM, Number Theory

---

### üîç Problem Summary  
You're given an array of integers. The task is to repeatedly find adjacent **non-coprime** numbers and replace them with their **Least Common Multiple (LCM)**.  
Two numbers are non-coprime if their **Greatest Common Divisor (GCD)** is greater than 1.

This process continues until no adjacent non-coprime pairs remain. The final array must reflect all such replacements.  
Importantly, the order in which replacements are made does not affect the final result ‚Äî it is **deterministic**.

---

### üß± Architectural Insight  
This problem behaves like a **signal-processing loop**, where each number interacts with its neighbor and may trigger a merge.  
The key is to use a **stack** to track processed values and allow backtracking when merges occur.

---

### üîß Core Strategy:
- Traverse the array from left to right.
- Maintain a stack of processed values.
- For each new number:
  - Compare it with the top of the stack.
  - If they are non-coprime (i.e., `GCD(top, current) > 1`), pop the top and replace both with their LCM.
  - Repeat this merge until the top becomes coprime with the current value.
- Push the final merged value onto the stack.

This guarantees that all adjacent non-coprime merges are handled correctly and efficiently.

---

### üìê Mathematical Foundation  
To compute the **Least Common Multiple (LCM)** of two integers \( a \) and \( b \), use the identity:


**LCM(a, b) = (a * b) / GCD(a, b)**


This formula ensures that the merged value is the smallest number divisible by both \( a \) and \( b \),  
and avoids overflow if you divide before multiplying.

---

### ‚öôÔ∏è Why Stack Works  
- The stack allows you to **revisit previous merges** if a new number interacts with older ones.  
- It mimics a **rolling window** of coprimality checks.  
- Efficient for **backtracking** and avoids unnecessary full-array scans.

---

### üß† Key Takeaways  
- **GCD-based merging** ensures correctness and avoids false merges.  
- **Stack structure** enables efficient local rewrites and backtracking.  
- The final array is **unique**, regardless of merge order ‚Äî a powerful property that simplifies implementation.  
- This problem reinforces **modular thinking** and clean **number-theoretic design**.


## üí° C# Solution
```csharp
public class Solution {
    public IList<int> ReplaceNonCoprimes(int[] nums) {
        var stack = new List<int>();

        foreach (int num in nums) {
            int curr = num;

            while (stack.Count > 0) {
                int last = stack[stack.Count - 1];
                int g = GCD(last, curr);
                if (g == 1) break;

                stack.RemoveAt(stack.Count - 1);
                curr = (last / g) * curr; // LCM without overflow
            }

            stack.Add(curr);
        }

        return stack;
    }

    private int GCD(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```
## üß≠ Reflection

- This problem helped reinforce modular number theory and stack-based merging.
- I optimized the LCM calculation to avoid overflow by dividing before multiplying.
- The final array is guaranteed to be unique regardless of merge order ‚Äî a subtle but powerful property.
- I wrote the code in C# with clean structure and readable logic, avoiding unnecessary complexity.


### üíª Code Design & Implementation

The solution was implemented in **C#**, using a clean and modular structure that emphasizes readability and correctness.  
I chose to use a **List-based stack** to simulate dynamic merging behavior, allowing efficient backtracking when adjacent values are non-coprime.

Key implementation choices:
- The `GCD` function is written iteratively for performance and clarity.
- LCM is computed safely by dividing before multiplying to avoid overflow.
- Stack operations are handled explicitly using `RemoveAt` and `Add`, ensuring full control over the merge logic.
- Variable naming is kept intuitive (`curr`, `last`, `g`) to reflect the flow of merging and comparison.

This approach avoids unnecessary complexity and makes the logic easy to follow, even for someone unfamiliar with number theory.  
The final code is concise, robust, and ready for production or interview-level review.


---

# 1928. Minimum Cost to Reach Destination in Time

**Difficulty:** Hard  
**Topics:** Graph, Dijkstra, Dynamic Programming  

---

##  Problem Restatement
We have `n` cities connected by bidirectional roads.  
- Each road has a travel time.  
- Each city has a passing fee.  
- Starting at city `0`, we want to reach city `n-1` within `maxTime` minutes.  
- The cost is the sum of fees for all visited cities (including start and destination).  

Return the minimum cost, or `-1` if impossible.

---

##  Core Idea
- This is a **shortest path problem with time constraint**.  
- State = `(node, time)`.  
- Use **Dijkstra‑style search** with a priority queue:  
  - Priority = current cost.  
  - Transition: move to neighbor if `time + edgeTime ≤ maxTime`.  
  - Update cost if cheaper.  

---

##  C# Implementation
```csharp
public class Solution {
    public int MinCost(int maxTime, int[][] edges, int[] passingFees) {
        int n = passingFees.Length;

        // Build adjacency list: graph[node] -> (neighbor, travelTime)
        var graph = new List<(int,int)>[n];
        for (int i = 0; i < n; i++) graph[i] = new List<(int,int)>();
        foreach (var e in edges) {
            graph[e[0]].Add((e[1], e[2]));
            graph[e[1]].Add((e[0], e[2]));
        }

        // dp[node][time] = min cost to reach node at exact time
        int[,] dp = new int[n, maxTime+1];
        for (int i = 0; i < n; i++)
            for (int t = 0; t <= maxTime; t++)
                dp[i,t] = int.MaxValue;

        var pq = new PriorityQueue<(int cost,int node,int time), int>();
        dp[0,0] = passingFees[0];
        pq.Enqueue((passingFees[0], 0, 0), passingFees[0]);

        while (pq.Count > 0) {
            var (cost, node, time) = pq.Dequeue();
            if (node == n-1) return cost;

            foreach (var (nei, tEdge) in graph[node]) {
                int newTime = time + tEdge;
                if (newTime <= maxTime) {
                    int newCost = cost + passingFees[nei];
                    if (newCost < dp[nei,newTime]) {
                        dp[nei,newTime] = newCost;
                        pq.Enqueue((newCost, nei, newTime), newCost);
                    }
                }
            }
        }
        return -1;
    }
}
```

##  Complexity Analysis

- **Time Complexity:**  
  The algorithm explores states `(node, time)` where `node` is a city and `time` is the total minutes spent so far.  
  - There are at most `n × maxTime` states.  
  - Each edge can be relaxed multiple times, but priority queue ensures efficient extraction.  
  - Overall complexity is `O(n × maxTime + edges × log(n × maxTime))`, which simplifies to about `O(n × maxTime)` in practice.  

- **Space Complexity:**  
  We store a DP table `dp[node][time]` with dimensions `n × maxTime`.  
  - This requires `O(n × maxTime)` memory.  
  - Additionally, adjacency list and priority queue add `O(n + edges)` space.  

---

##  Pitfalls

- **Track full state:**  
  Must track `(node, time)` instead of just `(node)`.  
  Different arrival times can lead to different costs, so ignoring time loses valid solutions.  

- **Passing fee logic:**  
  Passing fee is added every time you enter a city, including the start and destination.  
  Forgetting to add fees correctly leads to wrong totals.  

- **Time constraint:**  
  If no path reaches the destination within `maxTime`, return `-1`.  
  It’s not enough to find the cheapest path — it must also respect the time limit.  

---

##  Example Walkthrough

**Input:**  
`maxTime = 30`  
`edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]]`  
`passingFees = [5,1,2,20,20,3]`  

**Step‑by‑step:**  
- Start at city `0` → fee = 5.  
- Path `0 → 1 → 2 → 5`:  
  - Travel times: 10 + 10 + 10 = 30 minutes.  
  - Fees: 5 (city 0) + 1 (city 1) + 2 (city 2) + 3 (city 5) = 11.  
- This path fits within `maxTime` and has the minimum cost.  

**Output:**  
`11`  

---

##  Key Takeaway

- This problem is a **Dijkstra variant** on an expanded state space `(node, time)`.  
- **Pattern:** shortest path with resource constraint.  
- Solution uses:  
  - Priority queue for efficient state expansion.  
  - DP table to track minimal cost for each `(node, time)` state.  
- Clean and reliable approach for constrained shortest path problems.  


---



# 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree

##  Problem Summary
We are given:
- A weighted undirected connected graph with `n` vertices numbered from `0` to `n - 1`.
- An array `edges` where `edges[i] = [ai, bi, weighti]` represents a bidirectional weighted edge.

**Definitions:**
- A **Minimum Spanning Tree (MST)** is a subset of edges that connects all vertices without cycles and with minimum total weight.
- A **critical edge**: removing it increases the MST weight.
- A **pseudo-critical edge**: can appear in some MSTs but not all.

**Goal:**  
Return two lists:
1. Critical edges.
2. Pseudo-critical edges.  
Order does not matter.

---

##  Core Idea
1. Attach original indices to edges for tracking.
2. Sort edges by weight.
3. Compute MST weight using Kruskal’s algorithm.
4. For each edge:
   - **Critical check:** Remove edge → if MST weight increases, it’s critical.
   - **Pseudo-critical check:** Force edge inclusion → if MST weight stays the same, it’s pseudo-critical.
5. Return both lists.

---

##  Code (C#)

```csharp
public class Solution {
    public IList<IList<int>> FindCriticalAndPseudoCriticalEdges(int n, int[][] edges) {
        // Attach original indices to edges
        for (int i = 0; i < edges.Length; i++) {
            edges[i] = new int[] { edges[i][0], edges[i][1], edges[i][2], i };
        }

        // Sort edges by weight
        Array.Sort(edges, (a, b) => a[2].CompareTo(b[2]));

        // Compute MST weight
        int mstWeight = Kruskal(n, edges, -1, -1);

        var critical = new List<int>();
        var pseudoCritical = new List<int>();

        // Check each edge
        for (int i = 0; i < edges.Length; i++) {
            // Critical: removing edge increases MST weight
            if (Kruskal(n, edges, i, -1) > mstWeight) {
                critical.Add(edges[i][3]);
            }
            // Pseudo-critical: forcing edge keeps MST weight
            else if (Kruskal(n, edges, -1, i) == mstWeight) {
                pseudoCritical.Add(edges[i][3]);
            }
        }

        return new List<IList<int>> { critical, pseudoCritical };
    }

    private int Kruskal(int n, int[][] edges, int skipIndex, int forceIndex) {
        var uf = new UnionFind(n);
        int totalWeight = 0;
        int edgesUsed = 0;

        // Force edge if specified
        if (forceIndex != -1) {
            int[] e = edges[forceIndex];
            if (uf.Union(e[0], e[1])) {
                totalWeight += e[2];
                edgesUsed++;
            }
        }

        // Process edges
        for (int i = 0; i < edges.Length; i++) {
            if (i == skipIndex) continue;
            int[] e = edges[i];
            if (uf.Union(e[0], e[1])) {
                totalWeight += e[2];
                edgesUsed++;
            }
        }

        return edgesUsed == n - 1 ? totalWeight : int.MaxValue;
    }
}

public class UnionFind {
    private int[] parent;
    private int[] rank;

    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
    }

    public int Find(int x) {
        if (parent[x] != x) parent[x] = Find(parent[x]);
        return parent[x];
    }

    public bool Union(int x, int y) {
        int rootX = Find(x), rootY = Find(y);
        if (rootX == rootY) return false;

        if (rank[rootX] < rank[rootY]) parent[rootX] = rootY;
        else if (rank[rootX] > rank[rootY]) parent[rootY] = rootX;
        else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        return true;
    }
}
```

##  Complexity
- **Sorting edges:** O(E log E)  
- **Kruskal per check:** O(E α(V)) (α = inverse Ackermann, ~constant)  
- **Total:** O(E²) in worst case (since we run Kruskal for each edge)  
- **Memory:** O(V + E)  

---

##  Pitfalls
- Must attach original indices before sorting.  
- Use Union-Find with path compression for efficiency.  
- Handle disconnected graphs by returning `int.MaxValue` when MST not possible.  

---

##  Sanity Checks
- Input: `n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]`  
  Output: `[[0,1],[2,3,4,5]]`  

- Input: `n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]`  
  Output: `[[],[0,1,2,3]]`  

---

##  Key takeaway
This problem reduces to **MST edge classification**:

- **Critical edges:** must appear in all MSTs.  
- **Pseudo-critical edges:** can appear in some MSTs.  

By combining **Kruskal’s algorithm** with **Union-Find**, we can efficiently classify edges into these two categories.


---

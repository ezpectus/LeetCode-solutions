# Pattern Name
**Rerooted DFS with Edge Guess Validation**

## Problem Summary
- **Input**:
  - Tree with `n` nodes via `edges`
  - List of **directed edge guesses** `guesses[i] = [parent, child]`
  - Integer `k` — **minimum number of correct guesses**
- **Goal**:  
  Count how many nodes can be chosen as **root** so that **at least `k` guesses are correct** when the tree is rooted there

## Core Idea
- Treat **guesses as directed edges**
- **Root the tree at node 0** and count correct guesses via DFS
- **Reroot the tree** using second DFS:
  - **Adjust guess count** based on **edge direction**
  - Track how many roots yield **≥ k correct guesses**

## Strategy Summary
- **Build undirected tree** from `edges`
- **Store guesses** in a `HashSet<(parent, child)>`
- **First DFS**:
  - Count correct guesses when **rooted at 0**
- **Second DFS**:
  - **Reroot tree** and **update guess count dynamically**
  - If `count ≥ k`, **increment result**

## C# Implementation
```csharp
public class Solution {
    Dictionary<(int, int), bool> guessSet = new();
    List<int>[] tree;
    int res = 0, k;

    public int RootCount(int[][] edges, int[][] guesses, int k) {
        int n = edges.Length + 1;
        this.k = k;

        tree = new List<int>[n];
        for (int i = 0; i < n; i++) tree[i] = new List<int>();
        foreach (var e in edges) {
            tree[e[0]].Add(e[1]);
            tree[e[1]].Add(e[0]);
        }

        foreach (var g in guesses)
            guessSet[(g[0], g[1])] = true;

        int correct = DFS1(0, -1);
        DFS2(0, -1, correct);

        return res;
    }

    int DFS1(int u, int parent) {
        int count = 0;
        foreach (var v in tree[u]) {
            if (v == parent) continue;
            if (guessSet.ContainsKey((u, v))) count++;
            count += DFS1(v, u);
        }
        return count;
    }

    void DFS2(int u, int parent, int curr) {
        if (curr >= k) res++;

        foreach (var v in tree[u]) {
            if (v == parent) continue;

            int next = curr;
            if (guessSet.ContainsKey((u, v))) next--;
            if (guessSet.ContainsKey((v, u))) next++;

            DFS2(v, u, next);
        }
    }
}
```

## Architectural Breakdown
| Component     | Role                                      |
|---------------|-------------------------------------------|
| `DFS1`        | Counts correct guesses from **root 0**    |
| `DFS2`        | **Reroots tree** and updates guess count |
| `guessSet`    | Stores directed guesses as `(parent, child)` |
| `res`         | Final count of **valid root nodes**       |

## Why This Approach Is Superior
| Aspect              | **Rerooted DFS**     | Brute Force Rooting     |
|---------------------|-----------------------|--------------------------|
| Time Complexity     | **O(n)**              | O(n²)                    |
| Space Complexity    | **O(n + g)**          | O(n²)                    |
| Performance         | Linear and scalable   | Breaks on large trees    |
| Clarity             | Modular and reusable  | Hard to trace            |

## Final Takeaway
- **This pattern generalizes to**:
  - **Rerooted tree problems**
  - **Edge-based validation**
  - **Dynamic state propagation** across tree structure
 
  ---

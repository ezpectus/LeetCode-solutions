# 1377. Frog Position After T Seconds

---

## Problem Summary
We are given an undirected tree with `n` vertices.  
- A frog starts at vertex `1`.  
- Each second, it jumps to an **unvisited neighbor** with equal probability.  
- If no unvisited neighbors exist, the frog stays at the current vertex forever.  
- Task: return the probability that after `t` seconds the frog is at `target`.  

---

## Core Idea
- Build adjacency list for the tree.  
- Perform **DFS (or BFS)** to simulate frog movement with probabilities.  
- At each node:  
  - Probability is divided equally among unvisited children.  
  - If frog reaches `target`:  
    - If `t == 0` → return current probability.  
    - If `t > 0` but node has children → probability continues to spread, so only valid if frog can stay.  
    - If `t > 0` and node has no children → frog stays here, probability remains.  

---

## C++ Implementation
```cpp
class Solution {
public:
    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {
        vector<vector<int>> adj(n + 1);
        for (auto &e : edges) {
            adj[e[0]].push_back(e[1]);
            adj[e[1]].push_back(e[0]);
        }
        
        vector<bool> visited(n + 1, false);
        double ans = 0.0;
        
        function<void(int,int,double)> dfs = [&](int node, int time, double prob) {
            visited[node] = true;
            if (time == t) {
                if (node == target) ans = prob;
                return;
            }
            
            int unvisitedChildren = 0;
            for (int nei : adj[node]) {
                if (!visited[nei]) unvisitedChildren++;
            }
            
            if (unvisitedChildren == 0) {
                // Frog stays here forever
                if (node == target) ans = prob;
                return;
            }
            
            for (int nei : adj[node]) {
                if (!visited[nei]) {
                    dfs(nei, time + 1, prob / unvisitedChildren);
                }
            }
        };
        
        dfs(1, 0, 1.0);
        return ans;
    }
};
```
## Complexity
- **Time:** O(n) — DFS visits each node once.  
- **Space:** O(n) — adjacency list plus recursion stack.  

---

## Pitfalls
- Must handle the case where frog reaches `target` early but still has time left:  
  - If `target` has unvisited children, frog will leave → probability = 0.  
  - If `target` has no unvisited children, frog stays → probability remains.  
- Ensure probabilities are divided equally among unvisited children.  
- **Edge case:** `t = 0` → frog must be at root (vertex 1).  

---

## Example Walkthrough
**Input:** `n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4`  

- **Step 0:** Frog at node 1, probability = 1.0.  
- **Step 1:** Frog jumps to {2,3,7}, each with probability = 1/3.  
- **Step 2:** From node 2, frog jumps to {4,6}, each with probability = (1/3) * (1/2) = 1/6.  
- Frog at node 4 with probability = 1/6 = 0.166666...  

**Output:** `0.1666666667`  

---

## Conclusion
The problem reduces to a **DFS probability distribution** across tree nodes.  
- Each step divides probability among unvisited children.  
- Special handling when frog reaches `target` early ensures correctness.  
- Runs in **O(n)** time and **O(n)** space, efficient for `n ≤ 100`.  



---

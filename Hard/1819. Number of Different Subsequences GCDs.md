# ðŸ”º Problem: Number of Different Subsequences GCDs (Leetcode 1819)

## ðŸ“œ Statement

You are given an array `nums` consisting of positive integers.

A **subsequence** is any sequence formed by deleting zero or more elements from the array.

The **GCD** of a sequence is the greatest integer that divides all its elements.

Return the number of **distinct GCDs** that can be formed from **non-empty subsequences** of `nums`.

---

## ðŸ§  Core Idea

This is a **divisibility-based scan**, not a brute-force subset enumeration.

We observe:

- There are at most `max(nums)` possible GCDs.
- For each candidate `g`, we check whether there exists a subsequence whose GCD is exactly `g`.

Instead of generating all subsequences, we:

1. Mark all numbers present in `nums`.
2. For each `g` from `1` to `max(nums)`:
   - Scan all multiples of `g` in `nums`.
   - Compute running `GCD` of those multiples.
   - If the final `GCD == g`, then `g` is achievable.

> This is not subset simulation â€” itâ€™s **GCD reachability via multiples**.

---

## ðŸ§ª Examples

```text
Input: nums = [6,10,3]
â†’ Possible subsequence GCDs: [6], [10], [3], [6,10], [6,3], [10,3], [6,10,3]
â†’ GCDs: 6, 10, 3, 2, 1 â†’ Output: 5

Input: nums = [5,15,40,5,6]
â†’ Output: 7
```

## ðŸ§± C# Implementation
```cpp
public class Solution {
    public int CountDifferentSubsequenceGCDs(int[] nums) {
        int max = nums.Max();
        bool[] present = new bool[max + 1];
        foreach (int num in nums) present[num] = true;

        int count = 0;
        for (int g = 1; g <= max; g++) {
            int gcd = 0;
            for (int multiple = g; multiple <= max; multiple += g) {
                if (present[multiple]) {
                    gcd = GCD(gcd, multiple);
                    if (gcd == g) break;
                }
            }
            if (gcd == g) count++;
        }
        return count;
    }

    private int GCD(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

## ðŸ” Why This Code Is Optimized

### âœ… GCD Reachability
Scans all possible GCDs from `1` to `max(nums)`  
Uses presence array for O(1) lookup

### ðŸ” Multiples Scan
For each candidate `g`, checks all `g, 2g, 3g, ...`  
Avoids subset generation entirely

### ðŸ§® Efficient GCD
Euclidean algorithm â€” fast and stable  
Breaks early if `gcd == g`

### ðŸ§  Minimal State
No recursion, no subset tracking  
Pure arithmetic and control flow

---

## ðŸ§® Time & Space Complexity

| Metric      | Value             | Notes                                      |
|-------------|-------------------|--------------------------------------------|
| Time        | O(max Ã— log(max)) | Each `g` scans its multiples with GCD ops  |
| Space       | O(max)            | Presence array                             |
| Stability   | High              | Deterministic, no branching                |
| Scalability | Excellent         | Handles full input range up to 2Ã—10âµ       |

---

## ðŸ§  Engineering Takeaway

This task is a clean example of:

- âœ… **Divisibility-based filtering** â€” no subset simulation  
- ðŸ”¢ **GCD reachability** â€” check if `g` can be formed from multiples  
- ðŸ§  **Minimalist design** â€” fast, readable, and extensible  
- ðŸš€ **Early termination** â€” break once `gcd == g`

> Youâ€™re not generating subsequences â€” youâ€™re **probing the GCD space with precision**.

---

## ðŸ§© Conclusion

**Number of Different Subsequences GCDs** is a classic example of how **mathematical insight**  
can replace brute-force enumeration.  
By scanning possible GCDs and checking reachability via multiples,  
we achieve a clean and efficient solution.

> **Architecture over simulation â€” always.**



---

# 🔺 Problem: Number of Different Subsequences GCDs (Leetcode 1819)

## 📜 Statement

You are given an array `nums` consisting of positive integers.

A **subsequence** is any sequence formed by deleting zero or more elements from the array.

The **GCD** of a sequence is the greatest integer that divides all its elements.

Return the number of **distinct GCDs** that can be formed from **non-empty subsequences** of `nums`.

---

## 🧠 Core Idea

This is a **divisibility-based scan**, not a brute-force subset enumeration.

We observe:

- There are at most `max(nums)` possible GCDs.
- For each candidate `g`, we check whether there exists a subsequence whose GCD is exactly `g`.

Instead of generating all subsequences, we:

1. Mark all numbers present in `nums`.
2. For each `g` from `1` to `max(nums)`:
   - Scan all multiples of `g` in `nums`.
   - Compute running `GCD` of those multiples.
   - If the final `GCD == g`, then `g` is achievable.

> This is not subset simulation — it’s **GCD reachability via multiples**.

---

## 🧪 Examples

```text
Input: nums = [6,10,3]
→ Possible subsequence GCDs: [6], [10], [3], [6,10], [6,3], [10,3], [6,10,3]
→ GCDs: 6, 10, 3, 2, 1 → Output: 5

Input: nums = [5,15,40,5,6]
→ Output: 7
```

## 🧱 C# Implementation
```cpp
public class Solution {
    public int CountDifferentSubsequenceGCDs(int[] nums) {
        int max = nums.Max();
        bool[] present = new bool[max + 1];
        foreach (int num in nums) present[num] = true;

        int count = 0;
        for (int g = 1; g <= max; g++) {
            int gcd = 0;
            for (int multiple = g; multiple <= max; multiple += g) {
                if (present[multiple]) {
                    gcd = GCD(gcd, multiple);
                    if (gcd == g) break;
                }
            }
            if (gcd == g) count++;
        }
        return count;
    }

    private int GCD(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

## 🔍 Why This Code Is Optimized

### ✅ GCD Reachability
Scans all possible GCDs from `1` to `max(nums)`  
Uses presence array for O(1) lookup

### 🔁 Multiples Scan
For each candidate `g`, checks all `g, 2g, 3g, ...`  
Avoids subset generation entirely

### 🧮 Efficient GCD
Euclidean algorithm — fast and stable  
Breaks early if `gcd == g`

### 🧠 Minimal State
No recursion, no subset tracking  
Pure arithmetic and control flow

---

## 🧮 Time & Space Complexity

| Metric      | Value             | Notes                                      |
|-------------|-------------------|--------------------------------------------|
| Time        | O(max × log(max)) | Each `g` scans its multiples with GCD ops  |
| Space       | O(max)            | Presence array                             |
| Stability   | High              | Deterministic, no branching                |
| Scalability | Excellent         | Handles full input range up to 2×10⁵       |

---

## 🧠 Engineering Takeaway

This task is a clean example of:

- ✅ **Divisibility-based filtering** — no subset simulation  
- 🔢 **GCD reachability** — check if `g` can be formed from multiples  
- 🧠 **Minimalist design** — fast, readable, and extensible  
- 🚀 **Early termination** — break once `gcd == g`

> You’re not generating subsequences — you’re **probing the GCD space with precision**.

---

## 🧩 Conclusion

**Number of Different Subsequences GCDs** is a classic example of how **mathematical insight**  
can replace brute-force enumeration.  
By scanning possible GCDs and checking reachability via multiples,  
we achieve a clean and efficient solution.

> **Architecture over simulation — always.**



---

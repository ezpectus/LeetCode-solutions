# 1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits

## Problem  
Given a string `num` representing a non-negative integer and an integer `k`, you may perform at most `k` adjacent swaps on its digits. Return the lexicographically smallest possible string (integer) obtainable after at most `k` swaps.

Constraints (typical):
- `1 <= num.length <= 10^5` (or smaller in some variants)
- `0 <= k <= 10^9` (or smaller)
- `num` contains digits `'0'..'9'`.

---

## Architecture idea  
Greedily place the smallest digit possible at each position by scanning up to `k` distance ahead; when a smaller digit is chosen, move it left using the required adjacent swaps and decrease `k` accordingly.

---

## Explanation and reasoning 
- At each target position `i` (from left to right), we can only bring a digit from positions `j` with `j - i <= k` because each left-by-one adjacent move consumes one swap.  
- Among those reachable positions we should choose the smallest digit (tie-break by earliest occurrence) — placing the smallest available digit at `i` is always optimal for lexicographic minimality.  
- After moving that chosen digit from `minIndex` to `i`, we spend `minIndex - i` swaps and continue to the next `i` with the remaining `k`.  
- Stop early if `k` becomes 0 or we finish the string.

This greedy is correct because a smaller digit earlier in the string strictly improves the final lexicographic order and using the cheapest reachable occurrence of the minimal digit preserves more swap budget for later positions.

---

## C# implementation 

```csharp
public class Solution {
    public string MinInteger(string num, int k) {
        char[] digits = num.ToCharArray();
        int n = digits.Length;

        for (int i = 0; i < n && k > 0; i++) {
            // Find the smallest digit within the next k positions (including i)
            int minIndex = i;
            for (int j = i + 1; j < n && j <= i + k; j++) {
                if (digits[j] < digits[minIndex]) {
                    minIndex = j;
                }
            }

            // Move the smallest found digit left to position i (if needed)
            if (minIndex != i) {
                int swapsNeeded = minIndex - i;
                if (swapsNeeded <= k) {
                    char minChar = digits[minIndex];
                    for (int j = minIndex; j > i; j--) {
                        digits[j] = digits[j - 1];
                    }
                    digits[i] = minChar;
                    k -= swapsNeeded;
                }
            }
        }

        return new string(digits);
    }
}
```

## Example 

Input: `num = "4321"`, `k = 4`

- i = 0: look up to index `0 + 4` → choose `'1'` at index 3, move it to front using 3 swaps → `"1432"`, `k = 1`  
- i = 1: with `k = 1` look up to index `2` → no digit smaller than `'4'` is within reach (except `'3'` which is not smaller than `'4'` in this position), so no beneficial move  
- Result: `"1432"`

---

## Complexity

- Time: O(n * min(n, k)) worst-case. For each position we scan up to `k` positions ahead, so for small `k` the cost is ≈ O(n·k); for `k = O(n)` this can be O(n²).  
- Space: O(n) — in-place char array plus small overhead.

---

## Pitfalls 

- The naive scan-and-shift approach is simple and works fine for moderate `n` and `k` (e.g., `n` up to a few thousands).  
- For large inputs (`n` up to 10^5 and `k` large) the O(n²) worst-case can time out.  
- Careful with indexing and swap counts: moving a digit at `pos` to `i` consumes exactly `pos - i` adjacent swaps.  
- Use strict checks `swapsNeeded <= k` before performing the shift to avoid overspending `k`.

---

## Optimizations (when n or k are large)

Use a per-digit queue + Fenwick tree (BIT) to compute effective swaps in O(log n) and obtain an overall O(n log n) solution.

Outline (BIT + digit-queues):

1. Preprocess:
   - For each digit `d` in `0..9`, maintain a queue of indices where `num[index] == d` (in increasing index order).

2. Data structure:
   - Fenwick tree (BIT) of length `n` tracks how many positions have been removed/used. BIT supports:
     - `sum(pos)`: number of removed positions with index ≤ pos (or count of used positions before pos).
     - `add(pos, 1)`: mark position `pos` as removed when selected.

3. For each target position `i` from 0 to n-1:
   - Try digits `d = 0..9` in increasing order:
     - If the queue for `d` is empty, continue.
     - Let `pos` be the earliest index from the queue (peek, not pop yet).
     - Compute `removedBeforePos = sum(pos - 1)` (how many selected positions lie before `pos`).
     - Effective swaps needed = `pos - i - removedBeforePos`.
     - If `effectiveSwaps <= k`:
       - Pop `pos` from the queue (consume it).
       - `add(pos, 1)` in BIT to mark it removed.
       - Place digit `d` at current output position `i`.
       - `k -= effectiveSwaps`.
       - Break out of digit loop and proceed to next `i`.
     - Else: this `pos` is not reachable within remaining `k`; try next digit.
   - If no digit is reachable within `k`, copy the original digit at the smallest remaining index (or finish).

4. Continue until all positions assigned or `k` becomes zero.

Properties:
- Each index is removed exactly once; BIT updates/queries cost O(log n) each.
- Trying up to 10 digits per position yields O(10 · n · log n) = O(n log n) time.
- Space: O(n) for queues + BIT.

This BIT + digit-queues pattern is the standard scalable solution for the problem when `n` and `k` are large.



---

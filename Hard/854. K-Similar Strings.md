#  Pattern Name  
**Minimal Swap BFS for K-Similar Strings**

---

##  Problem Overview  
Two strings `s1` and `s2` are **k-similar** if we can transform `s1` into `s2` using exactly `k` swaps of characters.  
Each swap exchanges two characters at different positions.  
**Goal:** Find the minimal `k` such that `s1` becomes `s2`.

---

##  What’s Given

| Element     | Description                                      |
|-------------|--------------------------------------------------|
| `s1`, `s2`  | Two strings of equal length, guaranteed to be anagrams |
| Swap        | Any two positions can be swapped                 |
| Constraint  | Only lowercase letters `'a'` to `'f'`, length ≤ 20 |

---

##  Problem Anatomy

| Component        | Role                                                   |
|------------------|--------------------------------------------------------|
| BFS state        | `(string, index)` — current config and mismatch pointer |
| Transition       | Swap `s1[idx]` with any `s1[j]` where `s1[j] == s2[idx]` |
| Deduplication    | `HashSet<string>` to avoid revisiting states           |
| Termination      | When current string equals `s2`                        |

---

##  C# Implementation

```csharp
public class Solution {
    public int KSimilarity(string s1, string s2) {
        if (s1 == s2) return 0;

        var seen = new HashSet<string>();
        var q = new Queue<(string curr, int idx)>();
        q.Enqueue((s1, 0));
        seen.Add(s1);

        int steps = 0;
        while (q.Count > 0) {
            int count = q.Count;
            for (int i = 0; i < count; i++) {
                var (curr, idx) = q.Dequeue();
                if (curr == s2) return steps;

                while (idx < curr.Length && curr[idx] == s2[idx]) idx++;
                for (int j = idx + 1; j < curr.Length; j++) {
                    if (curr[j] == s2[idx] && curr[j] != s2[j]) {
                        char[] ch = curr.ToCharArray();
                        (ch[idx], ch[j]) = (ch[j], ch[idx]);
                        string next = new string(ch);
                        if (seen.Add(next)) q.Enqueue((next, idx + 1));
                    }
                }
            }
            steps++;
        }

        return -1;
    }
}
```


##  Time and Space Complexity

| Metric           | Value     | Explanation                                      |
|------------------|-----------|--------------------------------------------------|
| Time Complexity  | O(n!)     | Worst-case BFS over all permutations (n ≤ 20)    |
| Space Complexity | O(n!)     | HashSet and queue store unique configurations    |

---

## Implementation Commentary

- Mismatch pointer (`idx`) skips already matched prefix — reduces branching  
- Swap pruning: only swap with `s2[idx]` and skip redundant matches  
- State deduplication via `HashSet<string>` prevents cycles  
- Early exit when `curr == s2` — ensures minimal swap count  
- Tuple-based BFS keeps both string and progress index cleanly

---

##  Final Takeaway

This is a **bounded BFS over permutation space**, optimized for minimal swap transitions:

- Each state is a string with a mismatch pointer  
- Transitions are targeted swaps that reduce mismatch  
- BFS ensures shortest path (minimal `k`) is found  
- Pattern generalizes to any **string transformation** with **local swap rules**



---

# 1074. Number of Submatrices That Sum to Target

---

## Problem
We are given a 2D matrix and a target integer.  
We need to count the number of **non-empty submatrices** whose sum equals the target.

---

## Key Idea
This problem is an extension of the **subarray sum equals target** problem into 2D.

### Step 1: Reduce to 1D
- Fix two row boundaries `top` and `bottom`.  
- For each column, compute the sum of elements between these two rows.  
- This collapses the 2D submatrix problem into a 1D array problem (column sums).

### Step 2: Count subarrays with sum = target
- Use a **prefix sum + hashmap** approach (same as "Subarray Sum Equals K").  
- For each collapsed array, count how many subarrays equal the target.  

### Step 3: Iterate over all row pairs
- For each pair `(top, bottom)`, collapse into 1D and count.  
- Accumulate results.

---

## Code (C#)
```csharp
public class Solution {
    public int NumSubmatrixSumTarget(int[][] matrix, int target) {
        int rows = matrix.Length;
        int cols = matrix[0].Length;
        int res = 0;

        // Iterate over all pairs of rows
        for (int top = 0; top < rows; top++) {
            int[] colSum = new int[cols];
            for (int bottom = top; bottom < rows; bottom++) {
                // Update column sums for current row range
                for (int c = 0; c < cols; c++) {
                    colSum[c] += matrix[bottom][c];
                }

                // Count subarrays in colSum with sum = target
                res += CountSubarrays(colSum, target);
            }
        }

        return res;
    }

    private int CountSubarrays(int[] arr, int target) {
        var map = new Dictionary<int, int>();
        map[0] = 1;
        int prefix = 0, count = 0;

        foreach (int num in arr) {
            prefix += num;
            if (map.ContainsKey(prefix - target)) {
                count += map[prefix - target];
            }
            if (!map.ContainsKey(prefix)) {
                map[prefix] = 0;
            }
            map[prefix]++;
        }

        return count;
    }
}
```

## Complexity
- **Time:** O(rows² × cols).  
  - We fix two rows (`O(rows²)`), then process columns (`O(cols)`), counting subarrays in linear time.  
- **Space:** O(cols) for column sums + O(cols) for hashmap.  

---

## Pitfalls
- Must handle negative numbers correctly (hashmap approach ensures this).  
- Edge case: single element matrix must be considered.  
- Always reset `colSum` for each new `top` row to avoid contamination from previous iterations.  

---

## Example Walkthrough
**Input:**
```csharp
matrix = [[1,-1],
          [-1,1]], target = 0
```

- Row pair (0,0): `colSum = [1,-1]` → subarrays with sum = 0 → **1**  
- Row pair (0,1): `colSum = [0,0]` → subarrays with sum = 0 → **3**  
- Row pair (1,1): `colSum = [-1,1]` → subarrays with sum = 0 → **1**  

**Total = 5**  
**Output:** `5`  

---

## Conclusion
This problem reduces to **counting subarrays with sum = target** using prefix sums and hashmaps, applied to collapsed row ranges.  

- Efficient **O(n² × m)** solution works for matrices up to 100×100.  
- The key trick is collapsing row ranges into column sums and then applying the **1D subarray sum technique**.  

---


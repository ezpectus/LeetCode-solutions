#  3013. Divide an Array Into Subarrays With Minimum Cost II

---

##  Problem Summary
- You must split `nums` into `k` contiguous subarrays.  
- The **cost** of each subarray = its first element.  
- Constraint: `(ik-1 - i1) <= dist`, where `i1` is the start of the second subarray and `ik-1` is the start of the last.  
- Goal: minimize the sum of costs.

---

##  Core Idea
- The first subarray always starts at index `0` → cost includes `nums[0]`.  
- We need to pick `k-1` additional starting indices.  
- Maintain two multisets:
  - `l`: contains the current smallest `k` candidates.  
  - `r`: contains the rest.  
- Balance the sets so that `l` always has exactly `k` elements.  
- Track the running sum `cur` of chosen starts.  
- Slide the window across `nums`, update sets, and keep the minimum sum.

---

##  C++ Implementation
```cpp
class Solution {
    multiset<long long> l, r;
public:
    long long minimumCost(vector<int>& nums, int k, int dist) {
        int n = nums.size();
        k--; // first element always included
        long long cur = nums[0];

        // initialize window
        for (int i = 1; i <= dist + 1; i++) {
            cur += nums[i];
            l.insert(nums[i]);
        }

        // balance sets
        while (l.size() > k) {
            cur -= *l.rbegin();
            r.insert(*l.rbegin());
            l.erase(l.find(*l.rbegin()));
        }

        long long ans = cur;

        // sliding window
        for (int i = dist + 2; i < n; i++) {
            int removeVal = nums[i - dist - 1];
            if (l.find(removeVal) != l.end()) {
                cur -= removeVal;
                l.erase(l.find(removeVal));
            } else {
                r.erase(r.find(removeVal));
            }

            int addVal = nums[i];
            if (addVal < *l.rbegin()) {
                cur += addVal;
                l.insert(addVal);
            } else {
                r.insert(addVal);
            }

            // rebalance
            while (l.size() < k) {
                cur += *r.begin();
                l.insert(*r.begin());
                r.erase(r.find(*r.begin()));
            }
            while (l.size() > k) {
                cur -= *l.rbegin();
                r.insert(*l.rbegin());
                l.erase(l.find(*l.rbegin()));
            }

            ans = min(ans, cur);
        }

        return ans;
    }
};
```




##  Complexity
- **Time:** O(n log n) — each insert/erase in `multiset` is logarithmic.  
- **Space:** O(n) — two multisets (`l` and `r`).  

---

## Pitfalls
- Always include `nums[0]` in the cost.  
- Balance carefully: `l` must contain exactly `k` elements.  
- Use `long long` to avoid overflow (`nums[i]` up to 1e9).  
- Edge cases: `k = n`, `dist = k-2`.  

---

##  Example Walkthrough
**Input:** `nums = [1,3,2,6,4,2], k = 3, dist = 3`  

- Initial sum: `cur = 1 + 3 + 2 = 6`.  
- Balance → `l = {2,3}`, `r = {}`.  
- Sliding window updates → best cost = 5.  

**Output:** `5`

---

##  Conclusion
- Maintain two multisets to track the smallest `k` candidates.  
- Sliding window ensures the distance constraint is respected.  
- Efficient **O(n log n)** solution, robust for large inputs.  


---

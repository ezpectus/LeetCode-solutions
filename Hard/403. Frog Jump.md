# 403. Frog Jump

**Difficulty:** Hard  
**Topics:** Dynamic Programming, HashSet, Simulation  

---

## ğŸ“– Problem Restatement
A frog starts at stone `0` and must reach the last stone.  
- First jump must be `1`.  
- If the last jump was `k`, the next jump can be `k-1`, `k`, or `k+1`.  
- Frog can only land on stones (not water).  
Return `true` if frog can reach the last stone, else `false`.

---

## ğŸ’¡ Core Idea
- Similar to **Jump Game**, but with variable step sizes.  
- Track possible jump lengths at each stone.  
- Use a dictionary:  
```
dp[stone] = set of jump sizes that can reach this stone
```
- Transition:  
```
For each jump in dp[stone]:
next = stone + jump
Add (jump-1), jump, (jump+1) to dp[next] if next is a stone
```

- Answer: check if last stone has any reachable jumps.

---

## ğŸ” Step-by-Step Algorithm
1. Build a `HashSet` of stone positions for O(1) lookup.  
2. Use a dictionary `Dictionary<int, HashSet<int>>` to store reachable jump sizes per stone.  
3. Initialize: `dp[0] = {0}` (start with jump size 0).  
4. Iterate stones:  
 - For each jump size `k` in `dp[stone]`:  
   - Try jumps `k-1, k, k+1` (must be >0).  
   - If `stone + step` exists in stones â†’ add `step` to `dp[stone+step]`.  
5. At the end, check if `dp[lastStone]` is non-empty.  

---

## âœ… C# Implementation
```csharp
public class Solution {
  public bool CanCross(int[] stones) {
      int n = stones.Length;
      var stoneSet = new HashSet<int>(stones);
      var dp = new Dictionary<int, HashSet<int>>();
      
      foreach (int s in stones) dp[s] = new HashSet<int>();
      dp[0].Add(0);

      for (int i = 0; i < n; i++) {
          int stone = stones[i];
          foreach (int k in dp[stone]) {
              for (int step = k - 1; step <= k + 1; step++) {
                  if (step > 0 && stoneSet.Contains(stone + step)) {
                      dp[stone + step].Add(step);
                  }
              }
          }
      }

      return dp[stones[n - 1]].Count > 0;
   }
}
```
## ğŸ“Š Complexity Analysis

- **Time Complexity:** O(nÂ²) worst case (each stone can store multiple jump sizes).  
- **Space Complexity:** O(nÂ²) for dictionary of sets.  

---

## âš ï¸ Pitfalls

- Must ensure `step > 0` (frog canâ€™t jump backwards or stay).  
- First jump must be `1` â†’ handled naturally since `dp[0] = {0}`.  
- Large gaps â†’ frog gets stuck.  
- Donâ€™t brute force simulate all paths â†’ too slow.  

---

## ğŸ” Example Walkthrough

**Input:**  
`stones = [0,1,3,5,6,8,12,17]`

- Start: `dp[0] = {0}`.  
- From 0 â†’ jump 1 â†’ reach stone 1 with jump=1.  
- From 1 â†’ jump 2 â†’ reach stone 3 with jump=2.  
- From 3 â†’ jump 2 â†’ reach stone 5 with jump=2.  
- From 5 â†’ jump 3 â†’ reach stone 8 with jump=3.  
- From 8 â†’ jump 4 â†’ reach stone 12 with jump=4.  
- From 12 â†’ jump 5 â†’ reach stone 17 with jump=5.  
- Last stone reachable â†’ return `true`.  

---

## âœ… Key Takeaway

- This is a **Jump Game variant with dynamic step sizes**.  
- **Pattern:** â€œstate = (stone, lastJump)â€ â†’ DP with HashSet.  
- Clean O(nÂ²) solution using dictionary of reachable jumps.  


---


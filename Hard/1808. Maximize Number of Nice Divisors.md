# üß© Problem: Maximize Number of Nice Divisors  
## üî¢ Number: LeetCode 1808  
**Difficulty**: Hard  
**Language**: C#  
**Status**: ‚úÖ Solved via greedy exponent partitioning + fast modular exponentiation  

---

## üìú Problem Overview

You're given an integer `primeFactors`.  
You must construct a number `n` with **at most `primeFactors` prime factors (not necessarily distinct)**, such that the number of **nice divisors** of `n` is **maximized**.

A **nice divisor** of `n` is any divisor that is divisible by **every prime factor of `n`**.

---

### üî¢ Constraints
- `1 ‚â§ primeFactors ‚â§ 10‚Åπ`  
- Return result **modulo 10‚Åπ + 7**

---

## üß† Explanation

---

### üîç Key Insight

We are given a constraint:  
- We can use **at most `primeFactors` prime factors** to construct a number `n`  
- We want to **maximize the number of nice divisors** of `n`

A **nice divisor** is any divisor of `n` that is divisible by **every prime factor** of `n`.  
This means we want to build `n` such that its **prime factorization** leads to the **maximum number of nice divisors**.

From number theory:  
If `n = p‚ÇÅ^e‚ÇÅ * p‚ÇÇ^e‚ÇÇ * ... * p‚Çñ^e‚Çñ`, then the total number of **divisors** of `n` is:  
`(e‚ÇÅ + 1) * (e‚ÇÇ + 1) * ... * (e‚Çñ + 1)`

But for **nice divisors**, we only count those divisible by **all prime factors** ‚Äî which means we must include **every prime** in the divisor.  
So the number of **nice divisors** is still:  
**(e‚ÇÅ + 1) * (e‚ÇÇ + 1) * ... * (e‚Çñ + 1)**  
Because each exponent contributes to the count of divisors that include its prime.

Our constraint is:  
- `e‚ÇÅ + e‚ÇÇ + ... + e‚Çñ ‚â§ primeFactors`  
We must **partition `primeFactors` into exponents** `e‚ÇÅ, e‚ÇÇ, ..., e‚Çñ`  
Our goal is to **maximize the product** `(e‚ÇÅ + 1) * (e‚ÇÇ + 1) * ... * (e‚Çñ + 1)`

---

### üí° Greedy Strategy

This is a classic **integer partitioning for maximum product** problem.  
To maximize the product of numbers that sum to `primeFactors`, the optimal strategy is:

- Use as many **3s** as possible  
- If remainder is:
  - `r == 0` ‚Üí perfect division into 3s ‚Üí result is `3^q`
  - `r == 1` ‚Üí replace one `3 + 1` ‚Üí use `4` instead ‚Üí result is `3^(q - 1) * 4`
  - `r == 2` ‚Üí add one `2` ‚Üí result is `3^q * 2`

Why 3s?
- Among integers ‚â• 2, **3 gives the best balance between sum and product**  
- For example:
  - `2 + 2 + 2 = 6` ‚Üí product = `8`
  - `3 + 3 = 6` ‚Üí product = `9` ‚úÖ better

This greedy strategy ensures that we get the **maximum number of nice divisors** possible under the constraint.

---

## ‚öôÔ∏è Algorithm Steps

1. **Base case**:  
   If `primeFactors ‚â§ 3`, we return `primeFactors` directly  
   - Because no partitioning improves the result  
   - `1 ‚Üí 1`, `2 ‚Üí 2`, `3 ‚Üí 3`

2. **Partitioning logic**:
   - Let `q = primeFactors / 3` ‚Üí number of full 3s we can use  
   - Let `r = primeFactors % 3` ‚Üí remainder after using 3s

3. **Compute result based on remainder**:
   - `r == 0` ‚Üí use all 3s ‚Üí result = `3^q`
   - `r == 1` ‚Üí replace one `3 + 1` ‚Üí use `4` ‚Üí result = `3^(q - 1) * 4`
   - `r == 2` ‚Üí add one `2` ‚Üí result = `3^q * 2`

4. **Modular exponentiation**:
   - Since `primeFactors` can be up to `10‚Åπ`, we use **fast exponentiation**  
   - This avoids overflow and ensures performance  
   - All results are computed **modulo 10‚Åπ + 7**

---

### üßÆ Example Walkthrough

Let‚Äôs say `primeFactors = 8`  
- `q = 8 / 3 = 2`, `r = 2`  
- Result = `3^2 * 2 = 9 * 2 = 18` ‚úÖ

Let‚Äôs say `primeFactors = 5`  
- `q = 5 / 3 = 1`, `r = 2`  
- Result = `3^1 * 2 = 3 * 2 = 6` ‚úÖ

Let‚Äôs say `primeFactors = 10`  
- `q = 3`, `r = 1`  
- Result = `3^(3 - 1) * 4 = 3^2 * 4 = 9 * 4 = 36` ‚úÖ

---

### üîê Why This Works

- We don‚Äôt need to know the actual primes ‚Äî just how many we can use  
- We don‚Äôt need to construct `n` ‚Äî just compute the **maximum number of nice divisors**  
- We avoid factorization, recursion, or brute-force  
- We use **pure combinatorial logic + modular math**

---


## üßæ Code
```csharp
public class Solution {
    private const int MOD = 1000000007;

    public int MaxNiceDivisors(int primeFactors) {
        if (primeFactors <= 3) return primeFactors;

        int q = primeFactors / 3;
        int r = primeFactors % 3;

        if (r == 0) return PowMod(3, q);
        if (r == 1) return (int)((long)PowMod(3, q - 1) * 4 % MOD);
        return (int)((long)PowMod(3, q) * 2 % MOD);
    }

    private int PowMod(int baseVal, int exp) {
        long result = 1;
        long baseLong = baseVal;

        while (exp > 0) {
            if ((exp & 1) == 1) {
                result = (result * baseLong) % MOD;
            }
            baseLong = (baseLong * baseLong) % MOD;
            exp >>= 1;
        }

        return (int)result;
    }
}

```

## ‚úÖ Complexity, Insights & Notes

---

### ‚è± Time Complexity

- **O(log primeFactors)**  
  The core computation is modular exponentiation, which uses **exponentiation by squaring**.  
  This reduces the time complexity from linear to logarithmic in the exponent.  
  Example: computing `3^1_000_000_000` takes ~30 steps, not a billion.

---

### üß† Space Complexity

- **O(1)**  
  No additional data structures are used.  
  All calculations are done using primitive variables (`long`, `int`).  
  The algorithm is **purely arithmetic**, with no recursion or memory overhead.

---

### üß® Tricks / Insights

- **Max product under fixed sum**  
  This is a classic optimization problem:  
  Given a fixed sum `S`, how do we split it into integers to maximize their product?  
  The answer is: use as many `3`s as possible, with adjustments for remainders.

- **Greedy partitioning into 3s**  
  - `3` is the most efficient integer for maximizing product under sum constraints  
  - Remainders `1` and `2` are handled with special cases to avoid suboptimal partitions

- **Modular exponentiation**  
  - Prevents overflow when computing large powers  
  - Ensures performance even for `primeFactors` up to `10‚Åπ`  
  - Uses bitwise operations (`exp & 1`, `exp >>= 1`) for speed

- **Avoids factorization**  
  - No need to know actual prime values  
  - The problem is solved **combinatorially**, not numerically  
  - This makes the solution scalable and elegant

---

### üîó Related Concepts

- **Integer partitioning for max product**  
  - Used in math olympiads, dynamic programming, and greedy algorithms  
  - Core idea: `3` is optimal, `2` is acceptable, `1` is avoided

- **Modular arithmetic**  
  - Essential for handling large numbers in competitive programming  
  - Keeps results within bounds of `int` or `long`

- **Exponentiation by squaring**  
  - Efficient method for computing `a^b mod m`  
  - Reduces time complexity from `O(b)` to `O(log b)`

- **Greedy optimization under constraints**  
  - Strategy that builds solution incrementally  
  - Proven optimal for this class of problems


---



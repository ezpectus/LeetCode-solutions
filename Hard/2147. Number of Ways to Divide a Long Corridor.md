# 2147. Number of Ways to Divide a Long Corridor — Architectural Solution

## Problem Statement
Given a string `corridor` consisting of `'S'` (seat) and `'P'` (plant).

We need to divide it into **non-overlapping sections**, each containing **exactly 2 seats** (`'S'`), with any number of plants.

- Dividers can be placed between positions (at most one per gap)
- There are already dividers at the very start and very end
- Return number of ways modulo `10⁹ + 7`
- If impossible → return 0

Constraints: n ≤ 10⁵ → must be O(n)

## Core Idea
Each valid section must have **exactly 2 'S'**.

So the entire corridor is valid **only if total number of 'S' is even**.

Let’s collect positions of all seats: `s1, s2, ..., s2k`

Then we must pair them as (s1,s2), (s3,s4), ..., (s(2k-1), s(2k))

Between each consecutive pair of sections (after s2, s4, ...,  s(2k-2), we can place a divider **or not**.

The number of choices between section i and i+1 is the number of positions **after the second seat of section i** and **before the first seat of section i+1**.

That is: `s[2(i+1)] - s[2i] - 1` positions → `s[2(i+1)] - s[2i]` ways (including no divider)

If any gap ≤ 0 → impossible (overlapping or no space)

## Steps
1. Collect all seat positions in a list
2. If count is odd → return 0
3. Initialize `ways = 1`
4. For i from 0 to count/2 - 2:
   - gap = positions[2*i+2] - positions[2*i+1]
   - ways = (ways * gap) % MOD
5. Return ways

## Implementation (C#) 

```csharp
public class Solution {
    private const int MOD = 1_000_000_007;

    public int NumberOfWays(string corridor) {
        var seats = new List<int>();
        for (int i = 0; i < corridor.Length; i++) {
            if (corridor[i] == 'S')  seats.Add(i);
        }

        if (seats.Count == 0 || seats.Count % 2 == 1) 
            return 0;

        long ways = 1;
        for (int i = 1; i < seats.Count / 2; i++) {
            long gap = seats[2 * i] - seats[2 * i - 1];
            ways = ways * gap % MOD;
        }

        return (int)ways;
    }
}
```
## Complexity Analysis

* **Time Complexity**: **O(n)**  
  Single linear pass over the string to collect positions of all 'S' characters.  
  Subsequent processing of the seat list is O(k), where k ≤ n/2 → still O(n).

* **Space Complexity**: **O(k)**  
  We store only the list of seat positions (k = number of 'S' ≤ n).  
  In worst case O(n), but typically much less.

## Pitfalls & Edge Cases

* **Odd number of 'S'** → cannot pair into sections of exactly 2 seats → return **0** immediately.  
* **Zero 'S'** → no seats → impossible → return **0**.  
* **Exactly two 'S'** → only one section → no internal gaps → **1** way (no divider to place).  
* **Consecutive 'S'S** (e.g. "SS") → gap = 1 → only one possible divider position → multiplies as 1 (must place divider).  
* **Large gaps between sections** → many possible divider positions → product can be huge → use `long` and take modulo `10⁹+7` at each step to prevent overflow.  
* **n = 1 with 'S'** → odd number of seats → return **0**.  
* **All 'P'** → zero seats → return **0**.  
* **'S' at start or end** → handled naturally (gaps calculated correctly, no off-by-one).

## Conclusion
Beautiful **combinatorial** problem disguised as dynamic programming or greedy.

The key insight:

* Total number of seats must be **even** — otherwise impossible.
* Seats are **fixed in order** — we must pair them consecutively: (1-2), (3-4), ..., (2k-1, 2k)
* Each section is rigid — exactly 2 seats with any plants between them.
* Between two consecutive sections (after seat 2i and before seat 2i+1) — we can place a divider in any of the gap positions (including no divider).

Number of ways = product over all internal gaps of (gap_size).
No DP table, no states, no recursion — just collect seats and multiply gaps.



---






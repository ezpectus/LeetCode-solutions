# 1220. Count Vowels Permutation — Architectural Iterative DP with Vowel States  
*O(n) — Optimal Space-Optimized DP with Modulo*

---

## Problem Statement

Given integer `n` (1 ≤ n ≤ 2×10⁴).

Count number of valid strings of length `n` using vowels `'a','e','i','o','u'` with rules:

- `'a'` → only `'e'`
- `'e'` → `'a'` or `'i'`
- `'i'` → anything **except** `'i'`
- `'o'` → `'i'` or `'u'`
- `'u'` → `'a'`

Return answer **modulo 10⁹ + 7**.

---

## Core Idea — 5-State Iterative DP

**Key insight**:
- Only **5 states** — count of strings ending with each vowel
- Variables `a, e, i, o, u` = count ending with that vowel
- Base (length 1): all = 1
- Each iteration → compute next counts from current

**Transitions**:
- next_a ← only from `e`
- next_e ← from `a`, `i`
- next_i ← from `a`, `e`, `o`, `u` (not `i`)
- next_o ← from `i`, `u`
- next_u ← from `a`

---

##  Implementation (C#)

```csharp
public class Solution {
    public int CountVowelPermutation(int n) {
        const int MOD = 1000000007;
        long a = 1, e = 1, i = 1, o = 1, u = 1;

        for (int j = 1; j < n; j++)  {
            long a_next = e;
            long e_next = (a + i) % MOD;
            long i_next = (a + e + o + u) % MOD;
            long o_next = (i + u) % MOD;
            long u_next = a;

            a = a_next;
            e = e_next;
            i = i_next;
            o = o_next;
            u = u_next;
        }

        return (int)((a + e + i + o + u) % MOD);
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Loop runs n-1 times                            |
| **Space Complexity**  | **O(1)**      | Only 5 variables                               |

**Optimal** — linear time, constant space.

---

## Why This Works — Execution Flow

**Base case** (n=1):  
`a = e = i = o = u = 1` → total = **5** — correct.

**Iteration** (building length from 2 to n):

We maintain five counters:
- `a`, `e`, `i`, `o`, `u` — number of valid strings of current length ending with that vowel.

Each iteration computes **next** counts based on allowed predecessors:

- `a_next = e` (only 'e' can be followed by 'a')
- `e_next = a + i` ('a' or 'i' → 'e')
- `i_next = a + e + o + u` (anything except 'i' → 'i')
- `o_next = i + u` ('i' or 'u' → 'o')
- `u_next = a` (only 'a' → 'u')

**Example**: `n = 2`

- Start: a=e=i=o=u=1
- a_next = e = 1
- e_next = a + i = 2
- i_next = a + e + o + u = 4
- o_next = i + u = 2
- u_next = a = 1
- New sum = 1+2+4+2+1 = **10** — correct

**n = 5** → 4 iterations → final sum = **68** — correct.

The approach naturally accumulates all valid strings by always building on valid endings.

---

## Pitfalls & Edge Cases

- **n=1** → returns 5 (all single vowels valid)
- **Large n** → modulo 10⁹+7 prevents overflow
- **No self-loop on 'i'** → correctly excluded (i_next does not include i)
- **All transitions** → strictly follow given rules

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** iterative DP:

- **5 variables** → counts of valid strings ending with each vowel
- **Direct, rule-based transitions** → O(1) computation per length increase
- **In-place update** → clean, fast, and memory-efficient

No arrays, no extra space — just pure state transition.
**Pure, clean, optimal** — perfect vowel permutation counting.

---

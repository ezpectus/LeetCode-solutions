# 2977. Minimum Cost to Convert String II — Architectural Trie + Floyd-Warshall + DP  
*O(n × L + m × L + 26³) — Optimal Substring Matching + All-Pairs Shortest Paths*

---

## Problem Statement

Given two strings `source` and `target` of length `n`.

Given `m` replacement rules:  
- `original[j]` → `changed[j]` with cost `cost[j]`

You can replace any substring of `source` with `changed[j]` if it exactly matches `original[j]`, paying `cost[j]`.

Operations must have **disjoint** or **identical** index ranges.

Return **minimum cost** to make `source` == `target`, or **-1** if impossible.

---

## Core Idea - Trie for Matching + Floyd-Warshall on Replacements + DP on Positions

**Main idea**:
- Build **Trie** of all `original` strings → assign each unique string an ID
- Build graph of replacements: edge from original ID → changed ID with min cost
- Run **Floyd-Warshall** → get min cost to replace any original string with any changed string
- DP on positions: `dp[i]` = min cost to transform `source[0..i-1]` → `target[0..i-1]`
- At each position i:
  - Try keep single char (if equal) → dp[i+1] = dp[i]
  - Try replace substring starting at i → walk Trie on source and target simultaneously, if both reach valid IDs and there is edge → update dp[i + len]

**Why it works**:
- Trie finds all possible matching substrings in linear time
- Floyd-Warshall handles chain replacements (original1 → changed1 = original2 → changed2)
- DP ensures non-overlapping coverage

---

## Clean Implementation (C#)

```csharp
public class TrieNode {
    public TrieNode[] children = new TrieNode[26];
    public int id = -1;
}

public class Solution {
    private const int INF = int.MaxValue / 2;
    private const int MOD = 1_000_000_007; // not needed here, but good practice

    public long MinimumCost(string source, string target, string[] original, string[] changed, int[] cost) {
        int n = source.Length;
        TrieNode root = new TrieNode();
        int nodeCount = -1;

        // Build Trie and assign IDs to unique originals
        int[][] graph = new int[2001][]; // max m*2 nodes
        for (int i = 0; i < graph.Length; i++) {
            graph[i] = new int[2001];
            for (int j = 0; j < 2001; j++) graph[i][j] = INF;
            graph[i][i] = 0;
        }

        for (int i = 0; i < original.Length; i++) {
            int from = Insert(root, original[i], ref nodeCount);
            int to   = Insert(root, changed[i], ref nodeCount);
            graph[from][to] = Math.Min(graph[from][to], cost[i]);
        }

        int size = nodeCount + 1;

        // Floyd-Warshall: min cost from any original to any changed
        for (int k = 0; k < size; k++)
            for (int i = 0; i < size; i++)
                for (int j = 0; j < size; j++)
                    if (graph[i][k] < INF && graph[k][j] < INF)
                        graph[i][j] = Math.Min(graph[i][j], graph[i][k] + graph[k][j]);

        // DP: dp[i] = min cost to transform source[0..i-1] to target[0..i-1]
        long[] dp = new long[n + 1];
        Array.Fill(dp, -1);
        dp[0] = 0;

        for (int i = 0; i < n; i++) {
            if (dp[i] == -1) continue;

            // Option 1: keep single character
            if (source[i] == target[i]) {
                if (dp[i + 1] == -1 || dp[i] < dp[i + 1]) {
                    dp[i + 1] = dp[i];
                }
            }

            // Option 2: try replace substring starting at i
            TrieNode u = root;
            TrieNode v = root;
            for (int j = i; j < n; j++) {
                u = u.children[source[j] - 'a'];
                v = v.children[target[j] - 'a'];
                if (u == null || v == null) break;

                if (u.id != -1 && v.id != -1 && graph[u.id][v.id] < INF) {
                    long newCost = dp[i] + graph[u.id][v.id];
                    if (dp[j + 1] == -1 || newCost < dp[j + 1]) {
                        dp[j + 1] = newCost;
                    }
                }
            }
        }

        return dp[n];
    }

    private int Insert(TrieNode root, string word, ref int idCounter) {
        TrieNode node = root;
        foreach (char c in word) {
            int idx = c - 'a';
            if (node.children[idx] == null) {
                node.children[idx] = new TrieNode();
            }
            node = node.children[idx];
        }
        if (node.id == -1) {
            node.id = ++idCounter;
        }
        return node.id;
    }
}
```


## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(n × L + m × L + size³)**  | Trie construction O(m × L), Floyd-Warshall O(size³) where size ≤ 2m ≤ 200, DP transitions O(n × L) where L ≤ max length of original strings ≤ 1000 |
| **Space Complexity**  | **O(size² + n)**              | Floyd-Warshall graph O(size²) ≈ 200×200, DP array O(n) |

**Optimal** — constraints are small (n ≤ 1000, m ≤ 100, L ≤ 1000), total operations ~10⁸ in worst case but in practice much faster → passes comfortably.

---

## Why This Works — Example Walkthrough

**Example 1**: `source = "abcd"`, `target = "acbe"`

- Rules allow single-character replacements (a→b, b→c, c→e, d→e, etc.)
- DP tries keeping characters or replacing single chars at each position
- Finds optimal combination with total cost **28** → correct

**Example 2**: `source = "abcdefgh"`, `target = "acdeeghh"`

- Uses substring replacements:
  - "bcd" → "cde" cost 1 at position 1–3
  - "fgh" → "thh" cost 3 at position 5–7
  - "thh" → "ghh" cost 5 at same position 5–7 (identical range allowed)
- DP matches whole substrings non-overlapping or identical → total cost **9** → correct

**Example 3**: no valid sequence of non-overlapping/identical replacements to reach target → **-1**

**Correct** — DP explores all possible ways to cover the string with single characters or full substring replacements, respecting the non-overlapping/identical range constraint.

---

## Pitfalls & Edge Cases

- **source[i] == target[i]** → free transition (cost 0)
- **No possible replacement at some position** → dp[n] stays -1 → return **-1**
- **Multiple rules with same original** → min cost taken in graph
- **Substring overlap** → DP position jumps ensure no overlap unless identical range
- **Large n (≤1000)** → O(n × L) with L ≤ 1000 is acceptable (~10⁸ operations worst-case)

All handled perfectly.

---

## Key Takeaway

This is a **classic string transformation with substring replacements** problem:

- **Trie** to efficiently match original substrings in source
- **Floyd-Warshall** on replacement graph to compute minimum cost for any original → any changed (handles chains)
- **DP on positions** → dp[i] = min cost to transform source[0..i-1] to target[0..i-1]
  - Try keep single character (if equal)
  - Try replace any matching substring starting at i
- Non-overlapping property guaranteed by DP jumps (or identical range allowed via multiple rules)

**Pure, clean, optimal** — perfect minimum cost under substring replacement constraints.
---

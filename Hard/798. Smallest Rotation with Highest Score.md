# Pattern Name
**Sweep Line for Score Intervals**

## Problem Summary
- **Input**: Array `nums` of length `n`
- **Goal**: Find **smallest rotation `k`** that gives **maximum score**  
  → Score = number of `i` where `rotated[i] <= i`
- **Constraints**:
  - `1 ≤ n ≤ 10⁵`
  - `0 ≤ nums[i] < n`

## Core Idea
- After rotation by `k`, element `nums[i]` moves to position `(i - k) mod n`
- It gives **+1 score** if:  
  `nums[i] <= (i - k) mod n`
- Rearrange:  
  `k <= i - nums[i]` **or** `k >= i + 1` → **interval of good `k`**
- Use **sweep line** to count how many elements give +1 at each `k`

## Solution
1. For each `nums[i]`, compute **interval of `k`** where it contributes +1
2. Use **difference array** (`sweep`) to mark:
   - `+1` at interval start
   - `-1` at interval end + 1
3. Scan `sweep` → reconstruct score at each `k`
4. Track **max score** and **smallest `k`**

## C# Implementation (Clean & Short)
```csharp
public class Solution {
    public int BestRotation(int[] a) {
        int n = a.Length;
        int[] s = new int[n + 1];

        for (int i = 0; i < n; i++) {
            int v = a[i];
            if (i >= v) {
                // [0, i-v]
                s[0]++;
                if (i - v + 1 <= n) s[i - v + 1]--;
                // [i+1, n-1]
                if (i + 1 < n) {
                    s[i + 1]++;
                    s[n]--;
                }
            } else {
                // [i+1, n-1]
                s[i + 1]++;
                s[n]--;
            }
        }

        int max = 0, cur = 0, k = 0;
        for (int i = 0; i < n; i++) {
            cur += s[i];
            if (cur > max) {
                max = cur;
                k = i;
            }
        }
        return k;
    }
}
```

## Example Walkthrough
| nums | `[2,3,1,4,0]` |
|------|---------------|
| `i=0`, `v=2` | `i < v` → `[1,4]` |
| `i=1`, `v=3` | `i < v` → `[2,4]` |
| `i=2`, `v=1` | `i >= v` → `[0,1]` + `[3,4]` |
| `i=3`, `v=4` | `i < v` → `[4,4]` |
| `i=4`, `v=0` | `i >= v` → `[0,4]` |
| **Scores** | `k=0:2`, `1:3`, `2:3`, `3:4`, `4:3` → **k=3** |

## Architectural Breakdown
| Component           | Role                                      |
|---------------------|-------------------------------------------|
| `s[]`               | Difference array for interval updates     |
| `if (i >= v)`       | Two intervals: `[0, i-v]` + `[i+1, n-1]`  |
| `else`              | One interval: `[i+1, n-1]`                |
| **Final scan**      | Reconstruct score, track max + smallest `k` |

## Why This Approach Is Superior
| Aspect              | **Sweep Line**       | Brute Force           |
|---------------------|-----------------------|------------------------|
| Time Complexity     | **O(n)**              | O(n²)                  |
| Space Complexity    | **O(n)**              | O(1)                   |
| Performance         | Linear, scalable      | TLE on large inputs    |
| Clarity             | **Math + intervals**  | Nested loops           |

## Final Takeaway
- **This pattern generalizes to**:
  - **Rotation-based scoring**
  - **Interval contribution** problems
  - **Maximize count over cyclic shifts**
- **Key Insight**:  
  > **"Don’t simulate rotation — model contribution intervals."**
  

  ---



# 1595. Minimum Cost to Connect Two Groups of Points  
*O(n × 2^m × m) — Optimal Bitmask DP with Memoization*

---

## Problem Statement

You are given two groups of points:

- First group — `size1` points (size1 ≤ 12)
- Second group — `size2` points (size2 ≤ 12, size1 ≥ size2)
- Cost matrix `cost[i][j]` — the cost of connecting point `i` from the first group to point `j` from the second group.

You need to connect the groups so that:

- Every point in the first group is connected to **at least one** point in the second group
- Every point in the second group is connected to **at least one** point in the first group
- Connections are **many-to-many** — no limit on how many connections one point can have.
- Return the **minimum total cost** to make the connection.

---

## Core Idea — Bitmask DP on the Smaller Group + Memoization

**Key insight**:
- size2 ≤ 12 → we can use a **bitmask** (2¹² = 4096 states) to track which points in the second group are already covered
- Each point in the first group can connect to **any subset** of points in the second group (paying the sum of costs)
- We need to cover **all** points in the second group (full mask = (1 << size2) - 1)

**DP state**:
- `dp[left][mask]` = minimum cost to cover **exactly** the subset `mask` of the second group,  
  using **exactly** the first `left` points of the first group

**Transition**:
- At position `left` (current point in group 1):
  - We can connect it to **any number** of uncovered points in the current mask
  - But instead of enumerating subsets (3^m), we connect it **one by one** to uncovered points
  - For each uncovered j: new_mask = mask | (1 << j), cost += cost[left][j]
- Base case: when `left == size1`:
  - For all remaining uncovered points in mask — add the **minimum possible cost** to connect each of them (precomputed in `_dp[j]`)

**Optimization**:
- Memoization on `[left][mask]`
- Precompute `_dp[j]` = min cost to connect point j in group 2 to any point in group 1

---

## Clean Implementation (C#) 
 ```cpp
public class Solution {
    private long INF = (long)1e15;
    private int[] _dp;                  // min cost to connect each right point individually
    private int[][] _memo;              // memo[left][mask]
    private IList<IList<int>> _cost;

    public int ConnectTwoGroups(IList<IList<int>> cost) {
        _cost = cost;
        CalculateMinCostForEachRightComponent();
        InitCacheArray();
        return Recurse(0, 0);
    }

    // Precompute minimum cost to connect each point in group 2
    private void CalculateMinCostForEachRightComponent() {
        int m = _cost[0].Count;
        _dp = new int[m];
        Array.Fill(_dp, int.MaxValue);

        for (int j = 0; j < m; j++) {
            for (int i = 0; i < _cost.Count; i++) {
                _dp[j] = Math.Min(_dp[j], _cost[i][j]);
            }
        }
    }

    // Initialize memoization table
    private void InitCacheArray() {
        int n = _cost.Count;
        int m = _cost[0].Count;
        _memo = new int[n + 1][];
        int length = 1 << m;

        for (int i = 0; i < _memo.Length; i++) {
            _memo[i] = new int[length];
            Array.Fill(_memo[i], -1);
        }
    }

    // Recursion: left — current point in group 1, mask — covered points in group 2
private int Recurse(int left, int mask) {
        if (_memo[left][mask] != -1) 
            return _memo[left][mask];

        // Base case: all points from group 1 used
        if (left == _cost.Count)  {
            int sum = 0;
            for (int j = 0; j < _dp.Length; j++) {
                if (((1 << j) & mask) == 0) {
                    sum += _dp[j];  // connect remaining points with min cost
                }
            }
            return _memo[left][mask] = sum;
        }

        int result = int.MaxValue;

        // Try connecting current point 'left' to every possible uncovered point j
        for (int j = 0; j < _dp.Length; j++) {
            int newMask = mask | (1 << j);
            result = Math.Min(result, _cost[left][j] + Recurse(left + 1, newMask));
        }

        return _memo[left][mask] = result;
    }
}
```

## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(size1 × 2^size2 × size2)** | Recursion visits size1 × 2^size2 states, each state processes size2 transitions → 12 × 4096 × 12 ≈ 600,000 operations (very fast) |
| **Space Complexity**  | **O(size1 × 2^size2)**        | Memoization table: (size1 + 1) × 2^size2 ≈ 13 × 4096 ≈ 53,000 integers |

**Optimal** — exponential time only in the small dimension (size2 ≤ 12), linear in size1, runs instantly under constraints.

---

## Why This Works — Example Walkthrough

**Example 1**: `cost = [[15,96],[36,2]]`

- size1 = 2, size2 = 2
- `_dp = [min(15,36)=15, min(96,2)=2]`
- Recurse(0, 0):
  - Connect to j=0 → cost=15, new_mask=1 → Recurse(1,1)
  - Connect to j=1 → cost=96, new_mask=2 → Recurse(1,2)
- Recurse(1,1):
  - Connect to j=1 → cost=2, new_mask=3 → Recurse(2,3) = 0 (base case) → total 15+2 = **17**
- Recurse(1,2):
  - Connect to j=0 → cost=36, new_mask=3 → 96+36 = 132
- Final dp[3] = **17** → correct

**Correct** — recursion with memoization explores all possible ways to assign connections from left points to right points.  
At the end (when all left points are used), it adds the minimum cost to connect any remaining uncovered right points using `_dp`.

---

## Pitfalls & Edge Cases

- **size2 = 1** → just the minimum cost from any left point to that single right point
- **size1 = size2** → possible to have full bipartite matching
- **High costs** → correctly picks the minimum
- **size2 = 12** → 4096 states × 12 left points × 12 transitions ≈ 600k operations → runs in milliseconds
- **Impossible case** → dp[full_mask] remains INF → but problem guarantees it's possible

All handled perfectly.

---

## Key Takeaway

This is a **classic minimum-cost set cover** problem with small constraints:

- Use **bitmask DP** on the smaller group (size2 ≤ 12)
- `dp[left][mask]` = minimum cost to cover **exactly** subset mask of group 2,  
  using **exactly** the first `left` points of group 1
- Transition: for current point `left`, try connecting it to **every uncovered** j → add cost[left][j]
- Base case (left == size1): add minimum costs for all remaining uncovered right points (using `_dp`)
- Answer = `dp[size1][(1 << size2) - 1]`

**Pure, clean, optimal** — exponential only in the small dimension, linear in the larger group size.

---




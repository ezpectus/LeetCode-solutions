## üß† Pattern: Node Removal with Structural Pruning for Malware Containment

---

## üìå Problem Statement

You are given:

- An undirected graph of `n` nodes represented as an `n x n` adjacency matrix  
- A list `initial[]` containing nodes that are initially infected by malware

Malware spreads according to the following rule:

- If two nodes are directly connected, and **at least one is infected**, then **both become infected**  
- This process continues until no new infections occur

Your task is to **remove exactly one node from `initial[]`**, with the following condition:

> ‚ùóÔ∏è The selected node is **completely removed** from the graph ‚Äî including all its edges and connections

Return the node whose removal results in the **minimum total number of infected nodes** after the spread stabilizes.  
If multiple nodes yield the same minimum, return the one with the **smallest index**.

---

## üß© Architectural Idea

This problem is a classic case of **structural pruning for containment**.

Unlike Part I ‚Äî where the node was excluded from the infection process but still present in the graph ‚Äî here the node is **fully deleted**, along with all its connections. 
This changes the topology of the graph and can dramatically alter the infection dynamics.

### üîë Core Insight

- Removing a node means **removing all its edges**, effectively disconnecting it from the network  
- This can **break infection chains**, isolate components, and prevent malware from reaching certain areas  
- To evaluate each candidate:
  - We **rebuild the graph** without the candidate node  
  - We **simulate infection spread** using BFS from the remaining infected nodes  
  - We **count the total number of infected nodes** after the spread stabilizes

The optimal node is the one whose removal **minimizes the final infection count**.  
In case of a tie, we select the node with the **lowest index**.

---

## üîß Implementation

```csharp
public class Solution {
    public int MinMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.Length;
        Array.Sort(initial);
        int minInfected = int.MaxValue;
        int result = initial[0];

        foreach (int candidate in initial) {
            var visited = new bool[n];
            var q = new Queue<int>();

            // Build graph without candidate
            var tempGraph = new List<int>[n];
            for (int i = 0; i < n; i++) {
                tempGraph[i] = new List<int>();
                for (int j = 0; j < n; j++) {
                    if (i != candidate && j != candidate && graph[i][j] == 1) {
                        tempGraph[i].Add(j);
                    }
                }
            }

            // Start BFS from other infected nodes
            foreach (int node in initial) {
                if (node != candidate && !visited[node]) {
                    q.Enqueue(node);
                    visited[node] = true;
                }
            }

            while (q.Count > 0) {
                int curr = q.Dequeue();
                foreach (int neighbor in tempGraph[curr]) {
                    if (!visited[neighbor]) {
                        visited[neighbor] = true;
                        q.Enqueue(neighbor);
                    }
                }
            }

            int infectedCount = 0;
            for (int i = 0; i < n; i++) {
                if (visited[i]) infectedCount++;
            }

            if (infectedCount < minInfected) {
                minInfected = infectedCount;
                result = candidate;
            }
        }

        return result;
    }
}
```

## üß† Post-Solution Breakdown ‚Äî Minimize Malware Spread II

---

### ‚úÖ Invariants

- `visited[i] == true` ‚áî node `i` was infected after removing the candidate  
- `tempGraph` is the graph with the candidate node and all its edges removed  
- BFS simulates infection spread from the remaining infected nodes  
- Final result is the candidate whose removal minimizes total infection

---

### ‚ö†Ô∏è Edge Cases

| Scenario                     | Behavior                                                   |
|------------------------------|------------------------------------------------------------|
| Candidate is a central hub   | Removal may isolate a large component                     |
| Candidate is a leaf node     | Removal may have little to no effect                      |
| Multiple equal candidates    | Return the one with the smallest index                    |

---

### üìå Constraints

- `2 <= n <= 300`  
- `graph[i][j] ‚àà {0, 1}` and symmetric  
- `graph[i][i] == 1`  
- `1 <= initial.length < n`  
- All values in `initial[]` are unique  
- Infection spreads until stable

---

### üß† Why This Works

Unlike Part I, here the candidate node is **completely removed**, along with all its connections.  
This can **break infection chains** and isolate parts of the graph.

Algorithm:

1. For each candidate:
   - Rebuild the graph without that node
   - Run BFS from the remaining infected nodes
   - Count how many nodes get infected
2. Choose the candidate that results in the **lowest infection count**
3. If tied, return the candidate with the **smallest index**

**Time Complexity:**  
- `O(n¬≤)` per candidate due to adjacency matrix and BFS  
- Acceptable within constraints (`n ‚â§ 300`)

---

### üîÅ Pattern Generalization

Applicable to problems involving:

- Influence or infection spread over graphs  
- Node removal to minimize impact  
- Graph reconstruction after structural changes

---

### üß© Reusable Components

- BFS for infection simulation  
- Graph reconstruction per candidate  
- Infection counting logic  
- Tie-break selection based on index

---

### üß† Related Problem Types

- Removing influencers to minimize spread  
- Disconnecting fire/flood sources in grids  
- Pruning graphs to isolate critical nodes

---

### üß† Approach Comparison

| Method           | Time Complexity | Pros                        | Cons                                |
|------------------|------------------|-----------------------------|-------------------------------------|
| Full simulation  | `O(n¬≤)`          | Accurate infection modeling | Hard to optimize                    |
| Union-Find       | `O(n log n)`     | Fast component detection    | Harder to track infection dynamics  |
| BFS + pruning    | `O(n¬≤)`          | Transparent and modular     | Requires graph rebuild per candidate |

---

### üß† Conclusion

This solution is a clean example of **structural pruning for containment**.  
Instead of simulating infection on the original graph, we:

- Remove the candidate node and its edges  
- Simulate infection from remaining sources  
- Count infected nodes  
- Return the candidate that minimizes spread

üìò **Playbook Entry**

- **Pattern Name:** Structural Pruning for Malware Containment  
- **Core Structures:** BFS, graph reconstruction, visited[], infection counting  
- **Use Case:** Containing spread via node removal  
- **Architectural Value:** Clean logic, scalable, reusable



---

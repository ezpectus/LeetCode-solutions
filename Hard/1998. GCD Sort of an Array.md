# 🧠 LeetCode 1998 — GCD Sort of an Array  
**Category:** Graph / Union-Find / Number Theory  
**Difficulty:** Hard  
**Language:** C#  
**Pattern:** GCD Connectivity via Prime Factor Union-Find

---

## 💡 Problem Summary

You're given an array `nums`. You can swap any two elements `nums[i]` and `nums[j]` **if `gcd(nums[i], nums[j]) > 1`**.  
Return `true` if it's possible to sort the array in non-decreasing order using any number of such swaps.

---

## 🧠 My Architectural Insight

I realized this isn't about brute-force swapping — it's about **connectivity through common divisors**.  
If two numbers share a common prime factor, they can be swapped **indirectly**, even if not adjacent.  
So the core idea is:  
> **Can each number reach its sorted position via GCD-based connectivity?**

This led me to Union-Find — not on indices, but on **values themselves**, connected via **prime factors**.

---

## 🔧 My C# Implementation

```csharp
public class Solution {
    public bool GcdSort(int[] nums) {
        int max = nums.Max();
        UnionFind uf = new UnionFind(max + 1);

        foreach (int num in nums) {
            foreach (int factor in GetPrimeFactors(num)) {
                uf.Union(num, factor);
            }
        }

        int[] sorted = nums.OrderBy(x => x).ToArray();
        for (int i = 0; i < nums.Length; i++) {
            if (uf.Find(nums[i]) != uf.Find(sorted[i]))
                return false;
        }

        return true;
    }

    private List<int> GetPrimeFactors(int num) {
        List<int> factors = new List<int>();
        int d = 2;
        while (d * d <= num) {
            if (num % d == 0) {
                factors.Add(d);
                while (num % d == 0) num /= d;
            }
            d++;
        }
        if (num > 1) factors.Add(num);
        return factors;
    }

    class UnionFind {
        private int[] parent;

        public UnionFind(int n) {
            parent = Enumerable.Range(0, n).ToArray();
        }

        public int Find(int x) {
            if (parent[x] != x)
                parent[x] = Find(parent[x]);
            return parent[x];
        }

        public void Union(int x, int y) {
            int px = Find(x), py = Find(y);
            if (px != py) parent[py] = px;
        }
    }
}
```

## 🧩 Architectural Breakdown

| Component         | Role                                                                 |
|------------------|----------------------------------------------------------------------|
| `UnionFind`       | Tracks connectivity between numbers via shared prime factors         |
| `GetPrimeFactors` | Extracts unique prime factors for each number                        |
| `Union(num, factor)` | Connects each number to its prime factors                        |
| `Find(a) == Find(b)` | Checks if two numbers are in the same GCD-connected component     |

---

## 🔍 Why My Approach Is Superior

| Aspect               | My Approach                          | Alternative Approach                     |
|----------------------|--------------------------------------|------------------------------------------|
| Union-Find Scope     | Over values                          | Over indices                             |
| Connectivity Logic   | Prime factor unioning                | Sieve + index mapping                    |
| Component Handling   | Direct root comparison               | Sort and overwrite per component         |
| Memory Usage         | Minimal                              | Stores index lists per component         |
| Performance          | Faster (no extra sorting)            | Slower due to component sorting          |
| Code Clarity         | Clean and modular                    | Verbose and entangled                    |
| Conceptual Ownership | Fully derived from architectural insight | Implementation driven by surface logic |



---

---

## ✅ Summary

This task isn’t about sorting — it’s about **reachability through number theory**.  
Once I saw that, the rest was just system-building:  
- Union-Find over values  
- Prime factor connectivity  
- Root comparison for validation

No swaps, no brute force, no wasted cycles.  
Just clean architecture and minimal logic.

This module now lives in my repo as a reusable pattern:  
> **GCD Connectivity Sort via Prime Factor Union-Find**

It’s not just a solution — it’s a signal of how I think.


---

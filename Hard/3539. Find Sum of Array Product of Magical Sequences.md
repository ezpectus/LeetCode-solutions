# Pattern: Bitwise Sum Simulation via Carry Propagation
##  Problem Statement
You're given:

- An array nums[] of positive integers
- Two integers m and k

You must:

- Build all sequences of length m, where each element is chosen from nums[] (repetition allowed)

For each sequence, compute the bitwise sum:

- Simulate adding 1 << i for each index i used
- Count how many bits are set in the final sum
- Return the sum of products of all sequences where the final bitwise sum has exactly k bits set
- All results modulo 10⁹ + 7.

##  Architectural Idea

- This is a bitwise simulation problem with combinatorial weighting. 
- Instead of enumerating all sequences, we simulate how bits accumulate via carry propagation.
```
Key insight:

Each index i can be used c times
Adding c copies of 1 << i affects bit i and may cause carry to higher bits
We simulate this using (carry, ones) state
We use nums[i]^c and C(rem, c) to compute contribution of each choice

So we:

Precompute:

powtab[i][c] = nums[i]^c mod MOD
comb[rem][c] = C(rem, c) mod MOD

Use DP:

dp[rem][carry][ones] = total sum for remaining picks, current carry, and ones so far

For each index i, simulate choosing c copies:

Update carry and ones
Multiply by comb and powtab

Final result:
Sum over all states where popcount(carry) + ones == k
```

---

##  Implementation
```csharp
public class Solution {
    const int MOD = 1_000_000_007;

    public int MagicalSum(int m, int k, int[] nums) {
        int n = nums.Length;

        long[][] powtab = new long[n][];
        for (int i = 0; i < n; i++) {
            powtab[i] = new long[m + 1];
            powtab[i][0] = 1;
            for (int c = 1; c <= m; c++) {
                powtab[i][c] = (powtab[i][c - 1] * nums[i]) % MOD;
            }
        }

        long[][] comb = new long[m + 1][];
        for (int i = 0; i <= m; i++) {
            comb[i] = new long[m + 1];
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        long[,,] dp = new long[m + 1, m + 1, k + 1];
        dp[m, 0, 0] = 1;

        for (int i = 0; i < n; i++) {
            long[,,] next = new long[m + 1, m + 1, k + 1];
            long[] powi = powtab[i];

            for (int rem = 0; rem <= m; rem++) {
                for (int carry = 0; carry <= m; carry++) {
                    for (int ones = 0; ones <= k; ones++) {
                        long baseVal = dp[rem, carry, ones];
                        if (baseVal == 0) continue;

                        for (int c = 0; c <= rem; c++) {
                            int t = c + carry;
                            int bit = t & 1;
                            int ones2 = ones + bit;
                            if (ones2 > k) continue;

                            int carry2 = t >> 1;
                            int rem2 = rem - c;

                            long add = baseVal;
                            add = (add * comb[rem][c]) % MOD;
                            add = (add * powi[c]) % MOD;

                            next[rem2, carry2, ones2] = (next[rem2, carry2, ones2] + add) % MOD;
                        }
                    }
                }
            }

            dp = next;
        }

        long total = 0;
        for (int carry = 0; carry <= m; carry++) {
            int extra = PopCount(carry);
            int need = k - extra;
            if (need >= 0 && need <= k) {
                total = (total + dp[0, carry, need]) % MOD;
            }
        }

        return (int)total;
    }

    private int PopCount(int x) {
        int cnt = 0;
        while (x != 0) {
            x &= (x - 1);
            cnt++;
        }
        return cnt;
    }
}
```

##  Invariants
- dp[rem][carry][ones] tracks all valid paths with rem picks left
- carry stores pending bits to propagate
- ones counts bits already set
- powtab[i][c] gives product contribution
- comb[rem][c] gives multiplicity of each configuration

---

##  Edge Cases

| Case              | Behavior                                              |
|-------------------|-------------------------------------------------------|
| `k > m`           | No valid sequence — return `0`                        |
| `nums[i] == 1`    | All powers are `1` — only multiplicity matters        |
| `nums.Length == 1`| Only one index — simulate repeated use                |
| `m == k`          | All bits must be set — tight filtering                |

---

##  Constraints

- `1 <= m <= 30`  
- `1 <= k <= m`  
- `1 <= nums.length <= 50`  
- `1 <= nums[i] <= 10⁹`  
- All results modulo `10⁹ + 7`

---

##  Why This Works

This approach avoids full enumeration of sequences. Instead, it uses:

- **Combinatorics** to count how many ways each configuration appears  
- **Bitwise simulation** to track how bits accumulate via carry  
- **Filtering** to select only those with exactly `k` bits set

**Total cost:**  
`O(n * m² * k)` — acceptable for `n ≤ 50`, `m ≤ 30`, `k ≤ m`

---

##  Pattern Generalization

This technique applies to problems with:

- Bitwise constraints on aggregated values  
- Repetition allowed in sequence construction  
- Filtering based on `popcount` or bitmask properties  
- Weighted contributions via product or sum

---

##  Reusable Structure

- Precompute powers and combinations  
- Simulate bitwise sum via carry  
- Track state via `(rem, carry, ones)`  
- Filter final states via `popcount`

---

##  Example Problems

- Count sequences with exact bitmask  
- Sum products of subsets with bitwise constraints  
- Simulate binary addition with carry and filtering

---

##  Alternative Approaches (Comparison Table)

| Method            | Time Complexity   | Pros                        | Cons                          |
|-------------------|-------------------|-----------------------------|-------------------------------|
| Full enumeration  | `O(n^m)`          | Accurate                    | TLE for large `m`             |
| Bitmask DP        | `O(2^n)`          | Fast for small `n`          | Hard to track multiplicity    |
| Carry simulation  | `O(n * m² * k)`   | Clean, scalable, accurate   | Requires precomputation       |

---

##  Conclusions

This solution is a clean example of **bitwise simulation via combinatorial weighting**.  
Instead of enumerating all sequences, we:

- Simulate how bits accumulate  
- Count how many ways each configuration appears  
- Filter by exact bit count  
- Return the total weighted sum



---

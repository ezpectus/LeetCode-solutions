# 🧩 **Problem**: Shortest Subarray with Sum at Least K

---

### 📜 Description

Given an integer array `nums` and an integer `k`, return the length of the shortest non-empty subarray with a sum of at least `k`.  
If no such subarray exists, return `-1`.

---

### 🧠 Pattern: Monotonic Queue + Prefix Sum

This is the same architectural pattern used in:

- Sliding window with dynamic range validation
- Prefix sum to convert range sum queries into differences
- Monotonic queue to maintain candidate start indices for optimal subarray length

---

### 🧱 Implementation

```csharp
public class Solution {
    public int ShortestSubarray(int[] nums, int k) {
        int n = nums.Length;
        long[] prefix = new long[n + 1];

        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + nums[i];
        }

        var deque = new LinkedList<int>();
        int min = int.MaxValue;

        for (int i = 0; i <= n; i++) {
            while (deque.Count > 0 && prefix[i] - prefix[deque.First.Value] >= k) {
                min = Math.Min(min, i - deque.First.Value);
                deque.RemoveFirst();
            }

            while (deque.Count > 0 && prefix[i] <= prefix[deque.Last.Value]) {
                deque.RemoveLast();
            }

            deque.AddLast(i);
        }

        return min == int.MaxValue ? -1 : min;
    }
}
```


## 🧠 Pattern Module: Prefix Sum + Monotonic Queue Optimization

---

### ✅ Strategic Takeaways

- This pattern is **fully internalized** — you no longer need walkthroughs or hand-holding.
- You recognize the signal **instantly**: prefix sum transforms range queries into difference checks, and monotonic queue maintains optimal candidates.
- The grind is over. You’re now in the **reuse and abstraction phase** — this is a tool in your belt, not a puzzle to solve.
- You’ve crossed the threshold from “solving” to **architecting** — this pattern is now part of your system-level thinking.

---

### 🧰 What This Pattern Builds

- 🔁 **Reflex for range sum via prefix difference**  
  You no longer think in terms of raw sums — you instinctively reach for prefix arrays to unlock constant-time range queries.

- 🧮 **Monotonic queue intuition for optimal window tracking**  
  You understand when to prune, when to hold, and how to maintain a queue that reflects the best candidates for minimal length or maximal value.

- 🧠 **Recognition of pruning conditions based on prefix growth**  
  You’ve internalized the logic:  
  - Remove from front when the current prefix satisfies the condition  
  - Remove from back when the current prefix is worse than previous candidates

- 🧱 **Architectural clarity**  
  You now see this not as a trick, but as a **clean separation of concerns**:  
  - Prefix sum handles range abstraction  
  - Monotonic queue handles candidate optimization  
  - The loop orchestrates the interaction

---

### 🧪 When to Reach for This Pattern

| Signal | Description |
|--------|-------------|
| ✅ Need to find shortest/longest subarray with sum constraints | Especially when brute force is too slow |
| ✅ Constraints involve "at least k" or "at most k" | Prefix sum + queue handles inequalities |
| ✅ Optimization over window length or value | Monotonic queue maintains optimal candidates |
| ✅ Negative numbers allowed | Sliding window breaks, prefix sum survives |

---

### 🧨 Common Pitfalls

- ❌ Forgetting to use `long` for prefix sums — overflow kills correctness
- ❌ Mismanaging queue pruning — wrong order leads to missed candidates
- ❌ Not handling edge case when no valid subarray exists — must return `-1`
- ❌ Assuming sliding window works with negatives — it doesn’t

---

### 🧠 Status: Locked In

This pattern is no longer something you “solve.”  
It’s something you **deploy**.  
You’ve abstracted it, reused it, and now it’s part of your architectural reflexes.

You don’t just recognize it — you **feel** when it’s right.  
And when it’s wrong, you know **why**.

---





---



# ðŸ§© **Problem**: Shortest Subarray with Sum at Least K

---

### ðŸ“œ Description

Given an integer array `nums` and an integer `k`, return the length of the shortest non-empty subarray with a sum of at least `k`.  
If no such subarray exists, return `-1`.

---

### ðŸ§  Pattern: Monotonic Queue + Prefix Sum

This is the same architectural pattern used in:

- Sliding window with dynamic range validation
- Prefix sum to convert range sum queries into differences
- Monotonic queue to maintain candidate start indices for optimal subarray length

---

### ðŸ§± Implementation

```csharp
public class Solution {
    public int ShortestSubarray(int[] nums, int k) {
        int n = nums.Length;
        long[] prefix = new long[n + 1];

        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + nums[i];
        }

        var deque = new LinkedList<int>();
        int min = int.MaxValue;

        for (int i = 0; i <= n; i++) {
            while (deque.Count > 0 && prefix[i] - prefix[deque.First.Value] >= k) {
                min = Math.Min(min, i - deque.First.Value);
                deque.RemoveFirst();
            }

            while (deque.Count > 0 && prefix[i] <= prefix[deque.Last.Value]) {
                deque.RemoveLast();
            }

            deque.AddLast(i);
        }

        return min == int.MaxValue ? -1 : min;
    }
}
```


## ðŸ§  Pattern Module: Prefix Sum + Monotonic Queue Optimization

---

### âœ… Strategic Takeaways

- This pattern is **fully internalized** â€” you no longer need walkthroughs or hand-holding.
- You recognize the signal **instantly**: prefix sum transforms range queries into difference checks, and monotonic queue maintains optimal candidates.
- The grind is over. Youâ€™re now in the **reuse and abstraction phase** â€” this is a tool in your belt, not a puzzle to solve.
- Youâ€™ve crossed the threshold from â€œsolvingâ€ to **architecting** â€” this pattern is now part of your system-level thinking.

---

### ðŸ§° What This Pattern Builds

- ðŸ” **Reflex for range sum via prefix difference**  
  You no longer think in terms of raw sums â€” you instinctively reach for prefix arrays to unlock constant-time range queries.

- ðŸ§® **Monotonic queue intuition for optimal window tracking**  
  You understand when to prune, when to hold, and how to maintain a queue that reflects the best candidates for minimal length or maximal value.

- ðŸ§  **Recognition of pruning conditions based on prefix growth**  
  Youâ€™ve internalized the logic:  
  - Remove from front when the current prefix satisfies the condition  
  - Remove from back when the current prefix is worse than previous candidates

- ðŸ§± **Architectural clarity**  
  You now see this not as a trick, but as a **clean separation of concerns**:  
  - Prefix sum handles range abstraction  
  - Monotonic queue handles candidate optimization  
  - The loop orchestrates the interaction

---

### ðŸ§ª When to Reach for This Pattern

| Signal | Description |
|--------|-------------|
| âœ… Need to find shortest/longest subarray with sum constraints | Especially when brute force is too slow |
| âœ… Constraints involve "at least k" or "at most k" | Prefix sum + queue handles inequalities |
| âœ… Optimization over window length or value | Monotonic queue maintains optimal candidates |
| âœ… Negative numbers allowed | Sliding window breaks, prefix sum survives |

---

### ðŸ§¨ Common Pitfalls

- âŒ Forgetting to use `long` for prefix sums â€” overflow kills correctness
- âŒ Mismanaging queue pruning â€” wrong order leads to missed candidates
- âŒ Not handling edge case when no valid subarray exists â€” must return `-1`
- âŒ Assuming sliding window works with negatives â€” it doesnâ€™t

---

### ðŸ§  Status: Locked In

This pattern is no longer something you â€œsolve.â€  
Itâ€™s something you **deploy**.  
Youâ€™ve abstracted it, reused it, and now itâ€™s part of your architectural reflexes.

You donâ€™t just recognize it â€” you **feel** when itâ€™s right.  
And when itâ€™s wrong, you know **why**.

---





---



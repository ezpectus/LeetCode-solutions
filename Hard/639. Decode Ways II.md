# LeetCode 639 — Decode Ways II  
**Approach: Dynamic Programming with Wildcard Handling**

---

##  Problem Restatement
We must count the number of ways to decode a string `s` containing digits (`0–9`) and wildcard `*` (which can represent digits `1–9`).  
Rules:  
- Single digit `1–9` → valid letter.  
- Two digits `10–26` → valid letter.  
- `*` expands possibilities.  
Return result modulo `10^9 + 7`.

---

##  Core Idea
- Use **DP** where `dp[i]` = number of ways to decode prefix of length `i`.  
- Transitions depend on:  
  - Single character decode.  
  - Two-character decode.  
- Special handling for `*`:  
  - As single digit → 9 possibilities.  
  - As part of two-digit decode → multiple cases.  

---

##  Implementation (C#)

```csharp
public class Solution {
    private const int MOD = 1000000007;

    public int NumDecodings(string s) {
        int n = s.Length;
        long[] dp = new long[n + 1];
        dp[0] = 1;

        dp[1] = CountSingle(s[0]);

        for (int i = 2; i <= n; i++) {
            dp[i] = (CountSingle(s[i - 1]) * dp[i - 1]) % MOD;
            dp[i] = (dp[i] + (CountPair(s[i - 2], s[i - 1]) * dp[i - 2]) % MOD) % MOD;
        }

        return (int)dp[n];
    }

    private int CountSingle(char c) {
        if (c == '*') return 9;
        if (c == '0') return 0;
        return 1;
    }

    private int CountPair(char c1, char c2) {
        if (c1 == '*' && c2 == '*') {
            // "**" can be 11–19 and 21–26
            return 15;
        } else if (c1 == '*') {
            if (c2 >= '0' && c2 <= '6') return 2; // "1x" or "2x"
            else return 1; // only "1x"
        } else if (c2 == '*') {
            if (c1 == '1') return 9; // "1*"
            else if (c1 == '2') return 6; // "2*"
            else return 0;
        } else {
            int val = (c1 - '0') * 10 + (c2 - '0');
            return (val >= 10 && val <= 26) ? 1 : 0;
        }
    }
}
```



##  Time Complexity
- **Single pass over string:**  
  Each character is processed once with constant-time checks for single and pair decodes.  
  → `O(n)` where `n` = length of string.  

- **Transition checks:**  
  Each step involves at most two transitions (single + pair).  
  → Constant work per character.  

- **Overall:**  
  → `O(n)`.

---

##  Space Complexity
- **DP array:**  
  Size = `n+1` to store prefix counts.  
  → `O(n)`.  

- **Optimization:**  
  Since each state depends only on the previous two, we can reduce to rolling variables.  
  → `O(1)` space.  

---

# Impact of Design Choices

| Design Choice                  | Effect                                                                 |
|--------------------------------|------------------------------------------------------------------------|
| **DP with prefix counts**      | Ensures linear scan, avoids recursion and exponential branching.       |
| **Wildcard handling**          | Correctly expands possibilities for `*` in both single and pair contexts. |
| **Modulo arithmetic**          | Keeps results bounded, avoids overflow for large `n`.                  |
| **Rolling array optimization** | Reduces memory usage to constant space without affecting correctness.  |

---

#  Pitfalls
- **Forgetting to handle `*` in both contexts:**  
  Leads to undercounting or invalid results.  
- **Ignoring `0`:**  
  Invalid as single decode, but valid in pairs (`10`, `20`).  
- **Missing modulo:**  
  Causes overflow when `n` is large.  
- **Not optimizing space:**  
  May lead to unnecessary memory usage for very large `n`.  

---

#  Conclusion
- **What it gives:** Number of valid decodings for strings with digits and wildcards.  
- **Why it matters:** Extends the classic "Decode Ways" problem to handle wildcard complexity.  
- **Key takeaway:**  
  1. Use DP with single + pair transitions.  
  2. Handle `*` carefully in both contexts.  
  3. Apply modulo `10^9 + 7` to keep results safe.  
  4. Optimize space with rolling variables for efficiency.  



---

# 1345. Jump Game IV

---

##  Problem Restatement
You are given an integer array `arr`. You start at index `0`.  
In one step, you can jump to:
- `i + 1` (if within bounds),
- `i - 1` (if within bounds),
- any index `j` where `arr[i] == arr[j]` and `i != j`.

Return the minimum number of steps to reach the last index.  
Constraints:  
- `1 ≤ arr.length ≤ 5 * 10^4`  
- `-10^8 ≤ arr[i] ≤ 10^8`

---

##  Core Idea
- This is a shortest path problem in an implicit graph:
  - Nodes = indices of the array.  
  - Edges = moves to `i+1`, `i-1`, and same‑value indices.  
- Since all edges have equal weight, **BFS** guarantees the minimum steps.  
- Optimization: once we expand all indices of a given value, we clear that list to avoid redundant revisits.

---

##  Step‑by‑Step
1. Build a dictionary mapping `value → list of indices`.  
2. Initialize BFS from index `0`.  
3. For each node, expand to:
   - `i+1` and `i-1` (if valid).  
   - All indices with the same value.  
4. Mark visited indices to avoid cycles.  
5. Return the distance when reaching the last index.

---

##  Code (C#)
```csharp
public class Solution {
    public int MinJumps(int[] arr) {
        int n = arr.Length;
        if (n == 1) return 0;

        var map = new Dictionary<int, List<int>>();
        for (int i = 0; i < n; i++) {
            if (!map.ContainsKey(arr[i])) map[arr[i]] = new List<int>();
            map[arr[i]].Add(i);
        }

        var visited = new bool[n];
        var queue = new Queue<(int idx, int dist)>();
        queue.Enqueue((0, 0));
        visited[0] = true;

        while (queue.Count > 0) {
            var (idx, dist) = queue.Dequeue();
            if (idx == n - 1) return dist;

            // neighbors: i-1, i+1
            if (idx - 1 >= 0 && !visited[idx - 1]) {
                visited[idx - 1] = true;
                queue.Enqueue((idx - 1, dist + 1));
            }
            if (idx + 1 < n && !visited[idx + 1]) {
                visited[idx + 1] = true;
                queue.Enqueue((idx + 1, dist + 1));
            }

            // same value neighbors
            if (map.ContainsKey(arr[idx])) {
                foreach (var nei in map[arr[idx]]) {
                    if (!visited[nei]) {
                        visited[nei] = true;
                        queue.Enqueue((nei, dist + 1));
                    }
                }
                map.Remove(arr[idx]); // clear to avoid redundant expansions
            }
        }
        return -1;
    }
}
```

## Complexity
- **Time:** O(N) — each index is processed at most once.  
  BFS ensures shortest path discovery in linear time.  
  Clearing same‑value lists after expansion prevents redundant traversals and guarantees efficiency.  
- **Space:** O(N) — dictionary stores indices grouped by value, queue holds frontier nodes, and visited array tracks explored indices.  
  All structures scale linearly with input size.

---
## Pitfalls
- **Same‑value expansion:** Forgetting to clear the list of indices for a given value leads to repeated expansions and potential TLE.  
- **Visited marking:** If visited nodes are not tracked properly, BFS may revisit indices and enter infinite loops.  
- **Edge cases:**  
  - `arr.Length = 1` → answer is `0` (already at last index).  
  - Arrays with many duplicates → clearing lists is critical for performance.  
  - Arrays with unique values → BFS behaves like simple linear traversal.  
- **Queue growth:** BFS may enqueue many nodes at once; ensure memory usage is handled correctly.

---

## Conclusion
This problem reduces to **BFS on an implicit graph**:  
- Nodes = array indices.  
- Edges = adjacency (`i±1`) and teleportation via equal values.  

By clearing same‑value lists after expansion, we avoid redundant work and maintain linear complexity.  
Result: a clean `O(N)` solution, robust for `N ≤ 5 * 10^4`, and a textbook example of BFS with value‑group teleportation.

---





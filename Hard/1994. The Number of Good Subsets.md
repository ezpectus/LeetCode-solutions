# ğŸ”º Problem: The Number of Good Subsets (Leetcode 1994)

## ğŸ“œ Statement

You are given an integer array `nums`. A subset of `nums` is called **good** if the product of its elements can be represented as a product of one or more **distinct prime numbers**.

- For example, `[2, 3]` is good because `2 Ã— 3 = 6`, and 6 is the product of distinct primes.
- `[4]` is not good because `4 = 2 Ã— 2`, and 2 is repeated.

Return the number of **different good subsets** in `nums`, modulo `10â¹ + 7`.

Two subsets are considered different if they differ by indices, even if they contain the same values.

---

## ğŸ§  Core Idea

This is a **bitmask + dynamic programming** problem disguised as a subset enumeration.

The key insight is:

> We are only interested in subsets whose product is a multiplication of **distinct primes** â€” no repeated prime factors allowed.

This means:

- We must **exclude numbers** that contain square factors (like 4 = 2Â², 8 = 2Â³, 9 = 3Â², etc.)
- We must **track which primes are used** in each subset to avoid duplication
- We must **count combinations** of valid numbers whose prime factors do not overlap

---

## ğŸ” Step-by-Step Breakdown

### ğŸ”¢ Step 1: Frequency Count

We count how many times each number from 1 to 30 appears in `nums`.  
Why 30? Because `nums[i] â‰¤ 30`, so the domain is small and fixed.

```csharp
int[] freq = new int[31];
foreach (int num in nums) freq[num]++;
```

## ğŸ§® Step 2: Prime Factor Encoding

We define the set of primes up to 30:

```csharp
int[] primes = new int[] {2,3,5,7,11,13,17,19,23,29};
```
Each valid number (from 2 to 30) is encoded as a bitmask representing which primes divide it.

For example:

- 6 = 2 Ã— 3 â†’ mask = 0000000011
- 10 = 2 Ã— 5 â†’ mask = 0000000101

 We exclude numbers that contain repeated prime factors (like 4 = 2Â², 8 = 2Â³, 9 = 3Â², etc.)

```cpp
Dictionary<int, int> maskMap = new();
for (int i = 2; i <= 30; i++) {
    int mask = 0;
    bool valid = true;
    for (int j = 0; j < primes.Length; j++) {
        int p = primes[j];
        if (i % (p * p) == 0) {
            valid = false;
            break;
        }
        if (i % p == 0) mask |= (1 << j);
    }
    if (valid) maskMap[i] = mask;
}
```

## ğŸ§  Step 3: DP Over Bitmasks
 We define a DP array dp[state], where state is a bitmask representing the set of primes used so far.

- dp[0] = 1 â†’ base case: empty subset

For each valid number, we try to add it to existing states only if its prime mask does not overlap.
```cpp
long[] dp = new long[1 << primes.Length];
dp[0] = 1;

foreach (var kv in maskMap) {
    int num = kv.Key, mask = kv.Value;
    for (int state = (1 << primes.Length) - 1; state >= 0; state--) {
        if ((state & mask) == 0) {
            dp[state | mask] = (dp[state | mask] + dp[state] * freq[num]) % MOD;
        }
    }
}
```

This ensures that:

- We only build subsets with non-overlapping prime factors
- We multiply by freq[num] to account for multiple occurrences

## ğŸ” Step 4: Final Aggregation

We sum all dp[state] for state â‰  0 â€” these are all non-empty good subsets.
```cpp
long result = 0;
for (int i = 1; i < dp.Length; i++) result = (result + dp[i]) % MOD;
```

## ğŸ¯ Step 5: Handle 1s Separately
- The number 1 can be added to any subset without affecting the product. 
- So we multiply the result by 2^count_of_1s â€” each 1 can be either included or not.

```cpp
int ones = freq[1];
long pow = 1;
for (int i = 0; i < ones; i++) pow = (pow * 2) % MOD;

return (int)(result * pow % MOD);
```

## ğŸ§± Full C# Implementation
```cpp
public class Solution {
    public int NumberOfGoodSubsets(int[] nums) {
        const int MOD = 1_000_000_007;
        int[] freq = new int[31];
        foreach (int num in nums) freq[num]++;

        int[] primes = new int[] {2,3,5,7,11,13,17,19,23,29};
        Dictionary<int, int> maskMap = new();
        for (int i = 2; i <= 30; i++) {
            int mask = 0;
            bool valid = true;
            for (int j = 0; j < primes.Length; j++) {
                int p = primes[j];
                if (i % (p * p) == 0) {
                    valid = false;
                    break;
                }
                if (i % p == 0) mask |= (1 << j);
            }
            if (valid) maskMap[i] = mask;
        }

        long[] dp = new long[1 << primes.Length];
        dp[0] = 1;

        foreach (var kv in maskMap) {
            int num = kv.Key, mask = kv.Value;
            for (int state = (1 << primes.Length) - 1; state >= 0; state--) {
                if ((state & mask) == 0) {
                    dp[state | mask] = (dp[state | mask] + dp[state] * freq[num]) % MOD;
                }
            }
        }

        long result = 0;
        for (int i = 1; i < dp.Length; i++) result = (result + dp[i]) % MOD;

        int ones = freq[1];
        long pow = 1;
        for (int i = 0; i < ones; i++) pow = (pow * 2) % MOD;

        return (int)(result * pow % MOD);
    }
}
```



## ğŸ” Why This Code Is Optimized

### âœ… Prime Masking
Encodes each number as a bitmask of primes â€” avoids repeated factors  
This ensures that only numbers with distinct prime factorizations are considered, eliminating invalid candidates like 4 (2Â²), 8 (2Â³), or 9 (3Â²).

### ğŸ” DP Over States
Efficiently builds valid subsets using bitmask transitions  
Each DP state represents a unique combination of primes used so far. Transitions only occur when the new numberâ€™s prime mask does not overlap with the current state â€” preserving the â€œdistinct primesâ€ constraint.

### ğŸ§® Frequency Scaling
Handles multiple occurrences of the same number via `freq[num]`  
Instead of treating each instance separately, we scale the contribution of each number by its frequency, allowing combinatorial growth without explicit enumeration.

### ğŸš€ 1s Handling
Multiplies final result by `2^count_of_1s` â€” clean and isolated  
Since 1 does not affect the product, it can be freely added to any subset. We handle this multiplicative freedom at the end, avoiding contamination of DP logic.

### ğŸ§  Minimal State
No recursion, no subset simulation â€” just bitmask DP  
The solution avoids exponential subset generation and instead uses compact, deterministic state transitions over a fixed bitmask space.

---

## ğŸ§® Time & Space Complexity

| Metric      | Value             | Notes                                      |
|-------------|-------------------|--------------------------------------------|
| Time        | O(30 Ã— 2Â¹â°)       | 30 valid numbers, 1024 DP states           |
| Space       | O(2Â¹â°)            | DP array over bitmask states               |
| Stability   | High              | Deterministic, no branching                |
| Scalability | Excellent         | Handles full input range up to 10âµ         |

---

## ğŸ§  Engineering Takeaway

This task is a clean example of:

- âœ… **Bitmask modeling** â€” encode prime usage as binary states  
- ğŸ”¢ **Subset building via DP** â€” no brute-force enumeration  
- ğŸ§  **Mathematical filtering** â€” exclude invalid numbers early  
- ğŸš€ **Frequency-aware transitions** â€” scale combinations properly

> Youâ€™re not generating subsets â€” youâ€™re **constructing valid prime spaces with precision**.

---

## ğŸ§© Conclusion

**The Number of Good Subsets** is a textbook example of how **bitmasking + DP**  
can replace brute-force subset generation.  
By encoding prime usage and filtering invalid numbers,  
we build a scalable and elegant solution.

> **Architecture wins over brute force â€” always.**



---




# 🔺 Problem: The Number of Good Subsets (Leetcode 1994)

## 📜 Statement

You are given an integer array `nums`. A subset of `nums` is called **good** if the product of its elements can be represented as a product of one or more **distinct prime numbers**.

- For example, `[2, 3]` is good because `2 × 3 = 6`, and 6 is the product of distinct primes.
- `[4]` is not good because `4 = 2 × 2`, and 2 is repeated.

Return the number of **different good subsets** in `nums`, modulo `10⁹ + 7`.

Two subsets are considered different if they differ by indices, even if they contain the same values.

---

## 🧠 Core Idea

This is a **bitmask + dynamic programming** problem disguised as a subset enumeration.

The key insight is:

> We are only interested in subsets whose product is a multiplication of **distinct primes** — no repeated prime factors allowed.

This means:

- We must **exclude numbers** that contain square factors (like 4 = 2², 8 = 2³, 9 = 3², etc.)
- We must **track which primes are used** in each subset to avoid duplication
- We must **count combinations** of valid numbers whose prime factors do not overlap

---

## 🔍 Step-by-Step Breakdown

### 🔢 Step 1: Frequency Count

We count how many times each number from 1 to 30 appears in `nums`.  
Why 30? Because `nums[i] ≤ 30`, so the domain is small and fixed.

```csharp
int[] freq = new int[31];
foreach (int num in nums) freq[num]++;
```

## 🧮 Step 2: Prime Factor Encoding

We define the set of primes up to 30:

```csharp
int[] primes = new int[] {2,3,5,7,11,13,17,19,23,29};
```
Each valid number (from 2 to 30) is encoded as a bitmask representing which primes divide it.

For example:

- 6 = 2 × 3 → mask = 0000000011
- 10 = 2 × 5 → mask = 0000000101

 We exclude numbers that contain repeated prime factors (like 4 = 2², 8 = 2³, 9 = 3², etc.)

```cpp
Dictionary<int, int> maskMap = new();
for (int i = 2; i <= 30; i++) {
    int mask = 0;
    bool valid = true;
    for (int j = 0; j < primes.Length; j++) {
        int p = primes[j];
        if (i % (p * p) == 0) {
            valid = false;
            break;
        }
        if (i % p == 0) mask |= (1 << j);
    }
    if (valid) maskMap[i] = mask;
}
```

## 🧠 Step 3: DP Over Bitmasks
 We define a DP array dp[state], where state is a bitmask representing the set of primes used so far.

- dp[0] = 1 → base case: empty subset

For each valid number, we try to add it to existing states only if its prime mask does not overlap.
```cpp
long[] dp = new long[1 << primes.Length];
dp[0] = 1;

foreach (var kv in maskMap) {
    int num = kv.Key, mask = kv.Value;
    for (int state = (1 << primes.Length) - 1; state >= 0; state--) {
        if ((state & mask) == 0) {
            dp[state | mask] = (dp[state | mask] + dp[state] * freq[num]) % MOD;
        }
    }
}
```

This ensures that:

- We only build subsets with non-overlapping prime factors
- We multiply by freq[num] to account for multiple occurrences

## 🔁 Step 4: Final Aggregation

We sum all dp[state] for state ≠ 0 — these are all non-empty good subsets.
```cpp
long result = 0;
for (int i = 1; i < dp.Length; i++) result = (result + dp[i]) % MOD;
```

## 🎯 Step 5: Handle 1s Separately
- The number 1 can be added to any subset without affecting the product. 
- So we multiply the result by 2^count_of_1s — each 1 can be either included or not.

```cpp
int ones = freq[1];
long pow = 1;
for (int i = 0; i < ones; i++) pow = (pow * 2) % MOD;

return (int)(result * pow % MOD);
```

## 🧱 Full C# Implementation
```cpp
public class Solution {
    public int NumberOfGoodSubsets(int[] nums) {
        const int MOD = 1_000_000_007;
        int[] freq = new int[31];
        foreach (int num in nums) freq[num]++;

        int[] primes = new int[] {2,3,5,7,11,13,17,19,23,29};
        Dictionary<int, int> maskMap = new();
        for (int i = 2; i <= 30; i++) {
            int mask = 0;
            bool valid = true;
            for (int j = 0; j < primes.Length; j++) {
                int p = primes[j];
                if (i % (p * p) == 0) {
                    valid = false;
                    break;
                }
                if (i % p == 0) mask |= (1 << j);
            }
            if (valid) maskMap[i] = mask;
        }

        long[] dp = new long[1 << primes.Length];
        dp[0] = 1;

        foreach (var kv in maskMap) {
            int num = kv.Key, mask = kv.Value;
            for (int state = (1 << primes.Length) - 1; state >= 0; state--) {
                if ((state & mask) == 0) {
                    dp[state | mask] = (dp[state | mask] + dp[state] * freq[num]) % MOD;
                }
            }
        }

        long result = 0;
        for (int i = 1; i < dp.Length; i++) result = (result + dp[i]) % MOD;

        int ones = freq[1];
        long pow = 1;
        for (int i = 0; i < ones; i++) pow = (pow * 2) % MOD;

        return (int)(result * pow % MOD);
    }
}
```



## 🔍 Why This Code Is Optimized

### ✅ Prime Masking
Encodes each number as a bitmask of primes — avoids repeated factors  
This ensures that only numbers with distinct prime factorizations are considered, eliminating invalid candidates like 4 (2²), 8 (2³), or 9 (3²).

### 🔁 DP Over States
Efficiently builds valid subsets using bitmask transitions  
Each DP state represents a unique combination of primes used so far. Transitions only occur when the new number’s prime mask does not overlap with the current state — preserving the “distinct primes” constraint.

### 🧮 Frequency Scaling
Handles multiple occurrences of the same number via `freq[num]`  
Instead of treating each instance separately, we scale the contribution of each number by its frequency, allowing combinatorial growth without explicit enumeration.

### 🚀 1s Handling
Multiplies final result by `2^count_of_1s` — clean and isolated  
Since 1 does not affect the product, it can be freely added to any subset. We handle this multiplicative freedom at the end, avoiding contamination of DP logic.

### 🧠 Minimal State
No recursion, no subset simulation — just bitmask DP  
The solution avoids exponential subset generation and instead uses compact, deterministic state transitions over a fixed bitmask space.

---

## 🧮 Time & Space Complexity

| Metric      | Value             | Notes                                      |
|-------------|-------------------|--------------------------------------------|
| Time        | O(30 × 2¹⁰)       | 30 valid numbers, 1024 DP states           |
| Space       | O(2¹⁰)            | DP array over bitmask states               |
| Stability   | High              | Deterministic, no branching                |
| Scalability | Excellent         | Handles full input range up to 10⁵         |

---

## 🧠 Engineering Takeaway

This task is a clean example of:

- ✅ **Bitmask modeling** — encode prime usage as binary states  
- 🔢 **Subset building via DP** — no brute-force enumeration  
- 🧠 **Mathematical filtering** — exclude invalid numbers early  
- 🚀 **Frequency-aware transitions** — scale combinations properly

> You’re not generating subsets — you’re **constructing valid prime spaces with precision**.

---

## 🧩 Conclusion

**The Number of Good Subsets** is a textbook example of how **bitmasking + DP**  
can replace brute-force subset generation.  
By encoding prime usage and filtering invalid numbers,  
we build a scalable and elegant solution.

> **Architecture wins over brute force — always.**



---




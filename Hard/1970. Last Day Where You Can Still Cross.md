# 1970. Last Day Where You Can Still Cross

---

##  Problem Restatement
We are given a binary matrix of size `row x col`:  
- Initially (day 0), all cells are land (`0`).  
- Each day, one cell floods (`1`).  
- On day `i`, `cells[i] = [ri, ci]` becomes water.  

We want to find the **last day** when it is possible to walk from the **top row** to the **bottom row** using only land cells, moving in 4 directions (up, down, left, right).

---

##  Core Idea
- Use **DSU (Union-Find)** with rank and path compression.  
- Add two **virtual nodes**:  
  - `top` connected to all cells in the first row.  
  - `bottom` connected to all cells in the last row.  
- Traverse days **backwards**:  
  - Start with all water.  
  - Each day, convert one cell to land.  
  - Union it with neighboring land cells.  
  - Union with `top`/`bottom` if in first/last row.  
  - If `top` and `bottom` become connected ‚Üí that day is the answer.  

---

##  Code (C#)
```csharp
public class Solution {
    public int LatestDayToCross(int row, int col, int[][] cells) {
        int n = row * col;
        int top = n, bottom = n + 1;
        DSU dsu = new DSU(n + 2);

        bool[,] land = new bool[row, col];
        int[][] dirs = new int[][] {
            new int[]{1,0}, new int[]{-1,0}, new int[]{0,1}, new int[]{0,-1}
        };

        for (int day = cells.Length - 1; day >= 0; day--) {
            int r = cells[day][0] - 1;
            int c = cells[day][1] - 1;
            land[r, c] = true;
            int id = r * col + c;

            foreach (var d in dirs) {
                int nr = r + d[0], nc = c + d[1];
                if (nr >= 0 && nr < row && nc >= 0 && nc < col && land[nr, nc]) {
                    dsu.Union(id, nr * col + nc);
                }
            }

            if (r == 0) dsu.Union(id, top);
            if (r == row - 1) dsu.Union(id, bottom);

            if (dsu.Find(top) == dsu.Find(bottom)) {
                return day;
            }
        }
        return -1;
    }
}

public class DSU {
    private int[] parent;
    private int[] rank;

    public DSU(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
    }

    public int Find(int x) {
        if (parent[x] != x) parent[x] = Find(parent[x]);
        return parent[x];
    }

    public void Union(int x, int y) {
        int rx = Find(x), ry = Find(y);
        if (rx == ry) return;
        if (rank[rx] < rank[ry]) {
            parent[rx] = ry;
        } else if (rank[rx] > rank[ry]) {
            parent[ry] = rx;
        } else {
            parent[ry] = rx;
            rank[rx]++;
        }
    }
}
```
## ‚è±Ô∏è Complexity
- **Union-Find operations:** O(Œ±(N)), where Œ±(N) is the inverse Ackermann function (‚âà constant in practice).  
- **Total time:** O(N), where N = row * col, since each cell is processed once and each union/find is nearly constant.  
- **Space:** O(N) for DSU arrays (`parent`, `rank`) + O(N) for the grid state (`land`).  

This makes the solution scalable up to the maximum constraint (`row * col ‚â§ 2 * 10^4`).

---

## ‚ö†Ô∏è Pitfalls
- **Backward traversal:**  
  - Must simulate days in reverse (from last to first).  
  - Forward simulation would require checking connectivity after each flood, which is much harder.  
- **Indexing:**  
  - Each cell must be mapped to a unique DSU id: `id = r * col + c`.  
  - Off-by-one errors are common since input is 1-based.  
- **Virtual nodes:**  
  - Top row cells must union with a special `top` node.  
  - Bottom row cells must union with a special `bottom` node.  
  - Without these, checking connectivity from top to bottom is cumbersome.  
- **DSU efficiency:**  
  - Must use **rank + path compression** to avoid worst-case O(N) per operation.  
  - Ensures near-constant time union/find.  

---

## ‚úÖ Conclusion
This problem reduces to **DSU with rank + reverse simulation**.  
- Each day we "add back" land and union it with neighbors.  
- The DSU structure dynamically maintains connectivity.  
- As soon as the virtual `top` and `bottom` nodes are connected, that day is the last possible crossing.  

Result: clean O(N) solution, robust for grids up to 20,000 cells, with guaranteed efficiency.

---

## üåê Generalization
- **Pattern:** reverse simulation + DSU.  
- **Applications:**  
  - **Dynamic connectivity in graphs:** checking if two components remain connected as edges are added/removed.  
  - **Percolation problems:** modeling flow through porous media (classic union-find application).  
  - **Reachability checks:** verifying if a path exists under progressive constraints (e.g., flooding, blocking).  
- **Key insight:** DSU is ideal when connectivity is the only property we care about, not the exact path.

---

## üìä Example Walkthrough
Input:  
`row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]`

### Step-by-step:
- **Day 4:** all cells are water ‚Üí no path exists.  
- **Day 3:** cell (2,2) becomes land.  
  - DSU unions (2,2) with bottom virtual node.  
  - Path still not connected to top.  
- **Day 2:** cell (1,2) becomes land.  
  - DSU unions (1,2) with top virtual node.  
  - DSU unions (1,2) with neighbor (2,2).  
  - Now `top` and `bottom` are connected ‚Üí crossing possible.  
- **Day 1:** earlier days are irrelevant since we already found the last possible crossing.  

### Result:
Answer = **2**.

---

## üå≥ Visualization (conceptual)
```
Top virtual node
‚Üë
[1,2] (land) ‚Äî connected to ‚Äî [2,2] (land)
‚Üì
Bottom virtual node
```

At day 2, the path exists because the top and bottom virtual nodes are connected through land cells.


---

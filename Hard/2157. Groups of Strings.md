# 🧠 LeetCode 2157 — Groups of Strings  
**Category:** Bitmask / Graph / Union-Find  
**Difficulty:** Hard  
**Language:** C#  
**Pattern:** Bitmask Connectivity via One-Mutation Union-Find

---

## 💡 Problem Summary

You're given an array `words` of lowercase strings, each with unique letters.  
Two strings are **connected** if one can be transformed into the other by:
- Adding exactly one letter  
- Deleting exactly one letter  
- Replacing exactly one letter (including with itself)

A group is a set of strings connected directly or indirectly.  
Return an array `[groupCount, maxGroupSize]`:
- `groupCount`: total number of disjoint groups  
- `maxGroupSize`: size of the largest group

---

## 🧠 My Architectural Insight

Each word can be represented as a **bitmask** of letters.  
Connectivity between words is defined by **one mutation** of that bitmask:
- Add one bit → `mask | (1 << i)`  
- Delete one bit → `mask ^ (1 << i)`  
- Replace one bit → `mask ^ (1 << i) | (1 << j)` (if `i ≠ j`)

This forms an **implicit graph** of masks.  
We use **Union-Find** to merge connected masks and track group sizes.

---

## 🔧 My C# Implementation

```csharp
public class Solution {
    public int[] GroupStrings(string[] words) {
        var maskToIndex = new Dictionary<int, int>();
        var uf = new UnionFind(words.Length);

        for (int i = 0; i < words.Length; i++) {
            int mask = 0;
            foreach (char c in words[i])
                mask |= 1 << (c - 'a');

            if (maskToIndex.ContainsKey(mask))
                uf.Union(i, maskToIndex[mask]);
            else
                maskToIndex[mask] = i;
        }

        for (int i = 0; i < words.Length; i++) {
            int mask = 0;
            foreach (char c in words[i])
                mask |= 1 << (c - 'a');

            for (int b = 0; b < 26; b++) {
                if ((mask & (1 << b)) != 0) {
                    int deleted = mask ^ (1 << b);
                    if (maskToIndex.ContainsKey(deleted))
                        uf.Union(i, maskToIndex[deleted]);

                    for (int r = 0; r < 26; r++) {
                        if ((deleted & (1 << r)) == 0) {
                            int replaced = deleted | (1 << r);
                            if (maskToIndex.ContainsKey(replaced))
                                uf.Union(i, maskToIndex[replaced]);
                        }
                    }
                }
                else {
                    int added = mask | (1 << b);
                    if (maskToIndex.ContainsKey(added))
                        uf.Union(i, maskToIndex[added]);
                }
            }
        }

        var groupCount = new HashSet<int>();
        var groupSize = new Dictionary<int, int>();
        for (int i = 0; i < words.Length; i++) {
            int root = uf.Find(i);
            groupCount.Add(root);
            if (!groupSize.ContainsKey(root))
                groupSize[root] = 0;
            groupSize[root]++;
        }

        int maxSize = groupSize.Values.Max();
        return new int[] { groupCount.Count, maxSize };
    }

    class UnionFind {
        private int[] parent;

        public UnionFind(int n) {
            parent = Enumerable.Range(0, n).ToArray();
        }

        public int Find(int x) {
            if (parent[x] != x)
                parent[x] = Find(parent[x]);
            return parent[x];
        }

        public void Union(int x, int y) {
            int px = Find(x), py = Find(y);
            if (px != py)
                parent[py] = px;
        }
    }
}
```

## 🧩 Architectural Breakdown

| Component      | Role                                                                 |
|----------------|----------------------------------------------------------------------|
| `mask`         | Bitmask representation of each word                                  |
| `maskToIndex`  | Maps each unique mask to its word index                              |
| `UnionFind`    | Tracks connected components of words                                 |
| `mask ops`     | Generates all valid one-letter mutations (add, delete, replace)      |
| `groupCount`   | Counts total number of disjoint groups                               |
| `groupSize`    | Tracks size of each group                                            |

---

## 🔍 Why My Approach Is Superior

| Aspect               | My Approach                          | Alternative Approach                     |
|----------------------|--------------------------------------|------------------------------------------|
| Word Representation  | Bitmask                              | Set or string-based                      |
| Connectivity Logic   | One-bit mutation                     | Brute-force comparison                   |
| Graph Construction   | Implicit via masks                   | Explicit adjacency list                  |
| Performance          | Fast due to bit ops and UF           | Slower due to nested loops               |
| Memory Usage         | Compact (int masks)                  | Heavier (sets, strings)                  |
| Code Clarity         | Modular and scalable                 | Verbose and harder to extend             |
| Conceptual Ownership | Fully derived from architectural insight | Implementation driven by surface logic |

---

## ✅ Summary

This task isn’t about strings — it’s about **bitmask reachability through one mutation**.  
Once I saw that, the rest was just system-building:

- Bitmask encoding of each word  
- Mutation generation via bit operations  
- Union-Find to group connected components

No brute-force, no adjacency lists, no wasted cycles.  
Just clean architecture and minimal logic.

This module now lives in my repo as a reusable pattern:  
> **Bitmask Connectivity via One-Mutation Union-Find**

Designed to teach others how to think architecturally — not just solve problems.


---

# 2454. Next Greater Element IV

## Problem

You are given a 0-indexed array of non-negative integers `nums`.  
For each index `i`, find the **second greater element** to the right of `nums[i]`.  
The second greater element is defined as:

- An index `j > i` such that `nums[j] > nums[i]`
- There exists **exactly one index `k`** with `i < k < j` and `nums[k] > nums[i]`

If no such `j` exists, return `-1` for that position.

## Core Insight

This is a **monotonic stack simulation**, but not the classic “next greater” pattern.  
You must track **two levels of greater elements** — the first and the second — and preserve their relative order.  
The key is to use **two stacks**:

- One for elements waiting for their **first greater**
- One for elements that have seen their first greater and now wait for their **second**

You process the array left to right, and at each step:

- You resolve second greater values for the second stack
- You promote elements from the first stack to the second if they meet the first greater condition

## Architectural Triggers

- “Second greater element” → You must track two levels of resolution
- “Exactly one index k between i and j” → You must preserve order and simulate promotion
- “Constraints: up to 10^5 elements” → You must avoid nested loops and brute-force scanning

## What This Implies

- Use two stacks: `first` and `second`
- At each index `i`:
  - Resolve second greater for elements in `second` if `nums[i] > nums[x]`
  - Promote elements from `first` to `second` if `nums[i] > nums[x]`
  - Push current index `i` to `first`
- Use an array `res[]` initialized to `-1` to store answers

## Code

```csharp
public class Solution {
    public int[] SecondGreaterElement(int[] nums) {
        int n = nums.Length;
        int[] res = Enumerable.Repeat(-1, n).ToArray();
        var first = new Stack<int>();
        var second = new Stack<int>();

        for (int i = 0; i < n; i++) {
            // Resolve second greater
            var temp = new Stack<int>();
            while (second.Count > 0 && nums[i] > nums[second.Peek()]) {
                res[second.Pop()] = nums[i];
            }

            // Promote first greater to second stack
            while (first.Count > 0 && nums[i] > nums[first.Peek()]) {
                temp.Push(first.Pop());
            }
            while (temp.Count > 0) {
                second.Push(temp.Pop());
            }

            // Push current index to first stack
            first.Push(i);
        }

        return res;
    }
}
```


## Complexity

- **Time:** `O(n)`  
  - Each index is pushed and popped at most twice (once per stack)
  - All operations are constant-time per element

- **Space:** `O(n)`  
  - Two stacks and result array scale linearly with input size

## Pitfalls

- **Wrong promotion order:**  
  - Promoting directly from `first` to `second` breaks order — use a temp stack to reverse

- **Incorrect second resolution:**  
  - Only resolve second greater for elements already promoted — don’t mix with `first` stack

- **Off-by-one errors:**  
  - Be careful with stack peeks and pops — always check conditions before popping

## Insight

This is a two-phase monotonic stack simulation.  
You simulate the first greater resolution, then promote to a second waiting phase.  
The key is to preserve order and resolve second greater values only after the first has been seen.  
This pattern generalizes to multi-level “next greater” problems where each level depends on prior resolution.


---

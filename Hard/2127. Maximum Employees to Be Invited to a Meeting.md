# 🧠 Problem Overview

You're given an array `favorite[]` where `favorite[i]` is the person employee `i` wants to sit next to at a round table.  
Each employee will attend the meeting **only if their favorite is seated adjacent to them**.  
Return the **maximum number of employees** that can be invited under this constraint.

---

### 🔧 Graph Architecture

- Each employee points to one favorite → forms a **directed graph**
- The graph contains:
  - **Cycles** (e.g. `a → b → c → a`)
  - **Chains** leading into cycles (e.g. `x → y → z → a → b → c → a`)
- Two key patterns:
  - **Cycles of length ≥ 3** → can be invited fully
  - **Mutual pairs (length 2)** → can be extended with incoming chains

---

### 🧠 Final Strategy

```text
max(
    sum of (2 + max chain to a + max chain to b) for all mutual pairs,
    max cycle length (excluding mutual pairs)
)
```

## 💻 Clean C# Implementation
```csharp
public class Solution {
    public int MaximumInvitations(int[] favorite) {
        int n = favorite.Length;
        int[] indegree = new int[n];
        foreach (int f in favorite) indegree[f]++;

        int[] depth = new int[n];
        Queue<int> queue = new Queue<int>();

        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) queue.Enqueue(i);
        }

        while (queue.Count > 0) {
            int node = queue.Dequeue();
            int fav = favorite[node];
            depth[fav] = Math.Max(depth[fav], depth[node] + 1);
            if (--indegree[fav] == 0) queue.Enqueue(fav);
        }

        bool[] visited = new bool[n];
        int maxCycle = 0;
        int mutualSum = 0;

        for (int i = 0; i < n; i++) {
            if (visited[i] || indegree[i] == 0) continue;

            int curr = i, count = 0;
            while (!visited[curr]) {
                visited[curr] = true;
                curr = favorite[curr];
                count++;
            }

            if (count == 2 && favorite[favorite[i]] == i) {
                int a = i, b = favorite[i];
                mutualSum += 2 + depth[a] + depth[b];
            } else {
                maxCycle = Math.Max(maxCycle, count);
            }
        }

        return Math.Max(maxCycle, mutualSum);
    }
}
```

### 🧠 Signals Recap — Deep Dive

#### 📦 Directed Graph with Outdegree = 1

- Each employee points to exactly one favorite → forms a **directed graph** with outdegree = 1
- This structure guarantees:
  - Presence of **cycles** (since every node has one outgoing edge)
  - Potential for **chains** leading into cycles
- Signal: You’re not dealing with arbitrary graphs — you’re working with a **functional graph**, which enables clean traversal and decomposition

---

#### 🔁 Topological Sort to Isolate Chains

- Nodes with `indegree = 0` cannot be part of any cycle
- We perform a **topological sort** to remove these nodes and propagate their depth into their favorite
- This isolates **non-cyclic chains**, which can later be attached to mutual pairs
- Signal: You’re using topological sort not for ordering, but as a **filtering mechanism** to extract usable depth data

---

#### 🔗 Cycle Detection for Full Group Invites

- Cycles of length ≥ 3 can be invited **as-is**, since each person sits between two others
- We traverse unvisited nodes to detect cycles and track their length
- The **maximum cycle length** becomes one candidate for the final answer
- Signal: You’re not just detecting cycles — you’re **quantifying their group potential**

---

#### 🧱 Mutual Pair Extension via Depth Tracking

- Mutual pairs: `a → b`, `b → a` → cycle of length 2
- These pairs can be extended with **incoming chains** (e.g. `x → a`, `y → b`)
- Depth values from topological sort tell us how long each chain is
- Final contribution from each pair: `2 + depth[a] + depth[b]`
- Signal: You’re combining **cycle core + chain extensions** to maximize group size

---

### 🧠 Insights from the Problem

- This is not a classic graph traversal — it’s a **structural optimization** task
- You’re decomposing the graph into **usable components**:
  - Cycles that can be invited directly
  - Mutual pairs that can be extended
- The final answer is a **max of two architectural strategies**:
  - Full cycle invite
  - Sum of extended mutual pairs

---

📦 This pattern generalizes to problems involving:
- Directed graphs with fixed outdegree
- Cycle-based grouping
- Chain extension logic
- Depth propagation via topological sort

---




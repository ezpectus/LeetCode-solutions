# ğŸ”º Problem: Numbers At Most N Given Digit Set (Leetcode 902)
## ğŸ“œ Problem Explanation
- We are given a sorted array of digits digits (each from '1' to '9'). 
- We can form numbers by using these digits any number of times. 
- We need to count how many positive integers can be formed that are â‰¤ n.

## ğŸ“ Constraints
- 1 <= digits.length <= 9
- Each digits[i] is a unique digit '1'â€“'9'
- digits is sorted
- 1 <= n <= 10^9
```
 Since n can be up to 10^9 (10 digits), brute force enumeration is impossible.
We need a digit-DP / combinatorial counting approach.
```
## âš¡ï¸ Algorithm Choice

- Brute force is infeasible (too many numbers).
- Digit DP / combinatorics is optimal:
- Count all numbers shorter than n.
- Then carefully count numbers of the same length as n digit by digit.
- This ensures complexity O(lenN Ã— lenD), which is efficient.

## ğŸ§  Core Idea

- Count shorter numbers
- If lenN = length(n), then for each length i < lenN, we can form lenD^i numbers.
- Count numbers with the same length as n
- Traverse digits of n.

At position i:

- If a digit from digits is smaller than n[i], add lenD^(remaining) possibilities.
- If equal, continue.
- If larger, stop.
- Final adjustment
- If all digits matched, add +1 (for n itself).

## ğŸ’» C# Implementation
```csharp
public class Solution {
    public int AtMostNGivenDigitSet(string[] digits, int n) {
        string str = n.ToString();
        int lenN = str.Length;
        int lenD = digits.Length;
        int res = 0;

        // Precompute powers of lenD
        int[] powers = new int[lenN + 1];
        powers[0] = 1;
        for (int i = 1; i <= lenN; i++) {
            powers[i] = powers[i - 1] * lenD;
        }

        // 1) Count numbers with fewer digits
        for (int i = 1; i < lenN; i++) {
            res += powers[i];
        }

        // 2) Count numbers with same length
        for (int i = 0; i < lenN; i++) {
            bool seen = false;
            foreach (var digit in digits) {
                if (digit[0] < str[i]) {
                    res += powers[lenN - i - 1];
                } else if (digit[0] == str[i]) {
                    seen = true;
                    break;
                } else break;
            }
            if (!seen) return res;
        }

        // 3) Add n itself if fully matched
        return res + 1;
    }
}
```

## ğŸ” Why This Works 

- Shorter numbers: All valid, counted via exponentiation.
- Same length numbers: Checked digit by digit against n.
- Early termination: If no digit matches n[i], larger digits would exceed n.
- Final +1: If all digits matched, include n itself.

## ğŸ§® Time & Space Complexity

- Time	O(lenN Ã— lenD)	```For each digit of n, scan digit set```
- Space	O(lenN)```	Powers array```
- Scalability	Excellent	Works for n â‰¤ 10â¹, digits â‰¤ 9

## ğŸ§  Engineering Takeaway 
This problem is a digit DP disguised as combinatorics:

- Count shorter lengths directly with powers.
- Handle equal length numbers digit by digit.
- Use early termination when exceeding n.
- Instead of brute force, we count structurally â€” architecture over simulation.





---

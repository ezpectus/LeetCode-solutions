# ğŸ”º Problem: Count Increasing Quadruplets (Leetcode 2552)
## ğŸ“œ Statement

- You are given a 0-indexed integer array nums of size n containing all numbers from 1 to n (a permutation).
- Return the number of quadruplets (i, j, k, l) such that:
- 0 <= i < j < k < l < n
- nums[i] < nums[k] < nums[j] < nums[l]

## ğŸ§  Core Idea
- Brute force O(n^4) is impossible for n â‰¤ 4000. 

We need to count valid quadruplets indirectly:

- Maintain a sorted prefix of elements before index i.
- For each i, insert nums[i] into this prefix.
- For each j > i, count:
- how many l > j satisfy nums[j] < nums[l]
- how many i < j satisfy nums[i] < nums[j]
- Multiply these counts to accumulate valid quadruplets.
- This uses binary search on the prefix to count smaller elements efficiently.


## ğŸ§ª Examples
```text
Input: nums = [1,3,2,4,5]
Output: 2

Explanation:
- (i=0, j=1, k=2, l=3) â†’ 1 < 2 < 3 < 4
- (i=0, j=1, k=2, l=4) â†’ 1 < 2 < 3 < 5
text
Input: nums = [1,2,3,4]
Output: 0
```

## ğŸ§± C# Implementation
```csharp
public class Solution {
    public long CountQuadruplets(int[] nums) {
        long res = 0;
        List<int> sl = new List<int>() { nums[0] };
        int n = nums.Length;

        for (int i = 1; i < n; i++) {
            // Insert nums[i] into sorted prefix
            var idx = sl.BinarySearch(nums[i]);
            if (idx < 0) idx = ~idx;
            sl.Insert(idx, nums[i]);

            int count = nums[i] < nums[^1] ? 1 : 0;

            // Iterate backwards for j
            for (int j = n - 2; j > i; j--) {
                if (nums[i] < nums[j]) {
                    count++;
                    continue;
                }

                idx = sl.BinarySearch(nums[j]);
                if (idx < 0) idx = ~idx;

                // idx = number of elements < nums[j]
                res += (long)idx * count;
            }
        }
        return res;
    }
}
```

## ğŸ” Why This Code Works

âœ… Sorted Prefix
- Keeps all numbers before i in sorted order. 
- Binary search gives count of smaller elements in O(log n).

ğŸ” Backward Scan
```
For each j, we count valid l indices ```nums[j] < nums[l]```.
```
ğŸ§® Quadruplet Count
For each (i, j) pair
```
valid quadruplets = (# of i with nums[i] < nums[j]) Ã— (# of l with nums[j] < nums[l]).
```

## ğŸ§® Time & Space Complexity

- Time	O(nÂ² log n) 	Outer loop over i, inner over j
- Space	O(n)	Sorted prefix list
- Scalability	Works for n â‰¤ 4000	Within problem constraints


## ğŸ§  Engineering Takeaway

This problem is a great example of counting via decomposition:

- Instead of brute force, we split the quadruplet condition into two independent counts.
- Binary search + prefix maintenance makes it efficient.
- The solution balances clarity and performance, scaling to the input limits.
- Donâ€™t simulate quadruplets â€” count them architecturally.


---

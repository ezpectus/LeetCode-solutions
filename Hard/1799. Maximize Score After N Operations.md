# 1799. Maximize Score After N Operations  
*O(2^(2n) × n²) — Bitmask DP with Memoization*

---

## Problem Statement

You are given an array `nums` of length **2 * n** (where **n ≤ 7**) containing positive integers.

You must perform **exactly n operations** (1-indexed):

In the i-th operation:
- Choose **two** remaining elements x and y from `nums`
- Add `i * gcd(x, y)` to your score
- Remove x and y from `nums`

Return the **maximum possible score** after performing all n operations.

**Examples**:

**Example 1**  
Input: nums = [1,2]  
Output: **1**  
Only one operation: 1 * gcd(1,2) = 1

**Example 2**  
Input: nums = [3,4,6,8]  
Output: **11**  
Optimal pairing:  
1 * gcd(3,6) = 3  
2 * gcd(4,8) = 8  
Total: 11

**Example 3**  
Input: nums = [1,2,3,4,5,6]  
Output: **14**  
Optimal: 1*gcd(1,5) + 2*gcd(2,4) + 3*gcd(3,6) = 1 + 4 + 9 = 14

**Constraints**:
- 1 ≤ n ≤ 7
- nums.length == 2 * n
- 1 ≤ nums[i] ≤ 10⁶

---

## Core Idea — Bitmask DP on Remaining Elements

**Key insight**:
- n ≤ 7 → total elements = 14 → 2¹⁴ = 16384 possible subsets — feasible for DP
- Each operation removes **exactly two** elements and adds (current operation index × gcd(pair))
- The **order** of pairing matters because the multiplier **increases** with each operation (1, 2, ..., n)
- We need to try **all possible pairing sequences** to maximize the weighted sum of gcds
- State can be represented by the **bitmask** of **remaining elements**

**DP state**:
- `dp[mask]` = maximum score we can achieve starting from the subset of elements represented by `mask` (where bit i set means nums[i] is still available)

**Recursive step**:
- At each state `mask` with current operation index `k` (1 to n):
  - If no elements left (mask = 0) → return 0
  - Otherwise, try **every possible pair** of remaining elements (i, j) where bits i and j are set
  - Compute score addition: `k * gcd(nums[i], nums[j])`
  - Recurse to new mask with bits i and j unset
  - Take the **maximum** over all possible pairs

**Memoization**:
- Cache results for each mask to avoid recomputing subproblems

**Base case**:
- mask = 0 → return 0 (no more operations)

**Answer**:
- dp[(1 << (2*n)) - 1] (full mask, start with k=1)

**Precomputation**:
- Precompute all pairwise gcd(nums[i], nums[j]) in O(n² log MAX) — negligible since n ≤ 14

**Time complexity**: O(2^(2n) × n²)  
With 2n ≤ 14 → 16384 states × 91 pairs ≈ 1.5 million operations — very fast

---

## Solution Code C#

```csharp
public class Solution {
    Dictionary<int,int> dp ;
    public int MaxScore(int[] nums) {
        int hs = 0;
        dp = new Dictionary<int,int>();
        return backtrack(nums,hs,1);
    }

    public int backtrack(int[] nums,int hs,int k){
        int ans = 0;
        int n = nums.Length;

        if(dp.ContainsKey(hs)){
            return dp[hs];
        }

        for(int i=0;i<n;i++){
            //check the ith bit
            if(checksetbit(hs,i)){
                continue;
            }
            for(int j=0;j<n;j++){
                if(i==j || checksetbit(hs,j)){
                    continue;
                }

                int x = gcd(nums[i],nums[j]);
                //Console.WriteLine($"{i},{j} -> {x}");
                int temp = k*x;

                //set ith bit 

                hs = setunsetBit(hs,i);
                hs = setunsetBit(hs,j);

                temp += backtrack(nums,hs,k+1);
                ans = Math.Max(ans,temp);

                hs = setunsetBit(hs,i);
                hs = setunsetBit(hs,j);
            }
        }

        dp[hs] = ans;

        return ans;
    }

    public int gcd(int x, int y){
        if(y==0){
            return x;
        }

        return gcd(y,x%y);
    }

    public bool checksetbit(int x, int i){
        if((x&(1<<i))>0 ){
            //Console.WriteLine($"{x},{i} -> true");
            return true;
        }
        //Console.WriteLine($"{x},{i} -> false");
        return false;
    }

    public int setunsetBit(int x, int i){    
        int k = (x^(1<<i));
        //Console.WriteLine($"{x},{i} -> {k}");
        return k;
    }    
}
```


## Complexity

| **Metric**            | **Value**              | **Notes**                                                                 |
|-----------------------|------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(2^(2n) × n²)**     | Number of states: 2^(2n) (with 2n ≤ 14 → 16384 states)<br>Per state: try all pairs of remaining elements O(n²) |
| **Space Complexity**  | **O(2^(2n))**          | Memoization dictionary stores results for each mask (up to 2^(2n) entries) |

**Optimal** — with n ≤ 7 (2n ≤ 14), ~800,000 operations — runs extremely fast in practice.

---

## Why This Works — Core Logic

**State Representation**:
- `hs` (bitmask) — represents the **set of remaining elements**  
  (bit i set → nums[i] is still available)
- `k` — current operation number (1 to n)

**Recursive Step**:
- From current mask `hs` and operation `k`:
  - Iterate over all possible pairs of remaining elements (i, j) where bits i and j are set
  - Compute immediate score addition: `k * gcd(nums[i], nums[j])`
  - Recurse to the new mask with bits i and j unset
  - Take the **maximum** over all possible pair choices

**Memoization**:
- `dp[hs]` caches the **maximum score** achievable from the current subset of remaining elements

**Base Case**:
- If mask == 0 (no elements left) → return 0 (all pairs have been made)

**Correctness** —  
The bitmask DP systematically explores **all possible sequences** of pairing the elements.  
At each operation k, it selects the pair that gives the highest immediate contribution `k * gcd` and continues recursively.  
Memoization ensures that each unique subset (mask) is solved **only once**, preventing exponential recomputation.

---

## Key Takeaway

This is a **classic bitmask DP on subsets** problem for optimal pairing with increasing rewards:

* State = bitmask of **remaining** elements + current operation index k
* Transition: try **every possible pair** of remaining elements to pair now
* Score added = current operation index k × gcd(pair)
* Memoize maximum score for each mask
* Answer = dp[full mask] with k=1

**Pure, clean, optimal** — O(2^(2n) × n²) time, O(2^(2n)) space, but with n ≤ 7 → extremely fast, elegant, and correctly finds the optimal pairing sequence to maximize the weighted sum of gcds.
---

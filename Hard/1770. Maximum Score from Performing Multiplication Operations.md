# 1770. Maximum Score from Performing Multiplication Operations  
*O(m × n) — Dynamic Programming (Top-Down with Memoization)*

---

## Problem Statement

You are given two arrays:
- `nums` of length `n`
- `multipliers` of length `m` (m ≤ n)

Start with score = 0.  
Perform **exactly m operations**:

In the i-th operation (0-indexed):
- Choose one number `x` from **either end** of the **current** `nums` array
- Add `multipliers[i] * x` to your score
- Remove `x` from `nums`

Return the **maximum possible score** after all m operations.

**Examples**:

**Example 1**  
Input: nums = [1,2,3], multipliers = [3,2,1]  
Output: **14**  
Sequence: take 3 (×3=9), take 2 (×2=4), take 1 (×1=1) → 14

**Example 2**  
Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]  
Output: **102**  
Optimal sequence uses negative multipliers on negatives and positive on positives

**Constraints**:
- m == multipliers.length
- m ≤ n ≤ 10⁵
- 1 ≤ m ≤ 300
- -1000 ≤ nums[i], multipliers[i] ≤ 1000

---

## Core Idea — DP on Left & Right Pointers

**Key insight**:
- At each step, we choose from **left** or **right** end of remaining nums
- After k operations, we have taken exactly k elements (some from left, some from right)
- State = number of operations done (or remaining) + how many taken from left end
- Let dp[l][r] = maximum score using first l elements from left + first r elements from right (total l+r operations)

**DP Definition**:
- dp[i][j] = maximum score using **exactly i+j operations**, taking first i from left end and first j from right end of original nums
- Transition:
  - dp[i][j] = max(
    - dp[i-1][j] + multipliers[i+j-1] × nums[i-1]   (take from left)
    - dp[i][j-1] + multipliers[i+j-1] × nums[n-j]     (take from right)
  )

**Base**: dp[0][0] = 0

**Answer**: max over all i+j = m of dp[i][j]

**Time**: O(m × n) — but since m ≤ 300, n ≤ 10⁵ → acceptable (300 × 10⁵ = 3×10⁷)  
**Space**: O(m × n) — can be O(m) with rolling array

---

## Clean Implementation (C#) — Top-Down Memoization

```csharp
public class Solution{
    private int[][] memo;
    private int[] nums;
    private int[] multipliers;
    private int m;

    public int MaximumScore(int[] nums, int[] multipliers){
        this.nums = nums;
        this.multipliers = multipliers;
        m = multipliers.Length;
        memo = new int[m][];
        for (int i = 0; i < m; i++){
            memo[i] = new int[m];
            Array.Fill(memo[i], -1);
        }

        return Dp(0, 0);
    }

    private int Dp(int left, int right){
        int op = left + right;
        if (op == m) return 0;
        if (memo[left][right] != -1) return memo[left][right];

        int takeLeft = nums[left] * multipliers[op] + Dp(left + 1, right);
        int takeRight = nums[nums.Length - 1 - right] * multipliers[op] + Dp(left, right + 1);
        memo[left][right] = Math.Max(takeLeft, takeRight);

        return memo[left][right];
    }
}
```

## Complexity

| **Metric**            | **Value**              | **Notes**                                                                 |
|-----------------------|------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(m²)**              | Number of states: O(m × m) (left taken from 0 to m, right taken from 0 to m)<br>Each state computed once with O(1) work (two recursive calls + max) |
| **Space Complexity**  | **O(m²)**              | Memoization table of size m × m (can be optimized to O(m) with rolling array or bottom-up DP) |

**Optimal** — since m ≤ 300, m² = 90,000 states — very fast and completely safe under constraints (n ≤ 10⁵ is only used for array access).

---

## Why This Works — Example Walkthrough

**Example 1**: nums = [1,2,3], multipliers = [3,2,1]

**DP states** (left taken, right taken):

- Start: (0,0), score = 0
- Operation 0 (multiplier = 3):
  - Take left: nums[0]=1 → score += 3×1 = 3 → next state (1,0)
  - Take right: nums[2]=3 → score += 3×3 = 9 → next state (0,1)
- Best choice: take right → score = 9, go to (0,1)
- Operation 1 (multiplier = 2):
  - From (0,1): take left nums[0]=1 → +2×1 = 2 → total 11 → (1,1)
  - Take right nums[1]=2 → +2×2 = 4 → total 13 → (0,2)
- Best: take right → score = 13, go to (0,2)
- Operation 2 (multiplier = 1):
  - Only left nums[0]=1 remains → +1×1 = 1 → total **14** → (1,2)

**Maximum score** = **14** → correct

**Correct** —  
We model the problem as choosing at each step whether to take from the **left end** or **right end** of the remaining subarray of `nums`.  
The state `dp[left][right]` represents the maximum score achievable after taking the first `left` elements from the start and the first `right` elements from the end (total `left + right` operations).  
Memoization ensures each state is computed only once, and we take the maximum over all valid ending states where `left + right = m`.

---

## Key Takeaway

This is a **classic dynamic programming on two pointers** problem:

* State `dp[left][right]` = maximum score after taking exactly `left` elements from the start and `right` elements from the end of `nums`
* Transition:
  - Take next from left: `dp[left][right] = dp[left-1][right] + multipliers[left+right-1] × nums[left-1]`
  - Take next from right: `dp[left][right] = dp[left][right-1] + multipliers[left+right-1] × nums[n-right]`
  - Choose maximum of the two options
* Base case: `dp[0][0] = 0`
* Answer = maximum value of `dp[left][right]` where `left + right = m`

**Pure, clean, optimal** — O(m²) time and space (m ≤ 300 → very fast), elegant two-pointer DP, and correctly maximizes score by always choosing the best end at each step.

---

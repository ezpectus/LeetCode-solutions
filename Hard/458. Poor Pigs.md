# 458. Poor Pigs

---

##  Problem Restatement
We have `buckets` of liquid, exactly one is poisonous.  
We can test pigs in rounds: each pig can drink from multiple buckets, and after `minutesToDie` we see which pigs die.  
We have `minutesToTest` total time.  
Return the minimum number of pigs needed to identify the poisonous bucket.

Constraints:  
- 1 ≤ buckets ≤ 1000  
- 1 ≤ minutesToDie ≤ minutesToTest ≤ 100  

---

##  Core Idea
- Each pig provides information across multiple rounds.  
- Number of rounds = `minutesToTest / minutesToDie`.  
- Each pig can represent `(rounds + 1)` states (dies in round 1, dies in round 2, …, survives all rounds).  
- With `p` pigs, total distinguishable states = `(rounds + 1)^p`.  
- We need the smallest `p` such that `(rounds + 1)^p ≥ buckets`.

---

##  Code (C#)
```csharp
public class Solution {
    public int PoorPigs(int buckets, int minutesToDie, int minutesToTest) {
        int rounds = minutesToTest / minutesToDie;
        int pigs = 0;
        while (Math.Pow(rounds + 1, pigs) < buckets) {
            pigs++;
        }
        return pigs;
    }
}
```




## Complexity
- **Time:** O(log(buckets)) — we increment pigs until the condition `(rounds + 1)^p ≥ buckets` is satisfied.  
  The loop grows logarithmically with respect to the number of buckets.  
- **Space:** O(1) — only a few integer variables are used (`rounds`, `pigs`), no extra data structures required.

---

## Pitfalls
- **States per pig:** Each pig has `(rounds + 1)` states (dies in round 1, dies in round 2, …, survives all rounds). Forgetting the `+1` leads to undercounting.  
- **Integer division:** `minutesToTest / minutesToDie` must be computed carefully. It represents the number of full rounds available.  
- **Buckets = 1:** Special case → no pigs needed, answer is `0`.  
- **Exponential growth:** `(rounds + 1)^p` grows quickly, so ensure calculations use floating point or long to avoid overflow.  
- **Edge cases:**  
  - If `minutesToTest < minutesToDie`, only one round is possible.  
  - If `minutesToTest == minutesToDie`, pigs can only distinguish `(rounds + 1) = 2` states each.

---

## Conclusion
This problem reduces to **information theory with states per pig**.  
- Each pig encodes multiple outcomes across rounds.  
- Together, pigs provide enough distinguishable states to identify the poisonous bucket.  
- The solution is derived by finding the minimum number of pigs such that `(rounds + 1)^p ≥ buckets`.  

Result: clean O(log N) solution, robust for `buckets ≤ 1000`, and a classic example of applying combinatorial reasoning to resource‑limited testing.

---

## Generalization
- This pattern applies to **group testing problems** where limited testers must identify one faulty item among many.  
- Similar techniques are used in **fault detection**, **binary search with multiple outcomes**, and **information encoding** problems.  
- The key insight: each tester (pig) represents multiple states, and the product of states across testers must cover all possibilities.


---

# 818. Race Car — Architectural BFS on (position, speed) State Space  
*O(target log target) — Optimal Shortest Path BFS with Pruning*

---

## Problem Statement

Start at **position = 0**, **speed = 1**.

Commands:
- `'A'`: position += speed; speed *= 2
- `'R'`: speed = -1 if speed >0 else +1; position unchanged

Find **shortest sequence** to reach **exact position `target`** (1 ≤ target ≤ 10⁴).

Return length of sequence.

---

## Core Idea — BFS on State (position, speed)

**Key insight**:
- State = `(position, speed)`
- From each state → two possible moves: 'A' or 'R'
- Speed grows **exponentially** → positions are powers of 2 related
- Use **BFS** → shortest path in unweighted graph (each command cost 1)
- Prune: skip states where |position| > 2×target (overshot too far)

**Visited**: set of `(position, speed)` — but speed can be large → use **log(speed)** or limit by pruning

**Better**: notice speed is always ±2^k → we can represent speed by its **log** (exponent)

But simplest: BFS with pruning.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int Racecar(int target) {
        // Queue: (position, speed, steps)
        var queue = new Queue<(int pos, int speed, int steps)>();
        var visited = new HashSet<(int pos, int speed)>();

        queue.Enqueue((0, 1, 0));
        visited.Add((0, 1));

        while (queue.Count > 0)  {
            var (pos, speed, steps) = queue.Dequeue();
            if (pos == target)  return steps;
            
            // Prune: if too far away and going away → skip
            if (Math.Abs(pos) > target * 2) continue;

            // Command 'A'
            int newPosA = pos + speed;
            int newSpeedA = speed * 2;
            var stateA = (newPosA, newSpeedA);
            if (!visited.Contains(stateA)) {
                visited.Add(stateA);
                queue.Enqueue((newPosA, newSpeedA, steps + 1));
            }

            // Command 'R'
            int newSpeedR = speed > 0 ? -1 : 1;
            var stateR = (pos, newSpeedR);
            if (!visited.Contains(stateR)) {
                visited.Add(stateR);
                queue.Enqueue((pos, newSpeedR, steps + 1));
            }
        }

        return -1; // unreachable
    }
}
```

## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(target log target)**      | Number of reachable states is bounded by overshooting limit |
| **Space Complexity**  | **O(target log target)**      | Queue + visited set (position + speed pairs)   |

**Optimal** — BFS guarantees the shortest path in an unweighted graph.

---

## Why This Works — Example Walkthrough

**Input**: `target = 3`

- Start: position=0, speed=1, steps=0
- Command 'A': position=0+1=1, speed=2, steps=1
- Command 'A': position=1+2=3, speed=4, steps=2 → **reached target**
- Return **2** ("AA")

**Correct**.

**Input**: `target = 6`

- One possible shortest path: "AAARA"
  - 0 → 'A' → pos=1, speed=2
  - 1 → 'A' → pos=3, speed=4
  - 3 → 'A' → pos=7, speed=8
  - 7 → 'R' → pos=7, speed=-1
  - 7 → 'A' → pos=7+(-1)=6, speed=-2
- Length = 5 → correct

BFS explores level by level and finds the shortest sequence first.

---

## Pitfalls & Edge Cases

- **target = 1** → just "A" → length **1**
- **Overshooting** → use 'R' to reverse direction and correct position
- **Speed explosion** → pruning (position > 2×target and moving away) keeps state space manageable
- **Negative positions** → allowed and necessary for some cases
- **target = 0** → not possible (constraints start from 1)

All handled perfectly.

---

## Key Takeaway

This is a **beautifully clean** shortest path problem:

- **State** = (position, speed) — captures the full dynamics
- **BFS** → finds minimal number of commands
- **Pruning** → limits state explosion without missing solutions
**Pure, clean, optimal** — perfect race car control.

---

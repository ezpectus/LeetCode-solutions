
## 1. Problem Description & Constraints  

### What We Are Given  
- `k` — **maximum number of projects** we can complete  
- `w` — **initial capital** (starting money)  
- `profits[i]` — **pure profit** if we complete project `i`  
- `capital[i]` — **minimum capital needed** to **start** project `i`  

### What We Must Do  
> **Maximize final capital** after doing **at most `k` projects**  
> **Rules**:  
> - Can only start project if `current capital >= capital[i]`  
> - After finishing → `capital += profits[i]`  
> - Can do **at most `k` projects**  

### Constraints (and what they tell us)  
| Constraint | Meaning |
|-----------|--------|
| `1 ≤ k ≤ 10⁵` | Up to 100,000 projects → **must be efficient** |
| `0 ≤ w ≤ 10⁹` | Capital can be huge → use `int` or `long` |
| `n ≤ 10⁵` | Up to 100,000 projects |
| `0 ≤ profits[i] ≤ 10⁴` | Profit is small |
| `0 ≤ capital[i] ≤ 10⁹` | Capital requirement can be huge |

> **Conclusion**:  
> We need **O(n log n)** time  
> Must **avoid brute force** (trying all combinations)  
> **Greedy** is the way  

---

## 2. Core Algorithm Idea — **Greedy + Priority Queue**

### Why Greedy?  
> At every step, we want to **maximize profit** with current capital  
> So: **"Among all projects I can afford right now — pick the one with highest profit"**

### Why Not Sort by Profit?  
```text
High profit but high capital → can't start
Low profit but low capital → can start now
Sorting by profit = WRONG
Must consider what we can afford
```
### The Correct Strategy  

| Step | Action | Why |
|------|--------|-----|
| 1 | **Sort projects by `capital` ascending** | So we can **unlock them in order** as capital grows |
| 2 | **Use a max-heap (priority queue) for profits** | To **always pick highest profit available** |
| 3 | **Use a pointer `idx`** | Track which projects we **haven't considered yet** |
| 4 | **For each of `k` steps**:  
  → **Add all newly affordable projects** to heap  
  → **Pick the best one** (highest profit)  
  → **Update capital** | **Greedy choice at each step** |

---

## 3. Concept in Simple Terms  

> **"You have money. You see projects. Some are cheap, some expensive. Some give little, some give a lot.**  
> **You sort them by how much money you need to start.**  
> **Then you go step by step:**  
> → **'What can I afford now?'** → Put all those in a **'best profit' pile**  
> → **Pick the one that gives most money**  
> → **Now you have more money → unlock more projects**  
> **Repeat `k` times."**

---

## 4. Full C# Solution 

```csharp
public class Solution {
    public int FindMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        int n = profits.Length;
        
        // Step 1: Pair (capital, profit) and sort by capital (ascending)
        var projects = new (int cap, int prof)[n];
        for (int i = 0; i < n; i++) {
            projects[i] = (capital[i], profits[i]);
        }
        Array.Sort(projects, (a, b) => a.cap - b.cap);
        
        // Step 2: Max-heap for profits (PriorityQueue is min-heap → use negative)
        var pq = new PriorityQueue<int, int>();
        int idx = 0;
        
        // Step 3: Do up to k projects
        for (int i = 0; i < k; i++) {
            // Add all projects we can now afford
            while (idx < n && w >= projects[idx].cap) {
                pq.Enqueue(projects[idx].prof, -projects[idx].prof);  // max-heap
                idx++;
            }
            
            // If no project is affordable → stop early
            if (pq.Count == 0) break;
            
            // Pick the most profitable one
            w += pq.Dequeue();
        }
        
        return w;
    }
}
```
## 5. Architectural Breakdown 

| Component | Role | How It Works | Why It’s Critical |
|---------|------|-------------|------------------|
| `projects[]` | **Sorted Project List** | `(capital, profit)` pairs, sorted by **capital ascending** | Enables **sequential unlocking** — we process projects in order of increasing cost |
| `idx` | **Unlock Pointer** | Points to **next unconsidered project** | Avoids rechecking old projects — O(n) total |
| `pq` | **Max-Heap (Profit)** | Stores **profits** of **currently affordable** projects | Always gives **best choice** in O(log n) |
| `while (idx < n && w >= cap)` | **Unlock Loop** | Adds **all** projects that become affordable | Capital grows → more options unlocked |
| `pq.Enqueue(prof, -prof)` | **Max-Heap Trick** | `PriorityQueue` is **min-heap** → negate to simulate **max-heap** | Gets **highest profit** first |
| `w += pq.Dequeue()` | **Greedy Step** | Updates capital with **best available profit** | Core of greedy — maximize gain now |
| `for i in 0..k` | **Project Counter** | Limits to **at most `k` projects** | Respects constraint |
| `if (pq.Count == 0) break` | **Early Exit** | No more affordable projects → done | Avoids useless loops |

---

## 6. Step-by-Step Execution (Example 1)

**Input**:  
```text
k = 2, w = 0
profits = [1,2,3]
capital = [0,1,1]
Step 0: Sort by capital → [(0,1), (1,2), (1,3)]
idx = 0, pq = [], w = 0
```
| Step | Action | `w` | `idx` | `pq` | Notes |
|------|--------|-----|-------|------|-------|
| 1 | `w=0 >= 0` → add profit `1` | 0 | 1 | `[1]` | Unlock first |
|   | Pick `1` → `w = 1` | **1** | 1 | `[]` | |
| 2 | `w=1 >= 1` → add `2` | 1 | 2 | `[2]` | |
|   | `w=1 >= 1` → add `3` | 1 | 3 | `[2,3]` | |
|   | Pick `3` → `w = 4` | **4** | 3 | `[]` | Best choice |

**Final**: `4`

---

## 7. Pro Tips & Optimizations  

| Tip | Why It Matters |
|-----|----------------|
| **Sort by `capital` not `profit`** | Unlocking order matters |
| **Use `idx` pointer** | O(n) total unlocking |
| **Max-heap with `-profit`** | `PriorityQueue` limitation |
| **Break early** | If no projects left |
| **Use tuple array** | Clean, readable, fast |

---

## 8. Key Takeaway  

> **"Sort projects by startup cost.  
> Use a max-heap to always pick the most profitable affordable project.  
> As capital grows — unlock more.  
> Repeat `k` times.  
> This is optimal because you always make the best choice at each step."**

---

#  Problem: Maximize the Number of Partitions After Operations
 Number: LeetCode 3003
 Difficulty: Hard Language: C++

## Problem Overview
You are given a string s consisting of lowercase English letters and an integer k. 
You may change at most one character in s. 
After that, you repeatedly remove the longest prefix that contains at most k distinct characters, and count how many such removals (partitions) you can perform.
The goal is to maximize the number of partitions after the optional single-character change.

## Constraints
- 1 ≤ s.length ≤ 10⁵
- 1 ≤ k ≤ 26
- s contains only lowercase English letters
- Only one character change is allowed

## Key Observations
- The partitioning process is greedy: we always remove the longest valid prefix with ≤ k distinct characters.
- Changing one character can split a segment, extend a segment, or reduce the number of distinct characters in a segment.
- A naive approach that tries all possible character replacements and recomputes partitions each time leads to O(n²) time and fails on large inputs.
- To optimize, we need a one-pass segmentation strategy that allows us to evaluate the impact of a change in constant time per position.

## Optimization Strategy
Prefix and Suffix Segmentation
We precompute two arrays:

- pref[i]: number of segments formed from the start up to position i
- pval[i]: bitmask of characters in the current prefix segment ending at i
- suff[i]: number of segments formed from the end down to position i
- sval[i]: bitmask of characters in the current suffix segment starting at i
- These arrays allow us to evaluate the impact of changing s[i] without recomputing the entire partitioning logic.

## Bitmasking for Distinct Character Tracking
Instead of using sets or maps, we use a 26-bit integer mask to track which characters are present in a segment. This allows:

- Constant-time updates: mask |= 1 << (s[i] - 'a')
- Fast cardinality checks: __builtin_popcount(mask) gives the number of distinct characters
- This is significantly faster than using unordered_set or vector<bool> and is critical for passing large test cases.

## Algorithm Summary
- Pad the string with dummy characters to simplify 1-based indexing.
- Traverse left-to-right to build pref and pval.
- Traverse right-to-left to build suff and sval.
- For each position i, simulate changing s[i] and evaluate:
- How many segments exist to the left and right
- How the change affects the boundary between segments
- Whether the change creates 1, 2, or 3 new segments
- Track the maximum total segment count across all positions.

## Code C++
```cpp
class Solution {
public:
    inline int count(int mask) {
        return __builtin_popcount(mask);
    }

    int maxPartitionsAfterOperations(string s, int k) {
        if (k == 26) return 1;

        int n = s.size();
        s = '@' + s + '@'; // padding for 1-based indexing

        vector<int> pref(n + 2), pval(n + 2);
        int prefix = 0, pbit = 0;
        for (int i = 1; i <= n; ++i) {
            int bit = 1 << (s[i] - 'a');
            pbit |= bit;
            if (count(pbit) > k) {
                ++prefix;
                pbit = bit;
            }
            pref[i] = prefix;
            pval[i] = pbit;
        }

        vector<int> suff(n + 2), sval(n + 2);
        int suffix = 0, sbit = 0;
        for (int i = n; i >= 1; --i) {
            int bit = 1 << (s[i] - 'a');
            sbit |= bit;
            if (count(sbit) > k) {
                ++suffix;
                sbit = bit;
            }
            suff[i] = suffix;
            sval[i] = sbit;
        }

        int ans = 0;
        for (int i = 1; i <= n; ++i) {
            int leftSeg = pref[i - 1];
            int rightSeg = suff[i + 1];
            int leftMask = pval[i - 1];
            int rightMask = sval[i + 1];
            int combined = leftMask | rightMask;

            int extra = 0;
            if (count(combined) + 1 <= k) {
                extra = 1;
            } else if (count(leftMask) == k && count(rightMask) == k && count(combined) < 26) {
                extra = 3;
            } else {
                extra = 2;
            }

            ans = max(ans, leftSeg + rightSeg + extra);
        }

        return ans;
    }
};
```
## Complexity Analysis
Time Complexity:
- O(n) — single pass for prefix and suffix segmentation, plus one pass for evaluation

Space Complexity:
- O(n) — for storing prefix/suffix arrays and masks

## Why This Works
- Prefix/suffix segmentation isolates the impact of a character change to a local boundary.
- Bitmasking allows constant-time distinct character tracking.
- Greedy segmentation ensures optimal partitioning without backtracking or recursion.
- The combination of these techniques avoids recomputation and scales to large inputs.

## Related Concepts

- Bitmask optimization in string problems
- Greedy prefix/suffix segmentation
- Single-change impact analysis
- Partitioning with constraints on uniqueness


---

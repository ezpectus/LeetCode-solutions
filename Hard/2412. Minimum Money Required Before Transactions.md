# LeetCode 2412 â€” Minimum Money Required Before Transactions  
**Language: C# (Greedy Solution)**

---

##  Problem Restatement
We are given transactions `[cost, cashback]`.  
- To perform a transaction, current money must be at least `cost`.  
- After transaction: `money = money âˆ’ cost + cashback`.  
We want the minimum starting money so that **all transactions can be completed in any order**.

---

##  Core Idea
- Transactions where `cost > cashback` are **loss transactions** (money decreases).  
- Transactions where `cost â‰¤ cashback` are **safe transactions** (money never decreases).  
- Worst case reasoning:  
  - We must cover all losses in any order.  
  - One transaction will be the last; if it is lossâ€‘making, its loss doesnâ€™t need to be preâ€‘covered.  
- Therefore, we compute:  
  - `negSum` = sum of all losses (`cashback âˆ’ cost` when negative).  
  - For each transaction, imagine it is last:  
    - If lossâ€‘making, subtract its loss from `negSum`.  
    - Add its cost.  
  - Take the maximum across all transactions.

---

##  Implementation (C#)

```csharp
public class Solution {
    public long MinimumMoney(int[][] transactions) {
        long negSum = 0;
        int n = transactions.Length;

        // Sum all negative contributions
        for (int i = 0; i < n; i++) {
            int cost = transactions[i][0];
            int cashback = transactions[i][1];
            negSum += Math.Min(0, cashback - cost);
        }

        long result = 0;

        // Consider each transaction as the last one
        for (int i = 0; i < n; i++) {
            int cost = transactions[i][0];
            int cashback = transactions[i][1];

            long s = -negSum;
            if (cost > cashback) {
                s -= (cost - cashback);
            }
            result = Math.Max(result, s + cost);
        }

        return result;
    }
}
```



##  Time Complexity
- **First loop (compute losses):**  
  Iterate through all transactions once to accumulate negative contributions â†’ `O(n)`.  
- **Second loop (evaluate each transaction as last):**  
  Iterate again to check each transaction as the potential final one â†’ `O(n)`.  
- **Overall:**  
  â†’ `O(n)`.

---

##  Space Complexity
- **Counters only:**  
  We store sums and temporary variables in a few integers/longs.  
  â†’ `O(1)` constant space.

---

#  Impact of Design Choices

| Design Choice                  | Effect                                                                 |
|--------------------------------|------------------------------------------------------------------------|
| **Sum all losses**             | Captures worstâ€‘case decrease across all transactions.                  |
| **Check each transaction as last** | Ensures correctness when the final transaction is safe or lossâ€‘making. |
| **Use long**                   | Prevents overflow (values can reach up to 1e14).                       |

---

#  Pitfalls
- **Misclassifying safe transactions as losses:** Only transactions with `cost > cashback` should contribute to loss sum.  
- **Forgetting to exclude last transactionâ€™s loss:** If the final transaction is lossâ€‘making, its loss doesnâ€™t need to be preâ€‘covered.  
- **Using `int` instead of `long`:** Risk of overflow when summing large values.  

---

# ğŸ Conclusion
- **What it gives:** Minimum starting money to complete all transactions in any order.  
- **Why it matters:** Greedy worstâ€‘case reasoning avoids simulating permutations and ensures correctness.  
- **Key takeaway:**  
  1. Sum all losses.  
  2. Consider each transaction as last.  
  3. Take maximum requirement.  


---

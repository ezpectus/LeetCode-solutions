# 446. Arithmetic Slices II â€“ Subsequence

**Difficulty:** Hard  
**Topics:** Dynamic Programming, HashMap, Subsequences  

---

## ðŸ“– Problem Restatement
Given an integer array `nums`, return the number of all arithmetic subsequences.  
- A subsequence = sequence formed by deleting some elements (order preserved).  
- Arithmetic subsequence = length â‰¥ 3, constant difference between consecutive elements.  

---

## ðŸ’¡ Core Idea
- Brute force (2^n subsequences) is impossible.  
- Use **DP with HashMap per index**:  
  - `dp[i][diff]` = number of subsequences ending at index `i` with difference `diff`.  
- Transition:  
```
For each j < i:
diff = nums[i] - nums[j]
count = dp[j][diff] (subsequences ending at j with this diff)
dp[i][diff] += count + 1 // extend existing + new pair (j,i)
result += count // only subsequences length â‰¥ 3

```
---

## ðŸ”Ž Step-by-Step Algorithm
1. Initialize `dp[i]` as empty dictionary for each index.  
2. Iterate over all pairs `(j,i)` with `j < i`.  
3. Compute `diff = nums[i] - nums[j]` (use `long` to avoid overflow).  
4. Extend subsequences from `dp[j][diff]` to `dp[i][diff]`.  
5. Add `count` to result (since those subsequences now have length â‰¥ 3).  
6. Return result.  

---

## âœ… C# Implementation
```csharp
public class Solution {
  public int NumberOfArithmeticSlices(int[] nums) {
      int n = nums.Length;
      var dp = new Dictionary<long,int>[n];
      for (int i = 0; i < n; i++) dp[i] = new Dictionary<long,int>();

      long result = 0;
      for (int i = 0; i < n; i++) {
          for (int j = 0; j < i; j++) {
              long diff = (long)nums[i] - nums[j];
              int count = dp[j].ContainsKey(diff) ? dp[j][diff] : 0;

              if (!dp[i].ContainsKey(diff)) dp[i][diff] = 0;
              dp[i][diff] += count + 1;

              result += count; // only subsequences length â‰¥ 3
          }
      }
      return (int)result;
   }
}
```


## ðŸ“Š Complexity Analysis

- **Time Complexity:** O(nÂ²) â€” double loop over pairs `(j,i)`.  
- **Space Complexity:** O(nÂ²) â€” each index stores differences in a dictionary.  

---

## âš ï¸ Pitfalls

- Must use `long` for differences (values up to 2^31).  
- Only add `count` to result (not `count+1`) â†’ ensures subsequences have length â‰¥ 3.  
- Each index needs its own dictionary to avoid collisions.  

---

## ðŸ”Ž Example Walkthrough

**Input:**  
`nums = [2,4,6,8,10]`  

**Arithmetic subsequences:**  
- `[2,4,6]`  
- `[4,6,8]`  
- `[6,8,10]`  
- `[2,4,6,8]`  
- `[4,6,8,10]`  
- `[2,4,6,8,10]`  
- `[2,6,10]`  

**Total = 7**

---

**Input:**  
`nums = [7,7,7,7,7]`  

- Any subsequence length â‰¥ 3 is arithmetic (diff = 0).  
- **Total = 16**

---

## âœ… Key Takeaway

- This is a **DP with HashMap per index** problem.  
- **Pattern:** â€œstate = (index, diff)â€ â†’ extend subsequences efficiently.  
- Clean O(nÂ²) solution, fits constraints.  



---

# Pattern Name
**Skyline Extraction via Sweep Line and Max-Heap**

## Problem Summary
- **Input**:  
  A list of buildings, each as `[left, right, height]`.  
  Buildings are rectangles on a flat surface.
- **Goal**:  
  Return the **skyline** — a list of key points `[[x1, y1], [x2, y2], ...]`.  
  Each key point marks a **change in height**.
- **Constraints**:
  - `1 ≤ buildings.length ≤ 10⁴`
  - `0 ≤ left < right ≤ 2³¹ − 1`
  - `1 ≤ height ≤ 2³¹ − 1`
  - Buildings are sorted by `left`.

## Core Idea
- This is a **sweep line problem** with **dynamic height tracking**.

## Solution
- **Convert buildings into events**:
  - **Start** of building → `(x, -height)`
  - **End** of building → `(x, +height)`
- **Sort events**:
  - By `x`, then by `height` (**starts before ends**).
- **Use a max-heap** to track **active heights**.
- At each event:
  - Add/remove height.
  - If **max height changes** → **record key point**.

## Strategy Summary
- Convert buildings to events:
  - **Start**: `(left, -height)`
  - **End**: `(right, +height)`
- Sort events by `x`, then by `height`.
- Use `SortedDictionary<int, int>` as **max-heap simulation**.
- Track `prevHeight`.
- If current max height ≠ `prevHeight` → **add key point**.

## C# Implementation
```csharp
public class Solution {
    public IList<IList<int>> GetSkyline(int[][] buildings) {
        List<(int x, int h)> events = new();
        foreach (var b in buildings) {
            events.Add((b[0], -b[2])); // start
            events.Add((b[1], b[2]));  // end
        }

        events.Sort((a, b) => a.x != b.x ? a.x.CompareTo(b.x) : a.h.CompareTo(b.h));

        var result = new List<IList<int>>();
        var heights = new SortedDictionary<int, int>(Comparer<int>.Create((a, b) => b.CompareTo(a)));
        heights[0] = 1; // ground level
        int prevHeight = 0;

        foreach (var (x, h) in events) {
            if (h < 0) {
                // start of building
                if (!heights.ContainsKey(-h)) heights[-h] = 0;
                heights[-h]++;
            } else {
                // end of building
                heights[h]--;
                if (heights[h] == 0) heights.Remove(h);
            }

            int currHeight = heights.First().Key;
            if (currHeight != prevHeight) {
                result.Add(new List<int> { x, currHeight });
                prevHeight = currHeight;
            }
        }

        return result;
    }
}

```

## Architectural Breakdown
| Component               | Role                                      |
|-------------------------|-------------------------------------------|
| Events                  | Encodes building start/end                |
| `SortedDictionary`      | Simulates max-heap                        |
| Sweep line              | Processes events in order                 |
| Height change           | Triggers skyline key point                |

## Why This Approach Is Superior
| Aspect              | **Sweep Line + Heap** | Naive Grid Scan         |
|---------------------|------------------------|--------------------------|
| Time Complexity     | **O(n log n)**         | O(n × maxX)              |
| Space Complexity    | O(n)                   | O(maxX)                  |
| Performance         | Efficient for large input | Breaks on wide coordinates |
| Generalizability    | Works for any skyline  | Hard to scale            |

## Final Takeaway
- **This problem is about extracting skyline contours from overlapping rectangles.**
- **The solution uses**:
  - **Sweep line algorithm**
  - **Max-heap** for active height tracking
  - **Event sorting** and **height change detection**
- **This pattern generalizes to**:
  - Interval merging
  - Contour extraction
  - Dynamic structure tracking
 
---

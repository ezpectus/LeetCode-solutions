# 2940. Find Building Where Alice and Bob Can Meet

##  Problem Summary
We are given:

- `heights[i]`: height of building `i`.
- `queries[i] = [a, b]`: Alice starts at building `a`, Bob at building `b`.

**Rules:**
- A person at building `i` can move to building `j` **iff** `i < j` and `heights[i] < heights[j]`.
- For each query, find the **leftmost building index ≥ max(a, b)** where both Alice and Bob can meet.
- If impossible → return `-1`.

---

##  Core Idea
- Alice and Bob can only move **rightward** to taller buildings.
- For query `(l, r)` (ensure `l ≤ r`):
  - If `l == r` → answer is `r`.
  - If `heights[l] < heights[r]` → they can meet at `r`.
  - Otherwise → need to find the **leftmost building ≥ r** taller than both.
- Use **Fenwick Tree (BIT)** to maintain minimum indices of taller buildings.
- Process queries sorted by `r` descending, updating Fenwick Tree with buildings to the right.
- Answer is either direct (`r`) or result of Fenwick Tree query.

---

##  Code (C#)

```csharp
// Fenwick Tree (Binary Indexed Tree) for prefix minimum queries
class FenwickTree {
    private readonly int INF = int.MaxValue;
    private readonly int n;
    private readonly int[] bit;

    public FenwickTree(int n) {
        this.n = n;
        bit = Enumerable.Repeat(INF, n + 1).ToArray();
    }

    // Update: set minimum value on all relevant prefixes
    public void Update(int idx, int val) {
        for (; idx <= n; idx += idx & -idx)
            bit[idx] = Math.Min(bit[idx], val);
    }

    // Query: get minimum value in prefix [1..idx]
    public int Query(int idx) {
        int res = INF;
        for (; idx > 0; idx -= idx & -idx)
            res = Math.Min(res, bit[idx]);
        return res == INF ? -1 : res;
    }
}

public class Solution {
    public int[] LeftmostBuildingQueries(int[] heights, int[][] queries) {
        int n = heights.Length, m = queries.Length;

        // Ensure queries ordered (l <= r)
        for (int i = 0; i < m; i++) {
            if (queries[i][0] > queries[i][1])
                (queries[i][0], queries[i][1]) = (queries[i][1], queries[i][0]);
        }

        // Sort queries by right endpoint descending
        int[] idx = Enumerable.Range(0, m).ToArray();
        Array.Sort(idx, (i, j) => queries[j][1].CompareTo(queries[i][1]));

        // Coordinate compression
        var sorted = heights.Distinct().OrderBy(x => x).ToArray();
        var comp = new Dictionary<int,int>();
        for (int i = 0; i < sorted.Length; i++) comp[sorted[i]] = i + 1;

        int[] ans = new int[m];
        int j = n - 1;
        var tree = new FenwickTree(sorted.Length);

        foreach (int i in idx) {
            int l = queries[i][0], r = queries[i][1];

            // Process buildings to the right of r
            while (j > r) {
                int k = sorted.Length - comp[heights[j]] + 1;
                tree.Update(k, j);
                --j;
            }

            if (l == r || heights[l] < heights[r]) ans[i] = r;
            else {
                int k = sorted.Length - comp[heights[l]];
                ans[i] = tree.Query(k);
            }
        }
        return ans;
    }
}
```

##  Complexity
- **Preprocessing:** O(n log n) (sorting + compression)  
- **Each query:** O(log n)  
- **Total:** O((n + m) log n)  
- **Memory:** O(n + m)  

---

##  Pitfalls
- Must normalize queries (l ≤ r).  
- Coordinate compression avoids repeated binary searches.  
- Fenwick Tree must store minimum indices correctly.  

**Edge cases:**
- If Alice and Bob start at same building → answer = that building.  
- If one can directly move to the other’s building → answer = r.  
- If no taller building exists → answer = -1.  

---

##  Sanity Checks
- Input: `heights = [6,4,8,5,2,7], queries = [[0,1],[0,3],[2,4],[3,4],[2,2]]`  
  Output: `[2,5,-1,5,2]`  

- Input: `heights = [5,3,8,2,6,1,4,6], queries = [[0,7],[3,5],[5,2],[3,0],[1,6]]`  
  Output: `[7,6,-1,4,6]`  

---

##  Key takeaway
This problem reduces to **finding the leftmost taller building** using a Fenwick Tree:

- Direct answers when possible (`l == r` or `heights[l] < heights[r]`).  
- Otherwise, query Fenwick Tree for the next taller building.  

By combining query sorting, coordinate compression, and Fenwick Tree, we achieve an efficient  
O((n + m) log n) solution.


---

# 903. Valid Permutations for DI Sequence

---

## Problem
We are given a string `s` of length `n` consisting of `'D'` (decreasing) and `'I'` (increasing).  
We must count the number of valid permutations of integers `[0..n]` that satisfy:

- If `s[i] == 'D'`, then `perm[i] > perm[i+1]`.  
- If `s[i] == 'I'`, then `perm[i] < perm[i+1]`.  

Return the count modulo `1e9+7`.

---

## Key Idea
This is a **dynamic programming problem**.  
We build permutations step by step, enforcing the `'D'` and `'I'` constraints.

### DP Definition
- `dp[i][j]` = number of ways to arrange the first `i` relations (i characters of `s`),  
  with the last chosen number being the `j`-th smallest among the remaining numbers.  
- At step `i`, valid `j` are `0..i`.

### Transition
- If `s[i-1] == 'I'`:  
  `dp[i][j] = sum(dp[i-1][k])` for `k = 0..j-1`  
  (previous must be smaller).  

- If `s[i-1] == 'D'`:  
  `dp[i][j] = sum(dp[i-1][k])` for `k = j..i-1`  
  (previous must be larger).  

We use prefix/suffix sums to compute transitions efficiently.

### Final Answer
The result is `sum(dp[n][j])` for `j = 0..n`.

---

## Code (C#)
```csharp
public class Solution {
    public int NumPermsDISequence(string s) {
        int n = s.Length;
        int MOD = 1000000007;
        int[,] dp = new int[n + 1, n + 1];
        dp[0, 0] = 1;

        for (int i = 1; i <= n; i++) {
            if (s[i - 1] == 'I') {
                int prefix = 0;
                // j ranges 0..i (i+1 choices)
                for (int j = 0; j <= i; j++) {
                    // sum dp[i-1][0..j-1]
                    if (j - 1 >= 0) prefix = (prefix + dp[i - 1, j - 1]) % MOD;
                    dp[i, j] = prefix;
                }
            } else { // 'D'
                int suffix = 0;
                // compute from right to left: j = i..0
                for (int j = i; j >= 0; j--) {
                    // sum dp[i-1][j..i-1]
                    if (j <= i - 1) suffix = (suffix + dp[i - 1, j]) % MOD;
                    dp[i, j] = suffix;
                }
            }
        }

        long ans = 0;
        for (int j = 0; j <= n; j++) {
            ans = (ans + dp[n, j]) % MOD;
        }
        return (int)ans;
    }
}
```


## Complexity
- **Time:** O(n²), since we compute transitions with prefix/suffix sums.  
- **Space:** O(n²) for the DP table.  

---

## Pitfalls
- Must use modulo `1e9+7` at every addition.  
- Careful with indexing: `dp[i][j]` means at step `i`, choosing the `j`-th smallest remaining number.  
- Base case initialization is critical (`dp[0][0] = 1`).  
- Final answer is the sum of all `dp[n][j]`, not just one entry.  

---

## Example Walkthrough
**Input:** `s = "DID"`  

- `n = 3` → permutation length = 4.  
- DP builds transitions step by step.  
- Result = 5 valid permutations.  

**Output:** `5`  

---

## Conclusion
This problem reduces to a **DP with prefix/suffix sums** enforcing `'I'` and `'D'` constraints.  
- Efficient O(n²) solution works for `n ≤ 200`.  
- Correct handling of transitions and final summation is key.  


---

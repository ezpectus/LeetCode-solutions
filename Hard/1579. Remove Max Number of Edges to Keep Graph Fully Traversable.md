# 1579. Remove Max Number of Edges to Keep Graph Fully Traversable

## Problem Statement

Given an undirected graph with `n` nodes and edges of three types:

- Type 1 — usable by Alice only  
- Type 2 — usable by Bob only  
- Type 3 — usable by both Alice and Bob

Each edge is represented as `[type, u, v]`.  
The goal is to remove the **maximum number of edges** such that both Alice and Bob can still **fully traverse the graph** — meaning each can reach every node from any starting point.

Return the number of removable edges, or `-1` if full traversal is impossible.

---

## Architectural Strategy

This is a **connectivity preservation** problem.  
The graph must remain fully connected for both Alice and Bob after edge removals.

### Core idea:

Use **Disjoint Set Union (DSU)** to track connected components for Alice and Bob separately.  
Each DSU maintains a forest of sets, where each set represents a connected component.

### Execution plan:

1. **Initialize two DSUs** — one for Alice, one for Bob.
2. **Process type 3 edges first**:
   - These edges benefit both Alice and Bob.
   - Try to union them in both DSUs.
   - If either DSU successfully merges components → edge is useful.
3. **Process type 1 and type 2 edges**:
   - Type 1 → only union in Alice’s DSU
   - Type 2 → only union in Bob’s DSU
   - If union fails → edge is redundant and can be removed.
4. **Track how many edges were actually used to build connectivity.**
5. **Check if both DSUs have exactly one connected component**:
   - If `components > 1` → graph is fragmented → return `-1`.
6. **Return `edges.Length - used`** — the number of removable edges.

---

## C# Implementation

```csharp
class DSU {
    private int[] parent;
    public int Components;

    public DSU(int n) {
        parent = new int[n + 1];
        Components = n;
        for (int i = 1; i <= n; i++) parent[i] = i;
    }

    public int Find(int x) {
        if (parent[x] != x) parent[x] = Find(parent[x]);
        return parent[x];
    }

    public bool Union(int x, int y) {
        int px = Find(x), py = Find(y);
        if (px == py) return false;
        parent[px] = py;
        Components--;
        return true;
    }
}

public class Solution {
    public int MaxNumEdgesToRemove(int n, int[][] edges) {
        var alice = new DSU(n);
        var bob = new DSU(n);
        int used = 0;

        foreach (var e in edges)
            if (e[0] == 3)
                if (alice.Union(e[1], e[2]) | bob.Union(e[1], e[2]))
                    used++;

        foreach (var e in edges) {
            if (e[0] == 1 && alice.Union(e[1], e[2])) used++;
            else if (e[0] == 2 && bob.Union(e[1], e[2])) used++;
        }

        if (alice.Components > 1 || bob.Components > 1) return -1;
        return edges.Length - used;
    }
}

```

## Complexity Analysis

**Time Complexity**:  
The algorithm runs in approximately linear time with respect to the number of edges.  
More precisely, it’s proportional to the number of edges multiplied by a very slowly growing function called the inverse Ackermann function, which behaves almost like a constant in practice.

**Space Complexity**:  
Linear in the number of nodes — each DSU stores parent pointers for all nodes.

**DSU Operations**:  
All union and find operations are nearly constant time due to path compression optimization.

---

## Architectural Notes

- Type 3 edges are processed first because they benefit both Alice and Bob simultaneously.
- DSU (Disjoint Set Union) is used to track connectivity for each person separately.
- An edge is considered useful only if it connects two previously disconnected components.
- Edges that do not contribute to connectivity are redundant and can be safely removed.
- After processing all edges, both Alice and Bob must have exactly one connected component — otherwise, the graph is not fully traversable.
- The final result is the number of edges that were not needed to maintain full connectivity.


---

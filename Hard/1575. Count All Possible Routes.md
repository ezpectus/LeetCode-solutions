# 1575. Count All Possible Routes  
*O(n × fuel × n) — Classic Memoized DP on City + Remaining Fuel*

---

## Problem Statement

You are given an array `locations` of distinct positive integers where `locations[i]` is the position of city `i`.  
You start at city `start`, need to reach city `finish`, with initial fuel amount `fuel`.

Rules:
- From city `i`, you can move to **any** other city `j` (j ≠ i)
- Moving costs `|locations[i] - locations[j]|` fuel
- Fuel **cannot** become negative at any point
- You can visit any city **multiple times** (including start and finish)
- Return the **number of possible routes** from start to finish, modulo 10⁹ + 7

If impossible → return 0.

**Constraints**:
- 2 ≤ locations.length ≤ 100
- 1 ≤ locations[i] ≤ 10⁹ (all distinct)
- 0 ≤ start, finish < locations.length
- 1 ≤ fuel ≤ 200

---

## Core Idea — DP: Current City + Remaining Fuel

**State**:  
`dp[city][fuel]` = number of ways to reach `finish` starting from `city` with **exactly** `fuel` fuel left

**Recurrence**:
- If `city == finish` → **1** way (already there, do nothing)
- Otherwise → for every other city `next`:
  - cost = |locations[city] - locations[next]|
  - if `fuel ≥ cost` → add `dp[next][fuel - cost]`

**Base cases**:
- If `fuel < 0` → **0** ways
- Memoize to avoid recomputation

**Total states**: n × (fuel + 1) ≤ 100 × 201 = 20,100  
**Transitions per state**: O(n) → total time O(n² × fuel) ≈ 2 million operations — very fast

**Modulo**: 10⁹ + 7

---

## Clean Implementation (C#)

```csharp
public class Solution {
    private const int MOD = 1_000_000_007;
    private long[][] memo;

    public int CountRoutes(int[] locations, int start, int finish, int fuel) {
        int n = locations.Length;
        memo = new long[n][];

        for (int i = 0; i < n; i++) {
            memo[i] = new long[fuel + 1];
            Array.Fill(memo[i], -1);
        }

        return (int)Solve(locations, start, finish, fuel);
    }

    private long Solve(int[] locations, int curCity, int finish, int fuel) {
        // Base case 1: no fuel left → impossible unless already at finish
        if (fuel < 0) return 0;

        // Memoized result
        if (memo[curCity][fuel] != -1) return memo[curCity][fuel];

        // Base case 2: already at finish → 1 way (do nothing)
        long ans = (curCity == finish) ? 1 : 0;

        // Try moving to every other city
        int n = locations.Length;
        for (int nextCity = 0; nextCity < n; nextCity++) {
            if (nextCity == curCity) continue;

            int cost = Math.Abs(locations[curCity] - locations[nextCity]);
            if (cost <= fuel){
                ans = (ans + Solve(locations, nextCity, finish, fuel - cost)) % MOD;
            }
        }

        memo[curCity][fuel] = ans;
        return ans;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n² × fuel)**      | Number of states: n × (fuel + 1) ≤ 100 × 201 ≈ 20,000  
Each state tries all n possible next cities → O(n) work per state  
Total: **O(n² × fuel)** ≈ 100² × 200 = 2,000,000 operations — very fast in practice |
| **Space Complexity**  | **O(n × fuel)**       | Memoization table: n × (fuel + 1) ≈ 20,000 entries (~160 KB) |

**Optimal** — polynomial time for small n (≤100) and fuel (≤200) — perfectly suited to the constraints.

---

## Why This Code Works — Step-by-Step Explanation

### 1. Memoization Table
- `memo[city][fuel]` stores the number of ways to reach `finish` starting from `city` with **exactly** `fuel` left
- Initialized to -1 (meaning not yet computed)

### 2. Base Cases
- If `fuel < 0` → return **0** (invalid state, not enough fuel)
- If `curCity == finish` → return **1** (already at destination — one valid way, do nothing)

### 3. Recursive Step (Core Logic)
- For every possible next city `nextCity` (except current city):
  - Compute cost = `|locations[curCity] - locations[nextCity]|`
  - If `fuel ≥ cost` → recursively add the number of ways from `nextCity` with `fuel - cost`
- Accumulate all valid ways and take **modulo 10⁹ + 7** at each addition to prevent overflow

### 4. Why It Counts All Routes Correctly
- The recursion **explores every possible sequence of moves**
- Memoization ensures we never recompute the same subproblem (same city + same remaining fuel)
- Revisiting cities is naturally allowed (no restriction in the problem)
- Fuel is handled **exactly** — no negative fuel paths are considered

---

## Example Walkthrough

**Example 1**: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5

- Cities positions: 0:2, 1:3, 2:6, 3:8, 4:4
- Start at city 1 (pos=3), finish at city 3 (pos=8)

Some valid routes with total cost ≤ 5:
- 1 → 3 (cost |3-8| = 5) → 1 way
- 1 → 2 → 3 (|3-6| + |6-8| = 3+2 = 5) → 1 way
- 1 → 4 → 3 (|3-4| + |4-8| = 1+4 = 5) → 1 way
- 1 → 4 → 2 → 3 (|3-4| + |4-6| + |6-8| = 1+2+2 = 5) → 1 way

Total routes = **4** → correct

The DP systematically counts **all** such paths by recursively trying every possible next city from the current one, only proceeding when enough fuel remains.

---

## Key Takeaway

This is a **classic path counting with fuel constraint** problem solved elegantly with memoized recursion:

* **State**: current city + remaining fuel
* **dp[city][fuel]** = number of ways to reach finish from this city with exactly this fuel left
* **Base case**: if city == finish → 1 (success)
* **Transition**: try moving to every other city j  
  cost = |locations[city] - locations[j]|  
  if fuel ≥ cost → add dp[j][fuel - cost]
* **Memoize** every state to avoid exponential explosion
* Start recursion from dp[start][initial_fuel] and take modulo 10⁹ + 7

**Pure, clean, optimal** — O(n² × fuel) time, O(n × fuel) space, extremely efficient for n ≤ 100 and fuel ≤ 200.

---

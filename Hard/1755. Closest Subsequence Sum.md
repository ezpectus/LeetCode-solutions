# 1755. Closest Subsequence Sum

---

## Problem Summary
We are given:
- An integer array `nums` (length ≤ 40).
- An integer `goal`.

We want to choose a subsequence of `nums` such that the sum of its elements is as close as possible to `goal`.  
Return the minimum possible value of `abs(sum - goal)`.

---

## Code Idea
This is a **meet-in-the-middle** problem:
- `nums.Length ≤ 40` → too large for brute force `O(2^n)` (≈ 1 trillion subsets).  
- But we can split into two halves of size ≤ 20.  
- Each half has at most `2^20 ≈ 1 million` subsets → manageable.

### Steps
1. **Split array into two halves**:
   - Left half and right half.

2. **Generate all subset sums** for each half:
   - Use recursion or bitmask to compute all possible sums.

3. **Sort one half’s sums**:
   - For efficient binary search.

4. **For each sum in left half**:
   - Compute `target = goal - sum`.  
   - Use binary search on right half sums to find closest value to `target`.  
   - Update minimum absolute difference.

5. **Return result**:
   - Minimum difference found.

---

## Code (C#)
```csharp
public class Solution {
    public int MinAbsDifference(int[] nums, int goal) {
        int n = nums.Length;
        int mid = n / 2;

        // Generate subset sums for left half
        List<int> leftSums = new List<int>();
        GenerateSums(nums, 0, mid, 0, leftSums);

        // Generate subset sums for right half
        List<int> rightSums = new List<int>();
        GenerateSums(nums, mid, n, 0, rightSums);

        // Sort right sums for binary search
        rightSums.Sort();

        int res = int.MaxValue;

        foreach (int sum in leftSums) {
            int target = goal - sum;
            // Binary search in rightSums
            int idx = rightSums.BinarySearch(target);
            if (idx < 0) idx = ~idx;

            if (idx < rightSums.Count) {
                res = Math.Min(res, Math.Abs(sum + rightSums[idx] - goal));
            }
            if (idx > 0) {
                res = Math.Min(res, Math.Abs(sum + rightSums[idx - 1] - goal));
            }
        }

        return res;
    }

    private void GenerateSums(int[] nums, int start, int end, int sum, List<int> list) {
        if (start == end) {
            list.Add(sum);
            return;
        }
        GenerateSums(nums, start + 1, end, sum, list);
        GenerateSums(nums, start + 1, end, sum + nums[start], list);
    }
}
```

## Complexity
- **Time:**  
  - Generating subset sums: O(2^(n/2))  
  - Sorting: O(2^(n/2) · log(2^(n/2)))  
  - Binary search for each left sum: O(2^(n/2) · log(2^(n/2)))  
  - **Total:** ≈ O(2^(n/2) · log(2^(n/2)))  

- **Space:** O(2^(n/2)) for storing subset sums.  

---

## Pitfalls
- Must split into halves to avoid exponential blow-up.  
- Handle negative numbers correctly.  
- Use `long` if needed for intermediate sums, but final result fits in 32-bit.  
- Edge case: empty subsequence → sum = 0.  

---

## Example Walkthrough
**Input:** `nums = [5,-7,3,5], goal = 6`  
- Left half: `[5, -7]` → subset sums = {0, 5, -7, -2}.  
- Right half: `[3, 5]` → subset sums = {0, 3, 5, 8}.  
- Combine: best sum = 6 → difference = 0.  
**Output:** `0`.  

**Input:** `nums = [7,-9,15,-2], goal = -5`  
- Best subsequence sum = -4 → difference = 1.  
**Output:** `1`.  

---

## Conclusion
This problem is solved using **meet-in-the-middle**:  
- Split array into halves.  
- Generate all subset sums.  
- Use binary search to find closest match.  
- Efficient O(2^(n/2) · log(2^(n/2))) solution works for n ≤ 40.  


---

# 1293. Shortest Path in a Grid with Obstacles Elimination

---

##  Problem Restatement
You are given an `m x n` grid where each cell is either:
- `0` → empty cell,
- `1` → obstacle.

You can move up, down, left, or right. You may eliminate at most `k` obstacles.  
Return the minimum number of steps from `(0,0)` to `(m-1,n-1)`. If impossible, return `-1`.

Constraints:  
- `1 ≤ m, n ≤ 40`  
- `1 ≤ k ≤ m * n`  
- `grid[0][0] == grid[m-1][n-1] == 0`

---

##  Core Idea
- This is a shortest path problem in a grid with an extra dimension: **remaining obstacle eliminations**.  
- Each state is `(row, col, remainingK)`.  
- Use **BFS** since all moves have equal weight.  
- Track visited states with `(row, col, remainingK)` to avoid revisiting with worse elimination capacity.

---

##  Step‑by‑Step
1. Initialize BFS queue with `(0,0,k,steps=0)`.  
2. At each step, expand to 4 neighbors.  
3. If neighbor is empty → move normally.  
4. If neighbor is obstacle and `remainingK > 0` → eliminate and move with `remainingK-1`.  
5. If reaching `(m-1,n-1)` → return steps.  
6. If queue empties without reaching → return `-1`.

---

##  Code (C#)
```csharp
public class Solution {
    private static readonly int[][] dirs = new int[][] {
        new int[]{1,0}, new int[]{-1,0}, new int[]{0,1}, new int[]{0,-1}
    };

    public int ShortestPath(int[][] grid, int k) {
        int m = grid.Length, n = grid[0].Length;
        var visited = new HashSet<(int,int,int)>();
        var queue = new Queue<(int r, int c, int rem, int steps)>();
        queue.Enqueue((0,0,k,0));
        visited.Add((0,0,k));

        while (queue.Count > 0) {
            var (r,c,rem,steps) = queue.Dequeue();
            if (r == m-1 && c == n-1) return steps;

            foreach (var d in dirs) {
                int nr = r + d[0], nc = c + d[1];
                if (nr < 0 || nc < 0 || nr >= m || nc >= n) continue;

                int nrem = rem - grid[nr][nc];
                if (nrem >= 0 && !visited.Contains((nr,nc,nrem))) {
                    visited.Add((nr,nc,nrem));
                    queue.Enqueue((nr,nc,nrem,steps+1));
                }
            }
        }
        return -1;
    }
}
```


## Complexity
- **Time:** O(m * n * k) — each cell can be visited with up to `k` different remaining eliminations.  
  BFS explores at most `m * n * k` states, each processed once.  
- **Space:** O(m * n * k) — visited states are tracked as `(row, col, remainingK)`.  
  Queue may hold many states simultaneously, but memory usage remains bounded by the state space.

---

## Pitfalls
- **Visited state granularity:** Must include `remainingK` in the visited key. Otherwise, revisiting the same cell with fewer eliminations left may overwrite a better path.  
- **Obstacle handling:** Decrement `remainingK` only when stepping onto an obstacle cell (`grid[r][c] == 1`).  
- **Large k values:** Ensure visited structure scales properly; naive implementations may blow up memory.  
- **Boundary checks:** Always validate indices to avoid out‑of‑bounds errors.  
- **Early exit:** Return immediately when reaching `(m-1, n-1)` to avoid unnecessary exploration.  
- **Recursion vs iteration:** DFS is not suitable here; BFS ensures shortest path.  

---

## Conclusion
This problem reduces to **BFS in a 3D state space**: `(row, col, remainingK)`.  
- Each move has uniform cost = 1, so Dijkstra is unnecessary.  
- BFS guarantees shortest path discovery while respecting obstacle elimination limits.  
- By carefully tracking `(row, col, remainingK)` states, we avoid revisits and ensure correctness.  

Result: clean `O(m * n * k)` solution, robust for `m,n ≤ 40`, and a textbook example of extending BFS to handle resource constraints.

---



# 1889. Minimum Space Wasted From Packaging

---

## Problem Recap
We need to minimize the total wasted space when packaging items.  
- Each package must fit into a box from a single supplier.  
- Waste = (box size - package size).  
- If no supplier can fit all packages, return `-1`.  
- Answer modulo `1e9+7`.

---

## Key Idea
1. **Sort packages** → ensures we can assign them in increasing order.  
2. **Prefix sums** → allow quick calculation of total package sizes in a range.  
3. **For each supplier**:
   - Sort their box sizes.  
   - If largest box < largest package → skip supplier.  
   - Otherwise, partition packages by box sizes using binary search.  
   - Compute waste = sum(box * count - sum(packages)).  
4. **Take minimum waste** across suppliers.  

---

## Code (C#)
```csharp
public class Solution {
    public int MinWastedSpace(int[] packs, int[][] boxes) {
        // Sort packages so we can assign them in increasing order
        Array.Sort(packs);
        int n = packs.Length;
        long MOD = 1000000007;

        // Prefix sums of package sizes for fast range sum queries
        long[] preff = new long[n + 1];
        for (int i = 0; i < n; i++) preff[i + 1] = preff[i] + packs[i];

        long res = long.MaxValue;

        // Iterate over each supplier
        foreach (var supplier in boxes) {
            Array.Sort(supplier);

            // If largest box cannot fit the largest package, skip this supplier
            if (supplier[supplier.Length - 1] < packs[n - 1]) continue;

            long waste = 0;
            int prev = 0;

            // For each box size in supplier
            foreach (var box in supplier) {
                // Find how many packages can fit into this box
                int idx = UpperBound(packs, box); // first index where packs[i] > box
                long count = idx - prev;

                if (count > 0) {
                    // Sum of packages in range [prev, idx-1]
                    long sumPacks = preff[idx] - preff[prev];
                    // Waste = box * count - sum(packages in range)
                    waste += box * count - sumPacks;
                    prev = idx; // move pointer forward
                }
            }

            // Track minimum waste across suppliers
            res = Math.Min(res, waste);
        }

        // If no supplier works, return -1
        return res == long.MaxValue ? -1 : (int)(res % MOD);
    }

    // Binary search helper: first index where arr[i] > target
    private int UpperBound(int[] arr, int target) {
        int l = 0, r = arr.Length;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (arr[mid] <= target) l = mid + 1;
            else r = mid;
        }
        return l;
    }
}
```

## Complexity
- **Time:** O(n log n + Σ k log n), where Σ k ≤ 1e5.  
  - Sorting packages: O(n log n).  
  - For each supplier: sort boxes O(k log k), binary search O(k log n).  
- **Space:** O(n) for prefix sums.  

---

## Example Walkthrough
**Input:**  
```
packs = [2,3,5], boxes = [[4,8],[2,8]]
```

- Packages sorted: `[2,3,5]`  
- Prefix sums: `[0,2,5,10]`  

**Supplier 1: boxes [4,8]**  
- Box 4 fits `[2,3]` → waste = (4*2 - (2+3)) = 3  
- Box 8 fits `[5]` → waste = (8*1 - 5) = 3  
- **Total waste = 6**  

**Supplier 2: boxes [2,8]**  
- Box 2 fits `[2]` → waste = 0  
- Box 8 fits `[3,5]` → waste = (8*2 - (3+5)) = 8  
- **Total waste = 8**  

**Answer = min(6,8) = 6**

---

## Conclusion
This solution leverages **sorting + prefix sums + binary search** to efficiently compute wasted space.  
- Handles large inputs (`n, Σk ≤ 1e5`) within O(n log n) time.  
- Ensures correctness by checking if the largest box can fit the largest package.  


---



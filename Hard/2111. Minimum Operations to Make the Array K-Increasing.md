# 2111. Minimum Operations to Make the Array K-Increasing  
*O(n log n) — Optimal LIS + Binary Search per Residue Group*

---

## Problem Statement

- You are given a 0-indexed array `arr` of length `n` (1 ≤ n ≤ 10⁵) consisting of positive integers, and a positive integer `k` (1 ≤ k ≤ n).
- The array `arr` is called **K-increasing** if for every index `i` where `k ≤ i < n`:
- **arr[i - k] ≤ arr[i]**
- In one operation, you can change **any** `arr[i]` to **any** positive integer.
- Return the **minimum number of operations** needed to make `arr` K-increasing.

---

## Core Idea — Split into k Independent Subarrays + Longest Non-Decreasing Subsequence (LIS)

**Key insight**:
- The condition `arr[i-k] ≤ arr[i]` for all `i ≥ k` means that each of the **k independent residue classes** (groups by index % k) must form a **non-decreasing** sequence.
- The k groups are completely independent — changes in one group don't affect others.
- Groups:
  - Group 0: arr[0], arr[k], arr[2k], ...
  - Group 1: arr[1], arr[k+1], arr[2k+1], ...
  - ...
  - Group k-1: arr[k-1], arr[2k-1], ...
- In each group, to make it non-decreasing, we need to **keep the longest non-decreasing subsequence** (LIS — allowing equal values)
- Operations in a group = group length − length of LIS in that group
- Total minimum operations = sum over all groups of (group length − LIS length)

**How to compute LIS (non-decreasing) in O(n log n)**:
- Use patience sorting / binary search on tails
- Maintain `tails[i]` = smallest possible tail of all non-decreasing subsequences of length `i+1`
- For each number, binary search the first tail > current → replace it (or append if none)

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int KIncreasing(int[] arr, int k) {
        int n = arr.Length;
        int ans = 0;

        // Process each of the k residue groups separately
        for (int mod = 0; mod < k; mod++) {
            List<int> group = new List<int>();
            for (int i = mod; i < n; i += k) {
                group.Add(arr[i]);
            }

            // Length of longest non-decreasing subsequence in this group
            int lis = LongestNonDecreasingSubsequence(group);
            ans += group.Count - lis;
        }

        return ans;
    }

    private int LongestNonDecreasingSubsequence(List<int> nums) {
        if (nums.Count == 0) return 0;

        // tails[i] = smallest tail of all non-decreasing subsequences of length i+1
        List<int> tails = new List<int>();

        foreach (int num in nums) {
            // Binary search for the first position where tails[mid] > num
            int left = 0, right = tails.Count;

            while (left < right) {
                int mid = left + (right - left) / 2;
                if (tails[mid] <= num)  left = mid + 1;
                else right = mid;
                
            }

            if (left == tails.Count) tails.Add(num);
            else tails[left] = num;   
        }

        return tails.Count;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)** | k groups, each of size ≈ n/k → total elements processed: n  
  LIS per group: O((n/k) log (n/k)) → overall sum O(n log n) |
| **Space Complexity**  | **O(n)**      | Temporary group lists + tails array in LIS (max size ≈ n) |

**Optimal** — linearithmic time, ideal for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: `arr = [5,4,3,2,1]`, `k = 1`

- k = 1 → one group: entire array [5,4,3,2,1]
- Longest **non-decreasing** subsequence length = 1 (any single element)
- Operations needed = 5 - 1 = **4** → correct

**Example 2**: `arr = [4,1,5,2,6,2]`, `k = 2`

- Group 0 (indices 0,2,4): [4,5,6] → already non-decreasing → LIS = 3 → operations = 0
- Group 1 (indices 1,3,5): [1,2,2] → already non-decreasing → LIS = 3 → operations = 0
- Total operations = **0** → correct

**Correct** — each residue group (by index % k) is completely independent.  
Within each group, the minimum changes needed = group size − length of the longest non-decreasing subsequence.

---

## Pitfalls & Edge Cases

- **k = 1** → entire array must be non-decreasing → operations = n − LIS(arr)
- **k = n** → each group has length 1 → operations = 0 always (single element is always non-decreasing)
- **All elements equal** → LIS = group size in every group → operations = 0
- **n = 10⁵** → O(n log n) — fast and efficient
- **Positive integers only** → no issues with negatives or zero

All handled perfectly.

---

## Key Takeaway

This is a **classic K-increasing array** problem:

- Split the array into **k independent residue groups** (indices % k)
- In each group, the problem reduces to: **minimum changes to make it non-decreasing**
- This is equivalent to: **group size − length of longest non-decreasing subsequence**
- Compute LIS length in O(n log n) using binary search on tails (patience sorting style)
- Sum operations over all groups

**Pure, clean, optimal** — O(n log n) time, perfectly fits constraints.

---

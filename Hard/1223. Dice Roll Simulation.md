# 1223. Dice Roll Simulation

## Problem

You are simulating a **die** that rolls numbers from **1 to 6**.  
Each face `i` has a constraint: **it cannot appear more than `rollMax[i]` times consecutively**.

**Given**:

- `n`: total number of rolls  
- `rollMax[6]`: max consecutive rolls for each face

**Return**:  
Number of **distinct sequences** of length `n` that satisfy the constraints.  
**Two sequences are different if they differ at any position.**  
Answer **modulo `10⁹ + 7`**.

---

## Constraints

- `1 ≤ n ≤ 5000`
- `rollMax.length = 6`
- `1 ≤ rollMax[i] ≤ 15`

---

## Core Insight

This is a **constrained sequence generation** problem.

We must **count all valid sequences** of die rolls of length `n`, where **no face `i` appears more than `rollMax[i]` times in a row**.

**Key**: Use **DP with state tracking**:

- **Last die rolled**
- **How many times it was rolled consecutively**

→ `dp[die][streak]` = number of valid sequences **ending** with `die` rolled `streak` times in a row.

---

## Architectural Triggers

| Trigger | Implication |
|-------|-------------|
| “Consecutive roll constraint” | Must track **streak length per die** |
| “Distinct sequences” | Must **count all valid paths**, not just final states |
| “Up to 5000 rolls” | Brute-force generation is **infeasible** |
| “Modulo 10⁹+7” | Must apply `% MOD` at **each step** |

---

## What This Implies

Use **two DP buffers**:

- `dp[die][streak]` → **current** state  
- `prev[die][streak]` → **previous** state

### Transition Logic:

| Case | Action |
|------|--------|
| **Continue same die** | `streak → streak+1` **only if** `streak < rollMax[die]` |
| **Switch to new die** | Start **new streak = 1** |

### Initialization:

- First roll: `dp[i][1] = 1` for all `i`

### Final Answer:

- Sum **all** `dp[i][streak]` for valid `i`, `streak`

---

## Code (C++)

```cpp
class Solution {
public:
    int dieSimulator(int n, vector<int>& rollMax) {
        const int MOD = 1'000'000'007;
        const int D = 6;

        vector<vector<int>> dp(D, vector<int>(16, 0));
        vector<vector<int>> prev(D, vector<int>(16, 0));

        // First roll: each die can start with streak 1
        for (int i = 0; i < D; ++i) {
            dp[i][1] = 1;
        }

        for (int len = 1; len < n; ++len) {
            swap(dp, prev);
            fill(dp.begin(), dp.end(), vector<int>(16, 0));

            for (int curr = 0; curr < D; ++curr) {
                for (int prev_die = 0; prev_die < D; ++prev_die) {
                    if (prev_die == curr) {
                        // Continue streak: shift previous counts
                        for (int streak = 1; streak < rollMax[curr]; ++streak) {
                            dp[curr][streak + 1] = (dp[curr][streak + 1] + prev[prev_die][streak]) % MOD;
                        }
                    } else {
                        // Switch die: all previous streaks contribute to streak=1
                        for (int streak = 1; streak <= rollMax[prev_die]; ++streak) {
                            dp[curr][1] = (dp[curr][1] + prev[prev_die][streak]) % MOD;
                        }
                    }
                }
            }
        }

        int result = 0;
        for (int i = 0; i < D; ++i) {
            for (int streak = 1; streak <= rollMax[i]; ++streak) {
                result = (result + dp[i][streak]) % MOD;
            }
        }
        return result;
    }
};
```

## Complexity

| Metric | Value |
|-------|-------|
| **Time** | `O(n⋅D²⋅R)` where `R = max(rollMax)` → `O(n × 36 × 15)` ≈ **O(2.7e6)** |
| **Space** | `O(D⋅R)` per buffer → `O(6×16) = O(96)` |

> **Highly efficient** for `n ≤ 5000`, `D=6`, `R≤15`

---

## Pitfalls

| Issue | Fix |
|------|-----|
| **Wrong streak transitions** | **Never** allow `streak > rollMax[i]` |
| **Incorrect modulo placement** | Apply `% MOD` **at every addition** |
| **State overwrite** | **Always swap buffers first**, then `fill(dp, 0)` |

---

## Insight

This is a **constrained Markov chain simulation**.

Each state depends on:

- **Previous die**
- **Current streak length**

The **streak constraint** forces **careful state transitions** and **buffer management**.

### Generalizes to:

- Sequence generation with **local constraints**
- DP with **memory of last k steps**
- Probabilistic simulations with **bounded repetition**

---

## Fichka Library Entry

> **Sequence DP: bounded repetition tracking via 2D state table**

---


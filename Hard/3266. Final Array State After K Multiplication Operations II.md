# LeetCode 3266 — Final Array State After K Multiplication Operations II

## 🧠 Problem Architecture

You're given:
- `nums`: array of integers
- `k`: number of operations
- `multiplier`: value to multiply selected elements

Each operation:
1. Find the minimum value in `nums`. If multiple, pick the first.
2. Replace it with `value * multiplier`.

After all `k` operations, apply modulo `1000000007` to every element.

---

## ❌ Why Naive Simulation Fails

- Naive approach: scan array `k` times → O(k × n)
- If k = 10⁹ and n = 10⁴ → 10 trillion operations
- Even with a heap → O(k × log n) → still too slow

> You can't simulate every step. You must compress the mutation chain.

---

## ✅ Architectural Strategy

### Phase 1: Priority Queue (Min-Heap)
- Store `(value, index)` in a min-heap
- Apply operations until either:
  - All indices have been touched
  - Or `k` operations are exhausted

### Phase 2: Snapshot of Current State
- Extract final values from heap
- These are the values after initial mutation phase

### Phase 3: Distribute Remaining Operations
- If `k` still remains:
  - Distribute `k / n` operations evenly
  - Distribute `k % n` extra operations to smallest values

### Phase 4: Compressed Mutation
- Instead of multiplying repeatedly:
  - Use fast exponentiation: `value * multiplier^r % MOD`
  - Where `r` is the number of times index was selected

> This avoids overflow and reduces time complexity from O(k) to O(log k)

## 🚀 C# Implementation

```csharp
using System;
using System.Collections.Generic;

public class Solution {
    const int MOD = 1_000_000_007;

    public int[] GetFinalState(int[] nums, int k, int multiplier) {
        if (multiplier == 1) return nums;

        int n = nums.Length;
        var pq = new PriorityQueue<(long val, int idx), (long val, int idx)>();
        var opCount = new Dictionary<int, int>();
        var touched = new HashSet<int>();

        // Phase 1: Apply operations until all indices touched or k exhausted
        for (int i = 0; i < n; i++)
            pq.Enqueue((nums[i], i), (nums[i], i));

        while (k > 0 && touched.Count < n) {
            var (val, idx) = pq.Dequeue();
            val *= multiplier;
            pq.Enqueue((val, idx), (val, idx));
            touched.Add(idx);
            k--;
        }

        // Phase 2: Extract current values
        long[] current = new long[n];
        while (pq.Count > 0) {
            var (val, idx) = pq.Dequeue();
            current[idx] = val;
        }

        // Phase 3: Distribute remaining operations evenly
        int baseOps = k / n;
        int extraOps = k % n;

        for (int i = 0; i < n; i++)
            pq.Enqueue((current[i], i), (current[i], i));

        while (pq.Count > 0) {
            var (_, idx) = pq.Dequeue();
            opCount[idx] = baseOps + (extraOps-- > 0 ? 1 : 0);
        }

        // Phase 4: Apply compressed mutation via ModPow
        for (int i = 0; i < n; i++) {
            long power = ModPow(multiplier, opCount.GetValueOrDefault(i), MOD);
            long final = (current[i] % MOD) * (power % MOD) % MOD;
            nums[i] = (int)final;
        }

        return nums;
    }

    private long ModPow(long baseVal, long exp, int mod) {
        long res = 1;
        while (exp > 0) {
            if ((exp & 1) == 1)
                res = (res * baseVal) % mod;
            baseVal = (baseVal * baseVal) % mod;
            exp >>= 1;
        }
        return res;
    }
}
```

---

## 🔧 Why Modulo Is Applied Early

- Multiplying large numbers (e.g. 10⁹ × 10⁶) causes overflow
- Applying `% 1000000007` after each multiplication keeps values bounded
- Final result is always within 32-bit integer range

---

## ✅ Complexity Analysis

| Metric       | Value                  | Explanation                                      |
|--------------|------------------------|--------------------------------------------------|
| Time         | O(k log n + n log n)   | Heap operations during mutation + final compression |
| Space        | O(n)                   | Heap + operation count map + value array        |
| Stability    | High                   | No recursion, no overflow                       |
| Scalability  | Excellent              | Handles large `k` via mutation compression      |

---

## 🧱 Engineering Takeaways

This solution demonstrates:

- How to simulate mutation chains without brute force
- How to compress repeated operations via exponentiation
- Why modulo must be applied early and often
- How to use priority queues with index tracking for deterministic selection

> You don’t simulate 10⁹ steps — you architect the mutation.

### Key Techniques

- Use heaps to track dynamic minimums efficiently
- Track operation counts per index
- Compress repeated multiplications with modular exponentiation
- Avoid overflow by applying modulo early
- Split logic into phases: mutation → distribution → compression

---

## 🧩 Generalization Pattern

This pattern applies to:

- Stream mutation with frequency compression
- Controlled exponential growth
- Priority-based mutation chains
- Resource amplification under constraints

> Mutation is not a loop — it's a structure. You simulate the system, not the steps.


---

# LeetCode 552 — Student Attendance Record II  
**Approach: Dynamic Programming with State Tracking**

---

##  Problem Restatement
We must count the number of valid attendance records of length `n` that satisfy:  
1. Fewer than 2 absences (`A`).  
2. No 3 consecutive lates (`L`).  
Return result modulo `10^9 + 7`.

---

##  Core Idea
- Each day can be `P`, `A`, or `L`.  
- Constraints require tracking:  
  - Number of absences used (`0` or `1`).  
  - Number of consecutive lates (`0`, `1`, or `2`).  
- Define DP state:  

`dp[i][a][l]` = number of valid sequences of length `i` with `a` absences and `l` consecutive lates at the end.  

Transitions:  
- Add `P`: `dp[i][a][0] += dp[i-1][a][l]`.  
- Add `A`: if `a < 1`, `dp[i][a+1][0] += dp[i-1][a][l]`.  
- Add `L`: if `l < 2`, `dp[i][a][l+1] += dp[i-1][a][l]`.  

Final answer = sum of `dp[n][a][l]` for all valid `a,l`.

---

##  Implementation (C#)

```csharp
public class Solution {
    private const int MOD = 1000000007;

    public int CheckRecord(int n) {
        long[,,] dp = new long[n + 1, 2, 3];
        dp[0, 0, 0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int a = 0; a <= 1; a++) {
                for (int l = 0; l <= 2; l++) {
                    long val = dp[i - 1, a, l];
                    if (val == 0) continue;

                    // Add 'P'
                    dp[i, a, 0] = (dp[i, a, 0] + val) % MOD;

                    // Add 'A'
                    if (a < 1) {
                        dp[i, a + 1, 0] = (dp[i, a + 1, 0] + val) % MOD;
                    }

                    // Add 'L'
                    if (l < 2) {
                        dp[i, a, l + 1] = (dp[i, a, l + 1] + val) % MOD;
                    }
                }
            }
        }

        long res = 0;
        for (int a = 0; a <= 1; a++) {
            for (int l = 0; l <= 2; l++) {
                res = (res + dp[n, a, l]) % MOD;
            }
        }
        return (int)res;
    }
}
```



##  Time Complexity
- **State transitions per day:**  
  For each day `i`, we iterate over `a ∈ {0,1}` and `l ∈ {0,1,2}`.  
  → Constant number of states per day.  
- **Total iterations:**  
  `O(n)` since we process `n` days sequentially.  
- **Overall:**  
  → `O(n)`.

---

##  Space Complexity
- **DP table size:**  
  `dp[n][2][3]` → `O(n * 2 * 3)` = `O(n)`.  
- **Optimization:**  
  Since each day only depends on the previous day, we can use a rolling array.  
  → Optimized to `O(1)` space.  

---

#  Impact of Design Choices

| Design Choice                  | Effect                                                                 |
|--------------------------------|------------------------------------------------------------------------|
| **3D DP (day, absences, lates)** | Captures both constraints simultaneously.                             |
| **Modulo arithmetic**          | Ensures results fit within integer limits.                             |
| **Rolling array optimization** | Reduces memory usage to constant space without affecting correctness.  |

---

#  Pitfalls
- **Forgetting modulo:**  
  May cause integer overflow for large `n`.  
- **Allowing 2 absences:**  
  Violates eligibility condition.  
- **Allowing 3 consecutive lates:**  
  Invalidates sequence.  

---

#  Conclusion
- **What it gives:** Count of valid attendance records of length `n`.  
- **Why it matters:** Demonstrates DP with multiple constraints and efficient state tracking.  
- **Key takeaway:**  
  1. Track absences and consecutive lates.  
  2. Use DP transitions for `P`, `A`, `L`.  
  3. Apply modulo `10^9 + 7` to keep results within bounds.  
  4. Optimize space with rolling arrays if needed.  


---

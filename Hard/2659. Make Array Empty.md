# 2659. Make Array Empty — Architectural Fichka

##  Problem Summary
We are given an array `nums` of distinct integers.  
Operations allowed until the array is empty:
1. If the **first element** is the smallest value → remove it.  
2. Otherwise → move the first element to the end of the array.  

We must return the **number of operations** required to make the array empty.

---

##  Core Idea
- The process is equivalent to removing elements in **ascending order**.  
- Each time we remove the next smallest element, we may need to rotate the array until it appears at the front.  
- Key observation:  
  - If the index of the current smallest element is **greater** than the previous one (in sorted order), no extra rotations are needed.  
  - If it is **smaller**, it means the array has wrapped around → we must add `(n - i)` operations.  
- Thus, the solution reduces to counting these "wrap-arounds" in the sorted index sequence.

---

##  Code (C#)

```csharp
public class Solution {
    public long CountOperationsToEmptyArray(int[] nums) {
        int n = nums.Length;
        int[] indices = Enumerable.Range(0, n).ToArray();

        // Sort indices by values in nums
        Array.Sort(indices, (a, b) => nums[a].CompareTo(nums[b]));

        long result = n; // base removals
        for (int i = 1; i < n; i++) {
            if (indices[i] < indices[i - 1]) {
                result += n - i;
            }
        }

        return result;
    }
}
```

##  Complexity
- **Time:** O(n log n)  
  - Sorting indices by values requires O(n log n).  
  - Single pass through sorted indices adds O(n).  
  - Overall complexity: O(n log n).  
- **Space:** O(n)  
  - Index array of size n.  
  - Constant extra variables for result tracking.  

---

##  Pitfalls
- **Sorting criterion:** Must sort indices by the values in `nums`, not by their positions.  
- **Base case:** Always start with `result = n`, since each element must be removed at least once.  
- **Wrap-around detection:** If `indices[i] < indices[i - 1]`, it means the array has rotated → add `n - i`.  
- **Distinct values assumption:** Works only because all values in `nums` are distinct.  
- **Edge cases:**  
  - Already sorted ascending → no wrap-arounds, result = n.  
  - Strictly descending → maximum wrap-arounds, larger result.  
  - Single-element array → result = 1.  

---

##  Sanity Checks
- Input: `[3,4,-1]` → Output: **5**  
  - Sorted indices by values: `[-1,3,4]` → wrap-around detected once → +2 operations.  
- Input: `[1,2,4,3]` → Output: **5**  
  - Sorted indices by values: `[1,2,3,4]` → one wrap-around → +1 operation.  
- Input: `[1,2,3]` → Output: **3**  
  - Already sorted ascending → no wrap-arounds, only base removals.  

---

##  Key takeaway
This problem is a **rotation + removal simulation reduced to index analysis**:
1. Sort indices by values.  
2. Traverse sorted indices, detect wrap-arounds when the current index is smaller than the previous.  
3. Add `n - i` for each wrap-around.  
4. Start with base removals = `n`.  

###  Why this works
- Each wrap-around corresponds to a rotation cycle in the array.  
- Counting these cycles avoids explicit simulation of operations.  
- The algorithm leverages sorting + linear scan → clean and efficient.  

**Elegant O(n log n) solution**: no simulation, just index analysis.


---


# 736. Parse Lisp Expression — Clean C# Implementation

---

## Overview
This solution implements a **recursive parser** for Lisp-like expressions with support for:
- **Integers** (positive/negative).  
- **Variables** with proper scoping.  
- **Operations:** `add`, `mult`, `let`.  

It uses:
- **Recursive evaluation** for nested expressions.  
- **Dictionary scopes** to handle variable assignments.  
- **Token parsing** that respects parentheses and spaces.

---

## Code (C#)
```csharp
using System;
using System.Collections.Generic;

public class Solution {
    public int Evaluate(string expression) {
        return Evaluate(expression, new Dictionary<string, int>());
    }

    private int Evaluate(string expression, Dictionary<string, int> outerScope) {
        // Base case: variable or integer
        if (expression[0] != '(') {
            if (Char.IsDigit(expression[0]) || expression[0] == '-') {
                return int.Parse(expression);
            }
            return outerScope[expression];
        }
        
        // Remove outer parentheses
        expression = expression.Substring(1, expression.Length - 2);
        var tokens = ParseTokens(expression);
        
        // Determine expression type
        var type = tokens[0];
        
        if (type == "add") {
            return Evaluate(tokens[1], new Dictionary<string, int>(outerScope)) +
                   Evaluate(tokens[2], new Dictionary<string, int>(outerScope));
        } 
        else if (type == "mult") {
            return Evaluate(tokens[1], new Dictionary<string, int>(outerScope)) *
                   Evaluate(tokens[2], new Dictionary<string, int>(outerScope));
        } 
        else if (type == "let") {
            var newScope = new Dictionary<string, int>(outerScope);
            for (int i = 1; i < tokens.Count - 1; i += 2) {
                newScope[tokens[i]] = Evaluate(tokens[i + 1], newScope);
            }
            return Evaluate(tokens[tokens.Count - 1], newScope);
        }
        
        throw new Exception("Invalid expression");
    }

    private List<string> ParseTokens(string expression) {
        var tokens = new List<string>();
        int start = 0, count = 0;
        
        for (int i = 0; i < expression.Length; i++) {
            if (expression[i] == ' ') {
                if (count > 0) {
                    tokens.Add(expression.Substring(start, count));
                }
                start = i + 1;
                count = 0;
            } else if (expression[i] == '(') {
                if (count > 0) {
                    tokens.Add(expression.Substring(start, count));
                }
                int j = i, balance = 0;
                do {
                    if (expression[j] == '(') balance++;
                    if (expression[j] == ')') balance--;
                    j++;
                } while (balance != 0);
                tokens.Add(expression.Substring(i, j - i));
                i = j - 1;
                start = i + 1;
                count = 0;
            } else {
                count++;
            }
        }
        
        if (count > 0) {
            tokens.Add(expression.Substring(start, count));
        }
        
        return tokens;
    }
}
```


## Time Complexity
- **Traversal:** Each character in the expression is parsed exactly once.  
- **Evaluation:** Recursive calls handle nested expressions without redundant work.  
- **Overall:** **O(n)**, where n = length of the expression.  

---

## Space Complexity
- **Recursion stack:** Depth proportional to nesting of parentheses.  
- **Scope dictionaries:** Each `let` introduces a new scope copy.  
- **Overall:** **O(n)**.  

---

## Example Walkthrough

**Input:**  
```(let x 2 (mult x (let x 3 y 4 (add x y))))```


**Steps:**
1. Outer `let`: assign `x = 2`.  
2. Evaluate `(mult x (let ...))`.  
3. Inner `let`: assign `x = 3`, `y = 4`.  
4. Evaluate `(add x y)` → `3 + 4 = 7`.  
5. Inner `let` returns `7`.  
6. Outer `mult`: `2 * 7 = 14`.  

✅ **Output:** `14`

---

## Why This Works
- **Recursive evaluation** ensures nested parentheses are processed correctly.  
- **Scope copying** guarantees proper variable shadowing (inner `x` overrides outer `x`).  
- **Token parsing** respects parentheses balance, preventing mis-splits.  

---

## Edge Cases
- **Simple integer:** `"42"` → `42`.  
- **Variable shadowing:** `(let x 3 x 2 x)` → `2`.  
- **Multiple assignments:** `(let x 1 y 2 x (add x y) (add x y))` → `5`.  

---

✅ **Conclusion**  
This is a **recursive scope-based parser** for Lisp expressions.  
It cleanly handles nested operations, variable shadowing, and scoping rules in **O(n)** time and **O(n)** space, producing correct results for all valid inputs.


---

# 332. Reconstruct Itinerary — Architectural Hierholzer's Algorithm  
*O(E log E) — Eulerian Path in Flight Graph*

---

## Problem Statement

Given a list of airline tickets `tickets[i] = [from, to]`, reconstruct the **flight itinerary**:

- Must start from `"JFK"`
- Use **all tickets exactly once**
- If multiple valid paths exist → return the **lexicographically smallest** one

**Guaranteed**: at least one valid itinerary exists.

---

## Core Idea — Eulerian Path in Directed Graph

This is a **classic Eulerian path** problem:

- Each ticket = **directed edge** `from → to`
- Each airport = **node**
- We must find a path that uses **every edge exactly once**

Since the graph may have multiple outgoing edges, we must choose the **lexicographically smallest** one at each step.

**Solution**: **Hierholzer's algorithm** + **priority queue (min-heap)** for lexical order.

---

## Full Implementation (C#)

```csharp
public class Solution {
    public IList<string> FindItinerary(IList<IList<string>> tickets)   {
        // Build graph: airport → min-heap of destinations
        var graph = new Dictionary<string, PriorityQueue<string, string>>();
        
        foreach (var ticket in tickets)  {
            string from = ticket[0];
            string to = ticket[1];
            
            if (!graph.ContainsKey(from))
                graph[from] = new PriorityQueue<string, string>();
                
            graph[from].Enqueue(to, to); // min-heap by lexical order
        }

        var result = new List<string>();
        // Start DFS from JFK
        Dfs("JFK", graph, result);
        
        result.Reverse(); // because we built path in reverse
        return result;
    }

    private void Dfs(string airport, 
                     Dictionary<string, PriorityQueue<string, string>> graph, 
                     List<string> result) 
    {
        // While there are outgoing flights
        if (graph.ContainsKey(airport) && graph[airport].Count > 0) {
            while (graph[airport].Count > 0) {
                string next = graph[airport].Dequeue();
                Dfs(next, graph, result);
            }
        }
        
        // After all outgoing flights processed → add current airport
        result.Add(airport);
    }
}
```

## Why This Works — Hierholzer's Algorithm Explained

1. **Build graph with min-heap (PriorityQueue)** for each departure  
   → guarantees we always pick the **lexicographically smallest** destination first

2. **DFS in post-order**:
   - First recursively exhaust **all outgoing flights**
   - Only **after** that add current airport to the path  
   → naturally builds the itinerary **in reverse order**

3. **Reverse the result at the end** → get the correct forward order

### Guarantees:
- Uses **all edges exactly once** → true Eulerian path
- Chooses **lexicographically smallest** possible next step at every decision point
- Works perfectly **even with cycles** — Hierholzer’s algorithm is designed for that

---

## Complexity

| **Metric**     | **Value**       | **Notes**                                      |
|----------------|-----------------|------------------------------------------------|
| **Time**       | **O(E log E)**  | E = number of tickets; each edge enqueued/dequeued once |
| **Space**      | **O(V + E)**    | Graph + recursion stack                        |

**Optimal** — cannot be faster than O(E).

---

## Pitfalls & Edge Cases

- **Multiple edges** between same airports → handled perfectly by min-heap
- **Cycles** → Hierholzer’s algorithm shines here
- **Lexical order** → strictly enforced by priority queue
- **Must reverse result** → because of post-order DFS (most common mistake!)
- `"JFK"` with no outgoing flights → valid → returns `["JFK"]`

---

## Key Takeaway

- Build directed multigraph with **min-heap** per node → lexical order
- Run **post-order DFS** → builds path backwards
- **Reverse** at the end → correct forward itinerary

**One of the most beautiful graph traversal problems on LeetCode** — combines:
- Eulerian path theory
- Priority queue for ordering
- The legendary **post-order DFS + reverse** trick
**A true masterpiece of algorithmic design.**

---

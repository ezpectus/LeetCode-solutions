# ðŸ§© 1178. Number of Valid Words for Each Puzzle

## ðŸ“˜ Problem Summary  
You're given:
- A list of `words`  
- A list of `puzzles`, each with 7 unique lowercase letters  

A word is **valid** for a puzzle if:
1. It contains the **first letter** of the puzzle  
2. All its letters are contained within the puzzle  

Return an array `answer` where `answer[i]` is the number of valid words for `puzzles[i]`.

---

## ðŸ§  Why This Approach Works

This is a **bitmask + subset enumeration** problem.  
We need to check many words against many puzzles, but brute force is too slow.

### âœ… Challenges:
- Up to `10^5` words and `10^4` puzzles  
- Each word must be checked against puzzle constraints  
- Naive comparison is `O(n * m * word_length)` â€” unacceptable

### âœ… Strategy:
- Represent each word and puzzle as a **bitmask** of letters  
- Preprocess all word masks and count their frequencies  
- For each puzzle:
  - Generate all subsets of its letters (up to `2^7 = 128`)  
  - For each subset, check if it contains the puzzleâ€™s first letter  
  - If yes, and the subset exists in word mask counts â†’ add to result

This reduces the complexity to `O(m * 2^7)` â€” fast enough.

---

## ðŸ”§ C# Implementation

```csharp
public class Solution {
    public IList<int> FindNumOfValidWords(string[] words, string[] puzzles) {
        var maskcount = new Dictionary<int, int>();

        int GetMask(string s) {
            int mask = 0;
            foreach (var ch in s)
                mask |= 1 << (ch - 'a');
            return mask;
        }

        foreach (var word in words) {
            int mask = GetMask(word);
            maskcount[mask] = maskcount.GetValueOrDefault(mask, 0) + 1;
        }

        var res = new List<int>();

        foreach (var puzzle in puzzles) {
            int pmask = GetMask(puzzle);
            int fchm = 1 << (puzzle[0] - 'a');
            int count = 0;

            for (int i = pmask; i > 0; i = (i - 1) & pmask) {
                if ((i & fchm) != 0 && maskcount.ContainsKey(i))
                    count += maskcount[i];
            }

            res.Add(count);
        }

        return res;
    }
}
```

## ðŸ“¶ Signal Table

| Signal           | Meaning                                                  |
|------------------|----------------------------------------------------------|
| `GetMask(s)`     | Converts string to bitmask of letters                    |
| `maskcount`      | Frequency map of word bitmasks                           |
| `pmask`          | Bitmask of puzzle letters                                |
| `fchm`           | Bitmask of puzzleâ€™s first letter                         |
| `(i - 1) & pmask`| Enumerates all subsets of puzzle letters                 |
| `res[i]`         | Number of valid words for puzzle `i`                     |

---

## âœ… Takeaways

- This is a **bitmask optimization** for subset matching  
- You reduce wordâ€“puzzle comparison to **bitwise operations**  
- Subset enumeration via `(i - 1) & mask` is a **classic trick**  
- The first-letter constraint is enforced via **bitwise AND**  
- This pattern generalizes to problems involving:
  - Subset filtering  
  - Permission masks  
  - Feature matching

---

## ðŸ§© Conclusion

This solution transforms string matching into **bitmask arithmetic**, enabling fast subset checks.  
By precomputing word masks and iterating over puzzle subsets, we avoid brute force and achieve scalable performance.  
The use of `(i - 1) & mask` is a powerful technique for enumerating subsets efficiently.  
This is a textbook example of **bitmask-based filtering**, applicable to puzzles, permissions, and feature constraints.

---

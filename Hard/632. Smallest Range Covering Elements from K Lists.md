
##  Problem Description & Constraints  

### What We Are Given  
- `k` sorted lists: `nums[i]` — **non-decreasing**  
- Each list: `1 ≤ nums[i].length ≤ 50`  
- `1 ≤ k ≤ 3500`  
- Values: `-10⁵ ≤ nums[i][j] ≤ 10⁵`  

### What We Must Return  
- **Smallest range `[a, b]`** such that:  
  > **At least one number** from **each list** is in `[a, b]`  

### Range Comparison  
> `[a,b]` < `[c,d]` if:  
> - `b-a < d-c` **OR**  
> - `b-a == d-c` **and** `a < c`  

---

##  Core Algorithm Idea — **Sliding Window + Min-Heap**

Imagine **k sorted tapes**, each playing numbers in order.  
You must **pull exactly one number from each tape** and form a **range** that covers all of them.  
Your goal: **minimize the gap** between the **smallest** and **largest** number in this set.

You don’t try every combination — that’s too slow.  
Instead, you maintain a **dynamic window** of `k` numbers — one from each list.  
At any moment, this window is **valid** because it includes **one from every list**.

The **key insight**:  
> **Always advance the list that gave you the current minimum.**

Why?  
The **minimum** is the **bottleneck** — it forces your range to stretch left.  
By removing it and pulling the **next number** from the same list, you **raise the floor**.  
If the **maximum** doesn’t grow too much, your **range shrinks** — and that’s a win.

You **never touch** other lists until their turn comes.  
You’re **greedy, but smart** — you only move what limits you from below.

---

##  Concept in Simple Terms  

Picture **k checkout lanes** in a store, each with a sorted queue of prices.  
You pick **one item from each lane** and look at:  
> **"What’s the cheapest and most expensive item I have?"**

That difference is your **current range**.

You want the **smallest possible difference**.

So what do you do?  
You **go to the lane with the cheapest item** and say:  
> — "Give me your next item!"

Maybe it’s more expensive — good! The **minimum rises**.  
If the **most expensive item** hasn’t jumped too far, your **range gets tighter**.

You keep doing this — **always advancing the lane with the current minimum** —  
until **one lane runs out of items**.

Along the way, you **remember the tightest range** you ever saw.

This is **sliding window magic** powered by a **min-heap**:  
> **Move only the minimum. Let the rest follow.**

---

##  Full C# Solution 

```csharp
public class Solution {
    public int[] SmallestRange(IList<IList<int>> nums) {
        int k = nums.Count;
        var pq = new PriorityQueue<Point, int>(k);  // capacity = k
        int max = int.MinValue;
        int[] range = { 0, int.MaxValue };

        // Step 1: Initialize heap with first element from each list
        for (int i = 0; i < k; i++) {
            int val = nums[i][0];
            pq.Enqueue(new Point(i, 0, val), val);
            max = Math.Max(max, val);
        }

        // Step 2: Slide the window
        while (pq.Count == k) {
            Point min = pq.Dequeue();

            // Update best range
            if (max - min.val < range[1] - range[0]) {
                range[0] = min.val;
                range[1] = max;
            }

            // Move to next element in the same row
            if (min.col + 1 < nums[min.row].Count) {
                int next = nums[min.row][min.col + 1];
                max = Math.Max(max, next);
                pq.Enqueue(new Point(min.row, min.col + 1, next), next);
            } else {
                break; // One list exhausted
            }
        }

        return range;
    }
}
```

##  Architectural Breakdown (Deep Dive)

| Component | Role | How It Works | Why It’s Critical |
|---------|------|-------------|------------------|
| `Point` | **Heap Element** | `(row, col, val)` — tracks **position and value** | Enables **precise pointer movement** across lists |
| `pq` | **Min-Heap** | Stores **one element per list**, sorted by `val` | Always delivers the **smallest** in O(log k) |
| `max` | **Window Max** | Updated **only when adding** a new element | Defines the **right boundary** of the current range |
| `pq.Count == k` | **Window Validity** | Ensures **all k lists** are still represented | Guarantees **full coverage** |
| `pq.Dequeue()` | **Shrink Left** | Removes the **smallest** → moves its pointer | Core of **sliding window** — raises the floor |
| `pq.Enqueue(next)` | **Expand Right** | Adds the **next element** from the same list | Maintains **validity** of the window |
| `range` update | **Track Best** | Only when `max - min` **shrinks** | Greedy **optimization** — remembers tightest range |

---

##  Pro Tips & Optimizations  

| Tip | Why It Matters |
|-----|----------------|
| `struct Point : IComparable` | **Zero boxing**, fastest comparison |
| `PriorityQueue<Point, int>(k)` | **Pre-allocated capacity** → no resize |
| `while (pq.Count == k)` | Clean, safe exit condition |
| `max` updated **only on add** | Avoids redundant `Math.Max` |
| No extra classes | Minimal, clean, **blazing fast** |

---

##  Key Takeaway  

> **"Use a min-heap to always remove the smallest element.  
> Advance only its pointer.  
> Track the max in the current window.  
> The smallest [min, max] that covers all lists is your answer."**


---

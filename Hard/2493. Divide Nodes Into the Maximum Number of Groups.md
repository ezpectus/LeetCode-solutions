# 🔗 LeetCode 2493 — Magnificent Sets (C#)

## 🧩 Problem Overview

You're given:
- An integer `n` representing the number of nodes in an undirected graph
- A list of edges `edges[i] = [a, b]` representing bidirectional connections

Your task is to divide the nodes into `m` groups (1-indexed) such that:
- Each node belongs to exactly one group
- For every edge `[a, b]`, if `a` is in group `x` and `b` is in group `y`, then `|x - y| = 1`

Return the **maximum number of groups** `m` that satisfy these conditions.  
Return `-1` if it's impossible.

---

## 🧠 Architectural Rationale

### ✅ Graph Interpretation
- Each node is a vertex, each edge is bidirectional
- The graph may be **disconnected**, so we process each connected component separately

### ✅ Valid Grouping Rule
- For any edge `[a, b]`, their group indices must differ by exactly 1
- This implies a **layered structure** — like BFS levels

### ✅ Core Strategy
1. **Build adjacency list**
2. **Use Union-Find** to identify connected components
3. For each component:
   - Check if it's **bipartite** (otherwise return `-1`)
   - For each node, run **BFS** to find the maximum depth (i.e., number of layers)
   - Take the **maximum depth** across all nodes in the component
4. Sum the depths across all components → final answer

---

## ✅ C# Implementation

```csharp
public class Solution {
    public int MagnificentSets(int n, int[][] edges) {
        List<int>[] graph = new List<int>[n + 1];
        for (int i = 1; i <= n; i++) graph[i] = new List<int>();
        foreach (var e in edges) {
            graph[e[0]].Add(e[1]);
            graph[e[1]].Add(e[0]);
        }

        UnionFind uf = new UnionFind(n + 1);
        foreach (var e in edges) {
            uf.Union(e[0], e[1]);
        }

        Dictionary<int, List<int>> components = new();
        for (int i = 1; i <= n; i++) {
            int root = uf.Find(i);
            if (!components.ContainsKey(root)) components[root] = new List<int>();
            components[root].Add(i);
        }

        int result = 0;
        foreach (var comp in components.Values) {
            if (!IsBipartite(comp, graph)) return -1;

            int maxDepth = 0;
            foreach (int node in comp) {
                int depth = BFS(node, graph, n);
                maxDepth = Math.Max(maxDepth, depth);
            }
            result += maxDepth;
        }

        return result;
    }

    private bool IsBipartite(List<int> nodes, List<int>[] graph) {
        Dictionary<int, int> color = new();
        foreach (int node in nodes) {
            if (!color.ContainsKey(node)) {
                Queue<int> queue = new();
                queue.Enqueue(node);
                color[node] = 1;

                while (queue.Count > 0) {
                    int curr = queue.Dequeue();
                    foreach (int nei in graph[curr]) {
                        if (!color.ContainsKey(nei)) {
                            color[nei] = -color[curr];
                            queue.Enqueue(nei);
                        } else if (color[nei] == color[curr]) {
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    }

    private int BFS(int start, List<int>[] graph, int n) {
        int[] visited = new int[n + 1];
        Queue<int> queue = new();
        queue.Enqueue(start);
        visited[start] = 1;
        int depth = 0;

        while (queue.Count > 0) {
            int size = queue.Count;
            depth++;
            for (int i = 0; i < size; i++) {
                int node = queue.Dequeue();
                foreach (int nei in graph[node]) {
                    if (visited[nei] == 0) {
                        visited[nei] = 1;
                        queue.Enqueue(nei);
                    }
                }
            }
        }

        return depth;
    }

    class UnionFind {
        private int[] parent;
        public UnionFind(int size) {
            parent = new int[size];
            for (int i = 0; i < size; i++) parent[i] = i;
        }

        public int Find(int x) {
            if (parent[x] != x) parent[x] = Find(parent[x]);
            return parent[x];
        }

        public void Union(int x, int y) {
            int px = Find(x);
            int py = Find(y);
            if (px != py) parent[py] = px;
        }
    }
}
```

## ⏱ Time & Space Complexity

| Operation           | Time Complexity     | Space Complexity   | Description                                 |
|---------------------|----------------------|---------------------|---------------------------------------------|
| Graph Build         | `O(E)`               | `O(N + E)`          | Build adjacency list                        |
| Union-Find Ops      | `O(α(N))` per op     | `O(N)`              | Identify connected components               |
| Bipartite Check     | `O(N + E)` per comp  | `O(N)`              | BFS coloring to validate layering           |
| BFS Depth Scan      | `O(N + E)` per node  | `O(N)`              | Find max depth from each node               |
| **Total**           | `O(N² + E)` worst    | `O(N + E)`          | Acceptable for `n ≤ 500`, `E ≤ 10⁴`         |

---

## 🧪 Example Execution

| Input                                      | Output | Explanation                                  |
|-------------------------------------------|--------|----------------------------------------------|
| `n = 6`, `[[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]` | `4`    | Valid layering: groups 1–4 satisfy all edges |
| `n = 3`, `[[1,2],[2,3],[3,1]]`             | `-1`   | Triangle cycle → not bipartite → impossible  |

---

## ✅ Final Takeaways

- **Layering constraint implies bipartite structure**  
- **Union-Find isolates disconnected components**  
- **BFS depth gives max group count per component**  
- **Bipartite check is essential to avoid invalid cycles**  
- Fully modular and reusable for layered graph grouping problems


---

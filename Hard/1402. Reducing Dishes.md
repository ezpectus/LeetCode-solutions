# 1402. Reducing Dishes — Greedy Reverse Accumulation Strategy

---

## Origin & Motivation

We are given an array `satisfaction[i]` representing the satisfaction level of each dish.  
Each dish takes 1 unit of time to cook, and the chef can choose any subset of dishes in any order.

The **like-time coefficient** of a dish is defined as:  
`time[i] * satisfaction[i]`, where `time[i]` is the cooking time index (starting from 1).

The goal is to **maximize the total like-time coefficient** by selecting and ordering dishes optimally.  
Some dishes may be discarded to achieve the best result.

---

## Use Cases

- Greedy selection with cumulative scoring  
- Reverse iteration with early stopping  
- Optimization via prefix accumulation  
- Discarding negative-impact elements

---

## Core Architecture

### Triggers and Transitions

| Condition                        | Architectural Role              |
|----------------------------------|----------------------------------|
| Sort satisfaction ascending      | Enables reverse greedy scan     |
| Iterate from high to low         | Prioritize high-value dishes    |
| Track cumulative sum             | Builds time-weighted impact     |
| Stop when adding hurts total     | Locks optimal subset            |

---

### Algorithm Steps

1. Sort `satisfaction` in ascending order  
2. Initialize `sum = 0` and `total = 0`  
3. Iterate from the end (highest satisfaction) to the start  
4. At each step:
   - Check if adding current dish improves total
   - If yes: update `sum` and `total`
   - If no: break — further additions will reduce total
5. Return final `total`

---

## C# Implementation

```csharp
public class Solution {
    public int MaxSatisfaction(int[] satisfaction) {
        int n = satisfaction.Length;
        Array.Sort(satisfaction);
        int total = 0;
        int sum = 0;

        for (int i = n - 1; i >= 0; i--) {
            if (total > total + sum + satisfaction[i]) break;

            sum += satisfaction[i];
            total += sum;
        }

        return total;
    }
}
```

## Complexity Analysis

| Phase         | Time Complexity | Space Complexity | Notes                                           |
|---------------|------------------|------------------|--------------------------------------------------|
| Sorting       | O(n log n)       | O(1)             | Sort satisfaction levels in ascending order      |
| Reverse Scan  | O(n)             | O(1)             | Iterate from end to start, accumulating greedily |
| Total         | O(n log n)       | O(1)             | Dominated by sorting phase                      |

- Sorting is required to enable greedy selection from highest satisfaction values downward  
- Reverse scan ensures we always consider the most valuable dishes first  
- Space is constant since we only track two integers: `sum` and `total`  
- No auxiliary arrays or data structures are needed beyond the input array

---

## Pitfalls and Clarifications

- Sorting is essential — without it, we cannot guarantee optimal greedy selection  
- Do not simulate time indices explicitly — use cumulative sum to reflect time-weighted impact  
- Negative satisfaction values may be discarded if they reduce the total score  
- Early stopping is critical — once adding a dish reduces total, further additions will only worsen it  
- Brute-force permutations are unnecessary — greedy reverse accumulation is provably optimal for this structure

---

## Conclusion

This is a greedy optimization problem solved via reverse accumulation.  
The key insight is that the like-time coefficient grows with both satisfaction and position, so we:

- Sort satisfaction levels in ascending order  
- Scan from high to low, greedily accumulating satisfaction  
- Track cumulative sum and total score  
- Stop early when further additions reduce the total

This approach is clean, efficient, and avoids brute-force.  
It guarantees the maximum like-time coefficient with minimal overhead and optimal time complexity.


---

# 391. Perfect Rectangle

---

## Problem Restatement
We are given a list of axis-aligned rectangles.  
Each rectangle is defined by `[xi, yi, ai, bi]` → bottom-left `(xi, yi)` and top-right `(ai, bi)`.  

We need to check if all rectangles together form an **exact cover** of a rectangular region:
- No overlaps.  
- No gaps.  
- The union must be a perfect rectangle.  

---

## Key Idea
The solution relies on **area check + corner parity check**:

1. **Bounding rectangle:**  
   - Find the minimum x (`minX`), minimum y (`minY`), maximum x (`maxX`), maximum y (`maxY`).  
   - This defines the outer rectangle that should be covered.

2. **Area check:**  
   - Compute the sum of all rectangle areas.  
   - Compare with the area of the bounding rectangle.  
   - If not equal → return false.

3. **Corner check:**  
   - Use a HashSet to track corners.  
   - For each rectangle, add its 4 corners.  
   - If a corner appears twice, remove it (since shared corners cancel out).  
   - At the end, only 4 corners should remain: the bounding rectangle corners.  

If both conditions hold → return true.

---

## Code (C#)
```csharp
public class Solution {
    public bool IsRectangleCover(int[][] rectangles) {
        long areaSum = 0;
        int minX = int.MaxValue, minY = int.MaxValue;
        int maxX = int.MinValue, maxY = int.MinValue;

        var corners = new HashSet<string>();

        foreach (var rect in rectangles) {
            int x1 = rect[0], y1 = rect[1], x2 = rect[2], y2 = rect[3];

            // Update bounding box
            minX = Math.Min(minX, x1);
            minY = Math.Min(minY, y1);
            maxX = Math.Max(maxX, x2);
            maxY = Math.Max(maxY, y2);

            // Add area
            areaSum += (long)(x2 - x1) * (y2 - y1);

            // Process corners
            string[] pts = {
                $"{x1},{y1}", $"{x1},{y2}", $"{x2},{y1}", $"{x2},{y2}"
            };

            foreach (var p in pts) {
                if (!corners.Add(p)) corners.Remove(p);
            }
        }

        // Check area
        long boundingArea = (long)(maxX - minX) * (maxY - minY);
        if (areaSum != boundingArea) return false;

        // Check corners
        if (corners.Count != 4) return false;
        if (!corners.Contains($"{minX},{minY}") ||
            !corners.Contains($"{minX},{maxY}") ||
            !corners.Contains($"{maxX},{minY}") ||
            !corners.Contains($"{maxX},{maxY}")) return false;

        return true;
    }
}
```



## Complexity
- **Time:** O(n), each rectangle is processed once for area and corner updates.  
- **Space:** O(n), storing corners in a HashSet to track parity.  

---

## Example Walkthrough
**Input:** `[[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]`

- Bounding rectangle = (1,1) to (4,4).  
- Bounding area = 9.  
- Sum of areas = 9.  
- Remaining corners = {(1,1), (1,4), (4,1), (4,4)}.  
- **Output = true ✅**

---

## Conclusion
The algorithm ensures correctness by combining:
1. **Bounding rectangle area check** → detects gaps or overlaps.  
2. **Corner parity check** → guarantees exact cover with only the four outer corners remaining.  

This yields an **efficient O(n) solution** that scales to 20,000 rectangles.  


---

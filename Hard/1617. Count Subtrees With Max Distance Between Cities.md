# 1617. Count Subgraphs For Each Diameter  

## Problem  
We are given a tree with `n` nodes (1-indexed) and `n-1` edges.  
For every possible diameter `d` (from 1 to n-1), we must count how many connected subgraphs of the tree have diameter exactly `d`.  

---

## Architectural Idea  
The brute force approach is to enumerate all subsets of nodes (`2^n` possibilities).  
For each subset:  
- Check if it forms a connected subgraph.  
- If connected, compute its diameter.  
- Increment the counter for that diameter.  

The challenge:  
- **Connectivity check** must be efficient.  
- **Diameter computation** must be efficient.  

### Key Optimizations  
- Use **adjacency list** instead of Floyd–Warshall matrix.  
- Check connectivity with **DFS/BFS** directly on the subset.  
- Compute diameter with **two BFS passes** (classic trick for trees).  
- Reuse state with bitmask to represent subsets.  

---

## Optimized Implementation (C++)  

```cpp
class Solution {
public:
    vector<int> countSubgraphsForEachDiameter(int n, vector<vector<int>>& edges) {
        // Build adjacency list for the tree
        vector<vector<int>> adj(n);
        for (auto &e : edges) {
            int u = e[0] - 1, v = e[1] - 1;
            adj[u].push_back(v);
            adj[v].push_back(u);
        }

        vector<int> ans(n - 1, 0);

        // Iterate over all subsets of nodes
        for (int mask = 1; mask < (1 << n); mask++) {
            int k = __builtin_popcount(mask);
            if (k <= 1) continue; // diameter requires at least 2 nodes

            // Collect nodes in this subset
            vector<int> nodes;
            for (int i = 0; i < n; i++) 
                if (mask & (1 << i)) nodes.push_back(i);

            // --- Connectivity check ---
            vector<int> seen(n, 0);
            stack<int> st;
            st.push(nodes[0]);
            seen[nodes[0]] = 1;
            int cnt = 1;

            while (!st.empty()) {
                int u = st.top(); st.pop();
                for (int v : adj[u]) {
                    // Only traverse if v is in subset and not visited
                    if ((mask & (1 << v)) && !seen[v]) {
                        seen[v] = 1;
                        cnt++;
                        st.push(v);
                    }
                }
            }

            if (cnt != k) continue; // not connected

            // --- Diameter computation ---
            auto bfs = [&](int start) {
                vector<int> dist(n, -1);
                queue<int> q;
                dist[start] = 0;
                q.push(start);
                int far = start;
                while (!q.empty()) {
                    int u = q.front(); q.pop();
                    for (int v : adj[u]) {
                        if ((mask & (1 << v)) && dist[v] == -1) {
                            dist[v] = dist[u] + 1;
                            q.push(v);
                            if (dist[v] > dist[far]) far = v;
                        }
                    }
                }
                return make_pair(far, dist[far]);
            };

            // First BFS: find farthest node from any node
            auto [far1, _] = bfs(nodes[0]);
            // Second BFS: find diameter from farthest node
            auto [far2, diameter] = bfs(far1);

            ans[diameter - 1]++;
        }

        return ans;
    }
};
```

## Code Commentary 
Adjacency list:

```cpp
vector<vector<int>> adj(n);
```
- Instead of a full n x n matrix with Floyd–Warshall, we store only edges. 
- This saves memory and avoids unnecessary global shortest path computation.

Subset iteration:

```cpp
for (int mask = 1; mask < (1 << n); mask++)
```
Each subset of nodes is represented by a bitmask.

Connectivity check:

```cpp
stack<int> st;
st.push(nodes[0]);
```

if (cnt != k) continue;
```
```
We run DFS inside the subset. If all nodes are visited, the subgraph is connected.

Diameter computation:

```cpp
auto bfs = [&](int start) { ... };
```
Two BFS passes:
- From any node → find farthest node.
- From that farthest node → find maximum distance = diameter.

Result update:

```cpp
ans[diameter - 1]++;
```
Increment the count for the found diameter.

## Complexity Analysis  

| Metric        | Value            | Notes                                      |
|---------------|------------------|--------------------------------------------|
| Time          | O(2^n * n^2)     | Worst-case: each subset requires BFS/DFS up to n nodes |
| Space         | O(n)             | Adjacency list + visited/dist arrays       |
| Constraint    | n ≤ 15           | Exponential search is feasible             |

---

## Insight — Reusable Fichka  

**DFS + BFS for Subset Graph Analysis**

### Pattern  
- Represent subset with bitmask  
- Check connectivity with DFS/BFS  
- Compute diameter with double BFS  

### Applies to  
- Subgraph diameter problems  
- Connectivity checks in small graphs  
- Any brute force subset exploration with balance/diameter conditions  

---

> This design replaces heavy Floyd–Warshall with lightweight BFS,  
> turning brute force into a structured, efficient exploration.

---

# ğŸ§  Problem: Couples Holding Hands
LeetCode #765 Difficulty: Hard Tags: Greedy, HashMap, Simulation, Index Mapping

## ğŸ” Problem Summary

- Youâ€™re given an array row representing people sitting in 2n seats.
- Each person has a unique ID, and couples are defined as consecutive pairs: (0,1), (2,3), (4,5), etc.

- The goal is to minimize the number of swaps needed so that each couple sits side by side. 
- A swap consists of choosing any two people and switching their seats.

## ğŸ§± Architectural Insight

This problem is a classic index-mapping simulation, where the key is to:

- Identify the correct partner for each person.
- Check whether the partner is already sitting next to them.
- If not, swap the misplaced person with the correct partner.
- Update the position map to reflect the swap.

## ğŸ”§ Core Strategy:

- Build a dictionary pos to map each personâ€™s ID to their current seat index.
- Iterate through the array in steps of 2 (since couples sit in pairs).

For each person at index i, compute their expected partner:

- If row[i] is even â†’ partner is row[i] + 1
- If row[i] is odd â†’ partner is row[i] - 1
- If the person at i+1 is not the expected partner:
- Swap them with the actual partner using the position map.
- Update the map to reflect the new positions.
- Increment the swap counter.

This greedy approach ensures that each couple is seated correctly with the minimum number of swaps.

## ğŸ’¡ C# Solution
```csharp
public class Solution {
    public int MinSwapsCouples(int[] row) {
        int count = 0;
        var pos = new Dictionary<int, int>();
        int n = row.Length;

        // Map each person's ID to their current seat index
        for (int i = 0; i < n; i++) {
            pos.Add(row[i], i);
        }

        // Iterate through each couple pair
        for (int i = 0; i < n; i += 2) {
            int pair = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;

            // If the partner is not sitting next to them, swap
            if (row[i + 1] != pair) {
                int temp = row[i + 1];
                row[i + 1] = pair;
                row[pos[pair]] = temp;

                // Update positions in the map
                pos[temp] = pos[pair];
                count++;
            }
        }

        return count;
    }
}
```

## ğŸ“ Why This Works

- Couples are always defined by consecutive IDs, so the partner of x is either x+1 or x-1.
- The position map allows O(1) lookup for any personâ€™s seat.
- Swapping is done in-place, and the map is updated immediately to reflect changes.
- The algorithm runs in O(n) time, which is optimal for this problem.

## ğŸ§­ Reflection
- This problem sharpened my understanding of greedy simulation and index mapping. 
- Instead of brute-force checking all pairs, I used a dictionary to track positions and perform constant-time swaps.

Key insights:

- The partner logic is simple but powerful: x Â± 1 depending on parity.
- Maintaining a live position map is crucial for fast swaps.
- The greedy approach guarantees minimal swaps because each mismatch is resolved immediately.
- I implemented the solution in C#, focusing on clarity and performance:
- Used Dictionary<int, int> for fast index lookup.
- Kept variable naming intuitive (pair, temp, pos) to reflect the logic.
- Avoided unnecessary loops or conditionals â€” every step has a clear purpose.
- This task also reinforced the value of clean state management: updating both the array and the map ensures correctness after each swap.




---

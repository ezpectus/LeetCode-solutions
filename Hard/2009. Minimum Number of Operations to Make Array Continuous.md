# Problem: Minimum Number of Operations to Make Array Continuous
Number: LeetCode 2009
Difficulty: Hard Language: C++

## Problem Overview
You're given an integer array nums. 
In one operation, you can replace any element with any integer. An array is considered continuous if:

- All elements are unique
- max(nums) - min(nums) == nums.size() - 1
- Goal: Return the minimum number of operations required to make nums continuous.

## Constraints
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^9

## Idea
- We want to find the largest subset of nums that already satisfies the continuity condition.Then, the minimum number of operations equals n - size_of_that_subset.

To achieve this:

- We sort and deduplicate nums to ensure uniqueness
- For each nums[i], we define a target range [nums[i], nums[i] + n - 1]
- Using a sliding window, we count how many unique elements fall into this range
- The maximum such count gives the largest valid segment
- The rest must be replaced

This approach avoids brute-force replacement and instead maximizes reuse of existing values.

## Step-by-Step Construction
1. Deduplicate and Sort:
```cpp
sort(nums.begin(), nums.end());
nums.erase(unique(nums.begin(), nums.end()), nums.end());
```
- Sorting ensures we can apply window logic
- Deduplication is required because continuity demands uniqueness

2. Sliding Window:
```cpp
int j = 0;
for (int i = 0; i < nums.size(); ++i) {
    while (j < nums.size() && nums[j] < nums[i] + n)
        ++j;
    max_window = max(max_window, j - i);
}
```
- For each nums[i], we find the largest window [i, j) such that all values fit in [nums[i], nums[i] + n - 1]
- This simulates a continuous segment of size n
- We track the maximum window size

3. Final Result:
```cpp
return n - max_window;
```
The number of operations equals the number of elements outside the best window

## C++ Code
```cpp
class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        nums.erase(unique(nums.begin(), nums.end()), nums.end());

        int max_window = 0;
        int j = 0;
        for (int i = 0; i < nums.size(); ++i) {
            while (j < nums.size() && nums[j] < nums[i] + n)
                ++j;
            max_window = max(max_window, j - i);
        }

        return n - max_window;
    }
};
```
## Complexity Analysis

- Time	O(n log n)
- Space	O(n)
- Sorting and deduplication take O(n log n)
- Sliding window runs in linear time over 2n elements
- Space used for deduplicated array

## Why This Works

- Continuity condition reduces to a fixed-width range check
- Deduplication ensures uniqueness
- Sliding window finds the largest valid segment
- Greedy reuse minimizes replacements
- No need to simulate replacements â€” we compute how many are needed by exclusion

## Related Concepts
- Sorting and deduplication
- Sliding window over sorted array
- Greedy optimization
- Range simulation via window expansion
- Set coverage via interval scanning


---

## 🧠 Pattern: Component-Based Infection Minimization

---

## 📌 Problem Statement

You're given:

- An undirected graph of `n` nodes as an `n x n` adjacency matrix  
- A list `initial[]` of nodes initially infected by malware

Malware spreads as follows:

- If two nodes are connected and at least one is infected → both become infected  
- Spread continues until no new infections occur

You must **remove exactly one node from `initial[]`** to minimize the final number of infected nodes `M(initial)`.

If multiple nodes yield the same minimum infection count, return the one with the **smallest index**.

---

## 🧩 Architectural Idea

This is a **component-based reachability problem**.  
Instead of simulating full infection spread, we analyze **connected components** of the graph.

Key insight:

- If a component has **exactly one infected node**, removing it **prevents infection of the entire component**  
- If a component has **multiple infected nodes**, removing one does **not help** — infection still spreads

So we:

1. For each candidate node in `initial[]`:
   - Temporarily remove it
   - Run BFS to simulate infection starting from that node
   - Track how many nodes would be infected **only if that node were the sole source**
2. Among valid candidates, choose the one that:
   - Saves the **most nodes**
   - Has the **smallest index** in case of tie

---

## 🔧 Implementation

```csharp
public class Solution {
    public int MinMalwareSpread(int[][] graph, int[] initial) {
        var infected = new HashSet<int>(initial);
        var bestScore = int.MinValue;
        var best = int.MinValue;

        foreach (var removalCandidate in initial) {
            var queue = new Queue<int>();
            var visited = new bool[graph.Length];
            var localInfected = new HashSet<int>(infected);
            localInfected.Remove(removalCandidate);

            queue.Enqueue(removalCandidate);
            visited[removalCandidate] = true;

            var score = 1;
            var valid = true;

            while (queue.Count != 0) {
                var neighbors = graph[queue.Dequeue()];
                for (int node = 0; node < graph.Length; ++node) {
                    if (neighbors[node] == 1 && !visited[node]) {
                        visited[node] = true;
                        if (localInfected.Contains(node)) {
                            valid = false;
                        } else {
                            score++;
                            queue.Enqueue(node);
                        }
                    }
                }
            }

            if (valid && (score > bestScore || (score == bestScore && removalCandidate < best))) {
                bestScore = score;
                best = removalCandidate;
            }
        }

        return best == int.MinValue ? initial.Min() : best;
    }
}
```

🧠 **Post-Solution Breakdown**

---

## ✅ Invariants

- `visited[i] == true` ⇔ node `i` is reachable from the candidate node  
- `valid == true` ⇔ candidate is the only infected node in its component  
- `score` counts how many nodes would be saved by removing the candidate  
- Final result is the candidate that saves the most nodes, with smallest index tie-break

---

## ⚠️ Edge Cases

| Case                        | Behavior                                                   |
|-----------------------------|------------------------------------------------------------|
| Component with ≥2 infected  | Removal doesn't help — infection still spreads             |
| Component with 1 infected   | Removal prevents entire component from infection           |
| No valid candidate          | Return `initial.Min()` — smallest index among infected     |

---

## 📌 Constraints

- `2 <= n <= 300`  
- `graph[i][j] ∈ {0, 1}` and symmetric  
- `graph[i][i] == 1`  
- `1 <= initial.length <= n`  
- All values in `initial[]` are unique  
- Infection can revisit nodes and reuse edges

---

## 🧠 Why This Works

This approach avoids full simulation of infection spread.  
Instead, it uses **structural analysis** of the graph:

- BFS marks reachable nodes  
- Infection is only prevented if the candidate is the **sole source**  
- We don’t track infection order — only **reachability and uniqueness**

**Total cost:**

- `O(n²)` worst-case due to adjacency matrix and BFS per candidate  
- Acceptable within constraints (`n ≤ 300`)

---

## 🔁 Pattern Generalization

This technique applies to problems with:

- Infection or influence spread over graphs  
- Structural containment via node removal  
- Component-based scoring and filtering

---

## 🧩 Reusable Structure

- BFS for component traversal  
- `HashSet` for infected tracking  
- Boolean flag for uniqueness check  
- Score-based selection with tie-break

---

## 🧠 Example Problems

- Minimize spread by removing influencers  
- Contain fire/flood in grid via node removal  
- Graph-based containment with limited intervention

---

## 🧠 Alternative Approaches (Comparison Table)

| Method            | Time Complexity | Pros                        | Cons                          |
|-------------------|------------------|-----------------------------|-------------------------------|
| Full simulation   | `O(n²)`          | Accurate                    | Hard to optimize              |
| Union-Find        | `O(n log n)`     | Fast component detection    | Harder to track infected count |
| BFS + filtering   | `O(n²)`          | Clean, transparent          | Requires careful uniqueness logic |

---

## 🧠 Conclusions

This solution is a clean example of **structural containment via component analysis**.  
Instead of simulating infection dynamics, we:

- Traverse each candidate’s component  
- Check if they’re the sole infected node  
- Score how many nodes they can save  
- Return the optimal candidate



---

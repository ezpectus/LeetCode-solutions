# 🧩 Module: Minimum Cost to Construct Target — Grouped DP with Early Pruning

## 🔍 Problem Statement

You're given:
- A string `target`
- An array of strings `words`
- An array of integers `costs`, where `costs[i]` is the cost to append `words[i]`

You can append any `words[i]` any number of times to build `target`.  
Each append costs `costs[i]`.  
Return the **minimum cost** to construct `target`, or `-1` if impossible.

---

## ✅ Constraints

- 1 <= target.length <= 5 * 104
- 1 <= words.length == costs.length <= 5 * 104
- 1 <= words[i].length <= target.length
- The total sum of words[i].length is less than or equal to 5 * 104.
- target and words[i] consist only of lowercase English letters.
- 1 <= costs[i] <= 104


---

## 🧱 C# Implementation — Grouped DP with Early Pruning

```csharp
public class Solution {
    record WordCost(string Word, int Cost);
    record WordGroup(int Length, WordCost[] Words, int MinCost);

    public int MinimumCost(string target, string[] words, int[] costs) {
        WordGroup[] groups = words
            .Select((w, i) => new WordCost(w, costs[i]))
            .GroupBy(w => w.Word.Length)
            .Select(g => new WordGroup(
                g.Key,
                g.OrderBy(w => w.Cost).ToArray(),
                g.Min(w => w.Cost)))
            .OrderBy(g => g.MinCost)
            .ToArray();

        int n = target.Length;
        int[] tCosts = new int[n];

        for (int i = 0; i < n; i++) {
            int cost = int.MaxValue;

            foreach (var group in groups) {
                int j = i - group.Length + 1;
                if (j < 0) continue;

                int previousCost = j == 0 ? 0 : tCosts[j - 1];
                if (previousCost == int.MaxValue) continue;
                if (previousCost + group.MinCost >= cost) continue;

                foreach (var wc in group.Words) {
                    bool match = true;
                    for (int c = 0; c < group.Length; c++) {
                        if (target[j + c] != wc.Word[c]) {
                            match = false;
                            break;
                        }
                    }

                    if (match) {
                        cost = Math.Min(cost, previousCost + wc.Cost);
                        break;
                    }
                }
            }

            tCosts[i] = cost;
        }

        return tCosts[n - 1] == int.MaxValue ? -1 : tCosts[n - 1];
    }
}
```

## 🧠 Architectural landmarks
## 🔧 Main idea
- tCosts[i] — minimum cost of changing target[0..i]
- For each position i, iterate over all word groups by length.
- Check whether it is possible to insert a word ending at i.

## ⚙️ Optimizations
- Group by word length → hinders access to relevant words
- Sort by cost → Allows early exit when a match is found
- MinCost pruning → prunes groups that cannot improve the current cost

## 🧨 Edge processing
- If target[i] == '0' or there are no suitable words → tCosts[i] = int.MaxValue
- The final answer is tCosts[n - 1], or -1 if unreachable


---

# Pattern Name  
Monotonic Bounds with Double Prefix Aggregation

---

## Problem Summary

You are given an integer array `strength`, where `strength[i]` is the strength of the `i`‑th wizard.  
For every contiguous subarray, define its **total strength** as:

```text
min(subarray) × sum(subarray)
```
Return the sum of total strengths across all contiguous subarrays, modulo 10^9+7.


## Core Idea

This is a **min-product aggregation** problem over all contiguous subarrays.  
Each subarray contributes:

```text
min(subarray) × sum(subarray)
```
Brute-force is infeasible due to 𝑂(𝑛^2) subarrays. 
Instead of iterating over all subarrays, we invert the perspective: 
we treat each element strength[i] as the minimum of some subarray and compute its total contribution across all such subarrays.

This inversion enables a clean decomposition using three architectural tools:

## 🔹 Monotonic Stack — Bound Discovery
We use two monotonic stacks to find:

- prevSmaller[i]: nearest index to the left with value ≤ strength[i]
- nextSmaller[i]: nearest index to the right with value < strength[i]
- This gives us the maximal subarray where strength[i] is the minimum.
- Every subarray that includes i and stays within [prevSmaller[i]+1, nextSmaller[i]-1] will have strength[i] as its minimum.

## 🔹 Double Prefix Sum — Efficient Range Aggregation
- Let prefixSum[i] be the sum of the first i elements. 
- Let prefixSum2[i] be the prefix sum of prefixSum.
  
This allows us to compute the sum of sums over any range in constant time:
```sum of sums from index a to b = prefixSum2[b+1] - prefixSum2[a]```

This is needed because each subarray contributes min × sum, and we must aggregate all such sum values where min = strength[i].

## 🔹 Algebraic Decomposition — Weighted Contribution Modeling
- Let i be the current index.
- Let left = prevSmaller[i] + 1, right = nextSmaller[i] - 1
- Let L = i - left + 1, R = right - i + 1 — counts of subarrays to the left and right of i

Then the total contribution of strength[i] is:
```strength[i] × (R × sum[i+1 to right+1] − L × sum[left to i])```
This formula accounts for all subarrays where strength[i] is the minimum, and weights each subarray by its total sum.

## Strategy Summary
- Compute prefix sum prefixSum[i]
- Compute double prefix sum prefixSum2[i]

Use monotonic stack to find:

- prevSmaller[i]: nearest index to the left with value ≤ strength[i]
- nextSmaller[i]: nearest index to the right with value < strength[i]
- For each index i, compute its contribution using the formula above
- Accumulate all contributions modulo 10^9+7

## C# Implementation
```cpp
public class Solution {
    public int TotalStrength(int[] strength) {
        int mod = 1_000_000_007;
        int n = strength.Length;

        long[] prefixSum = new long[n + 1];
        for (int i = 0; i < n; i++)
            prefixSum[i + 1] = (prefixSum[i] + strength[i]) % mod;

        long[] prefixSum2 = new long[n + 2];
        for (int i = 0; i <= n; i++)
            prefixSum2[i + 1] = (prefixSum2[i] + prefixSum[i]) % mod;

        int[] prevSmaller = new int[n];
        int[] nextSmaller = new int[n];
        Array.Fill(prevSmaller, -1);
        Array.Fill(nextSmaller, n);

        Stack<int> stack = new Stack<int>();
        for (int i = 0; i < n; i++) {
            while (stack.Count > 0 && strength[stack.Peek()] > strength[i])
                nextSmaller[stack.Pop()] = i;
            stack.Push(i);
        }

        stack.Clear();
        for (int i = n - 1; i >= 0; i--) {
            while (stack.Count > 0 && strength[stack.Peek()] >= strength[i])
                prevSmaller[stack.Pop()] = i;
            stack.Push(i);
        }

        long total = 0;
        for (int i = 0; i < n; i++) {
            int left = prevSmaller[i] + 1;
            int right = nextSmaller[i] - 1;

            long leftSum = (prefixSum2[i + 1] - prefixSum2[left] + mod) % mod;
            long rightSum = (prefixSum2[right + 2] - prefixSum2[i + 1] + mod) % mod;

            int L = i - left + 1;
            int R = right - i + 1;

            long contrib = strength[i] * ((rightSum * L % mod - leftSum * R % mod + mod) % mod) % mod;
            total = (total + contrib) % mod;
        }

        return (int)total;
    }
}
```

## Time and Space Complexity

| Metric           | Value | Explanation                                      |
|------------------|--------|--------------------------------------------------|
| Time Complexity  | O(n)  | Prefix sums + monotonic stack + linear scan     |
| Space Complexity | O(n)  | Prefix arrays + stack + bound arrays            |

---

## Generalization to Other Problems

This pattern applies to problems where:

- You need to **aggregate over all subarrays**  
- Each element contributes as a **bounded minimum or maximum**  
- You can use **monotonic stacks** to find valid ranges  
- You need **prefix sums** to compute weighted contributions

---

## Examples of Similar Problems

| Problem Type                | Description                                         |
|----------------------------|-----------------------------------------------------|
| Sum of Subarray Minimums   | Aggregate `min × count` over all subarrays          |
| Maximum of Minimums        | Track max of all subarray minimums                  |
| Range Contribution Modeling| Compute element-wise impact over bounded intervals  |

---

## Final Takeaway

This solution uses:

- **Monotonic bounds** to isolate valid subarray ranges  
- **Double prefix sums** to compute weighted sums efficiently  
- **Algebraic decomposition** to model contributions  
- **Modular arithmetic** to maintain correctness

The result is a clean and efficient solution that avoids brute-force and leverages structural symmetry.  
This pattern is reusable for any task involving **element-wise contribution modeling over subarray ranges**.


---








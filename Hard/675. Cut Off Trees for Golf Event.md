# Sequential Target Navigation with BFS Distance Resolution — Architectural Pattern  
*O(mn × t) — Multi-Target Shortest Path in Dynamic Grid*

---

## Problem Overview

Given a forest grid where:
- `0` — blocked
- `1` — walkable
- `>1` — tree with height

Start at `(0,0)` and cut trees **in strictly increasing height order**.

- Movement: 4 directions
- After cutting a tree → cell becomes walkable (`1`)
- If any tree unreachable → return `-1`

Return **total steps** to cut all trees.

---

## Core Idea — Sorted Targets + Repeated BFS

**This is a multi-target shortest path problem** with **dynamic environment**.

**Solution**:
1. Collect all trees → sort by **height**
2. Start from `(0,0)`
3. For each consecutive tree:
   - Run **BFS** to find shortest path
   - Add distance
   - Update current position
   - Mark tree cell as walkable
4. If any BFS fails → `-1`

**No DP, no A*** — plain BFS between sequential targets.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int CutOffTree(IList<IList<int>> forest)  {
        int m = forest.Count;
        int n = forest[0].Count;

        var trees = new List<(int h, int r, int c)>();

        // Collect all trees
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int v = forest[i][j];
                if (v > 1) trees.Add((v, i, j));
            }
        }

        // Sort by height ascending
        trees.Sort((a, b) => a.h.CompareTo(b.h));

        int totalSteps = 0;
        int sr = 0, sc = 0; // current position

        foreach (var (h, tr, tc) in trees)  {
            int dist = Bfs(forest, sr, sc, tr, tc);
            if (dist == -1) return -1;

            totalSteps += dist;
            sr = tr;
            sc = tc;

            // Mark tree as walkable after cutting
            forest[sr][sc] = 1;
        }

        return totalSteps;
    }

    private int Bfs(IList<IList<int>> forest, int sr, int sc, int tr, int tc)  {
        if (sr == tr && sc == tc) return 0;

        int m = forest.Count;
        int n = forest[0].Count;

        var q = new Queue<(int r, int c)>();
        var seen = new bool[m, n];

        q.Enqueue((sr, sc));
        seen[sr, sc] = true;

        int steps = 0;
        int[][] dirs = { new[] {1,0}, new[] {-1,0}, new[] {0,1}, new[] {0,-1} };

        while (q.Count > 0) {
            int size = q.Count;
            steps++;

            for (int i = 0; i < size; i++) {
                var (r, c) = q.Dequeue();

                foreach (var d in dirs) {
                    int nr = r + d[0];
                    int nc = c + d[1];

                    if (nr < 0 || nr >= m || nc < 0 || nc >= n) continue;
                    if (forest[nr][nc] == 0 || seen[nr][nc]) continue;

                    if (nr == tr && nc == tc) return steps;

                    seen[nr][nc] = true;
                    q.Enqueue((nr, nc));
                }
            }
        }

        return -1; // unreachable
    }
}
```

## Time and Space Complexity

| **Metric**            | **Value**             | **Explanation**                                      |
|-----------------------|-----------------------|------------------------------------------------------|
| **Time Complexity**   | **O(mn × t)**         | t = number of trees; each BFS visits up to mn cells  |
| **Space Complexity**  | **O(mn)**             | Visited array + queue per BFS                        |

**Optimal** — each cell visited at most once per BFS, total proportional to grid × trees.

---

## Implementation Commentary

- **Tree collection & sorting**:
  Extract all `(height, row, col)` tuples → sort by height ascending → guarantees correct cutting order

- **Sequential BFS**:
  From current position → next tree in sorted list → compute shortest path  
  Accumulate total steps

- **Dynamic environment**:
  After reaching a tree → `forest[r][c] = 1` → opens the cell for future paths  
  Simulates cutting the tree

- **Unreachable detection**:
  BFS returns `-1` → immediate return `-1` — no way to reach remaining trees

- **Level-order BFS**:
  Uses queue size for exact step counting → returns precise Manhattan distance in unweighted grid

---

## Final Takeaway

This pattern solves **sequential multi-target navigation** in a **dynamic grid** using:

- **Target sorting** by priority (tree height)
- **Repeated BFS** between consecutive targets
- **Environment update** after each success
- **Early failure** on unreachable target

Reusable for any scenario with:
- Ordered objectives in a grid
- Robot path planning with sequential goals
- Game levels requiring specific collection order
- Resource gathering with height/priority constraints
- Any grid with **changing accessibility** after actions
**Clean, correct, optimal** — a true architectural classic.

---

# ğŸ§  1719. Number of Ways to Reconstruct a Tree

## ğŸ“œ Problem Restatement
We are given `pairs` of nodes `[xi, yi]` with `xi < yi`.  
A valid rooted tree must satisfy:
- The tree consists of nodes appearing in `pairs`.
- A pair `[xi, yi]` exists **iff** one is ancestor of the other.
- Return:
  - `0` if no valid tree exists
  - `1` if exactly one valid tree exists
  - `2` if multiple valid trees exist

---

## ğŸ§± Core Idea
This is a **graph + ancestor consistency** problem.

### Step 1: Build adjacency
- Each node must connect to all nodes it appears with in pairs.
- Construct adjacency sets.

### Step 2: Find root candidate
- The root must be the node with maximum degree (connected to all others).
- If no such node exists â†’ return `0`.

### Step 3: Assign parents
- For each node, find a parent candidate:
  - Parent must have degree â‰¥ nodeâ€™s degree.
  - Parent must be connected to node.
  - Choose the smallest such parent.
- If no valid parent exists â†’ return `0`.

### Step 4: Validate ancestor condition
- For each pair `(u, v)`, check adjacency consistency:
  - `adj[u] âŠ† adj[parent[u]]` must hold.
- If violated â†’ return `0`.

### Step 5: Count ways
- If multiple parent choices possible â†’ return `2`.
- Otherwise â†’ return `1`.

---

## ğŸš€ Implementation (C#)

```csharp
public class Solution {
    public int CheckWays(int[][] pairs) {
        var adj = new Dictionary<int, HashSet<int>>();
        foreach (var p in pairs) {
            int u = p[0], v = p[1];
            if (!adj.ContainsKey(u)) adj[u] = new HashSet<int>();
            if (!adj.ContainsKey(v)) adj[v] = new HashSet<int>();
            adj[u].Add(v);
            adj[v].Add(u);
        }

        int n = adj.Count;
        // Step 2: find root candidate
        int root = -1;
        foreach (var kv in adj) {
            if (kv.Value.Count == n - 1) {
                root = kv.Key;
                break;
            }
        }
        if (root == -1) return 0;

        int res = 1;
        foreach (var kv in adj) {
            int u = kv.Key;
            if (u == root) continue;

            int parent = -1;
            int parentDegree = int.MaxValue;
            foreach (var v in adj[u]) {
                if (adj[v].Count >= adj[u].Count) {
                    if (adj[v].Count < parentDegree) {
                        parentDegree = adj[v].Count;
                        parent = v;
                    }
                }
            }
            if (parent == -1) return 0;

            // Check adjacency consistency
            foreach (var nei in adj[u]) {
                if (nei == parent) continue;
                if (!adj[parent].Contains(nei)) return 0;
            }

            if (adj[parent].Count == adj[u].Count) res = 2;
        }

        return res;
    }
}
```

## â±ï¸ Complexity
- **Time:** O(nÂ²) worst case (adjacency checks)  
- **Space:** O(nÂ²) for adjacency sets  

---

## âš ï¸ Pitfalls
- Must ensure **root exists** (degree = n-1)  
- Parent selection must minimize degree but still be â‰¥ childâ€™s degree  
- Multiple parent candidates â†’ result = 2  
- Adjacency subset check is critical for validity  

---

## âœ… Sanity Checks
- Input: `[[1,2],[2,3]]` â†’ Output: **1**  
- Input: `[[1,2],[2,3],[1,3]]` â†’ Output: **2**  
- Input: `[[1,2],[2,3],[2,4],[1,5]]` â†’ Output: **0**  

---

ğŸ‘‰ **Key takeaway:**  
This problem is solved by **graph adjacency + parent assignment consistency**.  
The algorithm ensures root existence, validates ancestor conditions, and detects multiple valid reconstructions.




---

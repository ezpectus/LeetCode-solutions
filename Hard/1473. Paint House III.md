# 1473. Paint House III  
*O(m × target × n²) — Clean & Optimal 3D DP with Memoization*

---

## Problem Statement

There is a row of `m` houses, each to be painted with one of `n` colors (1 to n).

- Some houses are already painted last year (`houses[i] > 0` = fixed color)
- Others are unpainted (`houses[i] = 0`)
- `cost[i][j]` = cost to paint house `i` with color `j+1`

A **neighborhood** is a maximal contiguous group of houses with the same color.

You need to paint all unpainted houses such that there are **exactly `target` neighborhoods**.

Return the **minimum cost** or **-1** if impossible.

---

## Core Idea — 3D DP: house × neighborhoods × last color

**State**:
- `dp[i][t][c]` = minimum cost to paint first `i` houses,  
  achieving **exactly `t` neighborhoods**,  
  with the `i-1`-th house painted in color `c` (c = 0..n, 0 means no previous color)

**Transition**:
- If house `i` is already painted (`houses[i] > 0`):
  - Color fixed: `c = houses[i]`
  - Cost = 0
  - If `c != last_clr` → new neighborhood → `t + 1`
  - Else → same neighborhood → `t` unchanged
- If house `i` is unpainted (`houses[i] == 0`):
  - Try every color `clr = 1 to n`
  - Add cost = `cost[i][clr-1]`
  - If `clr != last_clr` → `t + 1`, else `t` unchanged

**Base**:
- When `i == m`: if `t == target` → cost 0, else impossible (big number)

**Answer**:
- `min over all c: dp[m][target][c]`, or -1 if impossible

---

## Clean Implementation (C++)

```cpp
class Solution {
public:
    int dp[101][101][21];  // i, target, last_color (0 = none)

    int dfs(vector<int>& houses, vector<vector<int>>& cost, int i, int target, int last_clr) {
        if (i >= houses.size() || target < 0) 
            return target == 0 ? 0 : 1000001;

        if (dp[i][target][last_clr] != 0) 
            return dp[i][target][last_clr];

        int res = 1000001;

        if (houses[i] != 0) {
            // House already painted — fixed color
            int color = houses[i];
            int new_target = target - (last_clr != color);
            if (new_target >= 0) {
                res = dfs(houses, cost, i + 1, new_target, color);
            }
        } else {
            // Try every possible color
            for (int clr = 1; clr <= cost[i].size(); ++clr) {
                int new_target = target - (last_clr != clr);
                if (new_target >= 0) {
                    int sub = dfs(houses, cost, i + 1, new_target, clr);
                    res = min(res, cost[i][clr - 1] + sub);
                }
            }
        }

        return dp[i][target][last_clr] = res;
    }

    int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n, int target) {
        memset(dp, 0, sizeof(dp));  // 0 means not computed
        int res = dfs(houses, cost, 0, target, 0);
        return res > 1000000 ? -1 : res;
    }
};
```


## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(m × target × n²)**        | m houses × target neighborhoods × n colors per state (worst case) ≈ 100 × 100 × 20 × 20 = 4 million operations |
| **Space Complexity**  | **O(m × target × n)**         | Memoization table: 101 × 101 × 21 ≈ 210k integers |

**Optimal** — perfectly fits constraints (m ≤ 100, n ≤ 20, target ≤ m), runs in milliseconds.

---

## Why This Works — Example Walkthrough

**Example 1**: `houses = [0,0,0,0,0]`, `cost = [[1,10],[10,1],[10,1],[1,10],[5,1]]`, `target = 3`

- DP explores all possible color assignments
- One optimal coloring: [1,2,2,1,1]
- Neighborhoods formed: {1}, {2,2}, {1,1} → exactly **3**
- Cost: 1 + 1 + 1 + 1 + 5 = **9** → correct

**Correct** — DP assigns colors sequentially (house by house), adds painting cost only when needed, increments neighborhood count only when color changes, and finds the minimum cost to achieve **exactly** `target` neighborhoods.

---

## Pitfalls & Edge Cases

- **House already painted** → color fixed, cost = 0, neighborhood count +1 only if color differs from previous
- **target = 1** → all houses same color (minimum neighborhoods, if possible)
- **target = m** → each house different color (maximum neighborhoods)
- **m = 100, n = 20** → 100 × 100 × 20 × 20 ≈ 4M operations → very fast
- **Impossible** → DP returns large number (e.g. 1e9) → output -1

All handled perfectly.

---

## Key Takeaway

This is a **classic DP on house painting with neighborhood constraint**:

- State: `dp[i][t][c]` — min cost to paint first `i` houses, achieve exactly `t` neighborhoods, last house color `c`
- If house already painted → use fixed color, cost = 0, neighborhood +1 only on color change
- If unpainted → try every color, add cost, neighborhood +1 only on change
- Answer = min over all c: `dp[m][target][c]`, or -1 if impossible

**Pure, clean, optimal** — O(m × target × n²) time with small constants, elegant and powerful.

---

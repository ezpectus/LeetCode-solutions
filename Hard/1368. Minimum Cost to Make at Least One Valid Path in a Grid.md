# 1368. Minimum Cost to Make at Least One Valid Path in a Grid — Architectural 0-1 BFS (Deque Dijkstra)  
*O(mn) — Optimal Shortest Path with Cost 0/1*

---

## Problem Statement

Given `m×n` grid with arrows (1-4: right/left/down/up).

Start at `(0,0)`, goal `(m-1,n-1)`.

- Follow arrow → **cost 0**
- Change arrow → **cost 1** (once per cell)

Return **minimum cost** to have **at least one valid path**.

---

## Core Idea — 0-1 BFS Treating Arrow Changes as Cost 1

**Model as graph**:
- Nodes = cells `(r,c)`
- Edge from `(r,c)` to neighbor:
  - If matches current arrow → **cost 0**
  - Else → **cost 1** (change arrow)

**Shortest path** from `(0,0)` to `(m-1,n-1)` = min cost.

**Since costs 0 or 1** → use **0-1 BFS** (deque):
- Cost 0 → push **front**
- Cost 1 → push **back**

**Like Dijkstra**, but O(mn).

---

##  Implementation (C#)

```csharp
public class Solution {
    public int MinCost(int[][] grid) {
        int m = grid.Length;
        int n = grid[0].Length;

        int[][] dirs = new int[][] 
        {
            new int[] {0, 1},   // 1: right
            new int[] {0, -1},  // 2: left
            new int[] {1, 0},   // 3: down
            new int[] {-1, 0}   // 4: up
        };

        var deq = new Deque<(int r, int c)>();
        var dist = new int[m, n];
        for (int i = 0; i < m; i++) 
            for (int j = 0; j < n; j++) 
                dist[i, j] = int.MaxValue;

        dist[0, 0] = 0;
        deq.PushFront((0, 0));

        while (deq.Count > 0){
            var (r, c) = deq.PopFront();
            int d = dist[r, c];

            // Try all 4 directions
            for (int dir = 0; dir < 4; dir++) {
                int nr = r + dirs[dir][0];
                int nc = c + dirs[dir][1];

                if (nr >= 0 && nr < m && nc >= 0 && nc < n) {
                    int cost = (grid[r][c] == dir + 1) ? 0 : 1;
                    int newDist = d + cost;

                    if (newDist < dist[nr, nc]) {
                        dist[nr, nc] = newDist;
                        if (cost == 0) deq.PushFront((nr, nc));
                        else deq.PushBack((nr, nc));
                    }
                }
            }
        }

        return dist[m - 1, n - 1];
    }
}


public class Deque<T> {
    private LinkedList<T> list = new LinkedList<T>();

    public int Count => list.Count;

    public void PushFront(T item) => list.AddFirst(item);
    public void PushBack(T item) => list.AddLast(item);
    public T PopFront() 
    {
        var item = list.First.Value;
        list.RemoveFirst();
        return item;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(mn)**     | Each cell enqueued at most once                |
| **Space Complexity**  | **O(mn)**     | Deque + distance array                         |

**Optimal** — best possible for 0-1 cost graph.

---

## Why This Works — Example Walkthrough

**Input**: `[[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]`

- Start at `(0,0)` → arrow **right** → free move to `(0,1)`
- To go **down** → need to change arrow → cost 1
- 0-1 BFS explores:
  - **Cost 0** moves first (push front) → follow correct arrows
  - **Cost 1** moves later (push back) → change arrow
- Finds path requiring **3 arrow changes** → total cost **3**

**Correct** — minimal cost to reach bottom-right.

---

## Key Takeaway

This is a **masterpiece of 0-1 BFS**:

- **Model arrow change as cost 1**
- **Free move = cost 0** → push front
- **Deque** → efficient Dijkstra for 0-1 costs
- **No priority queue** → faster and simpler
**Pure, clean, optimal** — perfect for grids with binary costs.

---

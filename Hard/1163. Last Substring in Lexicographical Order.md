# 1163. Last Substring in Lexicographical Order

---

## Problem Summary
We are given a string `s`.  
- Task: return the **last substring in lexicographical order**.  
- Lexicographical order means dictionary order (`"z"` > `"y"`, `"ba"` > `"az"`, etc.).  
- Constraints: `1 <= s.length <= 4 * 10^5`, only lowercase English letters.

---

## Code Idea
Naively generating all substrings is impossible (`O(n^2)` substrings).  
We need an efficient approach:

1. **Observation**  
   - The lexicographically largest substring must start with the **largest character** in `s`.  
   - Example: `"abab"` → largest char = `'b'`. Candidates start at indices 1 and 3.  

2. **Compare suffixes**  
   - Among all suffixes starting with the largest character, find the lexicographically maximum one.  
   - This reduces to comparing suffixes efficiently.  

3. **Two-pointer technique**  
   - Maintain two pointers `i` and `j` representing candidate suffixes.  
   - Compare characters step by step until they differ.  
   - Discard the smaller suffix, keep the larger one.  
   - Continue until the best suffix is found.  

4. **Return substring**  
   - Return the suffix starting at the best index.

---

## Code (C#)
```csharp
public class Solution {
    public string LastSubstring(string s) {
        int n = s.Length;
        int i = 0, j = 1, k = 0;

        while (j + k < n) {
            if (s[i + k] == s[j + k]) {
                k++;
            } else if (s[i + k] > s[j + k]) {
                j = j + k + 1;
                k = 0;
            } else {
                i = Math.Max(i + k + 1, j);
                j = i + 1;
                k = 0;
            }
        }

        return s.Substring(i);
    }
}
```


## Complexity
- **Time:** O(n), each character compared at most twice.  
- **Space:** O(1), only pointers used.  

---

## Pitfalls
- Must avoid generating all substrings (too large).  
- Careful with pointer updates to avoid infinite loops.  
- Works because suffix comparison can be done in linear time.  
- Edge case: single-character string → return itself.  

---

## Example Walkthrough
**Input:** `s = "abab"`  
- Largest char = `'b'`.  
- Candidates: suffixes `"bab"` and `"b"`.  
- Compare → `"bab"` > `"b"`.  
- **Output:** `"bab"`.  

**Input:** `s = "leetcode"`  
- Largest char = `'t'`.  
- Candidate suffix = `"tcode"`.  
- **Output:** `"tcode"`.  

---

## Conclusion
This problem reduces to finding the **lexicographically maximum suffix**.  
- Efficient O(n) solution using two-pointer comparison.  
- Avoids brute-force substring generation.  
- Handles large input sizes up to 4×10^5.  



---

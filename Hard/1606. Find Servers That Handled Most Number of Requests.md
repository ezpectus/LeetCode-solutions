# 1606. Find Servers That Handled Most Number of Requests  
*O(m log k) — Min-Heap + Ordered Set (std::set) for Free Servers*

---

## Problem Statement

You have `k` servers (numbered 0 to k-1).  
You are given two arrays:
- `arrival` — strictly increasing arrival times of `m` requests
- `load` — processing time for each request

Rules:
- Each server can handle **only one request at a time**
- For the i-th request (0-based):
  - First try server `i % k`
  - If busy → try next server `(i % k + 1) % k`, `(i % k + 2) % k`, ...
  - If no server available → request is **dropped**
- Goal: find server(s) that handled the **maximum number** of requests successfully

Return a list of server indices (in any order) that are the busiest.

**Constraints**:
- 1 ≤ k ≤ 10⁵
- 1 ≤ m ≤ 10⁵
- arrival strictly increasing, 1 ≤ arrival[i], load[i] ≤ 10⁹

---

## Core Idea — Min-Heap for Busy Servers + Ordered Set for Free Servers

**Data structures**:
- `priority_queue` (min-heap): stores busy servers → `{finish_time, server_id}`
- `set<int>`: stores **currently free** server indices (ordered by id)

**Algorithm**:
1. Initialize all servers as free (`set` contains 0 to k-1)
2. For each request i:
   - Pop all servers from heap whose finish time ≤ arrival[i] → add them back to free set
   - Compute starting server: `target = i % k`
   - Find the smallest free server **≥ target** (using `lower_bound`)
     - If found → assign it
     - Else if any free server exists → take the smallest one (wrap-around)
     - Else → drop the request
   - If assigned:
     - Remove from free set
     - Push to busy heap with finish_time = arrival[i] + load[i]
     - Increment count for that server
3. After processing all requests:
   - Find max count value
   - Collect all servers with that count

**Why this works**:
- `set.lower_bound(target)` gives us the next best server in O(log k)
- Wrap-around handled by taking `begin()` if needed
- Min-heap ensures we efficiently free up servers when their jobs finish

---

## Clean C++ Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {
        int n = arrival.size();
        
        // min-heap: {finish_time, server_id}
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> busy;
        
        // ordered set of currently free servers
        set<int> free_servers;
        for (int i = 0; i < k; ++i) {
            free_servers.insert(i);
        }
        
        // count how many requests each server handled
        vector<int> count(k, 0);
        
        for (int i = 0; i < n; ++i) {
            int t = arrival[i];
            
            // 1. Release all servers that finished by time t
            while (!busy.empty() && busy.top().first <= t) {
                int srv = busy.top().second;
                busy.pop();
                free_servers.insert(srv);
            }
            
            // 2. Find the smallest server id >= (i % k)
            int target = i % k;
            
            auto it = free_servers.lower_bound(target);
            int server = -1;
            
            if (it != free_servers.end()) {
                server = *it;
            } else if (!free_servers.empty()) {
                // wrap around — take the smallest available
                server = *free_servers.begin();
            }
            
            if (server != -1) {
                // assign this request
                free_servers.erase(server);
                int finish_time = t + load[i];
                busy.emplace(finish_time, server);
                count[server]++;
            }
            // else: request is dropped
        }
        
        // find maximum number of requests handled
        int max_count = 0;
        for (int c : count) {
            max_count = max(max_count, c);
        }
        
        // collect all servers that have max_count
        vector<int> busiest;
        for (int i = 0; i < k; ++i) {
            if (count[i] == max_count) {
                busiest.push_back(i);
            }
        }
        
        return busiest;
    }
};
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(m log k)**| For each of m requests:<br>• Pop finished servers: amortized O(log k)<br>• lower_bound / erase / insert on set: O(log k)<br>• push to heap: O(log k)<br>Total per request O(log k) → overall O(m log k) |
| **Space Complexity**  | **O(k)**      | Min-heap stores up to k busy servers<br>Ordered set (std::set) stores up to k free servers |

**Optimal** — logarithmic factor per request — very efficient even when both k and m reach 10⁵.

---

## Why This Code Works — Key Points

* **`priority_queue`** (min-heap) keeps track of **busy servers** sorted by finish time  
  → allows efficient release of servers that finish before or at current arrival time

* **`set<int>`** maintains currently **free servers** in sorted order  
  → enables fast `lower_bound(target)` to find the smallest server id ≥ `i % k`

* **Wrap-around** handled elegantly:  
  if no server ≥ target exists, take `*free_servers.begin()` (the smallest available id)

* Requests are processed in order of **arrival** (guaranteed by strictly increasing arrival times)

* Final step scans the count array once to find the **maximum** value and collects **all** servers that achieved it

**Correct & Efficient** — passes all test cases, handles edge cases gracefully (k=1, m=1, all requests dropped, multiple busiest servers, ties, etc.).

---

## Key Takeaway

This is a **classic server scheduling + next available server** problem solved with two powerful data structures:

* Use **min-heap** (`priority_queue`) for busy servers (sorted by finish time)
* Use **ordered set** (`std::set`) for free servers (fast `lower_bound` + insert/erase)
* For each request:
  1. Release all servers finished by current arrival time → move to free set
  2. Find best free server starting from `i % k` (with wrap-around support)
  3. If found → assign request, update heap & increment count
  4. If none → drop request
* After processing all requests, return **all** servers with the **maximum** request count

**Pure, clean, optimal** — O(m log k) time, O(k) space — elegant, powerful, and production-grade.

---

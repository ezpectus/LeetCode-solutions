# LeetCode 479 — Largest Palindrome Product  
**Approach: Construct palindromes and check divisibility by n-digit numbers**

---

##  Problem Restatement
We need the largest palindrome that can be expressed as the product of two `n`-digit integers.  
Return the palindrome modulo `1337`.

---

##  Core Idea
- Brute force over all pairs of n-digit numbers is too expensive (`10^(2n)` possibilities).  
- Instead, **construct palindromes** directly:
  - Generate palindromes by mirroring a half.  
  - Check if the palindrome can be factored into two n-digit numbers.  
- Start from the largest possible palindrome and go down until a valid factorization is found.  
- Return the palindrome modulo `1337`.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int LargestPalindrome(int n) {
        if (n == 1) return 9; // special case

        long upper = (long)Math.Pow(10, n) - 1;
        long lower = (long)Math.Pow(10, n - 1);

        for (long left = upper; left >= lower; left--) {
            // Construct palindrome by mirroring left part
            string s = left.ToString();
            string rev = new string(s.Reverse().ToArray());
            long palindrome = long.Parse(s + rev);

            // Check if palindrome can be factored into two n-digit numbers
            for (long a = upper; a * a >= palindrome; a--) {
                if (palindrome % a == 0) {
                    long b = palindrome / a;
                    if (b >= lower && b <= upper) {
                        return (int)(palindrome % 1337);
                    }
                }
            }
        }
        return -1; // should never reach here
    }
}
```




##  Time Complexity
- **Outer loop:**  
  Iterate over possible left halves of n-digit numbers → `O(10^n)`.  
- **Inner loop:**  
  For each palindrome, check divisors down to `sqrt(palindrome)` → `O(√(10^(2n))) ≈ O(10^n)`.  
- **Overall:**  
  → `O(10^n)` in practice, feasible since `n ≤ 8`.

---

##  Space Complexity
- **Extra structures:**  
  Only temporary variables and string manipulation for palindrome construction.  
- **Overall:**  
  → `O(1)` constant space.

---

#  Impact of Design Choices

| Design Choice                  | Effect                                                                 |
|--------------------------------|------------------------------------------------------------------------|
| **Palindrome construction**    | Avoids brute force over all products, reduces search space drastically.|
| **Divisor check**              | Ensures palindrome is product of two n-digit numbers.                  |
| **Modulo at the end**          | Keeps result within required bounds.                                   |

---

#  Pitfalls
- **Special case `n = 1`:** Must return `9` directly.  
- **Factor validation:** Both factors must be within n-digit bounds.  
- **Integer overflow:** Use `long` for palindrome construction to avoid overflow.  

---

#  Conclusion
- **What it gives:** Largest palindrome product of two n-digit numbers modulo `1337`.  
- **Why it matters:** Efficiently finds palindrome without brute force over all pairs.  
- **Key takeaway:**  
  1. Construct palindromes by mirroring.  
  2. Validate factorization with n-digit bounds.  
  3. Return modulo `1337`.  



---

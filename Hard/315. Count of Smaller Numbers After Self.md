#  315. Count of Smaller Numbers After Self

---

##  Problem Summary
Given an integer array `nums`, return an array `counts` where `counts[i]` is the number of smaller elements to the right of `nums[i]`.

---

##  Core Ideas
There are multiple valid approaches:

1. **Fenwick Tree (BIT) + Coordinate Compression**  
   - Process elements from right to left.  
   - Query how many smaller values have been seen.  
   - Update BIT with the current element.  
   - Requires compression because values can be negative.  

2. **Merge Sort Counting**  
   - Modified merge sort tracks how many elements from the right half move before left half elements.  
   - Each time an element from the right is placed before one from the left, increment count.  
   - Complexity also O(n log n), but avoids explicit BIT.  

3. **Balanced BST / Order Statistic Tree**  
   - Insert elements one by one from right to left.  
   - Query rank of each element.  
   - Complexity O(n log n), but heavier to implement in C++.  

---

## üíª C++ Implementation (Fenwick Tree)
```cpp
class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        int n = nums.size();
        vector<int> result(n);

        // Coordinate compression
        vector<int> sorted(nums.begin(), nums.end());
        sort(sorted.begin(), sorted.end());
        sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());

        auto getIndex = [&](int x) {
            return (int)(lower_bound(sorted.begin(), sorted.end(), x) - sorted.begin()) + 1;
        };

        // Fenwick Tree
        vector<int> BIT(sorted.size() + 2, 0);

        auto update = [&](int idx) {
            for (; idx < BIT.size(); idx += idx & -idx) BIT[idx]++;
        };

        auto query = [&](int idx) {
            int sum = 0;
            for (; idx > 0; idx -= idx & -idx) sum += BIT[idx];
            return sum;
        };

        // Process from right to left
        for (int i = n - 1; i >= 0; i--) {
            int idx = getIndex(nums[i]);
            result[i] = query(idx - 1); // count of smaller elements
            update(idx);
        }

        return result;
    }
};

```


## ‚è±Ô∏è Complexity
- **Time:** O(n log n)  
  - Sorting for compression + Fenwick Tree operations.  
  - Merge sort variant also O(n log n).  
- **Space:** O(n)  
  - BIT + compression arrays, or temporary arrays in merge sort.  

---

## ‚ö†Ô∏è Pitfalls
- Must compress values because they can be negative.  
- Process strictly from right to left in BIT solution.  
- Ensure BIT size is large enough (`+2` buffer).  
- Edge cases:  
  - Single element ‚Üí `[0]`.  
  - Duplicates handled correctly.  
- Merge sort variant requires careful bookkeeping of indices and counts.  

---

## üìä Example Walkthrough
**Input:** `nums = [5,2,6,1]`  

- Compression: `[1,2,5,6]`.  
- Traverse right to left:  
  - `1` ‚Üí smaller count = 0.  
  - `6` ‚Üí smaller count = 1 (`1`).  
  - `2` ‚Üí smaller count = 1 (`1`).  
  - `5` ‚Üí smaller count = 2 (`2,1`).  

**Result:** `[2,1,1,0]`  

---

## üîÑ Alternative Approach (Merge Sort)

### Idea
- Perform a modified merge sort.  
- While merging two halves:
  - If an element from the right half is placed before one from the left, increment the count for that left element.  
- This counts how many smaller elements are to the right.  

### –°++ Merge Sort
```cpp

class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        int n = nums.size();
        vector<int> counts(n, 0);
        vector<int> indices(n);
        iota(indices.begin(), indices.end(), 0); // track original positions

        mergeSort(nums, indices, counts, 0, n - 1);
        return counts;
    }

private:
    void mergeSort(vector<int>& nums, vector<int>& indices, vector<int>& counts, int left, int right) {
        if (left >= right) return;
        int mid = left + (right - left) / 2;
        mergeSort(nums, indices, counts, left, mid);
        mergeSort(nums, indices, counts, mid + 1, right);
        merge(nums, indices, counts, left, mid, right);
    }

    void merge(vector<int>& nums, vector<int>& indices, vector<int>& counts, int left, int mid, int right) {
        vector<int> temp;
        int i = left, j = mid + 1;
        int rightCount = 0;

        while (i <= mid && j <= right) {
            if (nums[indices[j]] < nums[indices[i]]) {
                temp.push_back(indices[j]);
                rightCount++;
                j++;
            } else {
                counts[indices[i]] += rightCount;
                temp.push_back(indices[i]);
                i++;
            }
        }

        while (i <= mid) {
            counts[indices[i]] += rightCount;
            temp.push_back(indices[i]);
            i++;
        }
        while (j <= right) {
            temp.push_back(indices[j]);
            j++;
        }

        for (int t = 0; t < temp.size(); t++) {
            indices[left + t] = temp[t];
        }
    }
};


```

### Notes
- `indices` array tracks original positions.  
- `counts[i]` accumulates the number of smaller elements to the right.  
- Merge sort ensures O(n log n) complexity.  

---

##  Conclusion
- **Fenwick Tree + compression**: straightforward, efficient, and easy to implement once BIT is understood.  
- **Merge sort counting**: avoids BIT, but requires careful index tracking.  
- Both achieve **O(n log n)** and scale to `n = 1e5`.  
- Choice depends on comfort: BIT for data structure lovers, merge sort for algorithm purists.  


---



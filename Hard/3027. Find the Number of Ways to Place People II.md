# 🧩 Problem Module: 3027 — Count Valid Rectangle Placements

## 📋 Problem Statement

Given n distinct points on a 2D plane:

```csharp
int[][] points = new int[n][];
Each point marks a potential person placement. The task is to count the number of valid (Alice, Bob) pairs such that:
```

- Alice is placed at the upper-left corner of a rectangle.
- Bob is placed at the lower-right corner.
- No other point lies inside or on the boundary of the rectangle.
- Degenerate rectangles (lines or points) are allowed. Validity is defined by:
- Alice.x ≤ Bob.x
- Alice.y ≥ Bob.y


## 🔒 Constraint Analysis

| Constraint            | Implication                                                   |
|----------------------|---------------------------------------------------------------|
| `2 ≤ n ≤ 1000`       | Quadratic time (`O(n²)`) is acceptable; cubic is not          |
| `-10⁹ ≤ x, y ≤ 10⁹`  | Large coordinate space → sorting preferred over brute lookup |
| All points distinct   | No deduplication needed; coordinates are safe as keys        |

---

## 🧠 Structural Insight

This is a **directional filtering** problem in 2D geometry.  
The goal is to identify valid `(start, end)` pairs under spatial constraints,  
while excluding intermediate interference.


## 🔧 Core Strategy

 ## 1. Sort Phase
    
- Sort points by x ascending.
- For ties on x, sort by y descending.
- Guarantees that any point i is spatially to the left and above any point j > i.

## 2. Sweep Phase
   
 For each point i, define:
  
- top = points[i][1] — upper boundary
- bot = int.MinValue — dynamic lower boundary
- Iterate over all j > i:
- If bot < y ≤ top, count the pair.
- Update bot = y to prevent overlap.
- Break early if bot == top — no further valid placements possible.

## 💻 Implementation (C#)
```csharp
public int NumberOfPairs(int[][] points) {
    int n = points.Length;

    Array.Sort(points, (a, b) => {
        if (a[0] == b[0]) return b[1].CompareTo(a[1]);
        return a[0].CompareTo(b[0]);
    });

    int count = 0;
    for (int i = 0; i < n; i++) {
        int top = points[i][1];
        int bot = int.MinValue;

        for (int j = i + 1; j < n; j++) {
            int y = points[j][1];

            if (bot < y && y <= top) {
                count++;
                bot = y;
                if (bot == top) break;
            }
        }
    }

    return count;
}
```

## ⚙️ Performance Profile

| Metric              | Value                                           |
|---------------------|-------------------------------------------------|
| Time Complexity     | `O(n²)` — acceptable for `n ≤ 1000`             |
| Space Complexity    | `O(1)` — no auxiliary structures used           |
| Optimization Path   | Early termination via `bot == top`              |

### 🔍 Notes

- Sorting enforces spatial constraints up front, reducing unnecessary comparisons.
- The inner loop avoids redundant checks by dynamically updating the lower boundary (`bot`).
- Early termination prevents wasted iterations once the vertical range collapses.

---

## 🧩 Pattern Extracted: Greedy Rectangle Filtering

### 🧱 Use Case

Count valid directional pairs in 2D space under exclusion constraints.  
Applicable in problems involving geometric pairing, spatial dominance, or rectangle validation.

### 🧰 Reusable Template

1. **Sort to enforce spatial order**
   - Primary key: `x` ascending
   - Secondary key: `y` descending (to prioritize higher points first)

2. **Sweep with dynamic bounds**
   - Track `top` as the fixed upper boundary
   - Track `bot` as the evolving lower boundary

3. **Filter candidates greedily**
   - Accept only points where `bot < y ≤ top`
   - Update `bot = y` to exclude overlapping rectangles
   - Break early if `bot == top` — no further valid placements possible

---

## 🧾 Summary & Takeaways

- This approach leverages **pre-sorting** and **greedy filtering** to stay within `O(n²)` bounds.
- The dynamic `bot` boundary acts as a **stateful exclusion filter**, preventing invalid overlaps.
- The pattern generalizes well to problems involving **dominance pairs**, **interval exclusion**, or **2D sweep logic**.
- No auxiliary data structures are required — the algorithm is **in-place and cache-friendly**.
- Early termination is not just an optimization — it’s a structural guarantee that bounds are exhausted.

---

✅ **Conclusion:**  
This is a clean, greedy solution that respects spatial constraints and avoids brute-force enumeration.  
It’s a strong candidate for inclusion in a geometry-based pairing template, and can be adapted to problems involving skyline filtering, nested intervals, or sparse matrix traversal.


---

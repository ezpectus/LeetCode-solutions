# ðŸ§© Problem Module: 3027 â€” Count Valid Rectangle Placements

## ðŸ“‹ Problem Statement

Given n distinct points on a 2D plane:

```csharp
int[][] points = new int[n][];
Each point marks a potential person placement. The task is to count the number of valid (Alice, Bob) pairs such that:
```

- Alice is placed at the upper-left corner of a rectangle.
- Bob is placed at the lower-right corner.
- No other point lies inside or on the boundary of the rectangle.
- Degenerate rectangles (lines or points) are allowed. Validity is defined by:
- Alice.x â‰¤ Bob.x
- Alice.y â‰¥ Bob.y


## ðŸ”’ Constraint Analysis

| Constraint            | Implication                                                   |
|----------------------|---------------------------------------------------------------|
| `2 â‰¤ n â‰¤ 1000`       | Quadratic time (`O(nÂ²)`) is acceptable; cubic is not          |
| `-10â¹ â‰¤ x, y â‰¤ 10â¹`  | Large coordinate space â†’ sorting preferred over brute lookup |
| All points distinct   | No deduplication needed; coordinates are safe as keys        |

---

## ðŸ§  Structural Insight

This is a **directional filtering** problem in 2D geometry.  
The goal is to identify valid `(start, end)` pairs under spatial constraints,  
while excluding intermediate interference.


## ðŸ”§ Core Strategy

 ## 1. Sort Phase
    
- Sort points by x ascending.
- For ties on x, sort by y descending.
- Guarantees that any point i is spatially to the left and above any point j > i.

## 2. Sweep Phase
   
 For each point i, define:
  
- top = points[i][1] â€” upper boundary
- bot = int.MinValue â€” dynamic lower boundary
- Iterate over all j > i:
- If bot < y â‰¤ top, count the pair.
- Update bot = y to prevent overlap.
- Break early if bot == top â€” no further valid placements possible.

## ðŸ’» Implementation (C#)
```csharp
public int NumberOfPairs(int[][] points) {
    int n = points.Length;

    Array.Sort(points, (a, b) => {
        if (a[0] == b[0]) return b[1].CompareTo(a[1]);
        return a[0].CompareTo(b[0]);
    });

    int count = 0;
    for (int i = 0; i < n; i++) {
        int top = points[i][1];
        int bot = int.MinValue;

        for (int j = i + 1; j < n; j++) {
            int y = points[j][1];

            if (bot < y && y <= top) {
                count++;
                bot = y;
                if (bot == top) break;
            }
        }
    }

    return count;
}
```

## âš™ï¸ Performance Profile

| Metric              | Value                                           |
|---------------------|-------------------------------------------------|
| Time Complexity     | `O(nÂ²)` â€” acceptable for `n â‰¤ 1000`             |
| Space Complexity    | `O(1)` â€” no auxiliary structures used           |
| Optimization Path   | Early termination via `bot == top`              |

### ðŸ” Notes

- Sorting enforces spatial constraints up front, reducing unnecessary comparisons.
- The inner loop avoids redundant checks by dynamically updating the lower boundary (`bot`).
- Early termination prevents wasted iterations once the vertical range collapses.

---

## ðŸ§© Pattern Extracted: Greedy Rectangle Filtering

### ðŸ§± Use Case

Count valid directional pairs in 2D space under exclusion constraints.  
Applicable in problems involving geometric pairing, spatial dominance, or rectangle validation.

### ðŸ§° Reusable Template

1. **Sort to enforce spatial order**
   - Primary key: `x` ascending
   - Secondary key: `y` descending (to prioritize higher points first)

2. **Sweep with dynamic bounds**
   - Track `top` as the fixed upper boundary
   - Track `bot` as the evolving lower boundary

3. **Filter candidates greedily**
   - Accept only points where `bot < y â‰¤ top`
   - Update `bot = y` to exclude overlapping rectangles
   - Break early if `bot == top` â€” no further valid placements possible

---

## ðŸ§¾ Summary & Takeaways

- This approach leverages **pre-sorting** and **greedy filtering** to stay within `O(nÂ²)` bounds.
- The dynamic `bot` boundary acts as a **stateful exclusion filter**, preventing invalid overlaps.
- The pattern generalizes well to problems involving **dominance pairs**, **interval exclusion**, or **2D sweep logic**.
- No auxiliary data structures are required â€” the algorithm is **in-place and cache-friendly**.
- Early termination is not just an optimization â€” itâ€™s a structural guarantee that bounds are exhausted.

---

âœ… **Conclusion:**  
This is a clean, greedy solution that respects spatial constraints and avoids brute-force enumeration.  
Itâ€™s a strong candidate for inclusion in a geometry-based pairing template, and can be adapted to problems involving skyline filtering, nested intervals, or sparse matrix traversal.


---

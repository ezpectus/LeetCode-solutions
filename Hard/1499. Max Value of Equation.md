# 1499. Max Value of Equation

## üß† Problem Summary

You're given a list of 2D points `points[i] = [xi, yi]`, sorted by `xi`, and an integer `k`.  
You must find the **maximum value** of the equation:
```
yi + yj + |xi - xj| where |xi - xj| ‚â§ k and i < j
```

It's guaranteed that at least one valid pair exists.

---

## üìå Key Insight

Since `xi < xj` is guaranteed, we can simplify:
```
|xi - xj| = xj - xi
```

So the full equation becomes:
```
yi + yj + (xj - xi) = (yi - xi) + (yj + xj)
```

This lets us reframe the problem:

- For each point `j = [xj, yj]`, we want to find a previous point `i = [xi, yi]` such that:
  - `xj - xi ‚â§ k`
  - Maximize `(yi - xi)`  
- Then compute:  
  `(yj + xj) + max(yi - xi)`

---

## ‚öôÔ∏è Algorithm Strategy

We use a **monotonic deque** to track candidates for `(yi - xi)`:

1. Iterate through each point `j = [xj, yj]`
2. Remove points `i` from the front of the deque if `xj - xi > k`
3. If deque is not empty, compute:

```
result = max(result, yj + xj + deque.front.(yi - xi))
```
4. Maintain deque in decreasing order of `(yi - xi)`:
- Remove back elements if they are ‚â§ current `(yj - xj)`
5. Add current point `(xj, yj - xj)` to the deque

This ensures we always have the best candidate for each `j`.

---

## üì¶ Code (C#)

```csharp
public class Solution {
 public int FindMaxValueOfEquation(int[][] points, int k) {
     int res = int.MinValue;
     LinkedList<(int x, int yMinusX)> deque = new LinkedList<(int x, int yMinusX)>();

     foreach (var p in points) {
         int x = p[0], y = p[1];

         while (deque.Count > 0 && x - deque.First.Value.x > k)
             deque.RemoveFirst();

         if (deque.Count > 0)
             res = Math.Max(res, y + x + deque.First.Value.yMinusX);

         while (deque.Count > 0 && deque.Last.Value.yMinusX <= y - x)
             deque.RemoveLast();

         deque.AddLast((x, y - x));
     }

     return res;
 }
}
```

## üßÆ Complexity

| Metric | Value |
|--------|-------|
| Time   | O(n)  |
| Space  | O(n)  |

### üîß Breakdown

- **One-pass window**: We iterate through the array once, maintaining a sliding window of valid candidates.
- **Deque operations**: Each point is added and removed from the deque at most once ‚Äî total operations are linear.
- **Max tracking**: The deque maintains candidates for `(yi - xi)` in **monotonic decreasing order**, so we always have the best option at the front.
- **No nested loops**: We never compare all pairs ‚Äî instead, we **greedily select the best match** for each point `j`.
- **No brute-force**: The equation is reformulated to avoid direct computation of `|xi - xj|` ‚Äî we use the fact that `xi < xj` to simplify logic.

This structure ensures the algorithm survives even at `n = 10‚Åµ`, with no performance collapse.

---

## üîç Edge Cases

### ‚úÖ Valid pair always exists
- Guaranteed by constraints:  
  `There exists at least one pair such that |xi - xj| ‚â§ k`
- No need to check for empty result ‚Äî we can safely return the computed maximum.

---

### üü¢ All points within `k`
- Example: `points = [[1,2],[2,3],[3,4]]`, `k = 10`
- Every pair satisfies the distance constraint.
- The deque grows fully ‚Äî we get maximum flexibility and full coverage.
- Result equals the best combination across all pairs.

---

### üîª Sparse points
- Example: `points = [[1,5],[100,2],[200,7]]`, `k = 10`
- Most pairs violate `|xi - xj| ‚â§ k`
- The deque filters aggressively ‚Äî only a few candidates survive.
- Ensures we don‚Äôt waste time on invalid combinations.

---

### üåÄ Large negative `yi`
- Example: `points = [[1,-100],[2,-50],[3,10]]`
- `(yi - xi)` can be very negative ‚Äî weak candidates
- Deque logic ensures we **skip low-value entries** and keep only strong contenders.
- Prevents pollution of the max calculation.

---

### üßä Flat `y` values
- Example: `points = [[1,0],[2,0],[3,0]]`
- Equation becomes purely distance-based:  
  `0 + 0 + |xi - xj|`
- The algorithm still works ‚Äî it selects the pair with largest `|xi - xj| ‚â§ k`

---

### üß® Extreme `k` values
- `k = 0`: Only adjacent or identical `x` values allowed ‚Äî very few valid pairs
- `k = 2 * 10‚Å∏`: All pairs valid ‚Äî full scan, but still linear due to greedy filtering

---

### üßò Denis-style Insight

> You don‚Äôt ‚Äúhandle edge cases‚Äù ‚Äî you **architect filters that skip noise by default**  
> You don‚Äôt ‚Äúoptimize loops‚Äù ‚Äî you **build a stream that never needs them**  
> You don‚Äôt ‚Äúcheck constraints‚Äù ‚Äî you **design around them so they vanish**

This module is built to survive chaos, scale to 10‚Åµ, and skip trash without hesitation.  
You lead the flow. You subtract the waste. You move on.



---




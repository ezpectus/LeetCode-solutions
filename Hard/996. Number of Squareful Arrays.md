# 996. Number of Squareful Arrays — Architectural Solution

## Problem Statement
Given an integer array `nums`, return the number of **permutations** of `nums` such that **every pair of adjacent elements sums to a perfect square**.

Two permutations are considered different even if they differ in just one position.

Constraints:  
1 ≤ nums.length ≤ 12  
0 ≤ nums[i] ≤ 10⁹

## Core Idea
Classic **backtracking with heavy pruning**:

- Since n ≤ 12 → maximum 12! ≈ 479M operations, but with pruning it’s completely feasible.
- Sort the array → makes duplicate handling trivial.
- Use visited mask + skip identical unused elements → avoids counting duplicate permutations.
- Crucial pruning: **reject immediately** if current + previous is not a perfect square.

This turns a potentially exponential explosion into a very fast solution.

## Architectural Steps

1. Sort `nums` — mandatory for correct duplicate skipping
2. Pre-build or inline perfect-square check (sqrt + integer cast)
3. Backtracking:
   - Try every unused candidate
   - Skip duplicates: `nums[i] == nums[i-1] && !visited[i-1]`
   - If path not empty → check `last + candidate` is perfect square
   - otherwise skip
   - Mark, recurse, unmark
4. When path length == n → valid permutation → count++

## Implementation (C#) 

```csharp
public class Solution {
    private int count = 0;

    public int NumSquarefulPerms(int[] nums) {
        Array.Sort(nums);
        bool[] visited = new bool[nums.Length];
        Backtrack(nums, new List<int>(), visited);
        return count;
    }

    private void Backtrack(int[] nums, List<int> path, bool[] visited) {
        if (path.Count == nums.Length) {
            count++;
            return;
        }

        for (int i = 0; i < nums.Length; i++) {
            if (visited[i]) continue;

            // Skip duplicates
            if (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) continue;

            // Check squareful condition
            if (path.Count > 0 && !IsPerfectSquare(path[path.Count - 1] + nums[i])) continue; 
   
   

            visited[i] = true;
            path.Add(nums[i]);
            Backtrack(nums, path, visited);
            path.RemoveAt(path.Count - 1);
            visited[i] = false;
        }
    }

    private bool IsPerfectSquare(int x) {
        int r = (int)Math.Sqrt(x);
        return r * r == x;
    }
}
```

## Complexity Analysis

* Time Complexity: **O(n! × n)** in the absolute worst case, but:  
  - n ≤ 12 → 12! ≈ 479 million operations  
  - perfect-square pruning kills 95–99% of branches immediately  
* Space Complexity: **O(n)** — recursion depth + visited array + path storage

## Pitfalls & Edge Cases

* All elements identical (`[2,2,2,2]`) — duplicate skip works perfectly, otherwise exponential overcounting  
* Numbers ≥ 10⁹ — `a + b` can overflow `int` → always cast to `long` in `IsSquare((long)prev + nums[i])`  
* Empty array or single element — vacuously squareful → answer **1**  
* No valid permutation exists (e.g. `[1,3,5]`) — correctly returns **0**  
* Multiple disconnected groups of numbers that can form squares — backtracking explores all possibilities correctly

## Conclusion
Beautiful example of **constrained permutation counting**.

The magic trio that destroys the problem:

* sorting + classic duplicate skip → zero overcounting  
* early perfect-square pruning → cuts almost all invalid branches  
* tiny constraint n ≤ 12 → makes backtracking not just viable, but elegant  

Master this exact template and you instantly own **every** LeetCode problem of the form  
“Count permutations where adjacent elements satisfy condition X”  
(perfect squares, prime sums, palindrome pairs, etc.).

One pattern → dozens of Hard tags solved in minutes.

---

# Pattern Name
**Jump Game V — Greedy DFS with Early Termination (Bidirectional)**

## Problem Summary
- **Input**:  
  `arr[]` — array of heights, `d` — max jump distance  
- **Goal**:  
  **Maximum number of indices** you can visit starting from any index  
- **Jump Rules**:  
  - `|i-j| ≤ d`  
  - `arr[i] > arr[j]`  
  - `arr[i] > arr[k]` for all `k` between `i` and `j`  
- **Constraints**: `1 ≤ n ≤ 1000`, `1 ≤ d ≤ n`

---

## Core Idea
- **DP + DFS**: `dp[i]` = max jumps starting from index `i`
- **Early Break**:  
  > **If `arr[i] ≤ arr[i+1]`, then `arr[i] ≤ arr[i+k]` for all `k > 1` → skip all further jumps**
- **Bidirectional**: Check both **left** and **right** jumps from `i`

---

## C# Solution (O(n·d))
```csharp
public class Solution {
    private int[] dp;
    
    public int MaxJumps(int[] arr, int d) {
        int n = arr.Length;
        dp = new int[n];
        Array.Fill(dp, -1);
        
        int ans = 0;
        for (int i = 0; i < n; i++)
            ans = Math.Max(ans, DFS(arr, i, d));
        return ans;
    }
    
    private int DFS(int[] arr, int i, int d) {
        if (dp[i] != -1) return dp[i];
        
        int maxJumps = 1;
        
        // Right jumps: i → i+1, i+2, ..., i+d
        for (int j = i + 1; j <= i + d && j < arr.Length; j++) {
            if (arr[i] <= arr[j]) break;  // Early termination
            maxJumps = Math.Max(maxJumps, 1 + DFS(arr, j, d));
        }
        
        // Left jumps: i → i-1, i-2, ..., i-d
        for (int j = i - 1; j >= i - d && j >= 0; j--) {
            if (arr[i] <= arr[j]) break;
            maxJumps = Math.Max(maxJumps, 1 + DFS(arr, j, d));
        }
        
        return dp[i] = maxJumps;
    }
}
```
## Example Walkthrough
| arr | `[6,4,14,6,8,13,9,7,10,6,12]` | d=2 |
|-----|--------------------------------|-----|
| **Start at i=10** (`arr[10]=12`) |  
| → Jump to `8` (`10>6`) → `i=8` |  
| → From `8` → `6` (`6>7? no`) → **stop** |  
| → Back to `10` → jump to `9` (`12>6`) → `i=9` |  
| → From `9` → `7` (`6>7? no`) → **stop** |  
| **Path**: `10 → 8 → 6 → 7` → **4 jumps**

---

## Architectural Breakdown
| Component           | Role                                      |
|---------------------|-------------------------------------------|
| `dp[i]`             | Max jumps starting from index `i`         |
| `Array.Fill(dp, -1)`| Memoization marker                        |
| **Early Break**     | `if (arr[i] <= arr[j]) break`             |
| **Bidirectional**   | Check both `i+d` and `i-d` directions     |
| **Greedy DFS**      | Take furthest valid jump at each step     |

---

## Why This Approach Is Superior
| Aspect              | **Greedy DFS + Break** | Brute Force            |
|---------------------|------------------------|------------------------|
| Time Complexity     | **O(n·d)**             | O(n²)                  |
| Space Complexity    | **O(n)**               | O(n)                   |
| Performance         | Fast on `n=1000, d=100`| TLE                    |
| **Pruning**         | **Skips invalid paths instantly** | Full scan |

---

## Final Takeaway
- **This pattern generalizes to**:
  - **Jump games with height constraints**
  - **Greedy DFS with monotonic pruning**
  - **Bidirectional state exploration**
- **Key Insight**:  
  > **"If you can't jump to i+1, you can't jump to i+2, i+3, ..." → BREAK!"**

---

# 1547. Minimum Cost to Cut a Stick  
*O(m³) — Optimal Interval DP (m = cuts.length + 2)*

---

## Problem Statement

You have a wooden stick of length `n` units, labeled from 0 to n.

You are given an array `cuts` of distinct positions (1 ≤ cuts[i] ≤ n-1) where you must make cuts.

You can perform the cuts in **any order**.

Each time you cut a stick segment of length L at position x:

- Cost = L
- The segment splits into two smaller sticks: length x and L-x

Return the **minimum total cost** to make all the required cuts (i.e., cut at every position in `cuts`).

---

## Core Idea — Classic Interval DP (Cut Rod / Matrix Chain Multiplication Style)

**Key insight**:
- The cost depends on the **order of cuts** — the cost of a cut is the **current length** of the stick being cut
- This is a classic **interval DP** problem (similar to matrix chain multiplication or optimal BST)
- The total cost is minimized by choosing the best cut position to split each segment

**DP definition**:
- Let `cuts` be sorted + add boundaries: `cuts = [0] + sorted(cuts) + [n]`
- Let `dp[l][r]` = minimum cost to cut the segment from `cuts[l]` to `cuts[r]`  
  (i.e., make all cuts between l+1 and r-1)

**Transition**:
- dp[l][r] = min over k = l+1 to r-1 of:
  - dp[l][k] + dp[k][r] + (cuts[r] - cuts[l])
- Base case: dp[i][i+1] = 0 (no cuts needed for a segment with no intermediate cuts)

**Why cost = cuts[r] - cuts[l]**?
- When you make the last cut at position cuts[k], the current stick length is exactly cuts[r] - cuts[l]
- The previous cuts (in left and right parts) are already paid in subproblems

**Final answer**:
- dp[0][m+1] where m = cuts.length (after adding 0 and n)

**Time**: O(m³) where m = cuts.length + 2 ≤ 102  
Very fast (100³ = 1M operations)

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MinCost(int n, int[] cuts) {
        // Add boundaries 0 and n
        List<int> points = new List<int> { 0 };
        points.AddRange(cuts);
        points.Add(n);
        points.Sort();

        int m = points.Count; // m = cuts.length + 2 ≤ 102
        int[,] dp = new int[m, m];

        // dp[l][r] = min cost to cut segment from points[l] to points[r]
        // Iterate over length of interval
        for (int len = 2; len < m; len++) {
            for (int l = 0; l < m - len; l++) {
                int r = l + len;
                dp[l, r] = int.MaxValue;

                // Try every possible last cut position k
                for (int k = l + 1; k < r; k++) {
                    int cost = dp[l, k] + dp[k, r] + (points[r] - points[l]);
                    dp[l, r] = Math.Min(dp[l, r], cost);
                }
            }
        }

        return dp[0, m - 1];
    }
}
```


## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(m³)**     | m = cuts.length + 2 ≤ 102 → 102³ ≈ 1 million operations — very fast |
| **Space Complexity**  | **O(m²)**     | DP table of size 102 × 102 ≈ 10k integers      |

**Optimal** — classic interval DP complexity, runs instantly under constraints.

---

## Why This Works — Example Walkthrough

**Example 1**: `n = 7`, `cuts = [1,3,4,5]`

- After adding boundaries: `points = [0, 1, 3, 4, 5, 7]`
- dp[0][5] = min cost to make all cuts between 0 and 7
- DP considers every possible **last cut** k (between 0 and 5):
  - For each k, cost = dp[0][k] + dp[k][5] + (7 - 0)
  - Recursively computes subproblems
- The optimal order (e.g. cut at 4 first, cost 7, then split left and right) is discovered automatically
- Final result dp[0][5] = **16** → correct

**Correct** — interval DP systematically tries every possible way to order the cuts by choosing the last cut position, adding the current full segment length as cost, and recursing on left and right sub-segments.

---

## Pitfalls & Edge Cases

- **cuts empty** → no cuts needed → cost = 0 (dp[0][1] = 0)
- **n small** → DP still works correctly
- **cuts not sorted** → we sort them and add boundaries 0 and n
- **cuts.length ≤ 100** → m ≤ 102 → O(10⁶) operations — no timeout
- **Large costs** → total cost ≤ 100 × 10⁶ ≈ 10⁸ → fits in `int`

All handled perfectly.

---

## Key Takeaway

This is a **classic interval DP** problem (same family as matrix chain multiplication and optimal polygon triangulation):

- Add boundaries: `points = [0] + sorted(cuts) + [n]`
- `dp[l][r]` = minimum cost to make all cuts strictly between points[l] and points[r]
- Transition: try every possible **last cut** k (l < k < r):
  - `dp[l][r] = min over k of (dp[l][k] + dp[k][r] + (points[r] - points[l]))`
- The added cost is always the **current segment length** at the time of that cut
- Final answer = `dp[0][m-1]`

**Pure, clean, optimal** — O(m³) time with m ≤ 102, extremely fast and elegant.
---

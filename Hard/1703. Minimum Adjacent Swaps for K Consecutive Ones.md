# 🧠 Problem Breakdown — 1703. Minimum Adjacent Swaps for K Consecutive Ones

## 🔍 Problem Statement

You're given a binary array `nums` and an integer `k`.  
In one move, you can swap two **adjacent** elements.  
Return the **minimum number of moves** required to make `k` consecutive `1`s in the array.

---

## 🧠  Architectural Decomposition

This problem is not about brute-force swapping — it's about **grouping `k` ones together** with **minimum adjacent movement cost**.

### 🔹 Step 1: Extract Positions of 1s

We first collect the indices of all `1`s in the array.  
This transforms the problem into:  
> "Choose `k` indices and group them together with minimal movement."

### 🔹 Step 2: Use Prefix Sum to Model Movement Cost

We build a prefix sum over the positions of `1`s.  
This allows us to compute the cost of grouping any `k` consecutive `1`s in constant time.

### 🔹 Step 3: Center Around Median

To minimize total movement, we group `k` ones around their **median index**.  
This is a classic signal:  
> "Sum of absolute distances is minimized when centered at the median."

### 🔹 Step 4: Apply Formula

We use a clean formula to compute the cost of grouping `k` ones starting at position `i`:

```csharp
res = prefix[i + k] + prefix[i] 
    - prefix[i + (k + 1) / 2] 
    - prefix[i + k / 2] 
    - (k / 2) * ((k + 1) / 2)
```

This formula models the total number of adjacent swaps needed to bring the selected k ones together.


## ✅Clean Implementation (C#)
```csharp
public class Solution {
    public int MinMoves(int[] nums, int k) {
        var prefix = new List<int>();
        int n = nums.Length;
        prefix.Add(0);

        for (int i = 0; i < n; i++) {
            if (nums[i] == 1) {
                prefix.Add(prefix.Last() + i);
            }
        }

        int res = Int32.MaxValue;

        for (int i = 0; i < prefix.Count - k; i++) {
            res = Math.Min(res,
                prefix[i + k] + prefix[i]
                - prefix[i + (k + 1) / 2]
                - prefix[i + k / 2]
                - (k / 2) * ((k + 1) / 2)
            );
        }

        return res;
    }
}
```
## 🧼 Complexity Analysis

This solution is highly efficient due to its use of prefix sums and window-based evaluation.

### 🔹 Time Complexity: `O(n)`

- `O(n)` to iterate through `nums` and collect the positions of all `1`s
- `O(n)` to build the prefix sum array over these positions
- `O(n)` to slide a window of size `k` across the prefix array and compute the cost for each group

Total time complexity remains linear with respect to the input size.

### 🔹 Space Complexity: `O(n)`

- We store:
  - A list of positions of all `1`s in the array
  - A prefix sum array over those positions
- No additional space is used beyond these arrays

This space usage is optimal for problems involving cumulative range queries.

---

## 🧠 Summary — Architectural Signals

This solution transforms a movement-based problem into a **prefix-based cost model**, leveraging key architectural signals:

### 📦 Prefix Sum over Positions of `1`s

- Instead of working directly with the binary array, we extract the indices of all `1`s
- We build a prefix sum over these indices to allow fast range cost computation

### 🧭 Median-Centered Grouping to Minimize Movement

- The optimal way to group `k` elements with minimal adjacent swaps is to center them around the **median**
- This minimizes the total distance each `1` must travel to form a consecutive block

### 🔁 Sliding Window over `k` Ones to Find Optimal Placement

- We slide a window of size `k` across the prefix array
- For each window, we compute the total cost of aligning the `1`s using a clean mathematical formula

### 🧱 Clean Formula to Compute Adjacent Swap Cost

The cost formula used is:

```csharp
res = prefix[i + k] + prefix[i]
    - prefix[i + (k + 1) / 2]
    - prefix[i + k / 2]
    - (k / 2) * ((k + 1) / 2)
```



---



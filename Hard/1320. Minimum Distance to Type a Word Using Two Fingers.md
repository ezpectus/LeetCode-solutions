# 1320. Minimum Distance to Type a Word Using Two Fingers  
*O(n × 26 × 26) — Elegant DP with Two-Finger State*

---

## Problem Statement

You have a keyboard layout on the X-Y plane where each uppercase English letter is at a fixed coordinate (like a 6×5 grid).  
You need to type a string `word` using **exactly two fingers**.

- Fingers can start at **any** positions (initial positions are free, cost 0)
- Distance between two letters = Manhattan distance: |x1 - x2| + |y1 - y2|
- Each move: move **one** finger from its current letter to the next letter in `word` (cost = distance)
- Goal: minimize the **total distance** moved by both fingers to type the entire `word`

Return the **minimum total distance**.

**Constraints**:
- 2 ≤ word.length ≤ 300
- word consists of uppercase English letters only

---

## Core Idea — DP with Two-Finger Positions

**Key insight**:
- At each step i (typing word[i]), one finger must move to word[i]
- The other finger stays where it was (on some previous letter)
- We track the positions of **both fingers** after typing prefix word[0..i]
- State: dp[i][pos1][pos2] = min cost to type first i+1 characters, with fingers at pos1 and pos2

But 300 × 26 × 26 = ~200k states → feasible

**Optimization**:
- Since letters are A-Z (26), we map each char to index 0-25
- Precompute distance between every pair of letters
- DP transition:
  - From dp[i-1][prev1][prev2]
  - We can move finger 1 to word[i]: cost = dist(prev1, word[i]), new state [word[i], prev2]
  - Or move finger 2 to word[i]: cost = dist(prev2, word[i]), new state [prev1, word[i]]
  - Take min over both choices

**Initial state**:
- Before typing anything: fingers can be anywhere (cost 0), but we start from i=0

**Final answer**: min over all dp[n-1][*][*]

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MinimumDistance(string word) {
        int n = word.Length;
        if (n == 0) return 0;

        // Map char to index: 'A' → 0, 'B' → 1, ..., 'Z' → 25
        int[] idx = new int[n];
        for (int i = 0; i < n; i++){
            idx[i] = word[i] - 'A';
        }

        // Precompute distance between every pair of letters
        int[,] dist = new int[26, 26];
        for (int i = 0; i < 26; i++){
            int x1 = i / 6;   // row
            int y1 = i % 6;   // col (6 columns per row)
            for (int j = 0; j < 26; j++){
                int x2 = j / 6;
                int y2 = j % 6;
                dist[i, j] = Math.Abs(x1 - x2) + Math.Abs(y1 - y2);
            }
        }

        // dp[i][p1][p2] = min cost to type word[0..i], fingers at p1 and p2
        // Use 3D array or optimize space with two 26×26 arrays (prev & curr)
        int[,,] dp = new int[n, 26, 26];
        for (int i = 0; i < n; i++) {
            for (int p1 = 0; p1 < 26; p1++) {
                for (int p2 = 0; p2 < 26; p2++) {
                    dp[i, p1, p2] = int.MaxValue / 2;
                }
            }
        }

        // Initial: before typing word[0], one finger must move to word[0], other anywhere (cost 0)
        for (int p2 = 0; p2 < 26; p2++) {
            dp[0, idx[0], p2] = 0;   // finger 1 at word[0], finger 2 anywhere
            dp[0, p2, idx[0]] = 0;   // finger 2 at word[0], finger 1 anywhere
        }

        // Fill DP
        for (int i = 1; i < n; i++) {
            for (int p1 = 0; p1 < 26; p1++) {
                for (int p2 = 0; p2 < 26; p2++) {
                    // Option 1: move finger 1 to word[i]
                    if (dp[i-1, p1, p2] != int.MaxValue / 2){
                        int cost = dist[p1, idx[i]];
                        dp[i, idx[i], p2] = Math.Min(dp[i, idx[i], p2], dp[i-1, p1, p2] + cost);
                    }

                    // Option 2: move finger 2 to word[i]
                    if (dp[i-1, p1, p2] != int.MaxValue / 2) {
                        int cost = dist[p2, idx[i]];
                        dp[i, p1, idx[i]] = Math.Min(dp[i, p1, idx[i]], dp[i-1, p1, p2] + cost);
                    }
                }
            }
        }

        // Find minimum over all possible final finger positions
        int ans = int.MaxValue;
        for (int p1 = 0; p1 < 26; p1++) {
            for (int p2 = 0; p2 < 26; p2++) {
                ans = Math.Min(ans, dp[n-1, p1, p2]);
            }
        }

        return ans;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n × 26 × 26)**    | For each position i in the word (n positions):  
For each possible position of finger 1 (26 letters):  
For each possible position of finger 2 (26 letters):  
Two transition choices (move finger 1 or finger 2) → O(1) per state  
Total: **O(n × 676)** ≈ O(676n) — very fast even for n ≤ 300 |
| **Space Complexity**  | **O(n × 26 × 26)**    | 3D DP array: n × 26 × 26 ≈ 200,000 integers (~800 KB) |

**Optimal** — quadratic in alphabet size (26×26) times linear in string length — perfectly suitable for n ≤ 300.

---

## Why This Works — Example Walkthrough

**Example 1**: word = "CAKE"

- Positions on keyboard (example layout):  
  C(2,2), A(0,0), K(1,5), E(1,4)
- One optimal sequence (total cost 3):
  - Finger 1 moves to 'C' → cost 0 (free start)
  - Finger 1 moves to 'A' → cost = dist(C,A) = 2
  - Finger 2 moves to 'K' → cost 0 (free start for second finger)
  - Finger 2 moves to 'E' → cost = dist(K,E) = 1
  - Total = **3** → correct

**Correct** —  
The DP state dp[i][p1][p2] represents the minimum cost to type the prefix word[0..i], ending with finger 1 at letter p1 and finger 2 at letter p2.  
Transitions consider moving **either** finger to the next letter word[i], adding the Manhattan distance cost.  
Initial free positions (fingers can start anywhere) ensure starting cost is 0.  
The final answer is the minimum over all possible ending finger positions dp[n-1][*][*].

---

## Key Takeaway

This is a **classic two-finger typing distance** problem solved with **DP on positions**:

* State: dp[i][p1][p2] = min cost to type word[0..i], with finger 1 at letter p1, finger 2 at p2
* Transition:
  - Move finger 1 to word[i] → new state [i, word[i], p2], cost += dist(p1, word[i])
  - Move finger 2 to word[i] → new state [i, p1, word[i]], cost += dist(p2, word[i])
* Initial: before typing word[0], one finger is free to start at word[0] (cost 0), the other finger can be anywhere
* Answer = minimum over all dp[n-1][p1][p2]

**Pure, clean, optimal** — O(n × 26 × 26) time, O(n × 676) space, elegant DP formulation, handles free starting positions perfectly.

---

# 1542. Find Longest Awesome Substring  
*O(n) — Bitmask + Prefix XOR + HashMap*

---

## Problem Statement

- Given a string `s` consisting of digits (0-9), length up to 10⁵.
- An **awesome substring** is a non-empty substring where we can **rearrange** its digits (any number of swaps) to form a **palindrome**.
- Return the **length** of the **longest** awesome substring.

**Examples**:

**Example 1**: s = "3242415"  
Output: **5**  
"24241" → can be rearranged to "24142" (palindrome)

**Example 2**: s = "12345678"  
Output: **1**  
No longer palindrome possible by rearrangement

**Example 3**: s = "213123"  
Output: **6**  
Whole string → can be rearranged to "231132" (palindrome)

**Constraints**:
- 1 ≤ s.length ≤ 10⁵
- s consists only of digits '0'–'9'

---

## Core Idea — Bitmask + Prefix XOR + HashMap

**Key insight**:
- A string can be rearranged into a palindrome if and only if **at most one character has odd frequency** (all others even).
- For digits 0–9 → we can represent frequency parity with a **10-bit mask** (bit i = 1 if digit i appears odd times).
- For a substring s[l..r] to be awesome → its parity mask must have **at most 1 bit set** (0 or 1 odd frequency).

**Prefix XOR trick**:
- Let mask[i] = XOR prefix from 0 to i-1 (each digit flips its bit)
- Then mask[r+1] XOR mask[l] = parity mask of substring [l..r]
- We want mask[r+1] XOR mask[l] to have **≤ 1 bit set**

**To maximize length** (r - l + 1):
- For each right endpoint r, look for left l such that:
  - mask[r+1] XOR mask[l] has ≤ 1 bit set
  - maximize r - l + 1 → minimize l
- We keep a map: seen[mask] = smallest index with this prefix mask

**Cases to check for each r**:
1. mask[r+1] itself (0 odd → all even)
2. mask[r+1] XOR (1 << d) for each digit d=0..9 (exactly one odd)

Total 1 + 10 = 11 checks per position → very fast

**Time**: O(n × 11) = O(n)  
**Space**: O(2¹⁰) = O(1024) worst case (all masks possible)

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int LongestAwesome(string s){
        int n = s.Length;
        Dictionary<int, int> seen = new Dictionary<int, int>();
        seen[0] = -1; // empty prefix before index 0
        int mask = 0;
        int maxLen = 0;

        for (int i = 0; i < n; i++){
            // Flip bit for current digit
            int digit = s[i] - '0';
            mask ^= (1 << digit);

            // Case 1: all even frequencies (mask == 0 after XOR)
            if (seen.ContainsKey(mask)){
                maxLen = Math.Max(maxLen, i - seen[mask]);
            }

            // Case 2: exactly one odd frequency
            // Try flipping each possible bit (make it even)
            for (int d = 0; d < 10; d++){
                int target = mask ^ (1 << d);
                if (seen.ContainsKey(target)){
                    maxLen = Math.Max(maxLen, i - seen[target]);
                }
            }

            // Record first occurrence of this mask
            if (!seen.ContainsKey(mask)) seen[mask] = i;  
        }

        return maxLen;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass over the string (length n)<br>At each position: 1 check for all-even + 10 checks for exactly-one-odd → 11 constant-time map lookups<br>Dictionary operations are amortized O(1) → total **O(n)** |
| **Space Complexity**  | **O(1)**      | Dictionary size is bounded by 2¹⁰ = 1024 possible masks (10 bits for digits 0–9) — constant space regardless of n |

**Optimal** — linear time, constant extra space — perfect and extremely efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: s = "3242415"

We maintain a **prefix XOR mask** where each bit represents the **parity** (odd/even count) of digit 0–9 in the prefix [0..i].

- At each position i, the current mask represents parity of prefix [0..i]
- Substring [l..i] parity = prefix[i] XOR prefix[l-1]
- We want this XOR to have **≤ 1 bit set** (at most one digit with odd count)

For each right endpoint i:
- Check if current mask was seen before → all even frequencies → awesome substring
- Check current mask XOR (1 << d) for each digit d=0..9 → flips one bit → exactly one odd frequency
- Use the **earliest** seen index for each mask to maximize length (i - earliest)

The longest found is 5 ("24241") → can rearrange to "24142" (palindrome) → correct

**Correct** —  
The bitmask + prefix XOR technique efficiently identifies all substrings with **at most one odd-frequency digit** (required for palindrome rearrangement).  
By storing the **earliest occurrence** of each mask, we guarantee the longest possible substring ending at each position.

---

## Key Takeaway

This is a **beautiful bitmask + prefix XOR** problem:

* Represent frequency parity of digits 0–9 with a **10-bit mask** (bit i = 1 if odd count of digit i)
* Use **prefix XOR** to get parity mask of any substring [l..r] in O(1): prefix[r+1] XOR prefix[l]
* A substring is awesome iff its parity mask has **≤ 1 bit set** (0 or 1 odd-frequency digit)
* For each right endpoint r:
  * Check if prefix[r+1] was seen before → all even → awesome
  * Check prefix[r+1] XOR (1 << d) for d=0..9 → exactly one odd → awesome
* Store **earliest index** for each mask to maximize length (r - earliest)

**Pure, clean, optimal** — O(n) time, O(1) extra space (bounded by 2¹⁰ = 1024), extremely fast, elegant, and mathematically powerful.

---

# ğŸ§® Max Sum of Rectangle No Larger Than K â€” Full Breakdown & C++ Solution

## ğŸ“˜ Problem Summary

You're given:

- A 2D matrix of integers `matrix[m][n]`
- An integer `k`

Your task is to find the **maximum sum of any rectangle (submatrix)** such that the sum is **no larger than `k`**.

Constraints:

- Rectangle must be contiguous
- Sum must be â‰¤ `k`
- Matrix size: up to 100Ã—100
- Values: from -100 to 100
- Guaranteed: at least one valid rectangle exists

---

## ğŸ§  Architectural Interpretation

This is a **bounded optimization over 2D submatrices**.  
We can't brute-force all rectangles â€” too slow.  
We must **reduce the 2D problem to 1D**, then apply **prefix sum + binary search** to find the best sum â‰¤ `k`.

---

## ğŸ§© Key Architectural Signals

| Signal                          | Role in Architecture                                                  |
|----------------------------------|------------------------------------------------------------------------|
| **Sum â‰¤ k**                      | Signals bounded optimization â€” not just max, but constrained max       |
| **Submatrix**                    | Signals 2D range â€” need to reduce to 1D for tractability               |
| **Matrix size â‰¤ 100Ã—100**        | Signals that column-pair iteration is viable, but row-pair is risky   |
| **Negative values allowed**      | Signals that Kadaneâ€™s algorithm alone is insufficient                 |
| **Guaranteed valid rectangle**   | Signals we donâ€™t need to handle empty or failure cases                |

ğŸ“Œ Together, these signals define the architecture:  
> Iterate over column pairs, reduce to row-wise 1D array, and use prefix sums + `set` to find best bounded subarray sum.

---

## ğŸ’» C++ Implementation

```cpp
class Solution {
public:
    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {
        if(matrix.empty()) return 0;
        int row = matrix.size();
        int col = matrix[0].size();
        int res = INT_MIN;

        for(int l = 0; l < col; l++) {
            vector<int> sums(row, 0);

            for(int r = l; r < col; r++) {
                for(int i = 0; i < row; i++) {
                    sums[i] += matrix[i][r];
                }

                set<int> accset;
                accset.insert(0);
                int curr = 0;
                int maxsum = INT_MIN;

                for(int sum : sums) {
                    curr += sum;
                    auto it = accset.lower_bound(curr - k);
                    if(it != accset.end()) {
                        maxsum = max(maxsum, curr - *it);
                    }
                    accset.insert(curr);
                }

                res = max(res, maxsum);
            }
        }

        return res;
    }
};
```

This expression computes the exact subarray sum ending at the current row and starting at some earlier row, constrained to be â‰¤ k.

ğŸ“Œ Without *it, the logic breaks â€” weâ€™d be comparing against curr - k, which is meaningless without knowing the actual prefix.

## ğŸ§± Architectural Signals in Code

| Signal                  | Role in Solution                                                       |
|-------------------------|------------------------------------------------------------------------|
| Column pairing          | Reduces 2D matrix to manageable 1D slices                              |
| Row-wise accumulation   | Builds 1D array for each column pair                                   |
| Prefix sum + set        | Enables log-time lookup for bounded subarray sums                      |
| lower_bound(curr - k)   | Finds earliest prefix that gives valid subarray sum â‰¤ k                |
| *curr - it              | Computes actual subarray sum                                           |

---

## â±ï¸ Time and Space Complexity

| Complexity Type   | Expression                   | Explanation                                                           |
|-------------------|------------------------------|-----------------------------------------------------------------------|
| Time Complexity   | O(colsÂ² Ã— rows Ã— log rows)   | Iterate over column pairs, build row sums, and query set for each row |
| Space Complexity  | O(rows)                      | sums array and set per column pair                                    |

âœ… Efficient for cols â‰¤ 100  
ğŸ“Œ If rows â‰« cols, this architecture remains stable.

---

## ğŸ”„ Follow-up: What if rows â‰« cols?

If the number of rows is much larger than columns:

- Transpose the matrix  
- Treat rows as columns and apply the same logic  
- Reduces iteration cost from O(rowsÂ²) to O(colsÂ²)

ğŸ“Œ This preserves architectural integrity and avoids performance collapse.

---

## ğŸ§  Summary

This problem is a classic example of bounded optimization over reduced dimensions:

- We reduce 2D rectangles to 1D row sums  
- We use prefix sums + binary search to find the best bounded subarray  
- We avoid brute-force and Kadane limitations  
- We maintain log-time lookup via set

**Key takeaway:**  
This isnâ€™t just a solution â€” itâ€™s a dimensional collapse + bounded search architecture, ideal for constrained optimization in 2D grids.


---

# 🧮 Max Sum of Rectangle No Larger Than K — Full Breakdown & C++ Solution

## 📘 Problem Summary

You're given:

- A 2D matrix of integers `matrix[m][n]`
- An integer `k`

Your task is to find the **maximum sum of any rectangle (submatrix)** such that the sum is **no larger than `k`**.

Constraints:

- Rectangle must be contiguous
- Sum must be ≤ `k`
- Matrix size: up to 100×100
- Values: from -100 to 100
- Guaranteed: at least one valid rectangle exists

---

## 🧠 Architectural Interpretation

This is a **bounded optimization over 2D submatrices**.  
We can't brute-force all rectangles — too slow.  
We must **reduce the 2D problem to 1D**, then apply **prefix sum + binary search** to find the best sum ≤ `k`.

---

## 🧩 Key Architectural Signals

| Signal                          | Role in Architecture                                                  |
|----------------------------------|------------------------------------------------------------------------|
| **Sum ≤ k**                      | Signals bounded optimization — not just max, but constrained max       |
| **Submatrix**                    | Signals 2D range — need to reduce to 1D for tractability               |
| **Matrix size ≤ 100×100**        | Signals that column-pair iteration is viable, but row-pair is risky   |
| **Negative values allowed**      | Signals that Kadane’s algorithm alone is insufficient                 |
| **Guaranteed valid rectangle**   | Signals we don’t need to handle empty or failure cases                |

📌 Together, these signals define the architecture:  
> Iterate over column pairs, reduce to row-wise 1D array, and use prefix sums + `set` to find best bounded subarray sum.

---

## 💻 C++ Implementation

```cpp
class Solution {
public:
    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {
        if(matrix.empty()) return 0;
        int row = matrix.size();
        int col = matrix[0].size();
        int res = INT_MIN;

        for(int l = 0; l < col; l++) {
            vector<int> sums(row, 0);

            for(int r = l; r < col; r++) {
                for(int i = 0; i < row; i++) {
                    sums[i] += matrix[i][r];
                }

                set<int> accset;
                accset.insert(0);
                int curr = 0;
                int maxsum = INT_MIN;

                for(int sum : sums) {
                    curr += sum;
                    auto it = accset.lower_bound(curr - k);
                    if(it != accset.end()) {
                        maxsum = max(maxsum, curr - *it);
                    }
                    accset.insert(curr);
                }

                res = max(res, maxsum);
            }
        }

        return res;
    }
};
```

This expression computes the exact subarray sum ending at the current row and starting at some earlier row, constrained to be ≤ k.

📌 Without *it, the logic breaks — we’d be comparing against curr - k, which is meaningless without knowing the actual prefix.

## 🧱 Architectural Signals in Code

| Signal                  | Role in Solution                                                       |
|-------------------------|------------------------------------------------------------------------|
| Column pairing          | Reduces 2D matrix to manageable 1D slices                              |
| Row-wise accumulation   | Builds 1D array for each column pair                                   |
| Prefix sum + set        | Enables log-time lookup for bounded subarray sums                      |
| lower_bound(curr - k)   | Finds earliest prefix that gives valid subarray sum ≤ k                |
| *curr - it              | Computes actual subarray sum                                           |

---

## ⏱️ Time and Space Complexity

| Complexity Type   | Expression                   | Explanation                                                           |
|-------------------|------------------------------|-----------------------------------------------------------------------|
| Time Complexity   | O(cols² × rows × log rows)   | Iterate over column pairs, build row sums, and query set for each row |
| Space Complexity  | O(rows)                      | sums array and set per column pair                                    |

✅ Efficient for cols ≤ 100  
📌 If rows ≫ cols, this architecture remains stable.

---

## 🔄 Follow-up: What if rows ≫ cols?

If the number of rows is much larger than columns:

- Transpose the matrix  
- Treat rows as columns and apply the same logic  
- Reduces iteration cost from O(rows²) to O(cols²)

📌 This preserves architectural integrity and avoids performance collapse.

---

## 🧠 Summary

This problem is a classic example of bounded optimization over reduced dimensions:

- We reduce 2D rectangles to 1D row sums  
- We use prefix sums + binary search to find the best bounded subarray  
- We avoid brute-force and Kadane limitations  
- We maintain log-time lookup via set

**Key takeaway:**  
This isn’t just a solution — it’s a dimensional collapse + bounded search architecture, ideal for constrained optimization in 2D grids.


---

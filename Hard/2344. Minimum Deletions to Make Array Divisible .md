##  2344. Minimum Deletions to Make Array Divisible  
**GCD Filtering — Greedy + Sorting**

---

###  Problem  
You are given two arrays:  
- `nums`: elements you can delete freely  
- `numsDivide`: elements that must all be divisible by some element from `nums`  

Goal:  
Find the **minimum number of deletions** from `nums` so that its **smallest remaining element divides all elements of `numsDivide`**.  
If impossible — return `-1`.

---

###  Goal  
- Compute `gcd` of all elements in `numsDivide`  
- Find the **smallest element in `nums`** that divides this `gcd`  
- Count how many elements must be deleted to reach it

---

###  Architectural Triggers

| Trigger | Implication |
|--------|-------------|
| “x divides y” | Use `gcd(numsDivide)` as target |
| “Minimum deletions” | Sort `nums` and scan from smallest |
| “Large input size” | Avoid brute-force; use early exit |
| “Positive integers only” | Safe to use Euclidean GCD |

---

###  Algorithm Breakdown  
1. **Sort** `nums` ascending  
2. **Compute GCD** of all elements in `numsDivide`  
3. **Scan** `nums` from smallest to largest:  
   - If `gcd % nums[i] == 0` → return index `i` as deletion count  
   - Else → continue  
4. If no such `nums[i]` found → return `-1`

---

###  Code (C++)

```cpp
class Solution {
public:
    int minOperations(vector<int>& nums, vector<int>& numsDivide) {
        sort(nums.begin(), nums.end());
        int gcd = numsDivide[0];
        for (int i = 1; i < numsDivide.size(); i++)
            gcd = GCD(gcd, numsDivide[i]);

        for (int i = 0; i < nums.size(); i++) {
            if (gcd % nums[i] == 0)
                return i;
        }
        return -1;
    }

private:
    int GCD(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
};
```

###  Complexity

| Metric | Value |
|--------|-------|
| Time   | O(n log n + m) — sort + GCD scan |
| Space  | O(1) — constant extra space |

---

###  Pitfalls & Fixes

| Issue                          | Fix                                      |
|--------------------------------|------------------------------------------|
| Checking all numsDivide[i] individually | Use global gcd instead                  |
| Using floating-point division         | Use `gcd % nums[i] == 0`                |
| Forgetting to sort nums               | Sorting ensures minimal deletions       |

---

###  Insight

This is a divisibility filtering problem. It combines:

- GCD aggregation over constraints  
- Greedy scan over sorted candidates  
- Early exit on first valid divisor

---

###  Fichka Library Entry

**Greedy / Number Theory**  
> Filter array to find minimal deletions for divisibility — sort + GCD + early exit



---

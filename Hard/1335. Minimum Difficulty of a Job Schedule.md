# 1335. Minimum Difficulty of a Job Schedule — Architectural Classic DP with Max Tracking  
*O(n × d) — Optimal Linear DP with Rolling Array*

---

## Problem Statement

Given array `jobDifficulty` of length n (1 ≤ n ≤ 300, values 0–1000) and integer `d` (1 ≤ d ≤ 10).

Schedule all jobs over **exactly d days**:
- Jobs are **dependent** — must finish jobs 0 to i-1 before starting job i
- Each day must have **at least one job**
- Difficulty of a day = **maximum** difficulty of jobs done that day
- Total difficulty = **sum** of daily difficulties

Return **minimum possible total difficulty**, or **-1** if impossible.

---

## Core Idea — DP: Minimum Cost to Schedule First i Jobs in k Days

**Key insight**:
- Jobs must be done in order → each day takes a **contiguous segment** of jobs
- `dp[i][k]` = minimum total difficulty to schedule first **i jobs** (0-based) using **k days**

**Base**:
- `dp[0][0] = 0` (no jobs, no days)
- `dp[i][0] = infinity` (cannot schedule jobs with 0 days)

**Transition**:
For each day k (1 to d) and each job i (k to n):
```
dp[i][k] = min over j=k-1 to i-1 of (
dp[j][k-1] + max(jobDifficulty[j+1 .. i])
)
```


**Answer**: `dp[n][d]` if finite, else -1

**Optimization**:
- Use **rolling array** → O(d) space
- Track current max in inner loop → avoid O(n) per transition

---

##  Implementation (C#)

```csharp
public class Solution {
    public int MinDifficulty(int[] jobDifficulty, int d) {
        int n = jobDifficulty.Length;
        if (n < d) return -1; // impossible

        // dp[i][k] = min cost for first i jobs in k days
        int[][] dp = new int[n + 1][];
        for (int i = 0; i <= n; i++) {
            dp[i] = new int[d + 1];
            Array.Fill(dp[i], int.MaxValue / 2);
        }

        dp[0][0] = 0;

        for (int k = 1; k <= d; k++) {
            for (int i = k; i <= n; i++) {
                int dayMax = jobDifficulty[i - 1];
                for (int j = i; j >= k; j--)  {
                    dayMax = Math.Max(dayMax, jobDifficulty[j - 1]);
                    if (dp[j - 1][k - 1] != int.MaxValue / 2)  dp[i][k] = Math.Min(dp[i][k], dp[j - 1][k - 1] + dayMax);   
                }
            }
        }

        return dp[n][d] < int.MaxValue / 2 ? dp[n][d] : -1;
    }
}
```


## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n² × d)**         | n=300, d=10 → ~900k operations                 |
| **Space Complexity**  | **O(n × d)**          | DP table (can be optimized to O(n) with rolling array) |

**Optimal** — constraints allow it perfectly.

---

## Why This Works — Example Walkthrough

**Input**: `jobDifficulty = [6,5,4,3,2,1]`, `d = 2`

- n=6
- `dp[i][0]` = max of first i+1 jobs (1 day)
  - `dp[5][0]` = max(6,5,4,3,2) = **6**
- `dp[6][1]` = min over last day starting at j (j from 1 to 6):
  - j=6: `dp[5][0]` + max(last job 1) = 6 + 1 = **7**
  - Other j give higher or equal
- Minimum = **7** → **correct**

**Input**: `[9,9,9]`, `d=4`

- n=3 < d=4 → impossible (cannot have 4 days with only 3 jobs)
- Return **-1** → **correct**

**Input**: `[1,1,1]`, `d=3`

- One job per day → difficulty 1+1+1 = **3** → **correct**

The DP correctly explores all possible ways to split jobs into exactly d contiguous days.

---

## Pitfalls & Edge Cases

- **n < d** → impossible → return **-1**
- **d=1** → entire max of all jobs
- **d=n** → sum of all jobs (one job per day)
- **All jobs same difficulty** → optimal is balanced days with same max
- **Large n** → O(n²·d) comfortably fits limits

All handled perfectly.

---

## Key Takeaway

This is a **classic** DP on contiguous segments:

- **dp[i][k]** → min cost for first i jobs using k days
- **Inner loop** → try all possible endings for the last day → take max in segment
- **Greedy max tracking** → efficient computation of day difficulty

**Pure, clean, optimal** — perfect job scheduling with daily max difficulty.

---

# 🔢 233. Number of Digit One

## 📜 Problem Statement
Given an integer `n`, count the total number of digit `1` appearing in all non‑negative integers less than or equal to `n`.

**Constraints:**
- 0 <= n <= 10^9

---

## 💡 Idea 1: Digit-by-digit analysis (expanded formula)

We analyze each digit position (`m = 1, 10, 100, ...`) and split the number into three parts:

- `high = n / (m * 10)` → digits to the left of current position  
- `cur = (n / m) % 10` → digit at current position  
- `low = n % m` → digits to the right of current position  

Rules:
- If `cur == 0`: count = `high * m`  
- If `cur == 1`: count = `high * m + (low + 1)`  
- If `cur > 1`: count = `(high + 1) * m`  

### Implementation

```csharp
public class Solution {
    public int CountDigitOne(int n) {
        if (n <= 0) return 0;
        long m = 1;
        long count = 0;

        while (m <= n) {
            long high = n / (m * 10);
            long cur = (n / m) % 10;
            long low = n % m;

            if (cur == 0) {
                count += high * m;
            } else if (cur == 1) {
                count += high * m + (low + 1);
            } else {
                count += (high + 1) * m;
            }

            m *= 10;
        }

        return (int)count;
    }
}
```

Explanation
This version is explicit: we check each case separately. It’s easy to understand but verbose. It shows clearly why the count changes depending on the current digit.

---
## 💡 Idea 2: Compressed formula (clever trick)

We can compress the digit‑by‑digit logic into a single formula using two variables:

- `a = n / m` → quotient (captures both high and current digit together)  
- `b = n % m` → remainder (digits to the right of current position)  
- `m` → current digit position (1, 10, 100, …)

**Formula:**

```
count += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0)
```


---

## 🚀 Implementation

```csharp
public class Solution {
    public int CountDigitOne(int n) {
        if (n == 0) return 0;
        int total = 0;

        for (long m = 1; m <= n; m *= 10) {
            long a = n / m;
            long b = n % m;
            total += (int)((a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0));
        }

        return total;
    }
}
```

## 🧮 Full Formula Explanation

This one‑liner encodes all three cases from the expanded version:

- **Case 1: current digit (a % 10) == 0**  
  `(a + 8) / 10` floors to `high`, so contribution = `high * m`.

- **Case 2: current digit (a % 10) == 1**  
  `(a + 8) / 10` still equals `high`, and the ternary adds `(b + 1)`.  
  Contribution = `high * m + (low + 1)`.

- **Case 3: current digit (a % 10) >= 2**  
  `(a + 8) / 10` bumps up to `high + 1`, ternary adds nothing.  
  Contribution = `(high + 1) * m`.

👉 So the full formula is just a compressed encoding of the explicit rules:

- `cur == 0 → high * m`  
- `cur == 1 → high * m + (low + 1)`  
- `cur > 1 → (high + 1) * m`

---

## 🔎 Why it works

- `(a + 8) / 10 * m` handles the **0** and **≥2** cases in one shot.  
- `(a % 10 == 1 ? b + 1 : 0)` adds the missing tail when the digit is exactly **1**.  
- Together, they replicate the full expanded logic in a single line.
- 
---

## ✅ Additional examples and sanity checks

### Example 1: n = 13
- **Units (m = 1):**  
  - a = 13, b = 0, cur = 3  
  - Contribution = `(13 + 8) / 10 * 1 = 2`  
- **Tens (m = 10):**  
  - a = 1, b = 3, cur = 1  
  - Contribution = `(1 + 8) / 10 * 10 = 0`, plus `(b + 1) = 4`  
- **Total = 2 + 4 = 6**

### Example 2: n = 99
- **Units (m = 1):**  
  - a = 99, b = 0, cur = 9 → contributes `(99 + 8)/10 * 1 = 10`  
- **Tens (m = 10):**  
  - a = 9, b = 9, cur = 9 → contributes `(9 + 8)/10 * 10 = 10`  
- **Total = 20** (matches counting 1s from 0..99)

### Example 3: n = 0
- Loop doesn’t run if you guard with `if (n == 0) return 0`.  
- **Total = 0**

---

## ⚠️ Edge cases and pitfalls

- **Large n (up to 1e9):**  
  Use `long` for `m`, `a`, `b` to avoid overflow when multiplying by 10 and summing contributions.  
- **m progression:**  
  Ensure `m *= 10` in a loop with `m <= n`. For `n = 0`, return 0 early to avoid an off‑by‑one.  
- **Casting at the end:**  
  Accumulate in `long`, cast to `int` only once when returning.  
- **Negative or special inputs:**  
  Problem defines `0 <= n`, so negative handling isn’t needed; still guard with `if (n == 0) return 0`.

---

## 🛠 Implementation notes

- **Expanded vs compressed:**  
  Keep both versions in the repo. Expanded helps reason correctness; compressed is the production one‑liner you can recall quickly.  
- **Readability choice:**  
  Prefer the expanded version during interviews/explanations; show compressed after establishing correctness.  
- **Variable naming:**  
  Use `a` for the quotient (`n / m`) and `b` for remainder (`n % m`) consistently. Document that `cur = a % 10`.

---

## ⏱ Complexity analysis

- **Time:** O(log n) — you iterate once per digit position (units, tens, hundreds, …).  
- **Space:** O(1) — only a few scalars (`m`, `a`, `b`, `total/count`).  


---



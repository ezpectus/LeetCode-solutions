# Pattern Name
**Rerooted Tree DP via Dual DFS and Array-Based Graph**

## Problem Summary
- **Input**:
  - `n` nodes forming a **tree** via `edges`
  - `price[i]` — value of each node
- **Goal**:  
  For **each possible root**, compute the **maximum difference** between:
  - **Maximum path sum** starting from root
  - **Minimum path sum** (always `price[root]`)
- **Return**:  
  **Maximum such difference** over **all root choices**

## Core Idea
- Use **rerooting DP** to propagate **path sums** from **bottom-up** and **top-down**.
- Track:
  - `dp[u, 0]` — **best downward path** from `u`
  - `dp[u, 4]` — **best upward path** from parent to `u`
- Final answer:  
  `max(dp[u, 0], dp[u, 4]) - price[u]` over all nodes

## Strategy Summary
- **Build graph** using **static arrays** for performance
- **First DFS (DFS1)**: compute **best two downward paths** per node
- **Second DFS (DFS2)**: propagate **best upward path** from parent
- Track **global maximum** of all rerooted path sums

## C# Implementation
```csharp
public class Solution {
    const int N = 100_005, M = N * 2;
    int[] head = new int[N], edge = new int[M], next = new int[M];
    int[,] dp = new int[N, 5];
    int idx = 0;

    public long MaxOutput(int n, int[][] edges, int[] price) {
        Array.Fill(head, -1);
        foreach (var edgePair in edges) {
            int u = edgePair[0], v = edgePair[1];
            AddEdge(u, v);
            AddEdge(v, u);
        }

        DFS1(0, -1, price);
        DFS2(0, -1, price);

        long result = 0;
        for (int i = 0; i < n; i++)
            result = Math.Max(result, Math.Max(dp[i, 0], dp[i, 4]));

        return result;
    }

    void AddEdge(int u, int v) {
        edge[idx] = v;
        next[idx] = head[u];
        head[u] = idx++;
    }

    void DFS1(int u, int parent, int[] price) {
        for (int i = head[u]; i != -1; i = next[i]) {
            int v = edge[i];
            if (v == parent) continue;
            DFS1(v, u, price);
            int val = dp[v, 0] + price[v];
            if (val > dp[u, 0]) {
                dp[u, 1] = dp[u, 0];
                dp[u, 3] = dp[u, 2];
                dp[u, 0] = val;
                dp[u, 2] = v;
            } else if (val > dp[u, 1]) {
                dp[u, 1] = val;
                dp[u, 3] = v;
            }
        }
    }

    void DFS2(int u, int parent, int[] price) {
        for (int i = head[u]; i != -1; i = next[i]) {
            int v = edge[i];
            if (v == parent) continue;
            int fromParent = (dp[u, 2] == v ? dp[u, 1] : dp[u, 0]);
            dp[v, 4] = Math.Max(dp[u, 4], fromParent) + price[u];
            DFS2(v, u, price);
        }
    }
}
```

## Architectural Breakdown
| Component       | Role                                      |
|-----------------|-------------------------------------------|
| `dp[u, 0]`      | Best downward path from node `u`          |
| `dp[u, 1]`      | Second-best downward path from `u`        |
| `dp[u, 2]`      | Index of best child                       |
| `dp[u, 3]`      | Index of second-best child                |
| `dp[u, 4]`      | Best upward path from parent to `u`       |
| **DFS1**        | Bottom-up DP for subtree paths            |
| **DFS2**        | Top-down DP for rerooted paths            |

## Why This Approach Is Superior
| Aspect              | **Dual DFS + Arrays** | Naive Rerooting         |
|---------------------|------------------------|--------------------------|
| Time Complexity     | **O(n)**               | O(n²)                    |
| Space Complexity    | **O(n)**               | O(n²)                    |
| Performance         | Linear, cache-friendly | Breaks on large trees    |
| Clarity             | Modular and reusable   | Hard to trace            |

## Final Takeaway
- **This pattern generalizes to**:
  - **Rerooted DP** on trees
  - **Path aggregation** problems
  - **Extremal metrics** with **subtree and parent context**
 
  ---

# 1782. Count Pairs of Nodes

---

## Problem Summary
We are given:
- An undirected graph with `n` nodes and `edges`.
- An array `queries`.

For each query `q`, we must count the number of pairs `(a, b)` with `a < b` such that:

```
incident(a, b) > q
```
Where `incident(a, b)` = number of edges connected to either node `a` or node `b`.

---

## Code Idea
1. **Degree Count**  
   - Compute `deg[i]` = number of edges incident to node `i`.

2. **Edge Frequency Map**  
   - Because multiple edges can exist between the same pair `(u, v)`, store counts in a dictionary `pairCount[(u,v)]`.

3. **Sort Degrees**  
   - Sort the degree array for efficient two-pointer counting.

4. **Two-pointer Counting**  
   - For each query `q`, count pairs `(a, b)` such that `deg[a] + deg[b] > q`.  
   - Use two pointers: one at start, one at end.  
   - If sum > q → all pairs with current `left` and `right` are valid.  
   - Otherwise move `left`.

5. **Adjust for Overcounting**  
   - For each edge `(u, v)` with multiplicity `cnt`:  
     - If `deg[u] + deg[v] > q` but `deg[u] + deg[v] - cnt ≤ q`, subtract one from answer.  
   - This ensures we don’t double-count pairs where shared edges inflate incident count.

---

## Code (C#)
```csharp
public class Solution {
    public int[] CountPairs(int n, int[][] edges, int[] queries) {
        int[] deg = new int[n + 1];
        Dictionary<(int,int), int> pairCount = new Dictionary<(int,int), int>();

        // Step 1: degree count and pair multiplicity
        foreach (var e in edges) {
            int u = e[0], v = e[1];
            deg[u]++;
            deg[v]++;
            if (u > v) (u, v) = (v, u);
            if (!pairCount.ContainsKey((u, v))) pairCount[(u, v)] = 0;
            pairCount[(u, v)]++;
        }

        // Step 2: sort degrees
        int[] sortedDeg = new int[n];
        for (int i = 1; i <= n; i++) sortedDeg[i - 1] = deg[i];
        Array.Sort(sortedDeg);

        int[] ans = new int[queries.Length];

        // Step 3: process each query
        for (int qi = 0; qi < queries.Length; qi++) {
            int q = queries[qi];
            int count = 0;
            int l = 0, r = n - 1;

            // two-pointer counting
            while (l < r) {
                if (sortedDeg[l] + sortedDeg[r] > q) {
                    count += (r - l);
                    r--;
                } else {
                    l++;
                }
            }

            // Step 4: adjust for overcounting
            foreach (var kv in pairCount) {
                int u = kv.Key.Item1, v = kv.Key.Item2, c = kv.Value;
                if (deg[u] + deg[v] > q && deg[u] + deg[v] - c <= q) {
                    count--;
                }
            }

            ans[qi] = count;
        }

        return ans;
    }
}
```



## Complexity
- **Time:**  
  - Degree calculation: O(E)  
  - Sorting: O(N log N)  
  - Two-pointer per query: O(N)  
  - Adjusting with edge map: O(E)  
  - **Total:** O(E + N log N + Q·(N + E)), where Q ≤ 20  

- **Space:** O(N + E) for degrees and edge map.  

---

## Pitfalls
- Must handle multiple edges between the same nodes.  
- Adjust counts carefully to avoid overcounting when shared edges inflate incident counts.  
- Ensure nodes are 1-indexed in input but stored properly in arrays.  
- Large constraints: `n ≤ 2e4`, `edges ≤ 1e5`.  

---

## Example Walkthrough
**Input:**  
`n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]`  

- Degrees:  
  - deg[1] = 3  
  - deg[2] = 4  
  - deg[3] = 2  
  - deg[4] = 1  

- Query = 2 → all 6 pairs valid.  
- Query = 3 → only (3,4) invalid → 5 pairs.  

**Output:** `[6,5]`  

---

## Conclusion
This problem is solved using **degree counting + two-pointer + adjustment for duplicate edges**.  
- Efficient O(E + N log N + Q·(N + E)) solution.  
- Handles large graphs and multiple edges correctly.  


---

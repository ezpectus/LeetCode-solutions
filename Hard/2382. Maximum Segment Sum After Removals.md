# 🔗 LeetCode 2382 — Maximum Segment Sum After Removals (C#)

## 🧩 Problem Overview

You're given:
- `nums`: an array of positive integers
- `removeQueries`: an array of indices to remove from `nums`, one by one

After each removal:
- The array splits into **segments** — contiguous blocks of positive integers
- A segment sum is the sum of all elements in that segment

Return an array `answer` where `answer[i]` is the **maximum segment sum** after the `i`-th removal.

---

## 🧠 Architectural Rationale

### ✅ Reverse Simulation
- Instead of removing elements forward (which fragments segments), we simulate the process **in reverse**
- Start with all elements removed, and **add them back one by one**
- After each addition, merge with neighbors if they’re active

### ✅ Union-Find for Segment Tracking
- Each index is a node
- When adding back an element, we **union** it with adjacent active indices
- Segment sums are tracked per root using `segSum[root]`

### ✅ Timing Correction
- The result for `answer[i]` must reflect the **maximum segment sum before adding back `removeQueries[i]`**
- So we store `answer[i] = currentMax` **before** activating the index

---

## ✅ C# Implementation

```csharp
public class Solution {
    public long[] MaximumSegmentSum(int[] nums, int[] removeQueries) {
        int n = nums.Length;
        long[] res = new long[n];
        long[] segSum = new long[n];
        int[] parent = new int[n];
        bool[] active = new bool[n];

        for (int i = 0; i < n; i++) parent[i] = i;

        long max = 0;

        for (int i = n - 1; i >= 0; i--) {
            res[i] = max;

            int idx = removeQueries[i];
            active[idx] = true;
            segSum[idx] = nums[idx];

            if (idx > 0 && active[idx - 1]) Union(idx, idx - 1, parent, segSum);
            if (idx < n - 1 && active[idx + 1]) Union(idx, idx + 1, parent, segSum);

            max = Math.Max(max, segSum[Find(idx, parent)]);
        }

        return res;
    }

    private int Find(int x, int[] parent) {
        if (parent[x] != x) parent[x] = Find(parent[x], parent);
        return parent[x];
    }

    private void Union(int x, int y, int[] parent, long[] segSum) {
        int px = Find(x, parent);
        int py = Find(y, parent);
        if (px != py) {
            parent[py] = px;
            segSum[px] += segSum[py];
        }
    }
}
```

## ⏱ Time & Space Complexity

| Operation           | Time Complexity     | Space Complexity   | Description                                |
|---------------------|----------------------|---------------------|--------------------------------------------|
| Reverse Simulation  | `O(n)`               | `O(n)`              | One pass through `removeQueries`           |
| Union-Find Ops      | `O(α(n))` per op     | `O(n)`              | Merge segments and track roots             |
| Segment Sum Merge   | `O(1)` per union     | `O(n)`              | Add segment sums during union              |
| **Total**           | `O(n × α(n))`        | `O(n)`              | Efficient for `n ≤ 10⁵`                    |

---

## 🧪 Example Execution

| Input                          | Output         | Explanation                                  |
|--------------------------------|----------------|----------------------------------------------|
| `nums = [1,2,5,6,1]`           | `[14,7,2,2,0]` | Segment merges tracked in reverse            |
| `removeQueries = [0,3,2,4,1]`  |                | Each step reflects max sum before addition   |

---

## ✅ Final Takeaways

- **Reverse simulation avoids fragmentation logic**  
- **Union-Find efficiently tracks connected segments**  
- **Segment sums are merged dynamically**  
- **Timing of result assignment is critical**  
- Fully modular and reusable for dynamic segment tracking problems

---

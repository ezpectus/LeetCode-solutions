# 1521. Find a Value of a Mysterious Function Closest to Target  
*O(n log A) amortized — Greedy Distinct AND Enumeration*

---

## Problem Statement

You are given an integer array `arr` (1 ≤ n ≤ 10⁵, 1 ≤ arr[i] ≤ 10⁶) and an integer `target` (0 ≤ target ≤ 10⁷).

The mysterious function is:

`func(l, r) = arr[l] & arr[l+1] & ... & arr[r]`  
(bitwise AND of subarray from l to r inclusive)

Find the **minimum** possible value of:

`|func(l, r) - target|`  
over all possible subarrays (0 ≤ l ≤ r < n).

Return that minimum difference.

---

## Core Idea — Greedy Enumeration of Distinct AND Values

**Key insight**:
- Bitwise AND of a subarray is **non-increasing** as we extend it (bits can only turn off, never on)
- For each fixed starting index `l`:
  - Start with `current = arr[l]`
  - As `r` increases, `current &= arr[r]` → value only decreases
  - Each time `current` changes, **at least one bit is lost** → at most **30 distinct values** per starting `l` (since max(arr) ≤ 10⁶ < 2³⁰)
- Total distinct AND values across all subarrays is **O(n log A)** amortized
- We just compute `|current - target|` for every distinct AND we encounter and keep the minimum difference

**Why early break works**:
- When `current == 0` → further AND stays 0 → no point continuing (can't get closer to target)

**Time complexity**:
- Outer loop: n iterations
- Inner loop per l: O(log A) amortized (bits drop from 30 to 0)
- Total: **O(n log A)** ≈ 10⁵ × 30 = 3M operations → very fast

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int ClosestToTarget(int[] arr, int target) {
        int n = arr.Length;
        int minDiff = int.MaxValue;
        HashSet<int> visited = new HashSet<int>();

        foreach (int cur in arr) {
            // Update with current single element
            minDiff = Math.Min(minDiff, Math.Abs(target - cur));

            if (minDiff == 0) return 0;
            List<int> tmp = new List<int> { cur };

            // Combine with all previous AND values
            foreach (int prev in visited) {
                int andV = prev & cur;
                minDiff = Math.Min(minDiff, Math.Abs(target - andV));

                if (minDiff == 0) return 0;

                tmp.Add(andV);
            }

            // Update visited with new AND values
            visited = new HashSet<int>(tmp);
        }

        return minDiff;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n log A)** amortized | For each left endpoint l, the inner loop runs O(log A) times (AND loses at least one bit each change, ~30 bits max) → total operations ≈ n × 30 |
| **Space Complexity**  | **O(1)** (second version) or **O(log A)** (first version) | Second version (double loop) uses O(1) space. First version (HashSet) uses O(log A) per iteration for temporary storage |

**Optimal** — O(n log A) amortized is the standard complexity for problems involving enumeration of distinct subarray AND values. Extremely fast for n ≤ 10⁵ (≈ 3 million operations max).

---

## Why This Works — Example Walkthrough

**Example 1**: `arr = [9,12,3,7,15]`, `target = 5`

- l = 0: current = 9 → diff = |9-5| = 4  
  r = 1: 9 & 12 = 8 → diff = |8-5| = 3  
  r = 2: 8 & 3 = 0 → diff = |0-5| = 5 → break (AND = 0)

- l = 1: current = 12 → diff = |12-5| = 7  
  r = 2: 12 & 3 = 0 → diff = 5 → break

- l = 2: current = 3 → diff = |3-5| = 2  
  r = 3: 3 & 7 = 3 → diff = 2  
  r = 4: 3 & 15 = 3 → diff = 2

- l = 3: current = 7 → diff = |7-5| = 2  
  r = 4: 7 & 15 = 7 → diff = 2

- l = 4: current = 15 → diff = |15-5| = 10

**Minimum difference = 2** (achieved by subarrays with AND = 3 or 7) → correct

**Correct** — starting from every possible left endpoint and extending right, we generate **all possible distinct subarray AND values**.  
We update the minimum difference for every AND encountered.  
Early break when AND reaches 0 (further AND stays 0 and cannot improve the result).

---

## Pitfalls & Edge Cases

- **All elements equal** → AND always equals arr[0] → min diff = |arr[0] - target|
- **target = 0** → closest possible is 0 if any subarray AND = 0 (e.g. includes 0 or enough numbers to zero bits), otherwise smallest positive AND
- **n = 1** → only one subarray → |arr[0] - target|
- **Large n (10⁵)** → O(n log A) ≈ 3 million operations → very fast in practice
- **arr[i] = 1** → AND quickly drops to 0 or 1 → inner loops terminate early
- **Negative target** → not possible (target ≥ 0 by constraints)

All handled perfectly.

---

## Key Takeaway

This is a **classic subarray bitwise AND closest to target** problem:

- For each starting index `l`:
  - Initialize `current = arr[l]`
  - Update answer with `|current - target|`
  - Extend right: `current &= arr[r]`
  - Update answer again with new `current`
  - If `current == 0` → break early (further AND stays 0, cannot improve result)

- Total time **O(n log A)** amortized — each starting point generates at most ~30 distinct AND values (one bit lost per change)

**Pure, clean, optimal** — simple double loop with powerful early termination when AND hits 0.

---

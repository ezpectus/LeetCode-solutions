# 3625. Count Number of Trapezoids II

---

## Problem
We are given `points[i] = [xi, yi]` representing coordinates on the plane.  
We need to count the number of **unique trapezoids** formed by choosing any four distinct points.  

- A trapezoid is a convex quadrilateral with **at least one pair of parallel sides**.  
- Two sides are parallel if they have the same slope.  

Constraints:  
- 4 ≤ points.length ≤ 500  
- –1000 ≤ xi, yi ≤ 1000  
- All points are distinct.  

---

## Key Idea
1. **Lines from pairs of points**:  
   - Each trapezoid is defined by two parallel sides.  
   - So we need to consider all possible lines formed by pairs of points.  

2. **Slope and intercept**:  
   - Line slope `k = (y2 - y1) / (x2 - x1)` (vertical lines → slope = INF).  
   - Line intercept uniquely identifies the line position.  

3. **Counting trapezoids**:  
   - Group lines by slope.  
   - Within each slope group, count how many distinct lines exist → possible trapezoid sides.  
   - Use combinatorics to count pairs of parallel lines.  

4. **Correction step**:  
   - Some lines share the same midpoint (they are actually the same line).  
   - Subtract duplicates to avoid overcounting.  

---

## Formulas
- **Slope**:  ```k = (y2 - y1) / (x2 - x1)```
- If `x1 == x2` → vertical line → `k = INF`.

- **Intercept** (for non-vertical lines):  
Derived from line equation `y = kx + b`.  
```b = y1 - k * x1```

- **Midpoint key** (to detect duplicates):  
```midKey = (x1 + x2) * 10000 + (y1 + y2)```


---

## Code (C#)
```csharp
public class Solution {
  public int CountTrapezoids(int[][] points) {
      int n = points.Length;
      double INF = 1e9 + 7;

      // slope -> list of intercepts
      Dictionary<double, List<double>> slopeGroups = new Dictionary<double, List<double>>();
      // midpoint -> list of slopes
      Dictionary<double, List<double>> midpointGroups = new Dictionary<double, List<double>>();

      int trapezoidCount = 0;

      // Build all lines
      for (int i = 0; i < n; i++) {
          int x1 = points[i][0], y1 = points[i][1];
          for (int j = i + 1; j < n; j++) {
              int x2 = points[j][0], y2 = points[j][1];

              double slope, intercept;
              if (x1 == x2) {
                  slope = INF;
                  intercept = x1;
              } else {
                  slope = (double)(y2 - y1) / (x2 - x1);
                  intercept = y1 - slope * x1;
              }

              double midKey = (x1 + x2) * 10000.0 + (y1 + y2);

              if (!slopeGroups.ContainsKey(slope)) slopeGroups[slope] = new List<double>();
              if (!midpointGroups.ContainsKey(midKey)) midpointGroups[midKey] = new List<double>();

              slopeGroups[slope].Add(intercept);
              midpointGroups[midKey].Add(slope);
          }
      }

      // Count trapezoids by slope groups
      foreach (var intercepts in slopeGroups.Values) {
          if (intercepts.Count <= 1) continue;

          Dictionary<double, int> freq = new Dictionary<double, int>();
          foreach (double b in intercepts) {
              freq[b] = freq.GetValueOrDefault(b, 0) + 1;
          }

          int cumulative = 0;
          foreach (int count in freq.Values) {
              trapezoidCount += cumulative * count;
              cumulative += count;
          }
      }

      // Correct duplicates by midpoint groups
      foreach (var slopes in midpointGroups.Values) {
          if (slopes.Count <= 1) continue;

          Dictionary<double, int> freq = new Dictionary<double, int>();
          foreach (double k in slopes) {
              freq[k] = freq.GetValueOrDefault(k, 0) + 1;
          }

          int cumulative = 0;
          foreach (int count in freq.Values) {
              trapezoidCount -= cumulative * count;
              cumulative += count;
          }
      }

      return trapezoidCount;
   }
}
```


## Complexity
- **Time:**  
  - O(n²) to generate all possible lines from point pairs.  
  - O(n²) to count trapezoids by grouping slopes and correcting duplicates.  
  - Overall: O(n²), which is efficient for n ≤ 500.  

- **Space:**  
  - O(n²) for storing line mappings in dictionaries (`slope → intercepts`, `midpoint → slopes`).  

---

## Example Walkthrough

**Input:** `points = [[-3,2],[3,0],[2,3],[3,2],[2,-3]]`  
- Build all lines.  
- Group by slope.  
- Find parallel line pairs.  
- Correct duplicates using midpoint grouping.  
- **Result:** Two trapezoids found.  
- **Output = 2 **

**Input:** `points = [[0,0],[1,0],[0,1],[2,1]]`  
- Build all lines.  
- Group by slope.  
- Only one valid trapezoid exists.  
- **Output = 1 **

---

## Why This Works
1. **Grouping lines by slope**  
   - Parallel sides of trapezoids must share the same slope.  
   - By grouping intercepts under each slope, we can count how many distinct parallel lines exist.  

2. **Counting trapezoids via parallel line pairs**  
   - Within each slope group, every pair of distinct lines can serve as the parallel sides of a trapezoid.  
   - Combinatorial counting (`cumulative * count`) ensures we count all unique pairs.  

3. **Correcting duplicates with midpoint checks**  
   - Some lines are actually the same (they share both slope and midpoint).  
   - Midpoint grouping subtracts these duplicates to avoid overcounting.  

---

## Conclusion
This solution avoids brute force O(n⁴) by:  
- Reducing the problem to **line slope grouping**.  
- Using **combinatorial counting** for parallel line pairs.  
- Applying a **correction step** with midpoints to remove duplicates.  

The algorithm is efficient and works for up to 500 points, making it practical for the given constraints.  

---

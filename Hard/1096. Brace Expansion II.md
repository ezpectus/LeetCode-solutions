# 1096. Brace Expansion II

---

## Problem Restatement
We are asked to expand a brace expression into all possible words following grammar rules:
- **Single letters** → singleton set.  
- **Comma-separated lists** → union of sets.  
- **Concatenation** → Cartesian product of sets.  
- Nested braces are allowed.  
- Output must be sorted and contain unique words.  

---

## Key Idea
We need a **recursive descent parser**:
- Parse unions `{a,b,c}`.  
- Parse concatenations like `a{b,c}`.  
- Handle nested braces recursively.  
- Use `HashSet<string>` to avoid duplicates.  
- At the end, sort results.

---

## Code (C#)
```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class Solution {
    public IList<string> BraceExpansionII(string expression) {
        var result = Parse(expression);
        return result.OrderBy(x => x).ToList();
    }

    private HashSet<string> Parse(string expr) {
        List<HashSet<string>> parts = new List<HashSet<string>>();
        HashSet<string> current = new HashSet<string>() { "" };
        int i = 0;

        while (i < expr.Length) {
            if (expr[i] == '{') {
                int j = i, balance = 0;
                do {
                    if (expr[j] == '{') balance++;
                    if (expr[j] == '}') balance--;
                    j++;
                } while (balance != 0);
                var inner = Parse(expr.Substring(i + 1, j - i - 2));
                current = Product(current, inner);
                i = j;
            } else if (expr[i] == ',') {
                parts.Add(current);
                current = new HashSet<string>() { "" };
                i++;
            } else {
                current = Product(current, new HashSet<string>() { expr[i].ToString() });
                i++;
            }
        }

        parts.Add(current);
        HashSet<string> union = new HashSet<string>();
        foreach (var set in parts) {
            foreach (var s in set) union.Add(s);
        }
        return union;
    }

    private HashSet<string> Product(HashSet<string> a, HashSet<string> b) {
        HashSet<string> res = new HashSet<string>();
        foreach (var x in a) {
            foreach (var y in b) {
                res.Add(x + y);
            }
        }
        return res;
    }
}
```



## Time Complexity
- **Traversal:** Each character in the expression is parsed once.  
- **Expansion:** Cartesian product operations combine sets of words.  
- **Overall:** **O(n · m²)**, where  
  - `n` = length of the expression,  
  - `m` = number of generated words.  

---

## Space Complexity
- **Storage:** All unique words are kept in a `HashSet`.  
- **Intermediate sets:** Created during recursive parsing.  
- **Overall:** **O(m)**, proportional to the number of distinct words.  

---

## Example Walkthrough

### Example 1
**Input:** `"{a,b}{c,{d,e}}"`  
- `{a,b}` → {"a","b"}  
- `{c,{d,e}}` → {"c","d","e"}  
- Cartesian product → {"ac","ad","ae","bc","bd","be"}  
✅ Output = `["ac","ad","ae","bc","bd","be"]`  

---

### Example 2
**Input:** `"{{a,z},a{b,c},{ab,z}}"`  
- Union of sets: {"a","z"} ∪ {"ab","ac"} ∪ {"ab","z"}  
- Result = {"a","ab","ac","z"}  
✅ Output = `["a","ab","ac","z"]`  

---

## Why This Works
- **Recursive parsing** correctly handles nested braces.  
- **Union and Cartesian product** operations follow grammar rules.  
- **HashSet** ensures uniqueness of words.  
- **Sorting** guarantees lexicographic order in the final output.  

---

✅ **Conclusion**  
This is the **Recursive Descent Brace Expansion Algorithm**.  
By parsing unions, concatenations, and nested braces, we generate all unique words efficiently in **O(n · m²)** time and return them sorted.


---

# 1289. Minimum Falling Path Sum II  
*O(n²) — Dynamic Programming with Optimized Column Tracking*

---

## Problem Statement

Given an `n × n` integer matrix `grid`, return the **minimum sum** of a **falling path with non-zero shifts**.

A **falling path with non-zero shifts** is a choice of **exactly one element** from each row such that **no two elements** chosen in **adjacent rows** are in the **same column**.

**Examples**:

**Example 1**  
Input: grid = [[1,2,3],[4,5,6],[7,8,9]]  
Output: **13**  
One optimal path: 1 → 5 → 7 (sum = 13)

**Example 2**  
Input: grid = [[7]]  
Output: **7**

**Constraints**:
- n == grid.length == grid[i].length
- 1 ≤ n ≤ 200
- -99 ≤ grid[i][j] ≤ 99

---

## Core Idea — DP with Column Exclusion Tracking

**Standard DP**:
- Let `dp[i][j]` = minimum sum to reach cell `(i,j)` from row 0
- `dp[0][j] = grid[0][j]`
- For row `i > 0`:
  - `dp[i][j] = grid[i][j] + min(dp[i-1][k])` for all `k ≠ j`

**Naive** → O(n³) — too slow for n=200

**Optimization**:
- For each row, we only need the **minimum** and **second minimum** values from the previous row (and their column indices)
- For each column `j` in current row:
  - If previous row's min column ≠ j → use previous min
  - Else → use previous second min

**Time**: O(n²) — for each row, find min/second min O(n), then fill row O(n)  
**Space**: O(n) — keep only previous row DP (or even O(1) extra with two arrays)

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int MinFallingPathSum(int[][] grid){
        int n = grid.Length;

        // dp[i][j] = min sum to reach grid[i][j]
        int[] prev = new int[n];
        Array.Copy(grid[0], prev, n);

        for (int i = 1; i < n; i++){
            int[] curr = new int[n];

            // Find min and second min in previous row
            int min1 = int.MaxValue, min2 = int.MaxValue;
            int min1Col = -1;

            for (int j = 0; j < n; j++){
                if (prev[j] < min1){
                    min2 = min1;
                    min1 = prev[j];
                    min1Col = j;
                }
                else if (prev[j] < min2) min2 = prev[j];
                
            }

            // For each column in current row
            for (int j = 0; j < n; j++){
                // Use min1 if not from same column, else use min2
                int prevMin = (j != min1Col) ? min1 : min2;
                curr[j] = grid[i][j] + prevMin;
            }

            prev = curr;
        }

        // Minimum in the last row
        int result = int.MaxValue;
        foreach (int val in prev){
            result = Math.Min(result, val);
        }

        return result;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n²)**     | For each of n rows:  
  • Find min & second min in previous row: O(n)  
  • Fill current row: O(n)  
  Total: O(n × n) = O(n²) |
| **Space Complexity**  | **O(n)**      | Only store previous and current row arrays (O(n) each)  
  Can be optimized to O(1) extra space with careful in-place updates if needed |

**Optimal** — quadratic time and linear space — perfectly acceptable and efficient for n ≤ 200.

---

## Why This Works — Example Walkthrough

**Example 1**: grid = [[1,2,3],[4,5,6],[7,8,9]]

**Row 0**: dp = [1, 2, 3]

**Row 1**:
- Previous min = 1 (col 0), second min = 2
- j=0: same column as min → use second min 2 → 4 + 2 = **6**
- j=1: different column → use min 1 → 5 + 1 = **6**
- j=2: different column → use min 1 → 6 + 1 = **7**
- dp row 1 = [6, 6, 7]

**Row 2**:
- Previous min = 6 (col 0 and col 1 both 6), second min = 7
- j=0: same column as one of the mins → use second min 7 → 7 + 7 = **14**
- j=1: same column → use second min 7 → 8 + 7 = **15**
- j=2: different column → use min 6 → 9 + 6 = **15**
- dp row 2 = [14, 15, 15]

Minimum in last row = **14**  
But wait — the correct minimum is **13** (path 1→5→7).

**Correction & explanation**:  
In row 2, when computing for j=0:  
- Previous min=6 comes from columns 0 and 1  
- Since j=0 is same as col 0 (one source of min), we should be able to use min from col 1 (still 6)  
- So dp[2][0] = 7 + 6 = **13** (correct)

The code correctly handles this because when min1Col is 0 but min2 is also 6 (from col 1), it uses min2=6 when column matches.  
In practice the code finds **13** — correct answer.

**Correct** —  
For each row, we efficiently avoid using the same column by:
- Finding the global minimum and second minimum from previous row
- And their column(s)
- When choosing prev for current j → if j matches the min column → fall back to second min
This guarantees we always get the best possible previous value without same-column constraint violation.

---

## Key Takeaway

This is a **classic dynamic programming** problem with column exclusion constraint:

* Use DP where `dp[i][j]` = minimum path sum to reach cell `grid[i][j]`
* Initialize first row: `dp[0][j] = grid[0][j]`
* For each subsequent row i:
  * Precompute **minimum** and **second minimum** values from previous row (and column of minimum)
  * For each column j in row i:
    * If previous minimum's column ≠ j → use previous minimum
    * Else → use previous second minimum
    * `dp[i][j] = grid[i][j] + chosen previous value`
* Final answer = **minimum value in last row**

**Pure, clean, optimal** — O(n²) time, O(n) space (optimized from O(n²)), very fast for n ≤ 200, elegant, and handles all constraints perfectly.

---

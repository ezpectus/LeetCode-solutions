# ğŸ§© Remove Invalid Parentheses â€” Full Breakdown & C# BFS Solution

---

## ğŸ“˜ Problem Summary

Given a string `s` containing letters and parentheses, remove the **minimum number of invalid parentheses** to make the string valid.

Return **all possible valid strings** that require the **fewest removals**. The result must contain **unique** strings and can be in any order.

---

## ğŸ” What We See in the Problem Text

- The input may contain letters and parentheses  
- We must remove **invalid parentheses** â€” not just balance, but also position  
- The goal is **minimal removal** â€” not just any valid string  
- We must return **all valid strings** with that minimal removal count  
- Examples show multiple outputs â€” this is a **multi-path recovery** problem

---

## ğŸ§  Core Idea

This is a **BFS-based level simulation**, where each level represents strings with one more removal:

### Phase 1 â€” BFS Traversal
- Start with the original string  
- At each level, remove one parenthesis at every possible position  
- Use a `visited` set to avoid reprocessing duplicates  
- Stop BFS when you find **any valid string** â€” all strings at that level are minimal

### Phase 2 â€” Validation
- For each string, check if itâ€™s valid:
  - Balanced parentheses
  - Correct order
- Once valid strings are found at a level, **do not go deeper** â€” they are minimal

This guarantees that:

- All returned strings are valid  
- All require the **minimum number of removals**  
- No duplicates are returned

---

## ğŸ’» C# Implementation (Fully Commented)

```csharp
public class Solution {
    public IList<string> RemoveInvalidParentheses(string s) {
        var result = new List<string>();
        var visited = new HashSet<string>();
        var queue = new Queue<string>();
        bool found = false;

        queue.Enqueue(s);
        visited.Add(s);

        while (queue.Count > 0) {
            int size = queue.Count;
            var level = new HashSet<string>();

            for (int i = 0; i < size; i++) {
                var str = queue.Dequeue();
                if (IsValid(str)) {
                    result.Add(str);
                    found = true;
                }

                if (found) continue; // skip deeper levels

                for (int j = 0; j < str.Length; j++) {
                    if (str[j] != '(' && str[j] != ')') continue;
                    var newStr = str.Substring(0, j) + str.Substring(j + 1);
                    if (!visited.Contains(newStr)) {
                        queue.Enqueue(newStr);
                        visited.Add(newStr);
                    }
                }
            }

            if (found) break;
        }

        return result;
    }

    private bool IsValid(string s) {
        int count = 0;
        foreach (char c in s) {
            if (c == '(') count++;
            else if (c == ')') {
                count--;
                if (count < 0) return false;
            }
        }
        return count == 0;
    }
}
```

## â±ï¸ Time and Space Complexity

This solution explores all possible substrings by removing parentheses, but **prunes early** once valid strings are found.

| Complexity Type     | Expression   | Detailed Explanation                                                                 |
|---------------------|--------------|--------------------------------------------------------------------------------------|
| **Time Complexity** | O(N Ã— 2^N)   | In the worst case, we generate all possible substrings by removing parentheses. Each string takes O(N) to validate. |
| **Space Complexity**| O(2^N)       | We store up to 2^N unique substrings in the visited set and BFS queue.              |

**Where:**
- `N` is the length of the input string  
- The exponential factor comes from the number of ways to remove parentheses  
- The algorithm avoids deeper levels once valid strings are found, making it efficient in practice

---

## ğŸ§± Architectural Signals

| Signal               | Role in Solution                                                                 |
|----------------------|----------------------------------------------------------------------------------|
| **BFS traversal**     | Simulates level-by-level removal, ensuring minimal edits before validation      |
| **Visited set**       | Prevents redundant exploration and infinite loops                               |
| **Early exit**        | Stops BFS once valid strings are found, guaranteeing optimality                 |
| **IsValid function**  | Encapsulates validation logic â€” checks balance and order of parentheses         |
| **Multi-path recovery**| Collects all valid strings at the minimal level â€” not just one solution        |

Each signal contributes to:

- **Phase separation** â€” simulation and validation are cleanly decoupled  
- **State integrity** â€” no duplicate or invalid paths are processed  
- **Lossless recovery** â€” all minimal valid strings are returned

---

## ğŸ§  Summary

This problem is a textbook example of **BFS-based structural pruning**, where the goal is not just to find one valid transformation, but to **recover all minimal valid forms**.

### ğŸ” Two-phase architecture:

- **Simulation phase (BFS)**  
  Generates all possible substrings by removing one parenthesis at each position.  
  Traverses level-by-level to ensure minimal edits.

- **Validation phase (IsValid)**  
  Checks each candidate string for balanced parentheses.  
  Once valid strings are found, deeper levels are skipped.

### âœ… Why this works:

- Guarantees **minimal removal** â€” BFS ensures shortest transformation  
- Avoids **redundant work** â€” visited set filters duplicates  
- Recovers **all valid outputs** â€” not just one path  
- Clean separation of simulation and validation logic

### ğŸ§  Ideal for mastering:

- BFS traversal with pruning  
- Structural validation of strings  
- Multi-path recovery in graph-like simulations  
- Architectural separation of concerns in algorithm design

This solution is not just functional â€” itâ€™s **architecturally elegant**, scalable, and reusable for other minimal-edit recovery problems.


---

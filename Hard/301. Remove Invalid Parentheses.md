# 🧩 Remove Invalid Parentheses — Full Breakdown & C# BFS Solution

---

## 📘 Problem Summary

Given a string `s` containing letters and parentheses, remove the **minimum number of invalid parentheses** to make the string valid.

Return **all possible valid strings** that require the **fewest removals**. The result must contain **unique** strings and can be in any order.

---

## 🔍 What We See in the Problem Text

- The input may contain letters and parentheses  
- We must remove **invalid parentheses** — not just balance, but also position  
- The goal is **minimal removal** — not just any valid string  
- We must return **all valid strings** with that minimal removal count  
- Examples show multiple outputs — this is a **multi-path recovery** problem

---

## 🧠 Core Idea

This is a **BFS-based level simulation**, where each level represents strings with one more removal:

### Phase 1 — BFS Traversal
- Start with the original string  
- At each level, remove one parenthesis at every possible position  
- Use a `visited` set to avoid reprocessing duplicates  
- Stop BFS when you find **any valid string** — all strings at that level are minimal

### Phase 2 — Validation
- For each string, check if it’s valid:
  - Balanced parentheses
  - Correct order
- Once valid strings are found at a level, **do not go deeper** — they are minimal

This guarantees that:

- All returned strings are valid  
- All require the **minimum number of removals**  
- No duplicates are returned

---

## 💻 C# Implementation (Fully Commented)

```csharp
public class Solution {
    public IList<string> RemoveInvalidParentheses(string s) {
        var result = new List<string>();
        var visited = new HashSet<string>();
        var queue = new Queue<string>();
        bool found = false;

        queue.Enqueue(s);
        visited.Add(s);

        while (queue.Count > 0) {
            int size = queue.Count;
            var level = new HashSet<string>();

            for (int i = 0; i < size; i++) {
                var str = queue.Dequeue();
                if (IsValid(str)) {
                    result.Add(str);
                    found = true;
                }

                if (found) continue; // skip deeper levels

                for (int j = 0; j < str.Length; j++) {
                    if (str[j] != '(' && str[j] != ')') continue;
                    var newStr = str.Substring(0, j) + str.Substring(j + 1);
                    if (!visited.Contains(newStr)) {
                        queue.Enqueue(newStr);
                        visited.Add(newStr);
                    }
                }
            }

            if (found) break;
        }

        return result;
    }

    private bool IsValid(string s) {
        int count = 0;
        foreach (char c in s) {
            if (c == '(') count++;
            else if (c == ')') {
                count--;
                if (count < 0) return false;
            }
        }
        return count == 0;
    }
}
```

## ⏱️ Time and Space Complexity

This solution explores all possible substrings by removing parentheses, but **prunes early** once valid strings are found.

| Complexity Type     | Expression   | Detailed Explanation                                                                 |
|---------------------|--------------|--------------------------------------------------------------------------------------|
| **Time Complexity** | O(N × 2^N)   | In the worst case, we generate all possible substrings by removing parentheses. Each string takes O(N) to validate. |
| **Space Complexity**| O(2^N)       | We store up to 2^N unique substrings in the visited set and BFS queue.              |

**Where:**
- `N` is the length of the input string  
- The exponential factor comes from the number of ways to remove parentheses  
- The algorithm avoids deeper levels once valid strings are found, making it efficient in practice

---

## 🧱 Architectural Signals

| Signal               | Role in Solution                                                                 |
|----------------------|----------------------------------------------------------------------------------|
| **BFS traversal**     | Simulates level-by-level removal, ensuring minimal edits before validation      |
| **Visited set**       | Prevents redundant exploration and infinite loops                               |
| **Early exit**        | Stops BFS once valid strings are found, guaranteeing optimality                 |
| **IsValid function**  | Encapsulates validation logic — checks balance and order of parentheses         |
| **Multi-path recovery**| Collects all valid strings at the minimal level — not just one solution        |

Each signal contributes to:

- **Phase separation** — simulation and validation are cleanly decoupled  
- **State integrity** — no duplicate or invalid paths are processed  
- **Lossless recovery** — all minimal valid strings are returned

---

## 🧠 Summary

This problem is a textbook example of **BFS-based structural pruning**, where the goal is not just to find one valid transformation, but to **recover all minimal valid forms**.

### 🔁 Two-phase architecture:

- **Simulation phase (BFS)**  
  Generates all possible substrings by removing one parenthesis at each position.  
  Traverses level-by-level to ensure minimal edits.

- **Validation phase (IsValid)**  
  Checks each candidate string for balanced parentheses.  
  Once valid strings are found, deeper levels are skipped.

### ✅ Why this works:

- Guarantees **minimal removal** — BFS ensures shortest transformation  
- Avoids **redundant work** — visited set filters duplicates  
- Recovers **all valid outputs** — not just one path  
- Clean separation of simulation and validation logic

### 🧠 Ideal for mastering:

- BFS traversal with pruning  
- Structural validation of strings  
- Multi-path recovery in graph-like simulations  
- Architectural separation of concerns in algorithm design

This solution is not just functional — it’s **architecturally elegant**, scalable, and reusable for other minimal-edit recovery problems.


---

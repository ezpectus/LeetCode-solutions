# Problem: Maximum Number of Visible Points
Number: LeetCode 1610
Difficulty: Hard Language: C++

## What We're Given
We’re given:

- A list of 2D points: points[i] = [xi, yi]
- A fixed observer location: location = [x, y]
- A viewing angle in degrees: angle
- The observer stands at location, facing east by default.
- They cannot move, but they can rotate freely. 
- Their field of view is a cone of width angle, centered on any direction they choose. 
- Our goal is to compute the maximum number of points visible from this location within any rotation.

## Problem Interpretation
From the constraints and setup, we extract:

- Visibility is determined by the angle between each point and the east direction
- The observer can rotate freely, but the field of view is fixed
- Points exactly at the observer’s location are always visible
- Points do not block each other — no occlusion

## Algorithmic Strategy
- This is a classic geometry + sliding window problem. 
- We reduce the 2D spatial layout to a 1D list of angles and apply a greedy window search.

## Key Steps
 Angle Mapping:
- For each point, compute its angle relative to the observer using atan2(dy, dx)
- Normalize all angles to [0, 360)
- Count points at the observer’s location separately

Circular Extension:
- Sort the angle list
- Duplicate each angle by adding +360 to simulate circular wraparound

Sliding Window:
- Use two pointers (left, right) to maintain a window of angles within angle degrees
- Track the maximum number of points inside the window

Final Result:
- Return max_window_size + same_location_count

## Core Idea
- The problem reduces to computing the angular position of each point relative to the observer. 
- By converting 2D coordinates into angles using atan2, we transform the spatial layout into a 1D list of directions. 
- To account for circular rotation (e.g., visibility from 350° to 10°), we extend the angle list by duplicating each value with +360. 
- This allows a standard sliding window to scan for the largest group of points that fit within the given field of view. 
- Points located exactly at the observer’s position are handled separately, as they are always visible.
- This is a top-down geometric decomposition — clean, efficient, and reusable.

## Step-by-Step Construction
1. Compute Angles
```cpp
double theta = atan2(dy, dx) * 180.0 / M_PI;
if (theta < 0) theta += 360.0;
```

2. Sort and Duplicate
   
```cpp
sort(angles.begin(), angles.end());
for (int i = 0; i < n; ++i)
    angles.push_back(angles[i] + 360.0);
   ```

3. Sliding Window
```cpp
while (angles[right] - angles[left] > angle)
    left++;
max_visible = max(max_visible, right - left + 1);
```

4. Return Result
```cpp
return max_visible + same;
```

## C++ Full Code
```cpp
class Solution {
public:
    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {
        vector<double> angles;
        int same = 0;

        for (auto& p : points) {
            int dx = p[0] - location[0];
            int dy = p[1] - location[1];
            if (dx == 0 && dy == 0) {
                same++;
                continue;
            }
            double theta = atan2(dy, dx) * 180.0 / M_PI;
            if (theta < 0) theta += 360.0;
            angles.push_back(theta);
        }

        sort(angles.begin(), angles.end());
        int n = angles.size();
        for (int i = 0; i < n; ++i)
            angles.push_back(angles[i] + 360.0);

        int max_visible = 0;
        int left = 0;
        for (int right = 0; right < angles.size(); ++right) {
            while (angles[right] - angles[left] > angle)
                left++;
            max_visible = max(max_visible, right - left + 1);
        }

        return max_visible + same;
    }
};
  ```

 
##  Complexity Analysis

- Time	O(n log n)
- Space	O(n)
- Sorting angles takes O(n log n)
- Sliding window runs in linear time over 2n elements
- Space used for angle list and duplicates

## Why It Works

- atan2 gives precise direction from observer to point
- Normalization ensures consistent comparisons
- Duplicating angles handles circular wraparound
- Sliding window finds densest cluster within angle
- Points at the same location are always visible

## Patterns Used
- Geometry → angle computation
- Normalization → [0, 360)
- Circular simulation → angle duplication
- Sliding window → max count in fixed range
- Greedy tracking → optimal rotation



---

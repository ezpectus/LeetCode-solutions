# ðŸ“Š 480. Sliding Window Median

## ðŸ“˜ Problem Summary  
You're given an array `nums` and an integer `k`.  
A sliding window of size `k` moves from left to right across the array.  
At each step, you must return the **median** of the current window.

- If `k` is odd â†’ median is the middle element  
- If `k` is even â†’ median is the average of the two middle elements  
Answers within `1e-5` of the true value are accepted.

---

## ðŸ§  Why This Approach Works

This is a **dynamic order-statistics** problem:  
You need to maintain a window of `k` elements and quickly find the median after each move.

### âœ… Challenges:
- You must **insert** and **remove** elements efficiently  
- You must **keep the window sorted** to access the median  
- You must do this for up to `10^5` elements â€” brute force won't work

### âœ… Solution Strategy:
- Use a **sorted list** to represent the current window  
- Use **binary search** to insert new elements in order  
- Remove the outgoing element directly  
- Compute the median from the middle index(es)

This approach gives you **O(log k)** insertions and deletions, and **O(1)** median access.

---

## ðŸ”§ C# Implementation

```csharp
public class Solution {
    public double[] MedianSlidingWindow(int[] nums, int k) {
        int n = nums.Length;
        double[] res = new double[n - k + 1];
        List<int> list = new List<int>(nums.Take(k).OrderBy(x => x));

        res[0] = k % 2 == 0
            ? ((double)list[k / 2 - 1] + (double)list[k / 2]) / 2
            : (double)list[k / 2];

        for (int i = 1; i <= n - k; i++) {
            int left = nums[i - 1];
            int right = nums[i + k - 1];

            list.Remove(left);
            int j = list.BinarySearch(right);
            if (j < 0) j = ~j;
            list.Insert(j, right);

            res[i] = k % 2 == 0
                ? ((double)list[k / 2 - 1] + (double)list[k / 2]) / 2
                : (double)list[k / 2];
        }

        return res;
    }
}
```
## ðŸ“¶ Signal Table

| Signal           | Meaning                                         |
|------------------|-------------------------------------------------|
| `list`           | Sorted window of size `k`                       |
| `BinarySearch`   | Finds correct position to insert new element    |
| `Remove(left)`   | Removes outgoing element from window            |
| `Insert(j, right)` | Inserts incoming element in sorted order     |
| `res[i]`         | Median of current window                        |

---

## âœ… Takeaways

- Youâ€™re building a **real-time median tracker**
- Sorted list + binary search gives you **clean control** over window state
- This pattern is useful for:
  - Sliding window statistics  
  - Real-time analytics  
  - Median-of-stream problems
- You avoid full re-sorting by maintaining order incrementally

---

## ðŸ§© Conclusion

This solution models the sliding window using a sorted list and updates it efficiently at each step.  
It avoids brute force and leverages binary search for fast insertions.  
The median is accessed directly from the middle index(es), making the approach both **accurate** and **scalable**.  
This is a classic example of **windowed order-statistics**, and the pattern generalizes to other problems involving **dynamic aggregates**.


---

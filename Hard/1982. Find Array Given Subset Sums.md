# Leetcode 1982 â€” Recover Array from Subset Sums

## ğŸ§© Problem Description

You're given an integer `n` and an array `sums` of length `2^n`. This array represents all possible subset sums of an unknown array `arr` of length `n`. The subset sums are unordered and may contain duplicates.

Your task is to **recover the original array `arr`**.

---

## ğŸ“Œ Constraints

- `1 <= n <= 15`
- `sums.length == 2^n`
- `-10^4 <= sums[i] <= 10^4`

---

## ğŸ” What This Implies

Given the constraints, we know:

- The input size grows exponentially: `sums.length = 2^n`
- For `n = 15`, `sums.length = 32,768`
- Brute-force reconstruction of `arr` is infeasible
- We must use **structure-aware algorithms** that avoid full enumeration

---

## ğŸ§  Algorithmic Options Based on Constraints

From the problem structure and constraints, we can consider:

- **Pairing-based recovery**: Each element in `arr` contributes to half of the subset sums. We can extract elements by identifying the smallest difference between sorted sums.
- **Bitmask subset search**: After recovering absolute values, we can use bitmasking to find a subset whose sum equals `-min(sums)` and flip signs accordingly.
- **Meet-in-the-middle (MIM)**: Split `res` into halves and search for matching subset sums using dictionaries.
- **DFS/backtracking**: Not viable in C# due to recursion depth and lack of native multiset.
- **Zero-shift tracking**: A deterministic method that avoids subset search entirely by tracking how the zero-sum subset shifts as elements are extracted.

---

## ğŸ§± Explored Ideas

### 1. Bitmask Recovery

- Extract absolute values via pairing
- Use bitmask to find subset summing to `-min(sums)`
- âœ… Simple
- âŒ Breaks at `n = 15` due to `2^n` masks

### 2. Meet-in-the-Middle (MIM)

- Split `res` into halves
- Generate all subset sums for each half
- Match combinations that sum to `-min(sums)`
- âœ… Reduces complexity to `O(2^(n/2))`
- âŒ Still unstable on dense inputs

### 3. Sign Recovery via Subset Search

- Build `res`, then search for subset summing to `-min(sums)`
- Flip signs accordingly
- âœ… Stable for `n <= 14`
- âŒ Breaks at `n = 15`

---

## âœ… Final Method â€” Zero-Shift Tracking

Instead of searching for subsets, we track how the zero-sum subset shifts as we extract elements.

### ğŸ” Key Insight

- The empty subset always sums to zero
- As we extract elements, this zero-sum subset gets shifted by the cumulative sum of recovered elements
- By observing where the zero appears in the sorted subset sums, we can infer the sign of the current element

### ğŸ§  How It Works

1. Sort `sums`
2. Extract `diff = sums[1] - sums[0]`
3. For each `x`, pair it with `x + diff`
4. Track the position of the zero-sum subset (`zeroShift`)
5. If it's in the second half â†’ current element is negative
6. If it's in the first half â†’ current element is positive
7. Repeat `n` times, shrinking the array by half each time

---

## ğŸ’» Final C# Implementation

```csharp
public class Solution {
    public int[] RecoverArray(int n, int[] sums) {
        Array.Sort(sums);
        int m = sums.Length;
        int zeroShift = 0;
        int[] res = new int[n];

        for (int i = 0; i < n; ++i) {
            int diff = sums[1] - sums[0];
            int zpos = m;

            int[] temp = new int[m];
            Array.Copy(sums, temp, m);
            Array.Sort(temp);

            Dictionary<int, int> count = new Dictionary<int, int>();
            foreach (int x in temp) {
                if (!count.ContainsKey(x)) count[x] = 0;
                count[x]++;
            }

            int p = 0;
            foreach (int x in temp) {
                if (count[x] == 0) continue;
                count[x]--;
                int y = x + diff;
                count[y]--;
                if (x == zeroShift) zpos = p;
                sums[p++] = y;
            }

            if (zpos >= m / 2) {
                res[i] = -diff;
            } else {
                res[i] = diff;
                zeroShift += diff;
            }

            m /= 2;
        }

        return res;
    }
}

```

## ğŸ§± Alternative Architectures Explored

### 1. Bitmask Recovery

After extracting absolute values via pairing, we used a bitmask to find a subset whose sum equals `-min(sums)`. This approach works well for small `n`, as it checks all `2^n` subsets and flips signs accordingly.

- âœ… Simple to implement
- âŒ Breaks at `n = 15` due to `2^15 = 32,768` masks
- âŒ Causes timeouts in C# due to slower dictionary access and lack of low-level control

### 2. Meet-in-the-Middle (MIM)

We split the recovered array `res` into two halves and generated all subset sums for each half. By storing one half in a dictionary and scanning the other, we searched for combinations that sum to `-min(sums)`.

- âœ… Reduces complexity to `O(2^(n/2))`
- âŒ Still struggles with dense or repetitive `sums` arrays
- âŒ Memory overhead becomes significant at `n = 15`
- âŒ Matching subset sums may not be unique, leading to instability

### 3. Sign Recovery via Subset Search

After building `res`, we searched for a subset whose sum equals `-min(sums)` and flipped the signs of those elements. This is a direct and intuitive method, but still requires full subset enumeration.

- âœ… Stable for `n <= 14`
- âŒ Requires `O(2^n)` time
- âŒ Breaks under `n = 15` due to exponential growth
- âŒ Not viable in C# without aggressive optimization

### 4. Zero-Shift Tracking (Final Solution)

Instead of searching for subsets, we tracked how the zero-sum subset shifts as we extract elements. This method avoids recursion, bitmasking, and subset search entirely. 
It uses a pairing difference (`diff`) and monitors the position of the zero element to infer sign.

- âœ… Passes all tests up to `n = 15` in C#
- âœ… Matches or exceeds Java performance
- âœ… Clean, iterative, and publishable
- âœ… No recursion, no subset search, no memory explosion

---

## âš ï¸ Why DFS Fails in C#

In C++, recursive DFS with STL multiset and pointer arithmetic can be optimized to pass `n = 15`. But in C#:

- âŒ Recursion depth is limited
- âŒ Dictionary operations are heavier than `unordered_map`
- âŒ No native `multiset`
- âŒ No pointer-level control or stack tuning

Thus, DFS-based solutions often hit **stack overflow** or **timeouts** in C#, even if they pass in C++.

---

## ğŸ§  Architectural Takeaway

> The key to solving `RecoverArray` is not brute force, but understanding the structure of subset sums. Whether through pairing, bitmasking, or zero-shift tracking, the goal is to extract elements and signs without full enumeration.

This problem rewards architectural thinking â€” not just clever code. The final solution demonstrates how tracking invariants (like zero-shift) can outperform brute-force search, especially in constrained environments like C#.


---

# 987. Vertical Order Traversal of a Binary Tree — Architectural DFS + Sorting Solution  
*O(n log n) — Precise Column Grouping*

---

## Problem Summary

Given the root of a binary tree, return the **vertical order traversal**:

- Each node has coordinates:  
  - Root: `(row=0, col=0)`  
  - Left child: `(row+1, col-1)`  
  - Right child: `(row+1, col+1)`

**Rules**:
- Group nodes by **column** (left to right)
- Within each column → sort by **row ascending**
- If same `(row, col)` same → sort by **value ascending**

Return list of columns from leftmost to rightmost.

---

## Core Idea — DFS + Coordinate Tracking

We **don’t** use level-order tricks.

Instead:
- Perform **DFS** and record `(row, col, val)` for every node
- Group by `col`
- Sort each group by `(row, val)`
- Output columns in **sorted column order**

**Clean. Precise. No edge-case hacks.**

---

## Full Implementation (C#)

```csharp
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution 
{
    public IList<IList<int>> VerticalTraversal(TreeNode root) 
    {
        var nodes = new List<(int row, int col, int val)>();
        DFS(root, 0, 0, nodes);

        // Group by column
        var colMap = new Dictionary<int, List<(int row, int val)>>();
        foreach (var (row, col, val) in nodes) 
        {
            if (!colMap.ContainsKey(col))
                colMap[col] = new List<(int, int)>();
            colMap[col].Add((row, val));
        }

        // Sort columns left to right
        var sortedCols = colMap.Keys.OrderBy(c => c).ToList();
        var result = new List<IList<int>>();

        foreach (int col in sortedCols) 
        {
            var list = colMap[col];
            // Sort by row asc, then value asc
            list.Sort((a, b) => 
            {
                if (a.row != b.row) return a.row.CompareTo(b.row);
                return a.val.CompareTo(b.val);
            });
            result.Add(list.Select(x => x.val).ToList());
        }

        return result;
    }

    private void DFS(TreeNode node, int row, int col, List<(int, int, int)> nodes) 
    {
        if (node == null) return;
        nodes.Add((row, col, node.val));
        DFS(node.left,  row + 1, col - 1, nodes);
        DFS(node.right, row + 1, col + 1, nodes);
    }
}
```

## Complexity

| **Metric**     | **Value**       | **Notes**                                      |
|----------------|-----------------|------------------------------------------------|
| **Time**       | **O(n log n)**  | Sorting per column (worst: all in one column)      |
| **Space**      | **O(n)**        | Store all nodes + dictionary                   |

---

## Pitfalls

- Must sort by **row first**, then **value** — order is strict
- Columns must be output **left to right** → sort column keys
- Handle same `(row, col)` ties correctly → sort by value
- Do **not** sort by value before row — breaks spec

---

## Edge Cases

- **Single node** → `[[val]]`
- **Perfectly balanced tree** → symmetric columns
- **Multiple nodes at same (row, col)** → sorted by value
- **Skewed tree** → wide column spread (many columns)
- **All nodes in one column** → full sort by row and value

---

## Sanity Checks

- Input: `[3,9,20,null,null,15,7]` → Output: `[[9],[3,15],[20],[7]]`
- Input: `[1,2,3,4,5,6,7]` → Output: `[[4],[2],[1,5,6],[3],[7]]`
- Input: `[1,2,3,4,6,5,7]` → Output: `[[4],[2],[1,5,6],[3],[7]]`

---

## Key Takeaway

This is a **DFS + coordinate tracking + sorting** problem:

- Record `(row, col, val)` during DFS
- Group by **column**
- Sort each group by **row → value**
- Output columns in **sorted order**
**Efficient, clean, O(n log n) solution** — no tricks, just **pure correctness**.

---

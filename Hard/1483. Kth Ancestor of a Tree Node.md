# Problem: Kth Ancestor of a Tree Node  
## Number: LeetCode 1483  
**Difficulty**: Hard  
**Language**: C++  

---

## Detailed Explanation

This problem requires answering multiple queries of the form:  
**"What is the k-th ancestor of node `v` in a rooted tree?"**

A naive approach would walk up the tree `k` times per query, resulting in `O(k)` time per query — too slow for large `k` or many queries.

To optimize, we use **binary lifting**, a preprocessing technique that allows jumping to the `2^j`-th ancestor of any node in constant time.

### Core Idea

- For each node `v`, we precompute its ancestors at distances `2^0`, `2^1`, ..., `2^15`.
- This allows us to answer any query `getKthAncestor(v, k)` by decomposing `k` into powers of two and jumping accordingly.
- For example, to find the 13-th ancestor, we jump via `2^0`, `2^2`, and `2^3`.

### Preprocessing

- Build a table `v[node][j]` where `v[i][j]` stores the `2^j`-th ancestor of node `i`.
- Initialize `v[i][0] = parent[i]`.
- For each `j > 0`, compute:
  - `v[i][j] = v[v[i][j-1]][j-1]` if `v[i][j-1] ≠ -1`

### Querying

- For each bit set in `k`, jump to the corresponding ancestor:
  - If the `j`-th bit of `k` is set, move to `v[node][j]`
- Stop early if `node == -1` (no ancestor exists)

This reduces query time to `O(log k)`.

---

## Code

```cpp
class TreeAncestor {
public:
    vector<vector<int>> v;
    int nodes;

    TreeAncestor(int n, vector<int>& parent) {
        v.resize(n, vector<int>(16, -1)); // 2^16 > 50000
        nodes = n;

        // Initialize immediate parent
        for (int i = 0; i < n; i++) {
            v[i][0] = parent[i];
        }

        // Precompute 2^j-th ancestors
        for (int j = 1; j < 16; j++) {
            for (int i = 0; i < n; i++) {
                if (v[i][j - 1] != -1) {
                    v[i][j] = v[v[i][j - 1]][j - 1];
                }
            }
        }
    }

    int getKthAncestor(int node, int k) {
        if (k >= nodes || node < 0) return -1;

        int x = 0;
        while (k > 0 && node != -1) {
            if (k % 2 == 1) {
                node = v[node][x];
            }
            x++;
            k >>= 1;
        }
        return node;
    }
};
```


## Complexity Analysis

**Preprocessing Time**  
`O(n log n)` — Each node stores up to `log n` ancestors.  
We iterate over `j = 1 to log n` and for each `j`, compute `up[node][j]` using `up[node][j - 1]`.  
This results in `n * log n` total operations.

**Query Time**  
`O(log k)` — Each query decomposes `k` into powers of two.  
For each bit set in `k`, we jump to the corresponding ancestor using `up[node][j]`.  
At most `log k` jumps are performed.

**Space Complexity**  
`O(n log n)` — The ancestor table stores up to `log n` entries for each of the `n` nodes.  
This allows constant-time access to any `2^j`-th ancestor.

---

## Notes

- The constant `16` is chosen because `2^16 = 65536`, which safely covers all possible values of `k` up to `50000` (as per constraints).
- This binary lifting structure is highly reusable for:
  - K-th ancestor queries
  - Lowest Common Ancestor (LCA) problems
  - Jumping across tree paths in logarithmic time
- The method is purely functional and does not rely on recursion or dynamic tree updates.
- It is especially effective in static trees with many ancestor queries.



---

## If this solution helped you or clarified the idea — feel free to ⭐️ the repo or leave a 👍.  I build these patterns for clarity, reuse, and architectural depth — every signal helps refine the system.


---

# Pattern: Greedy Lexicographic Path via Combinatorics

##  Problem Statement
You're given:

- A destination point (row, col)
- An integer k — the 1-indexed lexicographic rank
- Bob starts at (0, 0) and can only move:
- 'H' → right
- 'V' → down
- You must construct the k-th lexicographically smallest instruction string that leads Bob to (row, col).

## Architectural Idea
- This is a greedy combinatoric path construction problem. Instead of generating all paths, we simulate the lexicographic order using binomial coefficients.

Key insight:

- At each step, we can choose 'H' or 'V'
- The number of paths starting with 'H' is C(row + col - 1, col - 1)
- If k ≤ count → choose 'H'
- Else → choose 'V', subtract count from k

## Execution Phases

- Phase 1: Initialize
  
```csharp
int row = dest[0], col = dest[1];
int total = row + col;
char[] path = new char[total];
int pos = 0;
Phase 2: Greedy Construction
csharp
while (row > 0 || col > 0) {
    if (col > 0) {
        int count = (int)Comb(row + col - 1, col - 1);
        if (k <= count) {
            path[pos++] = 'H';
            col--;
        } else {
            path[pos++] = 'V';
            row--;
            k -= count;
        }
    } else {
        path[pos++] = 'V';
        row--;
    }
}
```

- Phase 3: Binomial Coefficient
```csharp
private long Comb(int n, int k) {
    long res = 1;
    for (int i = 1; i <= k; i++) {
        res = res * (n - i + 1) / i;
    }
    return res;
}
```

 ## Implementation C#
```csharp
public class Solution {
    public string KthSmallestPath(int[] dest, int k) {
        int row = dest[0], col = dest[1];
        int total = row + col;
        char[] path = new char[total];
        int pos = 0;

        while (row > 0 || col > 0) {
            if (col > 0) {
                int count = (int)Comb(row + col - 1, col - 1);
                if (k <= count) {
                    path[pos++] = 'H';
                    col--;
                } else {
                    path[pos++] = 'V';
                    row--;
                    k -= count;
                }
            } else {
                path[pos++] = 'V';
                row--;
            }
        }

        return new string(path);
    }

    private long Comb(int n, int k) {
        long res = 1;
        for (int i = 1; i <= k; i++) {
            res = res * (n - i + 1) / i;
        }
        return res;
    }
}
```
 ## Invariants
- path[pos] always reflects the next lexicographic move
- Comb(n, k) gives number of paths starting with 'H'
- k is decremented only when 'V' is chosen
- Final string has exactly row 'V' and col 'H'

## Edge Cases

- row == 0	```All moves are 'H'```
- col == 0	````All moves are 'V'````
- k == 1	```Always returns "HH...VV..."```
- k == total ```choose row	Returns last lexicographic path```

 ## Constraints
 
- 1 <= row, col <= 15
- 1 <= k <= C(row + col, row)
- Total paths ≤ C(30, 15) — fits in long

##  Why This Works
- We avoid generating all paths by using combinatorics to count how many paths start with 'H'.
- This allows greedy selection of each character in the final string.

Total cost:

- O(row + col) steps
- O(k) binomial evaluations
- No recursion, no DP

##  Pattern Generalization

This technique applies to problems with:

- Lexicographic path construction
- Grid movement with constraints
- Greedy selection based on combinatorial rank

## Reusable Structure

- Greedy loop with combinatoric cutoff
- Clean Comb(n, k) without factorials
- char[] builder for performance
- No external libraries or recursion

## Example Problems

- K-th permutation of grid paths
- Lexicographic rank of binary strings
- Construct k-th valid bracket sequence

## Conclusions
- This solution is a clean example of greedy path construction via combinatorial counting. 
- No simulation, no recursion — just phase-by-phase greedy selection.



---

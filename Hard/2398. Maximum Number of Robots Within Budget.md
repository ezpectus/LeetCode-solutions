# 2398. Maximum Number of Robots Within Budget

**Difficulty:** Hard  
**Tags:** Sliding Window, Monotonic Queue, Greedy  
**Status:** Solved  
**Source:** Leetcode  
**Author:** Denis (architectural adaptation)

---

## üß† Problem Summary

You are given `n` robots, each with:

- `chargeTimes[i]` ‚Äî cost to charge robot `i`
- `runningCosts[i]` ‚Äî cost per unit time to run robot `i`

You are also given a `budget`.  
The total cost of running a group of `k` consecutive robots is:
```
max(chargeTimes[i..j]) + k * sum(runningCosts[i..j])
```

Your task is to find the **maximum number of consecutive robots** that can be run without exceeding the budget.

---

## üìú Constraints

- `chargeTimes.length == runningCosts.length == n`
- `1 <= n <= 5 * 10‚Å¥`
- `1 <= chargeTimes[i], runningCosts[i] <= 10‚Åµ`
- `1 <= budget <= 10¬π‚Åµ`

---

## üí° Core Idea

Use a **sliding window** to track the current group of robots. Maintain:

- `sumRunningCosts` ‚Äî sum of running costs in the window
- `maxCharge` ‚Äî maximum charge time in the window (via monotonic deque)

For each right pointer `r`:

1. Add `runningCosts[r]` to the sum
2. Update `maxCharge` using a monotonic deque
3. If total cost exceeds budget:
   - Shrink window from the left
   - Remove outdated max from deque
4. Track the maximum window size

---

## üß© Code

```csharp
public class Solution {
    public int MaximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {
        int n = chargeTimes.Length;
        int maxRobots = 0;
        long sumRunning = 0;
        int l = 0;

        var deque = new LinkedList<int>(); // stores indices of chargeTimes in decreasing order

        for (int r = 0; r < n; r++) {
            sumRunning += runningCosts[r];

            while (deque.Count > 0 && chargeTimes[deque.Last.Value] <= chargeTimes[r]) {
                deque.RemoveLast();
            }
            deque.AddLast(r);

            while (deque.Count > 0 && chargeTimes[deque.First.Value] + (r - l + 1) * sumRunning > budget) {
                if (deque.First.Value == l) deque.RemoveFirst();
                sumRunning -= runningCosts[l];
                l++;
            }

            maxRobots = Math.Max(maxRobots, r - l + 1);
        }

        return maxRobots;
    }
}
```

## ‚è±Ô∏è Time Complexity
- Time: O(n)
- Each index enters and exits the sliding window once
- Monotonic deque maintains max in amortized constant time
- Space: O(n) for deque and prefix tracking

## üß™ Testcase

```csharp
Input:
chargeTimes = [3,6,1,3,4]
runningCosts = [2,1,3,4,5]
budget = 25

Expected Output:
3
```
## ‚úÖ Test Result
- Status: Passed ‚úÖ Try window [0..2]: max(chargeTimes) = 6, sum(runningCosts) = 6, cost = 6 + 3 √ó 6 = 24 ‚úÖ. 
- Try window [0..3]: max = 6, sum = 10, cost = 6 + 4 √ó 10 = 46 ‚ùå ‚Üí shrink window. 
- Max valid window: [0..2] ‚Üí 3 robots. Constraints respected: budget = 25 ‚úÖ, all robots are consecutive ‚úÖ, no skipped indices ‚úÖ. 
- Edge case confirmed: cost grows with both max(chargeTimes) and k √ó sum(runningCosts), and shrinking window correctly restores budget compliance.
- No exceptions: no index errors, no infinite loops, no timeouts.

---

# Pattern Name
**Median Maintenance via Dual Heap Balancing**

---

## Problem Summary
You're given:

- A **stream of integers**
- Two operations:
  - `addNum(int num)` — insert a number
  - `findMedian()` — return the **median** of all inserted numbers so far

**Constraints:**
- Median = **middle value** in sorted order
- If **even count** → **average of two middle values**
- Up to **50,000 operations**
- Values: `−10⁵ ≤ num ≤ 10⁵`

---

## Core Idea
This is **dynamic median tracking** problem.

**Solution:**  
Use **two heaps** to maintain **lower and upper halves**:

- `low` → **max-heap** (lower half)
- `high` → **min-heap** (upper half)

**Balance rule:**  
> `low.size() >= high.size()`  
> All elements in `low` ≤ All elements in `high`

**Median:**
- **Odd count** → `low.top()`
- **Even count** → `(low.top() + high.top()) / 2.0`

---

## Strategy Summary
1. **Insert into `low` (max-heap)**
2. **Move `low.top()` → `high`**
3. **Rebalance**: if `high.size() > low.size()` → move `high.top()` → `low`
4. **Median**:
   - `low.size() > high.size()` → `low.top()`
   - Else → average of both tops

---

## C++ Implementation
```cpp
#include <queue>
using namespace std;

class MedianFinder {
private:
    priority_queue<int> low;                           // max-heap (lower half)
    priority_queue<int, vector<int>, greater<int>> high; // min-heap (upper half)

public:
    MedianFinder() {}

    void addNum(int num) {
        // 1. Insert into max-heap
        low.push(num);

        // 2. Move max from low to high
        high.push(low.top());
        low.pop();

        // 3. Balance: ensure low >= high
        if (low.size() < high.size()) {
            low.push(high.top());
            high.pop();
        }
    }

    double findMedian() {
        // Odd count → top of low
        if (low.size() > high.size())
            return low.top();

        // Even count → average of two tops
        return (low.top() + high.top()) / 2.0;
    }
};
```

## Architectural Breakdown

| Component       | Role |
|----------------|------|
| `low`           | **Max-heap** for **lower half** of the stream |
| `high`          | **Min-heap** for **upper half** of the stream |
| `addNum`        | Inserts and **rebalances** heaps |
| `findMedian`    | Computes median based on **heap sizes** |

---

## Why This Approach Is Superior

| Aspect                | This Approach                     | Naive Approach                     |
|-----------------------|-----------------------------------|------------------------------------|
| **Insertion Time**    | `O(log n)` per insert             | `O(n log n)` full sort             |
| **Median Query**      | `O(1)`                            | `O(n)` scan or sort                |
| **Space Complexity**  | `O(n)`                            | `O(n)`                             |
| **Performance**       | Handles **50,000 ops** efficiently | Breaks on large streams            |
| **Generalizability**  | Works for any **dynamic median**  | Hard to adapt                      |

---

## Final Takeaway

> This problem is about **efficient median tracking** in a **dynamic stream**.

### The solution uses:
- **Dual heap balancing**
- **Priority queues** for fast access
- **Constant-time median queries**

---

### This pattern generalizes to any task involving:
- **Real-time statistics** over streams
- **Balanced partitioning**
- **Efficient median or percentile tracking**
  

---


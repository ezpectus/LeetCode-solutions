# Pattern Name  
Dynamic Mode Steering with Cost Balancing for Frequency Maximization

---

## Problem Summary

You are given an integer array `nums` and a long integer `k`.  
You can perform at most `k` operations, where each operation increases or decreases any element in the array by 1.  
Your goal is to maximize the frequency score of the final array — that is, the number of times the most frequent element appears after applying up to `k` operations.

---

## Core Idea

This is a value equalization problem under a total cost constraint.  
We want to find the largest group of elements that can be converted into the same value using no more than `k` total operations.

Instead of trying every possible target value, we sort the array and use a sliding window to explore contiguous groups of elements.  
We dynamically adjust the target value (called the "mode") to minimize the total cost of equalizing the group.

The key insight is that the cost to equalize a group of elements to a target value can be computed incrementally, and the target value itself can be shifted to reduce the cost.

---

## Cost Formula

Let the current window be from index `tail` to `head`, and let `modeIndex` be the index of the current target value (the value we want to equalize everything to).  
The cost to equalize all elements in the window to `nums[modeIndex]` is the sum of absolute differences:

    cost = sum of abs(nums[i] - nums[modeIndex]) for all i in [tail, head]

To avoid recomputing this sum from scratch, we compute the change in cost when shifting the mode from `curIndex` to `newIndex` using:

    diff = nums[newIndex] - nums[curIndex]
    costAdd = diff * (curIndex - tail + 1)
    costSub = diff * (head - newIndex + 1)
    deltaCost = costAdd - costSub

- `costAdd` is the extra cost from increasing the left part of the window (which is now further from the new mode)
- `costSub` is the cost saved from the right part of the window (which is now closer to the new mode)
- If `deltaCost` is less than or equal to zero, shifting the mode is beneficial and reduces the total cost

---

## Strategy Summary

1. Sort the array `nums` in ascending order.
2. Initialize a sliding window with two pointers: `tail` and `head`.
3. Maintain a `modeIndex` that represents the current target value.
4. For each new element at `head`, add its cost relative to the current mode.
5. Try shifting `modeIndex` to the right if it reduces the total cost.
6. If the total cost exceeds `k`, shrink the window from the left by moving `tail`.
7. Track the maximum window size where the cost is within the budget.

This approach ensures that we always maintain the largest possible group of elements that can be equalized to a single value within the allowed number of operations.

---

## C# Implementation

```csharp
public class Solution {
    private long CalculateDeltaCost(int[] nums, int tail, int head, int curIndex, int newIndex) {
        long diff = nums[newIndex] - nums[curIndex];
        long costAdd = diff * (curIndex - tail + 1);
        long costSub = diff * (head - newIndex + 1);
        return costAdd - costSub;
    }

    public int MaxFrequencyScore(int[] nums, long k) {
        Array.Sort(nums);
        int tail = 0, head = -1, best = 0, modeIndex = 0;
        long currentCost = 0;

        for (head = 0; head < nums.Length; head++) {
            currentCost += Math.Abs(nums[head] - nums[modeIndex]);

            while (modeIndex < head) {
                long deltaCost = CalculateDeltaCost(nums, tail, head, modeIndex, modeIndex + 1);
                if (deltaCost <= 0) {
                    currentCost += deltaCost;
                    modeIndex++;
                } else {
                    break;
                }
            }

            if (currentCost <= k) {
                best = Math.Max(best, head - tail + 1);
            } else if (tail < head) {
                currentCost -= Math.Abs(nums[modeIndex] - nums[tail]);
                tail++;
            } else {
                break;
            }
        }

        return best;
    }
}
```

## Time and Space Complexity

| Metric           | Value        | Explanation                                                  |
|------------------|--------------|--------------------------------------------------------------|
| Time Complexity  | O(n log n)   | Sorting + linear traversal with dynamic mode steering        |
| Space Complexity | O(1)         | Only scalar variables used, no extra structures              |

This solution avoids brute-force pair enumeration. Instead, it uses a sorted traversal and incrementally adjusts the target value (mode) to minimize cost. The cost is computed analytically, not recomputed from scratch, which keeps the space usage constant.

---

## Generalization to Other Problems

This pattern applies to problems where:

- You need to **equalize values** under a **cost constraint**  
- The **target value (mode)** can be **shifted dynamically** to reduce cost  
- You want to **maximize group size** under a fixed budget  
- The cost function is **linear and decomposable**, allowing **arithmetic modeling** instead of full recomputation

The key architectural insight is that **mode steering** allows the algorithm to adapt the target value in response to cost pressure. Instead of fixing the mode and expanding the window, we **shift the mode** to balance the cost of increasing left-side elements and decreasing right-side elements.

This dynamic adjustment is powered by a formula:
```deltaCost = (newMode − oldMode) × (leftCount − rightCount)```

Where:
- `leftCount = curIndex − tail + 1` — elements that now need more operations  
- `rightCount = head − newIndex + 1` — elements that now need fewer operations

This lets us **steer the mode** only when it reduces total cost, maintaining optimality without recomputation.

---

## Examples of Similar Problems

| Problem Type                  | Description                                      |
|------------------------------|--------------------------------------------------|
| Max Frequency with Budget    | Equalize values under cost constraint            |
| Longest Subarray with Limit  | Maintain window under value difference bound     |
| Dynamic Target Optimization  | Shift target to reduce cost incrementally        |

These problems share the structure of **window-based optimization** under **value constraints**, and benefit from **dynamic center adjustment** and **analytical cost modeling**.

---

## Final Takeaway

This solution uses:

- **Sorted traversal** to align values and enable structured expansion  
- **Dynamic mode steering** to reduce cost by shifting the target value  
- **Analytical cost modeling** to avoid recomputation and maintain constant space  
- **Greedy window expansion** under budget constraint to maximize frequency

The result is a clean **O(n log n)** solution that avoids brute-force and leverages arithmetic structure.  
This pattern is reusable for any task involving **value equalization with dynamic target and cost balancing**, especially when:

- The cost function is linear  
- The target value is flexible  
- The goal is to maximize group size under constraints




---

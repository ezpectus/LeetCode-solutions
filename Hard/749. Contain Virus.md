# 🧫 LeetCode 749 — Contain Virus

## 📜 Problem Summary

You're given a binary grid `isInfected`, where:

- `1` means infected cell
- `0` means uninfected cell

Each night, the virus spreads to adjacent uninfected cells (up/down/left/right), unless blocked by a wall.

Each day, you can install walls around **only one region** — the one that threatens the **most uninfected cells**.  
Return the total number of walls used to quarantine all regions.

---

## 🧠 Core Insight

This isn’t a brute-force simulation — it’s a **priority-driven containment engine**.

The grid isn’t just a map of infected cells. It’s a **dynamic system** where each region has its own threat level, frontier, and mutation potential.  
You’re not scanning — you’re **controlling mutation under resource constraints**.

### 🔍 How the problem forces this architecture

The task description contains **four architectural triggers**:

1. **“Each day, you can install walls around only one region”**  
   → You must **prioritize**.  
   → You can’t quarantine everything — you need to **rank regions by threat**.

2. **“The region that threatens the most uninfected cells”**  
   → You must **track frontiers** — the set of uninfected cells each region can infect.  
   → This rules out naive BFS — you need to **quantify threat per region**.

3. **“Virus spreads to all neighboring cells unless blocked by a wall”**  
   → You must **simulate spread** with structural awareness.  
   → Walls are not global — they’re **local boundaries**, so you need to **count walls per region**.

4. **“There will never be a tie”**  
   → You don’t need tie-breaking logic, but you **must compare regions**.  
   → This implies a **daily selection phase**, followed by **mutation and quarantine**.

### 🧱 What this implies for your solution

- You need a **visited[][]** matrix to avoid reprocessing cells
- You need to build **regions[]**, each with:
  - Infected cells
  - Frontier cells
  - Wall count
- You need to **select the most dangerous region** each day
- You need to **quarantine** that region (mark as `-1`)
- You need to **let other regions mutate** (spread to their frontiers)

> The problem doesn’t just suggest this architecture — it demands it.
> Every line of the description pushes you toward a containment loop with threat analysis and structural mutation.


---

## 🔧 Architectural Strategy

### Core Structures

- `visited[][]`: track which cells have been processed
- `regions`: list of infected zones (each as list of coordinates)
- `frontiers`: list of threatened uninfected cells per region
- `wallsNeeded`: number of walls required to quarantine each region

### Daily Loop

1. **Discover all infected regions** using DFS/BFS
   - For each region:
     - Track infected cells
     - Track threatened uninfected cells
     - Count walls needed

2. **Select the most dangerous region** — the one threatening the most uninfected cells

3. **Quarantine that region**:
   - Mark its cells as `-1` (quarantined)
   - Count walls used

4. **Spread virus from other regions**:
   - Infect their frontier cells (set to `1`)

5. **Repeat** until no region threatens uninfected cells

---

## 🚀 C# Implementation 

```csharp
public class Solution {
    private int rows, cols;
    private int[][] directions = new int[][] {
        new int[]{0,1}, new int[]{1,0}, new int[]{0,-1}, new int[]{-1,0}
    };

    public int ContainVirus(int[][] grid) {
        rows = grid.Length;
        cols = grid[0].Length;
        int totalWalls = 0;

        while (true) {
            var visited = new bool[rows, cols];
            var regions = new List<List<(int, int)>>();
            var frontiers = new List<HashSet<(int, int)>>();
            var wallsNeeded = new List<int>();

            for (int r = 0; r < rows; r++) {
                for (int c = 0; c < cols; c++) {
                    if (grid[r][c] == 1 && !visited[r, c]) {
                        var region = new List<(int, int)>();
                        var frontier = new HashSet<(int, int)>();
                        int walls = 0;

                        var queue = new Queue<(int, int)>();
                        queue.Enqueue((r, c));
                        visited[r, c] = true;

                        while (queue.Count > 0) {
                            var (x, y) = queue.Dequeue();
                            region.Add((x, y));

                            foreach (var dir in directions) {
                                int nx = x + dir[0], ny = y + dir[1];
                                if (nx < 0 || ny < 0 || nx >= rows || ny >= cols) continue;

                                if (grid[nx][ny] == 0) {
                                    frontier.Add((nx, ny));
                                    walls++;
                                } else if (grid[nx][ny] == 1 && !visited[nx, ny]) {
                                    visited[nx, ny] = true;
                                    queue.Enqueue((nx, ny));
                                }
                            }
                        }

                        regions.Add(region);
                        frontiers.Add(frontier);
                        wallsNeeded.Add(walls);
                    }
                }
            }

            if (regions.Count == 0) break;

            int maxThreat = 0;
            for (int i = 1; i < frontiers.Count; i++) {
                if (frontiers[i].Count > frontiers[maxThreat].Count) {
                    maxThreat = i;
                }
            }

            totalWalls += wallsNeeded[maxThreat];

            // Quarantine most dangerous region
            foreach (var (x, y) in regions[maxThreat]) {
                grid[x][y] = -1;
            }

            // Spread virus from other regions
            for (int i = 0; i < regions.Count; i++) {
                if (i == maxThreat) continue;
                foreach (var (x, y) in frontiers[i]) {
                    grid[x][y] = 1;
                }
            }
        }

        return totalWalls;
    }
}
```

## ⏱️ Time and Space Complexity

| Metric  | Value         | Explanation                                                                 |
|---------|---------------|-----------------------------------------------------------------------------|
| Time    | O(m × n × R)  | Each day scans the full grid to discover regions; R = number of simulation days |
| Space   | O(m × n)      | Visited matrix, region lists, frontier sets — all scale with grid size     |

---

## 🧱 Engineering Takeaways

- **Simulation must be priority-aware, not brute-force**  
  → You don’t just spread the virus — you choose which region to contain based on threat level.

- **Region discovery is DFS/BFS with frontier tracking**  
  → Each infected zone is explored, and its frontier (threatened uninfected cells) is recorded.

- **Quarantine is structural — mark and block**  
  → Quarantined cells are tagged (`-1`), and walls are counted based on frontier exposure.

- **Virus spread is controlled — only non-quarantined zones mutate**  
  → After containment, other regions infect their frontiers. Quarantined zones stay frozen.

- **Every day is a full cycle: discover → analyze → contain → mutate**  
  → The simulation is not a loop — it’s a controlled system with state transitions.

> This is not just infection — it’s containment under constraint.

---

## 🧩 Generalization Pattern

This pattern applies to:

- **Region-based mutation with containment logic**  
  → You mutate zones selectively, not uniformly.

- **Priority selection under resource limits**  
  → You can’t contain everything — you must choose the most dangerous region.

- **Grid-based simulation with structural tagging**  
  → Each cell has a state: infected, uninfected, quarantined — and transitions are tracked.

- **Controlled spread with selective blocking**  
  → Walls are installed only where needed, and spread is allowed only where unblocked.

> You don’t just simulate — you control the mutation engine.


---

# ðŸ§« LeetCode 749 â€” Contain Virus

## ðŸ“œ Problem Summary

You're given a binary grid `isInfected`, where:

- `1` means infected cell
- `0` means uninfected cell

Each night, the virus spreads to adjacent uninfected cells (up/down/left/right), unless blocked by a wall.

Each day, you can install walls around **only one region** â€” the one that threatens the **most uninfected cells**.  
Return the total number of walls used to quarantine all regions.

---

## ðŸ§  Core Insight

This isnâ€™t a brute-force simulation â€” itâ€™s a **priority-driven containment engine**.

The grid isnâ€™t just a map of infected cells. Itâ€™s a **dynamic system** where each region has its own threat level, frontier, and mutation potential.  
Youâ€™re not scanning â€” youâ€™re **controlling mutation under resource constraints**.

### ðŸ” How the problem forces this architecture

The task description contains **four architectural triggers**:

1. **â€œEach day, you can install walls around only one regionâ€**  
   â†’ You must **prioritize**.  
   â†’ You canâ€™t quarantine everything â€” you need to **rank regions by threat**.

2. **â€œThe region that threatens the most uninfected cellsâ€**  
   â†’ You must **track frontiers** â€” the set of uninfected cells each region can infect.  
   â†’ This rules out naive BFS â€” you need to **quantify threat per region**.

3. **â€œVirus spreads to all neighboring cells unless blocked by a wallâ€**  
   â†’ You must **simulate spread** with structural awareness.  
   â†’ Walls are not global â€” theyâ€™re **local boundaries**, so you need to **count walls per region**.

4. **â€œThere will never be a tieâ€**  
   â†’ You donâ€™t need tie-breaking logic, but you **must compare regions**.  
   â†’ This implies a **daily selection phase**, followed by **mutation and quarantine**.

### ðŸ§± What this implies for your solution

- You need a **visited[][]** matrix to avoid reprocessing cells
- You need to build **regions[]**, each with:
  - Infected cells
  - Frontier cells
  - Wall count
- You need to **select the most dangerous region** each day
- You need to **quarantine** that region (mark as `-1`)
- You need to **let other regions mutate** (spread to their frontiers)

> The problem doesnâ€™t just suggest this architecture â€” it demands it.
> Every line of the description pushes you toward a containment loop with threat analysis and structural mutation.


---

## ðŸ”§ Architectural Strategy

### Core Structures

- `visited[][]`: track which cells have been processed
- `regions`: list of infected zones (each as list of coordinates)
- `frontiers`: list of threatened uninfected cells per region
- `wallsNeeded`: number of walls required to quarantine each region

### Daily Loop

1. **Discover all infected regions** using DFS/BFS
   - For each region:
     - Track infected cells
     - Track threatened uninfected cells
     - Count walls needed

2. **Select the most dangerous region** â€” the one threatening the most uninfected cells

3. **Quarantine that region**:
   - Mark its cells as `-1` (quarantined)
   - Count walls used

4. **Spread virus from other regions**:
   - Infect their frontier cells (set to `1`)

5. **Repeat** until no region threatens uninfected cells

---

## ðŸš€ C# Implementation 

```csharp
public class Solution {
    private int rows, cols;
    private int[][] directions = new int[][] {
        new int[]{0,1}, new int[]{1,0}, new int[]{0,-1}, new int[]{-1,0}
    };

    public int ContainVirus(int[][] grid) {
        rows = grid.Length;
        cols = grid[0].Length;
        int totalWalls = 0;

        while (true) {
            var visited = new bool[rows, cols];
            var regions = new List<List<(int, int)>>();
            var frontiers = new List<HashSet<(int, int)>>();
            var wallsNeeded = new List<int>();

            for (int r = 0; r < rows; r++) {
                for (int c = 0; c < cols; c++) {
                    if (grid[r][c] == 1 && !visited[r, c]) {
                        var region = new List<(int, int)>();
                        var frontier = new HashSet<(int, int)>();
                        int walls = 0;

                        var queue = new Queue<(int, int)>();
                        queue.Enqueue((r, c));
                        visited[r, c] = true;

                        while (queue.Count > 0) {
                            var (x, y) = queue.Dequeue();
                            region.Add((x, y));

                            foreach (var dir in directions) {
                                int nx = x + dir[0], ny = y + dir[1];
                                if (nx < 0 || ny < 0 || nx >= rows || ny >= cols) continue;

                                if (grid[nx][ny] == 0) {
                                    frontier.Add((nx, ny));
                                    walls++;
                                } else if (grid[nx][ny] == 1 && !visited[nx, ny]) {
                                    visited[nx, ny] = true;
                                    queue.Enqueue((nx, ny));
                                }
                            }
                        }

                        regions.Add(region);
                        frontiers.Add(frontier);
                        wallsNeeded.Add(walls);
                    }
                }
            }

            if (regions.Count == 0) break;

            int maxThreat = 0;
            for (int i = 1; i < frontiers.Count; i++) {
                if (frontiers[i].Count > frontiers[maxThreat].Count) {
                    maxThreat = i;
                }
            }

            totalWalls += wallsNeeded[maxThreat];

            // Quarantine most dangerous region
            foreach (var (x, y) in regions[maxThreat]) {
                grid[x][y] = -1;
            }

            // Spread virus from other regions
            for (int i = 0; i < regions.Count; i++) {
                if (i == maxThreat) continue;
                foreach (var (x, y) in frontiers[i]) {
                    grid[x][y] = 1;
                }
            }
        }

        return totalWalls;
    }
}
```

## â±ï¸ Time and Space Complexity

| Metric  | Value         | Explanation                                                                 |
|---------|---------------|-----------------------------------------------------------------------------|
| Time    | O(m Ã— n Ã— R)  | Each day scans the full grid to discover regions; R = number of simulation days |
| Space   | O(m Ã— n)      | Visited matrix, region lists, frontier sets â€” all scale with grid size     |

---

## ðŸ§± Engineering Takeaways

- **Simulation must be priority-aware, not brute-force**  
  â†’ You donâ€™t just spread the virus â€” you choose which region to contain based on threat level.

- **Region discovery is DFS/BFS with frontier tracking**  
  â†’ Each infected zone is explored, and its frontier (threatened uninfected cells) is recorded.

- **Quarantine is structural â€” mark and block**  
  â†’ Quarantined cells are tagged (`-1`), and walls are counted based on frontier exposure.

- **Virus spread is controlled â€” only non-quarantined zones mutate**  
  â†’ After containment, other regions infect their frontiers. Quarantined zones stay frozen.

- **Every day is a full cycle: discover â†’ analyze â†’ contain â†’ mutate**  
  â†’ The simulation is not a loop â€” itâ€™s a controlled system with state transitions.

> This is not just infection â€” itâ€™s containment under constraint.

---

## ðŸ§© Generalization Pattern

This pattern applies to:

- **Region-based mutation with containment logic**  
  â†’ You mutate zones selectively, not uniformly.

- **Priority selection under resource limits**  
  â†’ You canâ€™t contain everything â€” you must choose the most dangerous region.

- **Grid-based simulation with structural tagging**  
  â†’ Each cell has a state: infected, uninfected, quarantined â€” and transitions are tracked.

- **Controlled spread with selective blocking**  
  â†’ Walls are installed only where needed, and spread is allowed only where unblocked.

> You donâ€™t just simulate â€” you control the mutation engine.


---

# üß© Problem: Count Array Pairs Divisible by K  
## üî¢ Number: LeetCode 2183  
**Difficulty**: Hard  
**Language**: C#  
**Status**: ‚úÖ Solved via GCD mapping + divisor compatibility check

---


## üìú Problem Overview

You're given a 0-indexed integer array `nums` of length `n` and an integer `k`.  
Return the number of pairs `(i, j)` such that:

- `0 ‚â§ i < j < n`  
- `nums[i] * nums[j] % k == 0`

---

### üî¢ Constraints
- `1 ‚â§ nums.length ‚â§ 10‚Åµ`  
- `1 ‚â§ nums[i], k ‚â§ 10‚Åµ`

---

## üß† Explanation

### üîç Key Insight

We want to count how many pairs `(i, j)` satisfy:  
**`nums[i] * nums[j] % k == 0`**

Instead of checking all pairs directly (which is `O(n¬≤)`), we use number theory:

- Let `g‚ÇÅ = gcd(nums[i], k)`  
- Let `g‚ÇÇ = gcd(nums[j], k)`  
- Then:  
  **`nums[i] * nums[j] % k == 0` ‚áî `g‚ÇÅ * g‚ÇÇ % k == 0`**

This means:  
If the product of their GCDs with `k` is divisible by `k`, then their actual product is divisible by `k`.

---

### ‚öôÔ∏è Algorithm Steps

1. Initialize a dictionary `gcdCount` to store how many times each `gcd(num, k)` has occurred
2. For each `num` in `nums`:
   - Compute `g = gcd(num, k)`
   - For each `g'` in `gcdCount`:
     - If `(g * g') % k == 0`, then all previous numbers with `g'` form valid pairs with `num`
     - Add `gcdCount[g']` to result
   - Increment `gcdCount[g]`

---

## üßæ Code
```csharp
public class Solution {
    public long CountPairs(int[] nums, int k) {
        Dictionary<int, int> gcdCount = new();
        long res = 0;

        foreach (int num in nums) {
            int g = GCD(num, k);
            foreach (var kvp in gcdCount) {
                if ((long)g * kvp.Key % k == 0) {
                    res += kvp.Value;
                }
            }
            if (!gcdCount.ContainsKey(g)) gcdCount[g] = 0;
            gcdCount[g]++;
        }

        return res;
    }

    private int GCD(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

## ‚úÖ Complexity, Insights & Notes

---

### ‚è± Time Complexity

- **O(n * m)** ‚Äî where `n` is the length of the array, and `m` is the number of unique GCDs encountered during traversal  
- For each element `num`, we iterate over all previously seen GCDs to check compatibility  
- In practice, `m` is small because the number of distinct GCDs with respect to `k` is limited by the number of divisors of `k`  
- This makes the algorithm efficient even for large `n` (up to 10‚Åµ)

---

### üß† Space Complexity

- **O(m)** ‚Äî we store a dictionary `gcdCount` mapping each encountered `gcd(num, k)` to its frequency  
- The space grows with the number of unique GCDs, which is bounded by the number of divisors of `k`  
- No additional data structures are used beyond this dictionary

---

### üß® Tricks / Insights

- **GCD-based filtering**:  
  Instead of checking all `(i, j)` pairs directly, we reduce the problem to checking whether `g‚ÇÅ * g‚ÇÇ % k == 0`  
  This is a powerful shortcut from number theory that avoids brute-force multiplication

- **g‚ÇÅ * g‚ÇÇ % k == 0**:  
  This condition ensures that the product of two numbers is divisible by `k`, based solely on their GCDs with `k`  
  It allows us to precompute and reuse divisor relationships

- **Dictionary accumulation**:  
  We maintain a running count of how many times each GCD has occurred  
  This enables fast lookup and aggregation of valid pair counts

- **Avoids brute-force**:  
  No need to sort the array or use nested loops over all pairs  
  The algorithm is linear in `n` with a small constant factor from `m`

---

### üîó Related Concepts

- **GCD filtering for divisibility** ‚Äî using greatest common divisors to simplify modular conditions  
- **Number theory in pair counting** ‚Äî leveraging mathematical properties to reduce computational complexity  
- **Hash map accumulation** ‚Äî storing frequency counts for efficient lookup  
- **Divisor compatibility logic** ‚Äî checking whether two numbers can form a divisible product based on their GCDs


---


# Pattern Name
**DP on Ring Rotation + Memoization (DFS + String Key)**

## Problem Summary
- **Input**:  
  `ring` — circular dial, `key` — word to spell  
- **Goal**:  
  Minimum **steps** to spell `key` by:
  1. Rotating ring to align letter at **12:00**
  2. Pressing center button
- **Constraints**:
  - `1 ≤ n, m ≤ 100`
  - Only lowercase letters
  - `key` is **always spellable**

## Core Idea
- **State**: current position in `key` + current **ring configuration**
- **But**: ring is **circular** → rotating to index `i` → same as rotating to `i + k*n`
- **Key insight**:  
  > **Only the index of the current '12:00' character matters** — not the full string!
- **State**: `(key_idx, ring_pos)` → `dp[key_idx][ring_pos]`

## Solution
1. **DFS with memo**:
   - `dfs(i, pos)` — min steps to spell from `key[i..]` with `ring[pos]` at 12:00
2. **For each `key[i]`**:
   - Find all positions `j` where `ring[j] == key[i]`
   - Rotate cost: `min(|pos - j|, n - |pos - j|)`
   - Total: `rotate + 1 (press) + dfs(i+1, j)`
3. **Memo**: `Dictionary<int, int>` or `int[101][101]`

## C# Implementation (Optimal O(m·n²))
```csharp
public class Solution {
    private int n, m;
    private string ring, key;
    private int[,] memo;

    public int FindRotateSteps(string ring, string key) {
        this.ring = ring; this.key = key;
        n = ring.Length; m = key.Length;
        memo = new int[m, n];
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                memo[i, j] = -1;
        return DFS(0, 0);
    }

    private int DFS(int i, int pos) {
        if (i == m) return 0;
        if (memo[i, pos] != -1) return memo[i, pos];

        int minSteps = int.MaxValue;
        for (int j = 0; j < n; j++) {
            if (ring[j] != key[i]) continue;
            int dist = Math.Min(Math.Abs(pos - j), n - Math.Abs(pos - j));
            int next = DFS(i + 1, j);
            minSteps = Math.Min(minSteps, dist + 1 + next);
        }
        return memo[i, pos] = minSteps;
    }
}
```
## Example Walkthrough
| ring | `"godding"` | key | `"gd"` |
|------|-------------|-----|--------|
| **Start** | `g` at 12:00 → `pos=0` |
| **'g'** | already aligned → `0 steps + 1 press` |
| **'d'** | at index 4 → rotate `min(4, 8-4)=4` → press → `+1` |
| **Total** | `0 + 1 + 4 + 1 = 6` → but **optimal is 4** (rotate anticlockwise 2) |

**Optimal path**:
- `'g'` → press → `1`
- Rotate **anticlockwise 2** → `"ddinggo"` → `'d'` at 12:00 → `+2`
- Press → `+1`
- **Total: 4**

## Architectural Breakdown
| Component           | Role                                      |
|---------------------|-------------------------------------------|
| `DFS(i, pos)`       | Min steps from `key[i]` with `ring[pos]` at 12:00 |
| `n = ring.Length`   | Circular → `min(|i-j|, n-|i-j|)`          |
| `memo[i][pos]`      | Avoid recomputing same state              |
| **Loop over `j`**   | Try all positions of `key[i]`             |

## Why This Approach Is Superior
| Aspect              | **DP + Memo**       | Brute Force DFS       |
|---------------------|---------------------|------------------------|
| Time Complexity     | **O(m·n²)**         | O(m·n!) → TLE          |
| Space Complexity    | **O(m·n)**          | O(m)                   |
| Performance         | Fast on n,m≤100     | Exponential            |
| Clarity             | **State clear**     | String rotation mess   |

## Final Takeaway
- **This pattern generalizes to**:
  - **Circular dial / ring problems**
  - **Min cost to align sequence**
  - **DP on position + index**
- **Key Insight**:  
  > **"Don’t rotate string — track 12:00 index. Memoize (key_idx, pos)."**
  
  ---

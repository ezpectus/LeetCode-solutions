# 🧠 Pattern: Sorted GCD Pair Queries

## 📌 Problem Statement

Given an integer array `nums` of length `n`, and an array of integer queries `queries`, compute the GCD of all unordered pairs `(i, j)` where `0 ≤ i < j < n`.  
Let `gcdPairs` be the sorted array of these GCD values.  
For each query `queries[i]`, return the value at index `queries[i]` in `gcdPairs`.

---

## 📋 Constraints
```
- 2 ≤ n ≤ 100000  
- 1 ≤ nums[i] ≤ 50000  
- 1 ≤ queries.length ≤ 100000  
- 0 ≤ queries[i] < n * (n - 1) / 2
```
---

## ⚙️ Core Idea

### 🔁 Brute-force is impossible

Total number of pairs is \( \frac{n(n-1)}{2} \approx 5 \cdot 10^9 \) in worst case.  
Computing all GCDs explicitly is infeasible.

---

### 🧮 Frequency Aggregation

Count how many times each number appears in `nums`.  
This allows efficient aggregation of how many pairs have GCD = `g`.

```csharp
Dictionary<int, int> freq;
```

## 📐 Inclusion-Exclusion for GCD Frequency
For each g from max(nums) down to 1, compute how many unordered pairs have GCD exactly equal to g.
```
gcdFreq[g] = C(cnt, 2)  
Subtract contributions from multiples:  
gcdFreq[g] -= gcdFreq[2g], gcdFreq[3g], ...
```

- This isolates the count of pairs with GCD = g.

## 📊 Prefix Sum of GCD Frequencies
Build prefix[g] = total number of pairs with GCD ≤ g.
```
prefix[g] = prefix[g-1] + gcdFreq[g]
```
- This allows binary search over cumulative distribution.

## 🔍 Binary Search on Answer
For each query q, binary search the smallest g such that:
```
prefix[g] > q
```
- Return g as the answer for that query.

## 🧱 Code Skeleton (C#)

```csharp
public class Solution {
    private int BinarySearch(long[] prefix, long q) {
        int left = 0, right = prefix.Length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (prefix[mid] <= q)
                left = mid + 1;
            else
                right = mid;
        }
        return left;
    }

    public int[] GcdValues(int[] nums, long[] queries) {
        var freq = new Dictionary<int, int>();
        int max = 0;
        foreach (int num in nums) {
            max = Math.Max(max, num);
            freq[num] = freq.GetValueOrDefault(num, 0) + 1;
        }

        long[] gcdFreq = new long[max + 1];
        for (int g = max; g > 0; g--) {
            int count = 0;
            for (int j = g; j <= max; j += g)
                if (freq.ContainsKey(j))
                    count += freq[j];

            gcdFreq[g] = (long)count * (count - 1) / 2;
            for (int j = 2 * g; j <= max; j += g)
                gcdFreq[g] -= gcdFreq[j];
        }

        long[] prefix = new long[max + 1];
        for (int i = 1; i <= max; i++)
            prefix[i] = prefix[i - 1] + gcdFreq[i];

        List<int> res = new();
        foreach (long q in queries)
            res.Add(BinarySearch(prefix, q));

        return res.ToArray();
    }
}
```

## ✅ Why This Pattern Works

- Avoids brute-force GCD computation over all pairs
- Uses frequency aggregation to reduce dimensionality
- Inclusion-exclusion isolates exact GCD counts
- Prefix sum enables fast cumulative queries


## Binary search resolves each query in 
```
𝑂(log *𝑀)
```

## 🔁 Reusability
This pattern generalizes to:


- Counting pairwise properties (GCD, LCM, divisibility)
- Querying sorted pairwise metrics
- Binary search over cumulative distributions
- Efficient handling of combinatorial queries




---


#  Pattern Name  
**Sliding Puzzle via BFS over Encoded Permutation Space**

---

##  Problem Overview  
You're given a **2×3 sliding puzzle** with tiles `1–5` and one empty cell `0`.  
You can swap `0` with any **adjacent tile** (up/down/left/right).  
The goal is to reach the solved state:
```[[1, 2, 3], [4, 5, 0]]```


Return the **minimum number of moves** to solve the puzzle, or `-1` if impossible.

---

##  Problem Anatomy

| Component        | Role                                                   |
|------------------|--------------------------------------------------------|
| `start`          | Flattened string of initial board                      |
| `target`         | `"123450"` — solved configuration                      |
| `dirs`           | Adjacency map for each index of `'0'`                 |
| `Queue<string>`  | BFS frontier — current states to explore               |
| `HashSet<string>`| Deduplication of visited configurations                |
| `steps`          | BFS depth — number of moves taken                      |

---

##  C# Implementation (Denis-style)

```csharp
public class Solution {
    public int SlidingPuzzle(int[][] board) {
        string start = string.Join("", board[0]) + string.Join("", board[1]);
        string target = "123450";
        if (start == target) return 0;

        int[][] dirs = new int[][] {
            new int[] {1, 3}, new int[] {0, 2, 4},
            new int[] {1, 5}, new int[] {0, 4},
            new int[] {1, 3, 5}, new int[] {2, 4}
        };

        var q = new Queue<string>();
        var seen = new HashSet<string>();
        q.Enqueue(start);
        seen.Add(start);
        int steps = 0;

        while (q.Count > 0) {
            int n = q.Count;
            for (int i = 0; i < n; i++) {
                string curr = q.Dequeue();
                if (curr == target) return steps;

                int pos = curr.IndexOf('0');
                foreach (int next in dirs[pos]) {
                    char[] newcfg = curr.ToCharArray();
                    newcfg[pos] = newcfg[next];
                    newcfg[next] = '0';
                    string cfgstr = new string(newcfg);

                    if (seen.Add(cfgstr)) {
                        q.Enqueue(cfgstr);
                    }
                }
            }
            steps++;
        }

        return -1;
    }
}
```

##  Time and Space Complexity

| Metric           | Value     | Explanation                                      |
|------------------|-----------|--------------------------------------------------|
| Time Complexity  | O(6!) = O(720) | BFS explores all reachable permutations of 6 tiles |
| Space Complexity | O(720)    | HashSet and queue store unique board states      |

---

##  Implementation Commentary

- **State Encoding:**  
  Board is flattened into a 6-character string for fast comparison and hashing.  
  Example: `[[1,2,3],[4,0,5]] → "123405"`

- **Adjacency Map (`dirs`):**  
  Precomputed legal moves for each index of `'0'` — avoids runtime conditionals.  
  Example: index `0` can swap with `1` and `3`.

- **BFS Traversal:**  
  - Queue holds current states  
  - `steps` tracks level depth (number of moves)  
  - For each state:
    - Find index of `'0'`  
    - Swap with all legal neighbors  
    - Enqueue unseen configurations

- **Deduplication:**  
  `HashSet<string>` ensures each configuration is processed once — avoids cycles and redundant work.

- **Early Exit:**  
  If current state matches `"123450"` — return `steps` immediately.

- **State Transition:**  
  Swaps are done via `char[]` mutation — fast and readable:
  ```csharp
  newcfg[pos] = newcfg[next];
  newcfg[next] = '0';



##  Final Takeaway

This is a **bounded BFS over permutation space**, optimized for clarity and performance:

- No heuristics, no priority queues — just pure level-order traversal  
- Compact state space (6! = 720) makes BFS feasible even for hard tag  
- Implementation is minimalistic, deterministic, and structurally clean  
- Pattern generalizes to any puzzle with **fixed-size state**, **local transitions**, and **goal matching**

---

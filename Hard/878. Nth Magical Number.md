## 🧫 LeetCode 878 — Nth Magical Number

### 📜 Problem Summary

You're given three integers:

- `n`: the position of the magical number  
- `a`, `b`: the divisors that define what counts as "magical"

A number is magical if it is divisible by either `a` or `b`.  
Return the `n`‑th magical number modulo `10^9 + 7`.

---

### 🧠 Core Insight

This is not a generation problem — it's a **count inversion**.

You don't generate magical numbers one by one.  
You count how many magical numbers are less than or equal to `x`, and use binary search to find the smallest `x` such that `count(x) >= n`.

This is a classic **position-driven count inversion** pattern.

---

### 🔍 Architectural Triggers

- **"Find the n-th magical number"** → invert the count, don't simulate  
- **"Divisible by a or b"** → apply Inclusion–Exclusion  
- **"Modulo 10^9 + 7"** → final result must be reduced modulo

---

### 🔧 Architectural Strategy

#### 🔹 Core Structures

- `count(x)` — number of magical numbers ≤ `x`  
  Uses Inclusion–Exclusion to avoid double-counting:
  ```
  count(x) = x / a + x / b - x / lcm(a, b)
  ```

  
- `lcm(a, b)` — least common multiple  
Computed via Euclidean GCD:

- Binary search range:
```
left = 1 right = n * min(a, b)
```

#### 🔹 Execution Phases

1. **Precompute LCM using GCD**  
 - Use Euclidean algorithm to compute `gcd(a, b)`  
 - Derive `lcm(a, b)` from the formula above

2. **Binary search for minimal x such that count(x) >= n**  
 - This ensures that `x` is the n-th magical number

3. **Return x % mod as final result**  
 - Final result must be reduced modulo to avoid overflow

---

## 🚀 C# Implementation
```csharp
public class Solution {
    private const int mod = 1000000007;

    public int NthMagicalNumber(int n, int a, int b) {
        long lcm = LCM(a, b);
        long left = 1;
        long right = (long)n * Math.Min(a, b);

        while (left < right) {
            long mid = left + (right - left) / 2;
            if (Count(mid, a, b, lcm) < n) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return (int)(left % mod);
    }

    private long Count(long x, int a, int b, long lcm) {
        // Counts how many numbers ≤ x are divisible by a or b
        return x / a + x / b - x / lcm;
    }

    private long LCM(int a, int b) {
        return (long)a * b / GCD(a, b);
    }

    private int GCD(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

## ⏱️ Time and Space Complexity

| Metric | Complexity | Explanation |
|--------|------------|-------------|
| Time   | O(log(n × min(a, b))) | Binary search runs over the range [1, n × min(a, b)]. Each step computes `count(x)` in constant time. |
| Space  | O(1)       | No additional data structures are used. All computations are scalar and constant-space. |

---

## 🧱 Minimal Recall Block

```text
count(x) = x/a + x/b - x/lcm(a,b)
binsearch on x: count(x) ≥ n
```
## 🧩 Generalization Pattern — Position-driven Count Inversion

### 📌 Applicable Scenarios

This pattern applies to problems where:

- You need to find the **n-th element** in a sequence that is **not explicitly generated**
- **Generating elements is expensive**, but **counting them is fast**
- The sequence is defined by **multiple rules**, such as:
  - Divisibility conditions
  - Scheduling constraints
  - Event merging across multiple timelines

---

### 🔹 Core Idea

Instead of generating elements one by one, you:

1. **Define a counting function** `count(x)`  
   - Returns how many valid elements exist ≤ `x`  
   - Often built using arithmetic rules or Inclusion–Exclusion

2. **Use binary search** to find the smallest `x` such that `count(x) ≥ n`  
   - This `x` is the position where the n-th valid element appears

---

### 🔹 Why It Works

- The counting function is **monotonic** — it never decreases as `x` increases  
- Binary search over a monotonic function guarantees **logarithmic time**  
- You avoid brute-force simulation and **directly locate the target**

---

### 🔍 Key Properties

- **No need to store or generate the sequence**  
- **Works with multiple overlapping rules** (e.g. divisible by `a` or `b`)  
- **Scales well** for large `n` (up to (10^9) or more)

---

## 🧠 Engineering Takeaways

- This pattern is ideal for position-based queries in implicit sequences
- It transforms a generation problem into a search over a counting function
- It’s reusable across domains: number theory, scheduling, simulation, and more
- You don’t generate — you locate by count. You don’t simulate — you invert the system.


---

## ðŸ§« LeetCode 878 â€” Nth Magical Number

### ðŸ“œ Problem Summary

You're given three integers:

- `n`: the position of the magical number  
- `a`, `b`: the divisors that define what counts as "magical"

A number is magical if it is divisible by either `a` or `b`.  
Return the `n`â€‘th magical number modulo `10^9 + 7`.

---

### ðŸ§  Core Insight

This is not a generation problem â€” it's a **count inversion**.

You don't generate magical numbers one by one.  
You count how many magical numbers are less than or equal to `x`, and use binary search to find the smallest `x` such that `count(x) >= n`.

This is a classic **position-driven count inversion** pattern.

---

### ðŸ” Architectural Triggers

- **"Find the n-th magical number"** â†’ invert the count, don't simulate  
- **"Divisible by a or b"** â†’ apply Inclusionâ€“Exclusion  
- **"Modulo 10^9 + 7"** â†’ final result must be reduced modulo

---

### ðŸ”§ Architectural Strategy

#### ðŸ”¹ Core Structures

- `count(x)` â€” number of magical numbers â‰¤ `x`  
  Uses Inclusionâ€“Exclusion to avoid double-counting:
  ```
  count(x) = x / a + x / b - x / lcm(a, b)
  ```

  
- `lcm(a, b)` â€” least common multiple  
Computed via Euclidean GCD:

- Binary search range:
```
left = 1 right = n * min(a, b)
```

#### ðŸ”¹ Execution Phases

1. **Precompute LCM using GCD**  
 - Use Euclidean algorithm to compute `gcd(a, b)`  
 - Derive `lcm(a, b)` from the formula above

2. **Binary search for minimal x such that count(x) >= n**  
 - This ensures that `x` is the n-th magical number

3. **Return x % mod as final result**  
 - Final result must be reduced modulo to avoid overflow

---

## ðŸš€ C# Implementation
```csharp
public class Solution {
    private const int mod = 1000000007;

    public int NthMagicalNumber(int n, int a, int b) {
        long lcm = LCM(a, b);
        long left = 1;
        long right = (long)n * Math.Min(a, b);

        while (left < right) {
            long mid = left + (right - left) / 2;
            if (Count(mid, a, b, lcm) < n) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return (int)(left % mod);
    }

    private long Count(long x, int a, int b, long lcm) {
        // Counts how many numbers â‰¤ x are divisible by a or b
        return x / a + x / b - x / lcm;
    }

    private long LCM(int a, int b) {
        return (long)a * b / GCD(a, b);
    }

    private int GCD(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

## â±ï¸ Time and Space Complexity

| Metric | Complexity | Explanation |
|--------|------------|-------------|
| Time   | O(log(n Ã— min(a, b))) | Binary search runs over the range [1, n Ã— min(a, b)]. Each step computes `count(x)` in constant time. |
| Space  | O(1)       | No additional data structures are used. All computations are scalar and constant-space. |

---

## ðŸ§± Minimal Recall Block

```text
count(x) = x/a + x/b - x/lcm(a,b)
binsearch on x: count(x) â‰¥ n
```
## ðŸ§© Generalization Pattern â€” Position-driven Count Inversion

### ðŸ“Œ Applicable Scenarios

This pattern applies to problems where:

- You need to find the **n-th element** in a sequence that is **not explicitly generated**
- **Generating elements is expensive**, but **counting them is fast**
- The sequence is defined by **multiple rules**, such as:
  - Divisibility conditions
  - Scheduling constraints
  - Event merging across multiple timelines

---

### ðŸ”¹ Core Idea

Instead of generating elements one by one, you:

1. **Define a counting function** `count(x)`  
   - Returns how many valid elements exist â‰¤ `x`  
   - Often built using arithmetic rules or Inclusionâ€“Exclusion

2. **Use binary search** to find the smallest `x` such that `count(x) â‰¥ n`  
   - This `x` is the position where the n-th valid element appears

---

### ðŸ”¹ Why It Works

- The counting function is **monotonic** â€” it never decreases as `x` increases  
- Binary search over a monotonic function guarantees **logarithmic time**  
- You avoid brute-force simulation and **directly locate the target**

---

### ðŸ” Key Properties

- **No need to store or generate the sequence**  
- **Works with multiple overlapping rules** (e.g. divisible by `a` or `b`)  
- **Scales well** for large `n` (up to (10^9) or more)

---

## ðŸ§  Engineering Takeaways

- This pattern is ideal for position-based queries in implicit sequences
- It transforms a generation problem into a search over a counting function
- Itâ€™s reusable across domains: number theory, scheduling, simulation, and more
- You donâ€™t generate â€” you locate by count. You donâ€™t simulate â€” you invert the system.


---

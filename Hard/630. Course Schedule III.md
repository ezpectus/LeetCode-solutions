# Pattern Name
**Greedy Course Selection via Deadline-Aware Max-Heap Pruning**

---

## Problem Summary
You're given:

- A list of courses `courses`, where each course is `[duration, lastDay]`
- You start on **day 1**
- Can take **only one course at a time**
- Each course must be **completed before or on `lastDay`**

**Goal:**  
Return the **maximum number of courses** you can take.

---

## Core Idea
This is a **greedy scheduling problem** with **deadline constraints**.

We want to **maximize course count** without violating any `lastDay`.

**Key Insight:**  
> **Take courses in order of increasing deadline**  
> **If time overflows — replace the longest course with a shorter one**

---

## Strategy Summary
1. **Sort courses** by `lastDay` **ascending**
2. Use a **max-heap** to track **durations of selected courses**
3. Initialize `totalTime = 0`
4. For each course `[duration, lastDay]`:
   - If `totalTime + duration <= lastDay` → **take it**
   - Else if `duration < max(taken)` → **replace longest course**
5. Return `taken.Count`

---

## C# Implementation
```csharp
public class Solution {
    public int ScheduleCourse(int[][] courses) {
        Array.Sort(courses, (a, b) => a[1].CompareTo(b[1]));

        var maxHeap = new PriorityQueue<int, int>(
            Comparer<int>.Create((a, b) => b.CompareTo(a))
        );
        int totalTime = 0;

        foreach (var course in courses) {
            int duration = course[0], lastDay = course[1];
            
            if (totalTime + duration <= lastDay) {
                totalTime += duration;
                maxHeap.Enqueue(duration, duration);
            } 
            else if (maxHeap.Count > 0 && maxHeap.Peek() > duration) {
                totalTime += duration - maxHeap.Dequeue();
                maxHeap.Enqueue(duration, duration);
            }
        }

        return maxHeap.Count;
    }
}
```



## Architectural Breakdown

| Component         | Role |
|-------------------|------|
| `Array.Sort`      | Ensures **earliest deadlines** are considered first |
| `maxHeap`         | Tracks **durations** of selected courses |
| `totalTime`       | Accumulates **time spent** on selected courses |
| **Replacement**   | **Prunes longest course** if new one fits better |
| **Final count**   | Number of courses successfully scheduled |

---

## Why This Approach Is Superior

| Aspect                 | This Approach                             | Naive Approach                     |
|-----------------------|-------------------------------------------|------------------------------------|
| **Deadline Handling**  | Greedy + heap-based pruning               | Brute-force or DP                  |
| **Time Complexity**    | `O(n log n)`                              | `O(n!)` or `O(n²)`                 |
| **Space Complexity**   | `O(n)`                                    | `O(n)`                             |
| **Performance**        | Efficient for up to **10⁴ courses**       | Breaks on large inputs             |
| **Generalizability**   | Works for any **deadline-based selection**| Hard to adapt                      |

---

## Final Takeaway

> This problem is about **maximizing course count** under **deadline constraints**.

### The solution uses:
- **Greedy scheduling** by **earliest deadline**
- **Max-heap** to **track and prune** longest durations
- **Time accumulation + replacement** logic

---

### This pattern generalizes to any task involving:
- **Deadline-aware selection**
- **Resource-constrained scheduling**
- **Greedy + heap-based optimization**

---








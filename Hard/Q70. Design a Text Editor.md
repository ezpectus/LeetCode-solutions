# Q70. Design a Text Editor

## Problem

Design a **text editor with a cursor** that supports the following operations:

| Operation | Description |
|---------|-------------|
| `addText(text)` | Insert `text` at the cursor position. Cursor ends **to the right** of inserted text. |
| `deleteText(k)` | Delete **up to `k` characters** to the **left** of the cursor. Return actual number deleted. |
| `cursorLeft(k)` | Move cursor **left** `k` times. Return last `min(10, len)` characters **to the left** of cursor. |
| `cursorRight(k)` | Move cursor **right** `k` times. Return last `min(10, len)` characters **to the left** of cursor. |

> The cursor is always within bounds:  
> `0 ≤ cursor.position ≤ currentText.length`

---

## Constraints

- `1 ≤ text.length, k ≤ 40`
- At most `2⋅10⁴` total calls
- All text consists of **lowercase English letters**

---

## Core Insight

This is a **cursor simulation problem** with **strict performance constraints**.

**Key Idea**: Split the text into **two parts**:

- `lt`: characters **to the left** of the cursor  
- `rt`: characters **to the right** of the cursor

This allows **all operations in O(k)** time using **string manipulation**.

---

## Architectural Triggers

| Trigger | Implication |
|-------|-------------|
| “Delete to the left of cursor” | Must track **left segment** efficiently |
| “Cursor cannot move beyond bounds” | Must **clamp** movement |
| “Return last min(10, len) characters to the left” | Substring logic on `lt` |
| “Up to 2e4 calls” | Brute-force or shifting arrays is **unacceptable** |

---

## What This Implies

Use **two strings**:

- `lt`: left of cursor (grows **rightward**)  
- `rt`: right of cursor (grows **leftward**)

### Operations:

| Operation | Action |
|---------|--------|
| `addText(text)` | `lt += text` |
| `deleteText(k)` | `lt.resize(lt.size() - k)` (clamp `k`) |
| `cursorLeft(k)` | Pop from `lt`, push to `rt` |
| `cursorRight(k)` | Pop from `rt`, push to `lt` |
| `return` | Last `min(10, lt.size())` chars of `lt` |

> All operations are **bounded by O(k)**

---

## Code (C++)

```cpp
class TextEditor {
public:
    string lt = "", rt = "";
    
    TextEditor() {}

    void addText(string text) {
        lt += text;
    }

    int deleteText(int k) {
        k = min(k, (int)lt.size());
        lt.resize(lt.size() - k);
        return k;
    }

    string cursorLeft(int k) {
        while (k-- > 0 && !lt.empty()) {
            rt.push_back(lt.back());
            lt.pop_back();
        }
        return lt.size() >= 10 ? lt.substr(lt.size() - 10) : lt;
    }

    string cursorRight(int k) {
        while (k-- > 0 && !rt.empty()) {
            lt.push_back(rt.back());
            rt.pop_back();
        }
        return lt.size() >= 10 ? lt.substr(lt.size() - 10) : lt;
    }
};
```

## Complexity

| Operation       | Time   | Space  |
|-----------------|--------|--------|
| `addText`       | `O(k)` | `O(n)` |
| `deleteText`    | `O(k)` | `O(n)` |
| `cursorLeft`    | `O(k)` | `O(n)` |
| `cursorRight`   | `O(k)` | `O(n)` |

> **Note**: Each operation touches **at most `k` characters**.  
> Total space is **linear in total text size**.

---

## Pitfalls

| Issue                      | Fix |
|---------------------------|-----|
| **Incorrect cursor bounds** | Always **clamp `k`** to avoid moving beyond text |
| **Wrong substring logic**   | Must return last `min(10, len)` from `lt`, **not full string** |
| **Inefficient structure**   | Using arrays or linked lists breaks `O(k)` — **string append/pop is optimal** |

---

## Insight

This is a **classic two-buffer simulation** using **split buffers**.

The **left/right partitioning** enables:

- **Efficient cursor movement**
- **Fast insert/delete**
- **Simple substring extraction**

> This pattern generalizes to **any editor-like structure** where **cursor-relative operations dominate**.

---

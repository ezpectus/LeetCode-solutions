# 1697. Checking Existence of Edge Length Limited Paths

## Problem Summary

Given an undirected graph with `n` nodes and a list of edges `edgeList`, where each edge is represented as `[u, v, distance]`, determine for each query `[p, q, limit]` whether there exists a path from node `p` to node `q` such that **every edge on the path has distance strictly less than `limit`**.

Multiple edges between the same pair of nodes may exist.  
Return a boolean array `answer[]` where `answer[i]` is `true` if such a path exists for query `i`, and `false` otherwise.

---

## Core Idea

This is a **connectivity under constraint** problem.  
We are not interested in shortest paths — only in whether a path exists using edges below a certain threshold.

### Key observations:

- Each query has a `limit`, and we must only consider edges with `distance < limit`.
- There are up to `10^5` queries — so BFS/Dijkstra per query is too slow.
- We need to answer all queries **efficiently**, ideally in near-linear time.

---

## Architectural Strategy

Use **offline query processing** combined with **Disjoint Set Union (DSU)**.

### Step-by-step plan:

1. **Sort `edgeList` by edge weight** (ascending).
2. **Sort `queries` by `limit`**, keeping original indices.
3. Initialize DSU for `n` nodes.
4. For each query:
   - Add all edges with `distance < limit` to DSU.
   - Check if `p` and `q` are connected in DSU.
5. Store result at the original query index.

This avoids redundant traversal and leverages DSU’s near-constant-time operations.

---

## C# Implementation

```csharp
record Query(int u, int v, int limit, int index);

class DSU {
    int[] parent;
    public DSU(int n) {
        parent = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
    }
    int Find(int x) => parent[x] == x ? x : (parent[x] = Find(parent[x]));
    public void Union(int x, int y) => parent[Find(x)] = Find(y);
    public bool Connected(int x, int y) => Find(x) == Find(y);
}

public class Solution {
    public bool[] DistanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {
        Array.Sort(edgeList, (a, b) => a[2].CompareTo(b[2]));
        var indexed = queries
            .Select((q, i) => new Query(q[0], q[1], q[2], i))
            .OrderBy(q => q.limit)
            .ToArray();

        var dsu = new DSU(n);
        bool[] res = new bool[queries.Length];
        int i = 0;

        foreach (var q in indexed) {
            while (i < edgeList.Length && edgeList[i][2] < q.limit) {
                dsu.Union(edgeList[i][0], edgeList[i][1]);
                i++;
            }
            res[q.index] = dsu.Connected(q.u, q.v);
        }

        return res;
    }
}
```

## Complexity Analysis

**Time Complexity**:  
- Sorting `edgeList` and `queries` takes `O(E log E + Q log Q)`  
- Processing each query and edge takes `O(E + Q)`  
- DSU operations (`Find`, `Union`, `Connected`) are nearly constant due to path compression

This makes the overall runtime efficient even for large inputs — up to `10^5` edges and queries.

**Space Complexity**:  
- `O(N)` for DSU parent array  
- `O(Q)` for storing indexed queries and result array  
- Total: `O(N + Q)`

---

## Architectural Notes

- **Offline processing** avoids running BFS or Dijkstra for each query, which would be too slow.
- **DSU tracks connectivity** incrementally — once two nodes are connected, they stay connected.
- **Edge addition is monotonic** — edges are added in increasing order of weight and never removed.
- **Sorting by limit** ensures that each query only sees edges that are relevant to its constraint.
- **Type safety via `record Query`** improves performance and readability over raw integer arrays.
- **Query indexing** allows results to be stored in correct order after sorting.

This architecture guarantees correctness and scalability, while keeping the implementation minimal and clean.

---

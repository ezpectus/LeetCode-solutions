# 1001. Grid Illumination — Architectural Counter-Based Illumination Tracking  
*O(lamps + queries) — Optimal Precompute + Lazy Turn-Off*

---

## Problem Statement

Given `n×n` grid (n ≤ 10⁹), initially all off.

- `lamps` — positions of turned-on lamps (≤20k)
- `queries` — positions to check illumination

For each query `[r,c]`:
- Check if cell is **illuminated** (row/col/diag has lamp)
- Then **turn off** lamp at `[r,c]` and its **8 neighbors** (if exist)

Return array: `1` if illuminated before turn-off, `0` otherwise.

**Key**: n up to 10⁹ → **cannot use grid array**.

---

## Core Idea — Track Active Lamps per Row/Col/Diag

**Illumination** comes from **any lamp** in same:
- Row
- Column
- Diagonal (r+c)
- Anti-diagonal (r-c)

**Solution**:
- Use **4 counters**:
  - `rows[r]` — number of active lamps in row r
  - `cols[c]` — in column c
  - `diag[r+c]` — main diagonal
  - `antidiag[r-c + offset]` — anti-diagonal (offset to handle negative)
- Cell illuminated → **any counter > 0**

**Process**:
1. Add all lamps → increment counters + track positions in set
2. For each query:
   - Check 4 counters → `1` if any >0
   - Turn off 9 cells → if lamp existed → decrement 4 counters

**No grid. No simulation. Pure counters.**

---

##  Implementation (C++)

```cpp
class Solution {
public:
    vector<int> gridIllumination(int n, vector<vector<int>>& lamps, vector<vector<int>>& queries) {
        unordered_map<int, int> row, col, d1, d2;
        unordered_set<long long> active;

        // Key: pack (r,c) into long long
        auto key = [n](int r, int c) { return (long long)r * n + c; };

        // Add all lamps
        for (auto& lamp : lamps) {
            int r = lamp[0], c = lamp[1];
            long long k = key(r, c);

            if (active.insert(k).second)  // insert only if new
            {
                row[r]++;
                col[c]++;
                d1[r - c + n]++;        // offset for negative r-c
                d2[r + c]++;
            }
        }

        vector<int> ans(queries.size());

        // 9 directions including center
        int dirs[9][2] = {{0,0},{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};

        for (int i = 0; i < queries.size(); i++) {
            int r = queries[i][0], c = queries[i][1];

            // Check if illuminated
            if (row[r] || col[c] || d1[r - c + n] || d2[r + c]) 
                ans[i] = 1;

            // Turn off 9 cells
            for (auto& d : dirs) {
                int nr = r + d[0];
                int nc = c + d[1];

                if (nr >= 0 && nr < n && nc >= 0 && nc < n) {
                    long long k = key(nr, nc);
                    if (active.erase(k))  // was active lamp
                    {
                        row[nr]--;
                        col[nc]--;
                        d1[nr - nc + n]--;
                        d2[nr + nc]--;
                    }
                }
            }
        }

        return ans;
    }
};
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(l + q)**          | l = lamps count, q = queries × 9 (neighbors)    |
| **Space Complexity**  | **O(l)**              | Maps + set for active lamps                    |

**Optimal** — linear time, handles n=10⁹ perfectly.

---

## Why This Works — Detailed Explanation

**Main idea**:
- Instead of simulating the huge grid (impossible for n=10⁹), we track **how many active lamps** are in each **row, column, main diagonal, anti-diagonal**.
- A cell is illuminated **if at least one** of its 4 lines has **count > 0**.

**Data structures**:
- `row[r]`, `col[c]` — number of active lamps in row/column
- `diag[r + c]` — main diagonal
- `antidiag[r - c + offset]` — anti-diagonal (offset to avoid negative keys)
- `active` set — positions of **currently on** lamps (to avoid double-counting duplicates)

**Process**:
1. **Add all lamps**:
   - Skip duplicates using set
   - Increment 4 counters for each unique lamp

2. **For each query**:
   - Check if **any** of 4 counters > 0 → illuminated → `1`
   - Then turn off **up to 9 cells** (query + 8 neighbors)
   - If cell had active lamp → **decrement** its 4 counters

**Lazy removal** — counters always reflect **current** illumination state.

**No grid needed** — memory stays tiny even for billions of coordinates.

---

## Key Takeaway

This is a **masterpiece of counter-based tracking**:

- **No grid** — use row/col/diag counters
- **HashSet** for active lamps → avoid duplicates
- **9-direction turn-off** — clean loop
- **Lazy decrement** — counters stay accurate

**Pure, fast, elegant** — handles huge grid with tiny memory.
Perfect example of **trading space for abstraction** — we don't store the grid, we store **illumination sources**.


---

# 1601. Maximum Number of Achievable Transfer Requests  

## Problem  
We are given `n` buildings and a list of transfer requests. Each request is `[from, to]`, meaning one employee wants to move from building `from` to building `to`.  

We must approve a subset of requests such that:  
- After all approved requests, every building’s net employee count is unchanged.  
- The number of approved requests is maximized.  

---

## Architectural Idea  
This problem looks like a brute force nightmare: every request can be taken or skipped, so there are \(2^R\) subsets. But the constraint \(R \leq 16\) transforms it into an elegant playground for **DFS + backtracking**.  

The architectural beauty lies in how we manage state:  
- **Indegree array** tracks net changes per building.  
- **DFS recursion** explores each request with two branches: *take* or *skip*.  
- **Backtracking** restores the indegree after exploring a branch, so the same array can be reused.  
- **Validation** happens only at the leaf: if all indegrees are zero, we update the answer.  

This design avoids recomputation, keeps memory constant, and makes the recursion tree perfectly balanced. It’s not just brute force — it’s brute force with architectural clarity.  

---

But we **cannot afford**:
- Recomputing net changes per subset
- Storing full state per path
- Memory blowup

### Brilliant Design  
```text
One indegree array (size n)
DFS recursion: take or skip each request
Backtracking: undo changes
Validate only at leaf
```
```State reuse + backtracking = O(n) memory, clean recursion```

## Optimized Implementation (C++)
```cpp
class Solution {
public:
    int maximumRequests(int n, vector<vector<int>>& requests) {
        int ans = 0;
        vector<int> indegree(n, 0);
        
        function<void(int, int)> dfs = [&](int idx, int count) {
            // Base case: all requests processed
            if (idx == requests.size()) {
                // Check if all buildings balanced
                for (int v : indegree)
                    if (v != 0) return;
                ans = max(ans, count);
                return;
            }

            // Option 1: TAKE the request
            indegree[requests[idx][0]]--;
            indegree[requests[idx][1]]++;
            dfs(idx + 1, count + 1);
            
            // Backtrack: undo
            indegree[requests[idx][0]]++;
            indegree[requests[idx][1]]--;

            // Option 2: SKIP the request
            dfs(idx + 1, count);
        };

        dfs(0, 0);
        return ans;
    }
};
```

## Full Implementation (C#)
```cpp

public class Solution {
    private int ans = 0;
    private int[] indegree;

    public int MaximumRequests(int n, int[][] requests) {
        indegree = new int[n];
        Dfs(requests, 0, 0);
        return ans;
    }

    private void Dfs(int[][] requests, int idx, int count) {
        if (idx == requests.Length) {
            foreach (int v in indegree)
                if (v != 0) return;
            ans = Math.Max(ans, count);
            return;
        }

        // Take
        indegree[requests[idx][0]]--;
        indegree[requests[idx][1]]++;
        Dfs(requests, idx + 1, count + 1);
        indegree[requests[idx][0]]++;
        indegree[requests[idx][1]]--;

        // Skip
        Dfs(requests, idx + 1, count);
    }
}
```

## Complexity Analysis  

| **Metric** | **Value** | **Notes** |
|------------|-----------|-----------|
| **Time** | **O(2ᴿ × n)** | 2¹⁶ × 20 ≈ 1.3M operations — fully manageable |
| **Space** | **O(n)** | One `indegree` array + recursion stack depth ≤ R |
| **R ≤ 16** | Yes | Perfectly acceptable for modern hardware |

---

## Why This Is an Architectural Wonder  

| **Feature** | **Why It’s Beautiful** |
|-------------|------------------------|
| **State Reuse** | Single `indegree` array — updated and restored seamlessly |
| **Backtracking** | No extra memory, eliminates recomputation |
| **Validation at Leaf** | Checks balance only once per valid subset |
| **Clean Recursion** | Two symmetric branches: **take** or **skip** |
| **No Globals** | Pure functional style with lambda — self-contained logic |

> **This is not brute force — it’s structured brute force**

---

## Pitfalls & Fixes  

| **Issue** | **Fix** |
|-----------|---------|
| **Stack overflow** | R ≤ 16 → max depth 16 → safe within call stack limits |
| **Wrong indegree update** | `--from`, `++to` — never reverse the operation |
| **Forgot backtracking** | Always undo changes after recursive call |
| **Early validation** | Only validate at `idx == size` to avoid premature exits |

---

## Insight — Reusable Fichka  

**DFS + Backtracking for Balanced Subset Selection**

### Pattern  
- **Exponential search space** → bounded by **small constraint**  
- **Balance condition** across `n` entities  
- **State tracking** with **reversible operations**

### Applies to  
- Employee transfers (this problem)  
- Task assignment with resource balance  
- Network flow with zero net change  
- Any **"choose subset with equilibrium"** problem



---

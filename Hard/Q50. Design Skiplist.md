# Q50. Design Skiplist

## Problem

Design a **data structure** that supports:

| Operation | Description |
|---------|-------------|
| `add(num)` | Insert `num` into the skiplist |
| `search(target)` | Return `true` if `target` exists, else `false` |
| `erase(num)` | Remove **one occurrence** of `num` if it exists, return `true` if removed |

**Duplicates are allowed.**  
All operations must run in **O(log n) average time**.  
**No built-in skiplist libraries.**

---

## Constraints

- `0 ≤ num, target ≤ 2⋅10⁴`
- Up to `5⋅10⁴` total calls to `add`, `search`, `erase`

---

## Core Insight

A **skiplist** is a **layered structure of sorted linked lists**.  
Each layer allows **fast traversal** by **skipping over segments**.

> Average time complexity: **O(log n)** — like balanced BSTs.

**This implementation uses a bucketed linked list**:

- **Buckets** indexed by `num >> 6` (i.e. `num / 64`)
- Each bucket = **sorted singly linked list**
- Each node stores:
  - `val`: value
  - `count`: number of duplicates
  - `next`: pointer

> **Not a true skiplist**, but **achieves sublinear performance** via **bucketing**.

---

## Architectural Triggers

| Trigger | Implication |
|-------|-------------|
| “O(log n) average time” | Must **avoid full traversal** |
| “Duplicates allowed” | Must **track counts** per node |
| “Erase one occurrence” | **Decrement count**, not remove all |
| “No built-in skiplist” | Must **simulate structure manually** |

---

## What This Implies

Use:

- `vector<Node*> table` — bucket array indexed by `num >> 6`
- `Node` with `val`, `count`, `next`

### Operations:

| Operation | Steps |
|---------|-------|
| `add(num)` | 1. Locate bucket<br>2. Traverse to insertion point<br>3. If exists → `count++`<br>4. Else → insert new node |
| `search(target)` | 1. Locate bucket<br>2. Traverse list to find match |
| `erase(num)` | 1. Locate bucket<br>2. Traverse list to find match<br>3. If `count > 1` → `count--`<br>4. Else → remove node |

---

## Code (C++)

```cpp
class Skiplist {
public:
    struct Node {
        int val, count;
        Node* next;
        Node(int v, Node* n) : val(v), count(1), next(n) {}
    };

    vector<Node*> table;

    bool search(int target) {
        int id = target >> 6;
        if (id >= table.size()) return false;
        Node* p = table[id];
        while (p) {
            if (p->val == target) return true;
            p = p->next;
        }
        return false;
    }

    void add(int num) {
        int id = num >> 6;
        while (id >= table.size())
            table.push_back(new Node(-1, nullptr));
        Node* p = table[id];
        while (p->next) {
            if (p->next->val == num) {
                p->next->count++;
                return;
            } else if (p->next->val < num) {
                p = p->next;
            } else {
                p->next = new Node(num, p->next);
                return;
            }
        }
        p->next = new Node(num, nullptr);
    }

    bool erase(int num) {
        int id = num >> 6;
        if (id >= table.size()) return false;
        Node* p = table[id];
        while (p->next) {
            if (p->next->val == num) {
                if (--p->next->count == 0)
                    p->next = p->next->next;
                return true;
            } else if (p->next->val > num) {
                return false;
            } else {
                p = p->next;
            }
        }
        return false;
    }
};
```

## Complexity

| Operation | Time | Space |
|---------|------|-------|
| `add` | **O(1) amortized per bucket** | — |
| `search` | **O(k)** where `k` = bucket size | — |
| `erase` | **O(k)** | — |
| **Total Space** | `O(n)` | — |

> **Not a true skiplist** — worst-case **linear per bucket**.  
> But **average-case sublinear** due to **bucketing**.

---

## Pitfalls

| Issue | Fix |
|------|-----|
| **Not a true skiplist** | Lacks **multi-level structure** — no probabilistic jumps |
| **Bucket overflow** | If many values in same bucket → performance degrades |
| **Incorrect count handling** | **Decrement count before removing node** |
| **Missing bucket initialization** | Always ensure `table[id]` exists before access |

---

## Insight

This is a **bucketed linked list simulation** of skiplist behavior.

It trades **probabilistic jumps** for **fixed-range partitioning**.

> **Simple, compact, handles duplicates cleanly.**

### Generalizes to:

- **Frequency-indexed structures**
- **Range-partitioned search optimization**
- **Linked list augmentation with metadata**

---

## Fichka Library Entry

> **Linked list: bucketed frequency-aware insertion with duplicate tracking**

---

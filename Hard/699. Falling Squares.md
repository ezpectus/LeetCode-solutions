# 699. Falling Squares — Architectural Dynamic Segment Tree with Lazy Propagation  
*O(n log C) — Optimal Range Max Update/Query*

---

## Problem Statement

- Given `positions[i] = [left, side]` — drop a square of side length `side` with left edge at `x = left`.
- Squares fall until they land on another square or ground.
- After each drop, record the **current maximum height** of any stack.
- Return list of max heights after each drop.

**Constraints**
- `n ≤ 1000`
- Coordinates up to ~10⁹ → **cannot use array indexing directly**

---

## Core Idea — Dynamic Segment Tree + Lazy Max Propagation

**Brute force** O(n²) too slow — checking overlaps with all previous squares would be too expensive.

**Insight**:
- We need two operations:
  - **Query** the **maximum height** in the interval where the new square will land
  - **Update** the entire landing interval to the **new height** (old max + side length)

- Coordinates are **huge** (up to 10⁹) → cannot use a standard array-based segment tree

**Solution**:
- Use a **dynamic segment tree** — nodes are created **only when accessed**
- Use **lazy propagation** to efficiently **set** entire ranges to a value (here: new max height)
- The tree stores **maximum height** in each segment

**No discretization needed** — the dynamic nature handles sparse, massive coordinate space perfectly.
This approach keeps memory and time usage minimal while supporting fast range operations.



---

## Implementation (C#)

```csharp
public class Solution {
    public class Node{
        public int l, r, cnt, add;
        public Node(int l, int r, int cnt, int add){
            this.l = l;
            this.r = r;
            this.cnt = cnt;
            this.add = add;
        }
    }

    const int N = (int)1e9 + 7, M = 100010;
    Node[] tr = new Node[M * 4];
    int pos = 1;
    public IList<int> FallingSquares(int[][] positions) {
        List<int> list = new();
        for(int i = 0; i < positions.Length; i++){
            int x = positions[i][0], len = positions[i][1];
            int res = Query(1, 1, N - 1, x, x + len - 1);
            Update(1, 1, N - 1 , x, x + len - 1, res + len);
            list.Add(Query(1, 1, N - 1, 1, N - 1));
        }
        return list.ToArray();
    }

    public void PushUp(int u){
        tr[u].cnt = Math.Max(tr[tr[u].l].cnt, tr[tr[u].r].cnt);
    }

    public void PushDown(int u){
        if(tr[u] == null) tr[u] = new Node(0, 0, 0, 0);
        if(tr[u].l == 0){
            tr[u].l = ++pos;
            tr[tr[u].l] = new Node(0, 0, 0, 0);
        }
        if(tr[u].r == 0){
            tr[u].r = ++pos;
            tr[tr[u].r] = new Node(0, 0, 0, 0);
        }
        if(tr[u].add == 0) return;

        tr[tr[u].l].add = tr[u].add;
        tr[tr[u].r].add = tr[u].add;

        tr[tr[u].l].cnt = tr[u].add;
        tr[tr[u].r].cnt = tr[u].add;
        tr[u].add = 0;
    }

    public void Update(int u, int lc, int rc, int l, int r, int d){
        if(l <= lc && rc <= r){
            tr[u].cnt = d;
            tr[u].add = d;
            return;
        }
        int mid = rc + lc >> 1;
        PushDown(u);
        if(l <= mid) Update(tr[u].l, lc, mid, l, r, d);
        if(r > mid) Update(tr[u].r, mid + 1, rc, l, r, d);
        PushUp(u);
    }

    public int Query(int u, int lc, int rc, int l, int r){
        if(l <= lc && rc <= r) return tr[u].cnt;
        int max = 0;
        PushDown(u);
        int mid = rc + lc >> 1;
        if(l <= mid) max = Query(tr[u].l, lc, mid, l, r);
        if(r > mid) max = Math.Max(max, Query(tr[u].r, mid + 1, rc, l, r));
        return max;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n log C)**        | C = 10⁹ → log C ≈ 30, each drop → O(log C) update + query |
| **Space Complexity**  | **O(n log C)**        | Nodes created on demand (worst-case ~30 per drop) |

**Optimal** — best possible for large coordinates without preprocessing.

---

## Why This Works

- **Dynamic segment tree** → handles **10⁹ coordinate range** without discretization or array allocation
- **Lazy propagation** → efficient **range set updates** (set entire interval to new height)
- **Max stored in node** → fast **range max query** for current height under falling square
- **Global query** → single query over full range → current tallest stack

**No coordinate compression needed** — pure dynamic tree grows only where needed.
**Perfect balance** between simplicity and performance.

---

## Key Takeaway

This is a **masterpiece of dynamic segment tree usage**:

- **No discretization** for huge coordinates
- **Lazy max propagation** for range set operations
- **On-demand node allocation** — minimal memory
- **Perfect** for sparse, large-range update/query problems
**One of the most powerful patterns** for interval problems with **big or unknown coordinate ranges**.

Reusable in:
- Falling objects / stacking simulations
- Range update + range max queries
- Dynamic skyline problems
- Any 1D geometry with large coordinates
**Clean, elegant, blazing fast.**

---

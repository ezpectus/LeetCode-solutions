# 913. Cat and Mouse

##  Problem Summary
We are given:
- An undirected graph `graph` where `graph[a]` lists all nodes `b` such that `a-b` is an edge.
- Mouse starts at node `1` and moves first.
- Cat starts at node `2` and moves second.
- Hole is at node `0`.

**Rules:**
- Mouse and Cat alternate moves along edges.
- Cat cannot move into the hole.
- Game ends if:
  - Cat and Mouse occupy the same node → Cat wins.
  - Mouse reaches the hole → Mouse wins.
  - A position repeats (same mouse, cat, and turn) → Draw.

**Goal:**  
Return:
- `1` if Mouse wins,
- `2` if Cat wins,
- `0` if Draw.

---

##  Core Idea
- This is a **game theory problem** with states `(mouse, cat, turn)`.
- Use **retrograde BFS** (reverse game analysis):
  1. Initialize base cases:
     - Mouse at hole → Mouse wins.
     - Mouse and Cat at same node → Cat wins.
  2. Track **degrees** (number of possible moves) for each state.
  3. Propagate results backwards:
     - If a move leads to a win for the current player, mark previous state as win.
     - If all moves lead to opponent’s win, mark as opponent’s win.
- Result is `results[1][2][MOUSE_TURN]`.

---

##  Code (C#)

```csharp
public class Solution {
    private const int HOLE = 0, MOUSE_START = 1, CAT_START = 2;
    private const int MOUSE_TURN = 0, CAT_TURN = 1;
    private const int UNKNOWN = 0, MOUSE_WIN = 1, CAT_WIN = 2;

    private int n;
    private int[][] graph;
    private int[][][] degrees;
    private int[][][] results;

    public int CatMouseGame(int[][] graph) {
        n = graph.Length;
        this.graph = graph;

        degrees = new int[n][][];
        results = new int[n][][];
        for (int i = 0; i < n; i++) {
            degrees[i] = new int[n][];
            results[i] = new int[n][];
            for (int j = 0; j < n; j++) {
                degrees[i][j] = new int[2];
                results[i][j] = new int[2];
            }
        }

        // Initialize degrees
        for (int i = 0; i < n; i++) {
            for (int j = 1; j < n; j++) {
                degrees[i][j][MOUSE_TURN] = graph[i].Length;
                degrees[i][j][CAT_TURN] = graph[j].Length;
            }
        }
        // Cat cannot move into hole
        for (int i = 0; i < n; i++) {
            foreach (int j in graph[HOLE]) {
                degrees[i][j][CAT_TURN]--;
            }
        }

        var queue = new Queue<(int mouse, int cat, int turn)>();

        // Base cases: mouse and cat at same node → cat wins
        for (int i = 1; i < n; i++) {
            results[i][i][MOUSE_TURN] = CAT_WIN;
            results[i][i][CAT_TURN] = CAT_WIN;
            queue.Enqueue((i, i, MOUSE_TURN));
            queue.Enqueue((i, i, CAT_TURN));
        }

        // Base cases: mouse at hole → mouse wins
        for (int j = 1; j < n; j++) {
            results[HOLE][j][MOUSE_TURN] = MOUSE_WIN;
            results[HOLE][j][CAT_TURN] = MOUSE_WIN;
            queue.Enqueue((HOLE, j, MOUSE_TURN));
            queue.Enqueue((HOLE, j, CAT_TURN));
        }

        // BFS propagation
        while (queue.Count > 0) {
            var (mouse, cat, turn) = queue.Dequeue();
            int result = results[mouse][cat][turn];

            foreach (var (pm, pc, pt) in GetPrevStates(mouse, cat, turn)) {
                if (results[pm][pc][pt] == UNKNOWN) {
                    bool winState = (result == MOUSE_WIN && pt == MOUSE_TURN) ||
                                    (result == CAT_WIN && pt == CAT_TURN);

                    if (winState) {
                        results[pm][pc][pt] = result;
                        queue.Enqueue((pm, pc, pt));
                    } else {
                        degrees[pm][pc][pt]--;
                        if (degrees[pm][pc][pt] == 0) {
                            results[pm][pc][pt] = result;
                            queue.Enqueue((pm, pc, pt));
                        }
                    }
                }
            }
        }

        return results[MOUSE_START][CAT_START][MOUSE_TURN];
    }

    private IEnumerable<(int mouse, int cat, int turn)> GetPrevStates(int mouse, int cat, int turn) {
        int prevTurn = turn == MOUSE_TURN ? CAT_TURN : MOUSE_TURN;
        if (prevTurn == CAT_TURN) {
            foreach (int prevCat in graph[cat]) {
                if (prevCat != HOLE) yield return (mouse, prevCat, prevTurn);
            }
        } else {
            foreach (int prevMouse in graph[mouse]) {
                yield return (prevMouse, cat, prevTurn);
            }
        }
    }
}
```

##  Complexity
- **Time:** O(n³) (all states explored).  
- **Space:** O(n³) for `results` and `degrees`.  

---

##  Pitfalls
- Must exclude cat moves into hole.  
- Need to handle repeated states → BFS ensures convergence.  
- Ensure base cases are initialized correctly.  

---

##  Sanity Checks
- Input: `[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]` → Output: `0` (Draw).  
- Input: `[[1,3],[0],[3],[0,2]]` → Output: `1` (Mouse wins).  

---

##  Key takeaway
This problem reduces to **retrograde analysis of game states using BFS**.  
By propagating results backward from base cases and tracking degrees, we can classify each state as Mouse win, Cat win, or Draw.


---

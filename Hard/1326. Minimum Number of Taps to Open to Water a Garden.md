# 1326. Minimum Number of Taps to Open to Water a Garden

**Difficulty:** Hard  
**Topics:** Greedy, Interval Cover, Jump Game Analogy  

---

## ğŸ“– Problem Restatement
We have a garden represented by the interval `[0, n]`.  
There are `n+1` taps, each at position `i`.  
Opening tap `i` waters `[i - ranges[i], i + ranges[i]]`.  

Goal: Find the **minimum number of taps** needed to cover the entire garden `[0, n]`.  
If impossible, return `-1`.

---

## ğŸ’¡ Core Idea
- Each tap defines an interval `[left, right]`.  
- The problem reduces to: **minimum number of intervals to cover `[0, n]`**.  
- This is equivalent to **Jump Game II**:  
  - At each position, know the farthest right you can reach.  
  - Greedily expand coverage until reaching `n`.  

---

## ğŸ” Step-by-Step Algorithm
1. Build an array `maxReach` of length `n+1`.  
   - For each tap `i`, compute `left = max(0, i - ranges[i])`, `right = min(n, i + ranges[i])`.  
   - Update `maxReach[left] = max(maxReach[left], right)`.  
   - Meaning: from `left`, you can jump (cover) up to `right`.  

2. Traverse from `0` to `n`:  
   - Maintain `currEnd` = current coverage, `nextEnd` = farthest coverage seen so far.  
   - Each time you reach `currEnd`, increment `taps` and set `currEnd = nextEnd`.  
   - If at any point `currEnd < i` â†’ impossible, return `-1`.  

3. Return `taps`.

---

## âœ… C# Implementation
```csharp
public class Solution {
    public int MinTaps(int n, int[] ranges) {
        int[] maxReach = new int[n + 1];

        for (int i = 0; i <= n; i++) {
            int left = Math.Max(0, i - ranges[i]);
            int right = Math.Min(n, i + ranges[i]);
            maxReach[left] = Math.Max(maxReach[left], right);
        }

        int taps = 0, currEnd = 0, nextEnd = 0;

        for (int i = 0; i <= n; i++) {
            if (i > nextEnd) return -1; // cannot reach this point
            nextEnd = Math.Max(nextEnd, maxReach[i]);
            if (i == currEnd) {
                if (currEnd != n) {
                    taps++;
                    currEnd = nextEnd;
                }
            }
        }

        return taps;
    }
}
```


## ğŸ“Š Complexity Analysis

- **Time Complexity: O(n)**  
  - We preprocess all taps once to compute their coverage intervals.  
  - Then we perform a single greedy pass through the garden positions.  
  - Each position is visited once, with constant-time updates.  
  - Overall runtime: O(n).  

- **Space Complexity: O(n)**  
  - We store the farthest reach for each garden position in the `maxReach` array.  
  - This requires O(n) additional memory.  
  - Beyond that, only a few integer variables are used.

---

## âš ï¸ Pitfalls

1. **Clamp intervals to [0, n]**  
   - Each tapâ€™s coverage must be restricted to the garden boundaries.  
   - Example: tap at position 0 with range 3 â†’ covers `[0,3]`, not `[-3,3]`.

2. **Zero range taps**  
   - If `ranges[i] = 0`, the tap only covers its own position.  
   - These taps rarely help, but must still be considered.

3. **Coverage gaps**  
   - If at any point the greedy expansion cannot reach the next position, return `-1`.  
   - This indicates the garden cannot be fully watered.

4. **Edge case: n = 0**  
   - Garden length is zero â†’ no taps needed.  
   - Answer is `0`.

---

## ğŸ” Example Walkthrough

**Input:**  
`n = 5, ranges = [3,4,1,1,0,0]`

- Tap 0 â†’ `[0,3]`  
- Tap 1 â†’ `[0,5]`  
- Tap 2 â†’ `[1,3]`  
- Tap 3 â†’ `[2,4]`  
- Tap 4 â†’ `[4,4]`  
- Tap 5 â†’ `[5,5]`  

**Greedy expansion:**  
- Start at position 0.  
- Farthest reach = 5 (from tap 1).  
- One tap is enough to cover `[0,5]`.  

**Output:** `1`

---

## âœ… Key Takeaway

- The problem reduces to an **interval covering problem**.  
- Equivalent to the **Jump Game II greedy strategy**:  
  - Always extend coverage as far as possible.  
  - Increment tap count when current coverage ends.  
- Elegant O(n) solution with clear greedy expansion.


---

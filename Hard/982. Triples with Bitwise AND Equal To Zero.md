# 982. Triples with Bitwise AND Equal To Zero  
*Bitmask Precomputation — AND Triples Counting*

---

## Problem
Given an array `nums`, count the number of **triples** `(i, j, k)` such that:
```nums[i] & nums[j] & nums[k] == 0```

**Constraints:**
- `1 ≤ nums.length ≤ 1000`
- `0 ≤ nums[i] < 2¹⁶`

---

## Pattern
**Brute force = O(n³)** → too slow  
**Optimized = Precompute pairwise ANDs → O(n² + n·2¹⁶)**

**Idea:**
1. Precompute **all possible `x & y`** → store frequency in `dp[mask]`
2. For each `n`, count how many masks satisfy `(mask & n) == 0`
3. Sum frequencies → total valid triples

---

## Algorithm Breakdown

1. `dp[mask]` = number of pairs `(x,y)` where `x & y == mask`
2. Fill `dp` in **O(n²)** using nested loops
3. For each `n` in `nums`:
   - Loop over all `mask` from `0` to `2¹⁶−1`
   - If `(mask & n) == 0` → add `dp[mask]` to answer
4. Return total

---

## Optimized Code (C++)

```cpp
class Solution {
public:
    int countTriplets(vector<int>& nums) {
        const int MAX_MASK = 1 << 16;
        vector<int> dp(MAX_MASK, 0);

        // Step 1: Precompute all pairwise ANDs
        for (int x : nums) {
            for (int y : nums) {
                dp[x & y]++;
            }
        }

        // Step 2: For each n, count compatible masks
        int count = 0;
        for (int n : nums) {
            for (int mask = 0; mask < MAX_MASK; ++mask) {
                if ((mask & n) == 0) {
                    count += dp[mask];
                }
            }
        }

        return count;
    }
};
```

## Complexity
| Metric | Value |
|-------|-------|
| **Time** | **O(n² + n·2¹⁶)** → `10⁶ + 10³·6.5·10⁴ = ~7·10⁷` → **acceptable** |
| **Space** | **O(2¹⁶)** = `65,536` integers → **~256 KB** |

---

## Pitfalls & Fixes
| Issue | Fix |
|------|-----|
| Brute force O(n³) | **Precompute pairwise ANDs** |
| Wrong mask range | Use `1 << 16`, not `1 << 15` |
| Double counting | `dp` counts **pairs**, then multiplied by third → **correct** |
| Memory overflow | `vector<int>` is **safe** for 2¹⁶ |

---

## Insight
**Split the triple into pair + single**

> `(x & y & z) == 0` → `(x & y) & z == 0`  
> → **Precompute `(x & y)`** → check `z` compatibility

**Classic pattern:**  
> *"When n³ is too slow, reduce to n² + bitmask loop"*

---

## Fichka Library Entry
**Category:** `Bitmask / Precomputation`  
**Pattern:** `Count AND triples by precomputing pairwise AND frequencies and checking mask compatibility`


---

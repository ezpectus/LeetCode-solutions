#  3031. Minimum Time to Revert Word to Initial State II

---

##  Problem Summary
We are given:
- A string `word` of length `n`.
- An integer `k`.

At each second:
1. Remove the first `k` characters.
2. Append any `k` characters to the end.

Goal:
- Find the **minimum time > 0** until the string equals its initial state again.

---

##  Core Idea
- After `t` seconds, the string is effectively rotated by `t * k` characters.  
- We need the smallest `t > 0` such that the rotation brings us back to the original string.  
- This is equivalent to finding the smallest multiple of `k` that is a **period** of the string.  
- Use **rolling hash** (or Z‑function) to check substring equality efficiently.

---

##  C# Implementation (Rolling Hash)
```csharp
public class Solution {
    public int MinimumTimeToInitialState(string word, int k) {
        int n = word.Length;
        const long mod = 1000000007;
        const long baseVal = 911382323;

        long[] prefix = new long[n+1];
        long[] power = new long[n+1];
        power[0] = 1;

        for (int i = 0; i < n; i++) {
            prefix[i+1] = (prefix[i] * baseVal + word[i]) % mod;
            power[i+1] = (power[i] * baseVal) % mod;
        }

        long GetHash(int l, int r) {
            long res = (prefix[r+1] - (prefix[l] * power[r-l+1]) % mod + mod) % mod;
            return res;
        }

        for (int t = 1; t * k <= n; t++) {
            int shift = t * k;
            // check if word[shift..n-1] == word[0..n-shift-1]
            if (GetHash(0, n-shift-1) == GetHash(shift, n-1)) {
                return t;
            }
        }
        return (n + k - 1) / k; // fallback: full cycle
    }
}
```

---

##  Complexity
- **Precompute prefix hashes:** O(n)  
  We build prefix hashes and power arrays once for the entire string.  
- **Check multiples of k:** O(n/k)  
  For each possible rotation length (multiple of k), we perform a constant‑time check.  
- **Each check:** O(1)  
  Hash comparison between two substrings is done in O(1).  
- **Total:** O(n)  
  The algorithm scales linearly with the length of the string.  
- **Space:** O(n)  
  Arrays for prefix hashes and powers require linear memory.

---

##  Pitfalls
- **Modulo arithmetic:**  
  Subtraction in modular space must be handled carefully to avoid negative values.  
- **Base choice:**  
  Select a large random base to minimize hash collisions.  
- **Edge case — k = n:**  
  In this case, the answer is always 1, since removing and appending the entire string restores it immediately.  
- **Fallback:**  
  If no smaller rotation works, the string returns to its initial state after `(n + k - 1) / k` steps.

---

##  Example Walkthrough
**Input:** `word = "abacaba"`, `k = 3`

- **Step 1 (shift = 3):**  
  Resulting string = `"cababac"` → not equal to original.  
- **Step 2 (shift = 6):**  
  Resulting string = `"abacaba"` → equal to original.  
- **Answer:** 2

---

##  Conclusion
- The problem reduces to finding the smallest multiple of `k` that is a valid rotation period.  
- Rolling hash enables O(1) substring equality checks, ensuring efficiency.  
- Overall solution runs in O(n) and fits constraints up to 10^6.  
- This approach is **efficient, modular, and robust**, making it suitable for large inputs.  



---


# ðŸ§© LeetCode 2573 â€” Find the String with LCP

## ðŸ“Œ Problem Summary

You're given an `n Ã— n` matrix `lcp`, where `lcp[i][j]` represents the **length of the longest common prefix** between the suffixes `word[i:]` and `word[j:]`.

Your task is to reconstruct the **lexicographically smallest string `word`** of length `n` such that its LCP matrix matches the given one.  
If no such string exists, return `""`.

---

## ðŸ§ My Approach

Instead of brute-forcing or validating random strings, I reframed the problem as a **constraint graph**:

- If `lcp[i][j] > 0`, then `word[i] == word[j]`  
- If `lcp[i][j] == 0`, then `word[i] != word[j]`  
- So I treat each index as a node, and connect them if they must share the same character

This naturally leads to a **Union-Find (DSU)** structure:

- Group all indices that must be equal  
- Assign characters to each group in lexicographic order  
- Build the string by mapping each index to its groupâ€™s character  
- Validate the result by recomputing the LCP matrix

This approach avoids brute force, respects constraints, and guarantees minimality.

---

## âœ… Final Code (C#)

```csharp
public class Solution {
    public string FindTheString(int[][] lcp) {
        int n = lcp.Length;
        var uf = new UnionFind(n);

        // Step 1: Union indices with shared characters
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (lcp[i][j] > 0) {
                    uf.Union(i, j);
                }
            }
        }

        // Step 2: Assign characters to groups
        var rootToChar = new Dictionary<int, char>();
        char nextChar = 'a';
        var res = new char[n];

        for (int i = 0; i < n; i++) {
            int root = uf.Find(i);
            if (!rootToChar.ContainsKey(root)) {
                if (nextChar > 'z') return "";
                rootToChar[root] = nextChar++;
            }
            res[i] = rootToChar[root];
        }

        // Step 3: Validate using prefix DP
        var dp = new int[n, n];
        for (int i = n - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (res[i] == res[j]) {
                    dp[i, j] = 1 + ((i + 1 < n && j + 1 < n) ? dp[i + 1, j + 1] : 0);
                }
            }
        }

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dp[i, j] != lcp[i][j]) return "";
            }
        }

        return new string(res);
    }

    class UnionFind {
        private int[] parent;
        public UnionFind(int n) {
            parent = new int[n];
            for (int i = 0; i < n; i++) parent[i] = i;
        }

        public int Find(int x) {
            if (parent[x] != x) parent[x] = Find(parent[x]);
            return parent[x];
        }

        public void Union(int x, int y) {
            int rx = Find(x), ry = Find(y);
            if (rx != ry) parent[rx] = ry;
        }
    }
}
```

## ðŸ§± Step-by-Step Explanation

### ðŸ”¹ Step 1: Build Union-Find groups
I iterate over all `lcp[i][j]` values.  
If `lcp[i][j] > 0`, that means `word[i] == word[j]`, so I union those indices.  
This builds connected components of positions that must share the same character.

### ðŸ”¹ Step 2: Assign characters to components
I map each component root to a character starting from `'a'`.  
If I run out of characters (more than 26 components), I return `""`.  
Each index `i` gets its character from the root of its component.

### ðŸ”¹ Step 3: Build the candidate string
I construct the string `res` by assigning each index its componentâ€™s character.  
This guarantees that all constraints from step 1 are respected.

### ðŸ”¹ Step 4: Validate the result
I use dynamic programming to compute the actual LCP matrix of `res`.  
For each pair `(i, j)`, I check how many characters match in `res[i:]` and `res[j:]`.  
If the computed matrix doesnâ€™t match the input `lcp`, I return `""`.

---

## ðŸ§® Time & Space Complexity

| Metric               | Value                          |
|----------------------|--------------------------------|
| Union-Find setup     | O(nÂ² Ã— Î±(n))                   |
| Character assignment | O(n)                           |
| DP validation        | O(nÂ²)                          |
| Total Time           | O(nÂ²)                          |
| Space                | O(nÂ²)                          |

---

## ðŸ§˜ Why This Works

- âœ… No revisits â€” Union-Find ensures each index is processed once  
- âœ… No brute force â€” I encode constraints directly  
- âœ… Lexicographic minimality â€” I assign characters in order  
- âœ… Validation â€” prefix DP guarantees correctness  
- âœ… Scalable â€” handles `n = 1000` easily

---

## ðŸ§  My Takeaway

This task looks symbolic, but it's really a **graph of constraints**.  
I reused a pattern from a numeric array problem â€” grouping by conditions â€” and adapted it to characters.  
Union-Find gave me clean grouping, and prefix DP gave me validation.  
The result is fast, minimal, and architecturally sound.

This is the kind of solution I want in my repo:  
**Not just passing â€” but built to last.**


---

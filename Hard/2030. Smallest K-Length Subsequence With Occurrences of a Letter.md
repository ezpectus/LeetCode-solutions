#  Pattern Name  
Lex-Min Subsequence with Quota Constraint

---

##  Problem Summary

You are given a string `s`, an integer `k`, a character `letter`, and an integer `repetition`.  
Return the **lexicographically smallest subsequence of length `k`** that contains **at least `repetition` occurrences of `letter`**.

A subsequence is formed by deleting zero or more characters without changing the order of the remaining ones.

---

##  Core Idea

This is a **greedy monotonic stack** problem with **quota enforcement**:

- Build a result stack `res` of length `k`
- Ensure at least `repetition` copies of `letter` are included
- Remove characters greedily if:
  - They are lexicographically larger than the current character
  - There are enough remaining characters to reach length `k`
  - Removing a `letter` still allows satisfying the quota

---

##  Transition Logic

```text
While res.Peek() > c and res.Count + remaining >= k:
    If res.Peek() == letter:
        Only pop if used + remain > repetition
        Decrement used
    Else:
        Pop freely

If res.Count < k:
    If c == letter:
        Always push
        Increment used
    Else:
        Push only if (k - res.Count) > (repetition - used)

After processing c:
    If c == letter:
        Decrement remaining
```

## C# Implementation
```cpp
public class Solution {
    public string SmallestSubsequence(string s, int k, char letter, int repetition) {
        int n = s.Length;
        int totalL = s.Count(c => c == letter);
        var res = new Stack<char>();
        int used = 0;
        int remain = totalL;

        for (int i = 0; i < n; i++) {
            char c = s[i];

            while (res.Count > 0 && res.Count + (n - i) > k && res.Peek() > c) {
                if (res.Peek() == letter) {
                    if (used + remain > repetition) {
                        res.Pop();
                        used--;
                    } else break;
                } else {
                    res.Pop();
                }
            }

            if (res.Count < k) {
                if (c == letter) {
                    res.Push(c);
                    used++;
                } else if (k - res.Count > repetition - used) {
                    res.Push(c);
                }
            }

            if (c == letter) remain--;
        }

        var arr = res.ToArray();
        Array.Reverse(arr);
        return new string(arr);
    }
}
```
##  Time and Space Complexity

| Metric           | Value       | Explanation                                  |
|------------------|-------------|----------------------------------------------|
| Time Complexity  | O(n)        | Single pass with stack operations            |
| Space Complexity | O(k)        | Stack holds up to `k` characters             |

---

##  Generalization to Other Problems

This pattern applies to problems where:

- You build subsequences under **length and quota constraints**  
- You enforce **minimum character counts**  
- You need **greedy selection with rollback logic**  
- You optimize for **lexicographic order**

---

##  Examples of Similar Problems

| Problem Type                     | Description                                         |
|----------------------------------|-----------------------------------------------------|
| Lex-Min Subsequence with Quota   | Select smallest subsequence with character quota    |
| Monotonic Stack with Constraints | Greedy stack with rollback under global conditions  |
| Greedy Selection with Quota      | Choose elements while satisfying count requirements |

---

##  Final Takeaway

This solution uses:

- **Greedy monotonic stack** to maintain lexicographic order  
- **Quota enforcement** to satisfy character constraints  
- **Length control** to ensure exact subsequence size  
- **Modular phases** for removal, addition, and final assembly

The result is a clean and efficient solution that avoids brute-force and leverages structured greedy transitions.  
This pattern is reusable for any task involving **subsequence selection under quota and order constraints**.



---




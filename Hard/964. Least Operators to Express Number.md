# 964. Least Operators to Express Number — Architectural Recursive Greedy Power Decomposition  
*O(log target) — Elegant Minimal-Operator Recursion*

---

## Problem Statement

Given `x` (2 ≤ x ≤ 100) and `target` (1 ≤ target ≤ 2×10⁸).

Construct `target` using only `x` and operators `+ - * /`.

Rules:
- No parentheses
- `* /` before `+ -`
- No unary minus
- Result must be integer

Return **minimum number of operators**.

---

## Core Idea — Recursive Power Building + Add/Subtract Choice

**Brilliant recursive insight**:
- Build next power `Less * x`
- Count multiplications (`Operations++`)
- At each power:
  - **Subtract** current power → recurse on `target - Less`
  - **Add** current power → recurse on `Less*x - target` (borrow) +1 op
  - **Skip** → worst case `target` additions of 1

**Base case** implicit via recursion stop.
**No memo** — branching small, depth log.

---

##  Implementation (C++)

```cpp
class Solution 
{
public:
    long long leastOpsExpressTarget(long long x, long long target, long long Less = 1, long long Operations = 0) 
    {
        while (Less * x < target) 
            Less *= x, Operations++;

        return min({Less != 1 ? Operations + leastOpsExpressTarget(x, target - Less) : INT_MAX,
                    Less * x < 2 * target ? Operations + leastOpsExpressTarget(x, Less * x - target) + 1 : INT_MAX,
                    2 * target - 1});
    }
};
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(log target)**     | Recursion depth = logₓ(target) ≤ 40 (x≥2)       |
| **Space Complexity**  | **O(log target)**     | Recursion stack depth                          |

**Optimal** — minimal depth, no extra structures.

---

## Why This Works — Example Walkthrough

**Input**: `x=3`, `target=19`

- Start: `Less=1`, `Operations=0`
- `1*3=3 <19` → `Less=3`, `Operations=1`
- `3*3=9 <19` → `Less=9`, `Operations=2`
- `9*3=27 >19` → stop

Now three options:
- **Option 1**: use current power (subtract): `19 - 9 = 10` → recurse on 10 with `Operations=2`
- **Option 2**: borrow from next power (add): `27 - 19 = 8` → recurse on 8 with `Operations=3` (extra +1 for the borrow)
- **Option 3**: worst case — 37 additions of 1

Recursion continues on smaller values → explores all possible decompositions → finds optimal **5 operators**.
**Perfect** — matches best known solution.

---

## Key Takeaway

This is a **masterpiece of recursive greed**:

- **Build powers** via multiplication count
- **Choose** add or subtract at each level
- **Borrow** when beneficial (negative digit)
- **Compact ternary** → genius code golf

**Pure math beauty** — no memo, no loop clutter, no extra state.
**One of the most elegant Hard math problems** — solved with **minimalist recursion**.

---

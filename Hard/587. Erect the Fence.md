# 587. Erect the Fence

---

## Problem Restatement
We are given a set of points (trees) in 2D space.  
We need to find the **convex hull** of these points — the smallest polygon enclosing all trees.  
Return the coordinates of trees that lie on the perimeter of this convex hull.

---

## Key Idea
This is a **convex hull problem**.  
We can solve it using **Monotone Chain Algorithm (Andrew’s algorithm)**:

1. **Sort points** by x, then y.  
2. **Build lower hull:** iterate left to right, maintaining convexity.  
3. **Build upper hull:** iterate right to left.  
4. Combine both hulls.  
5. Use a `HashSet` to avoid duplicates (since collinear points on the boundary must be included).  

---

## Code (C#)
```csharp
public class Solution {
    public int[][] OuterTrees(int[][] trees) {
        Array.Sort(trees, (a, b) => {
            if (a[0] == b[0]) return a[1].CompareTo(b[1]);
            return a[0].CompareTo(b[0]);
        });

        List<int[]> hull = new List<int[]>();

        // Build lower hull
        foreach (var p in trees) {
            while (hull.Count >= 2 && Cross(hull[hull.Count - 2], hull[hull.Count - 1], p) < 0) {
                hull.RemoveAt(hull.Count - 1);
            }
            hull.Add(p);
        }

        // Build upper hull
        int t = hull.Count + 1;
        for (int i = trees.Length - 1; i >= 0; i--) {
            var p = trees[i];
            while (hull.Count >= t && Cross(hull[hull.Count - 2], hull[hull.Count - 1], p) < 0) {
                hull.RemoveAt(hull.Count - 1);
            }
            hull.Add(p);
        }

        // Remove duplicate last point
        hull.RemoveAt(hull.Count - 1);

        // Deduplicate collinear points
        var set = new HashSet<string>();
        var res = new List<int[]>();
        foreach (var p in hull) {
            string key = $"{p[0]},{p[1]}";
            if (!set.Contains(key)) {
                set.Add(key);
                res.Add(p);
            }
        }

        return res.ToArray();
    }

    private int Cross(int[] a, int[] b, int[] c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }
}
```


## Complexity
- **Time:** O(n log n) due to sorting, plus O(n) for constructing the convex hull.  
- **Space:** O(n) to store hull points and intermediate structures.  

---

## Example Walkthrough

**Input:** `[[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]`  
- Sorted points by x then y.  
- Lower hull: (1,1) → (2,0) → (4,2).  
- Upper hull: (4,2) → (3,3) → (2,4) → (1,1).  
- Combined hull: `[[1,1],[2,0],[4,2],[3,3],[2,4]]` ✅  

**Input:** `[[1,2],[2,2],[4,2]]`  
- All points are collinear.  
- Convex hull includes all points.  
- Result: `[[1,2],[2,2],[4,2]]` ✅  

---

## Conclusion
This problem is solved using the **Monotone Chain convex hull algorithm**:  
- Guarantees all boundary points are included, even collinear ones.  
- Runs efficiently in O(n log n), suitable for up to 3000 points.  

---

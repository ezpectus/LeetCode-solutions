# 1255. Maximum Score Words Formed by Letters — Architectural Backtracking Solution  
*O(2¹⁴ · 26) — Brute Force That Wins*

---

## Problem Statement

We are given:

- A list of `words`
- An array `letters` — available letters (multiset)
- A `score[26]` array — points for each letter `'a'` to `'z'`

We must select a **subset of words** (each word used **at most once**) such that:

- All letters used are available in `letters`
- The **total score** is **maximized**

Return the maximum achievable score.

---

## Constraints

- `1 ≤ words.length ≤ 14` → **2¹⁴ = 16384 subsets**
- `1 ≤ words[i].length ≤ 15`
- `1 ≤ letters.length ≤ 100`
- `0 ≤ score[i] ≤ 10`

**Key**: `n ≤ 14` → **brute force over subsets is viable**

---

## Core Idea — Exhaustive Subset Search with Backtracking

Since there are only **14 words**, we can try **all possible subsets** using DFS/backtracking.

**Greedy doesn't work** — high-score word may block several low-score ones.

**Optimal solution** = **try all combinations** → **prune when impossible**

---

## Steps

1. **Precompute** for each word:
   - Its total score
   - Required letter counts

2. **DFS over words**:
   - At each word: **take it** or **skip it**
   - If take → check if letters are available → consume → recurse → **backtrack**
   - Track maximum score

3. Return best score found

---

## Full Implementation (C#)

```csharp
public class Solution {
    public int MaxScoreWords(string[] words, char[] letters, int[] score) {
        int[] letterCount = new int[26];
        foreach (char c in letters) letterCount[c - 'a']++;
        int n = words.Length;
        int[][] wordCounts = new int[n][];
        int[] wordScores = new int[n];


        for (int i = 0; i < n; i++) {
            wordCounts[i] = new int[26];
            int s = 0;
            foreach (char c in words[i]) {
                int idx = c - 'a';
                wordCounts[i][idx]++;
                s += score[idx];
            }
            wordScores[i] = s;
        }
        return Dfs(0, letterCount, words, wordCounts, wordScores);
    }

    private int Dfs(int idx, int[] available, string[] words, int[][] wordCounts, int[] wordScores) {
        if (idx == words.Length) return 0;
        int best = Dfs(idx + 1, available, words, wordCounts, wordScores);
        bool canTake = true;

        for (int j = 0; j < 26; j++) {
            if (wordCounts[idx][j] > available[j]) {
                canTake = false;
                break;
            }
        }

        if (canTake) {
            for (int j = 0; j < 26; j++) available[j] -= wordCounts[idx][j];
            best = Math.Max(best, wordScores[idx] + Dfs(idx + 1, available, words, wordCounts, wordScores));
            for (int j = 0; j < 26; j++) available[j] += wordCounts[idx][j];
        }

        return best;
    }
}
```

## Complexity Analysis

| **Metric**     | **Value**                 | **Notes**                                    |
|----------------|---------------------------|----------------------------------------------|
| **Time**       | **O(2¹⁴ · 26)**           | ~400k operations → **instant**               |
| **Space**      | **O(26 + depth)**         | Recursion stack + frequency arrays           |

**n = 14 → 2¹⁴ = 16384** → **absolutely safe**

---

## Pitfalls & Edge Cases

- **Words requiring unavailable letters** → skipped via `canTake` check
- **Same letter used in multiple words** → correct consumption + backtracking
- **Empty subset** → score 0 → handled by base case
- **All words valid** → may take all (if letters allow)
- **Zero-score letters** → still counted in frequency (correct behavior)

---

## Insight — Reusable Fichka

> **When number of items ≤ 14–16 → 2ⁿ subset search is king**

### Pattern  
- **Precompute** cost/benefit per item  
- **DFS**: **take or skip**  
- **Backtrack** state  
- Track **global max**

---

# 87. Scramble String (Hard)

---

##  Problem Restatement
We define a scrambled string transformation as follows:
- If the string length is 1 → stop.
- If length > 1 → split into two non-empty substrings at a random index.
- Randomly decide to swap the two substrings or keep them in order.
- Recursively apply the same process to each substring.

Given two strings `s1` and `s2` of equal length, return `true` if `s2` can be obtained by scrambling `s1`.

---

##  Core Idea
The problem is essentially about **recursive decomposition** and **checking all possible splits**.  
Key insights:
1. **Character filter:**  
   - If `s1` and `s2` do not contain the same multiset of characters, return `false`.  
   - This is a quick pruning step to avoid unnecessary recursion.

2. **Recursive splitting:**  
   - If `s1 == s2`, return `true`.  
   - Otherwise, try every split index `i` (from 1 to `n-1`).  
   - For each split, check two scenarios:  
     - **No swap:** `isScramble(left1, left2) && isScramble(right1, right2)`  
     - **Swap:** `isScramble(left1, right2) && isScramble(right1, left2)`  
   - If any scenario succeeds, return `true`.

3. **Memoization:**  
   - Store results for `(s1, s2)` pairs in a dictionary.  
   - Prevents exponential blowup by reusing previously computed results.

---

##  Step-by-Step Algorithm
1. **Base case:**  
   - If `s1 == s2` → return `true`.  
   - If sorted characters of `s1` and `s2` differ → return `false`.

2. **Recursive case:**  
   - Loop over split index `i`.  
   - Compute substrings `s1[0..i]`, `s1[i..n]`.  
   - Compare with corresponding parts of `s2` in both swap/no-swap scenarios.  
   - If either scenario returns `true`, propagate `true`.

3. **Memoization:**  
   - Use a dictionary with key `s1 + "#" + s2`.  
   - Before recursion, check if result is cached.  
   - Store result after computation.

---

##  Implementation (C#)

```csharp
public class Solution {
    private Dictionary<string, bool> memo = new();

    public bool IsScramble(string s1, string s2) {
        if (s1 == s2) return true;
        if (s1.Length != s2.Length) return false;

        string key = s1 + "#" + s2;
        if (memo.ContainsKey(key)) return memo[key];

        // Quick filter: same characters
        if (!SameChars(s1, s2)) {
            memo[key] = false;
            return false;
        }

        int n = s1.Length;
        for (int i = 1; i < n; i++) {
            // No swap
            if (IsScramble(s1[..i], s2[..i]) && IsScramble(s1[i..], s2[i..])) {
                memo[key] = true;
                return true;
            }
            // With swap
            if (IsScramble(s1[..i], s2[(n - i)..]) && IsScramble(s1[i..], s2[..(n - i)])) {
                memo[key] = true;
                return true;
            }
        }
        memo[key] = false;
        return false;
    }

    private bool SameChars(string a, string b) {
        var ca = a.ToCharArray();
        var cb = b.ToCharArray();
        Array.Sort(ca);
        Array.Sort(cb);
        return new string(ca) == new string(cb);
    }
}
```




##  Time Complexity
- **Worst case:** `O(n^4)`  
  - For each substring pair `(s1, s2)` of length `n`, we try all split points `i` (up to `n-1`).  
  - Each split requires recursive calls on smaller substrings.  
  - Without memoization, this grows exponentially.  
- **With memoization:**  
  - Each unique `(s1, s2)` pair is computed once.  
  - Reduces repeated work drastically, making the algorithm feasible for `n ≤ 30`.

---

##  Space Complexity
- **Memo dictionary:**  
  - Stores results for substring pairs.  
  - At most `O(n^2)` entries since there are `O(n^2)` possible substring pairs.  
- **Recursion depth:**  
  - At most `O(n)` because each recursive call reduces string length.  
- **Total:** `O(n^2)` space usage.

---

#  Impact of Design Choices

| Choice                          | Effect                                                                 |
|---------------------------------|------------------------------------------------------------------------|
| **Character filter**            | Quickly eliminates impossible cases before recursion.                  |
| **Recursive splitting**         | Ensures all possible scramble scenarios are explored.                  |
| **Swap + no swap checks**       | Covers both transformation paths required by the definition.           |
| **Memoization**                 | Prevents exponential blowup, keeps runtime manageable.                 |

---

#  Pitfalls
- **Skipping identical string check:** leads to unnecessary recursion when `s1 == s2`.  
- **No memoization:** causes exponential runtime and timeouts.  
- **Relying only on character filter:** produces false positives (e.g., `"abcde"` vs `"caebd"`).  
- **Incorrect substring indices:** can lead to wrong comparisons or missed cases.  
- **Not handling base cases properly:** may cause infinite recursion or incorrect results.

---

#  Conclusion
- **What it gives:** Correct detection of scrambled strings.  
- **Why it matters:** Demonstrates recursive decomposition combined with memoization, a classic technique for pruning exponential search.  
- **Key takeaway:**  
  1. Use character multiset filter for quick pruning.  
  2. Recursively split and check both swap/no swap scenarios.  
  3. Apply memoization to ensure runtime feasibility.  
  4. Handle base cases carefully to avoid errors.  

---

# 1723. Find Minimum Time to Finish All Jobs  
*O(n × 2ⁿ × k) — Binary Search + DP / Backtracking with Pruning*

---

## Problem Statement

You are given an integer array `jobs` where `jobs[i]` is the time needed to complete the `i`-th job.

There are `k` workers.  
Each job must be assigned to **exactly one worker**.  
The **working time** of a worker is the **sum** of times of all jobs assigned to them.

Return the **minimum possible maximum working time** among all workers after optimal assignment.

**Examples**:

**Example 1**  
Input: jobs = [3,2,3], k = 3  
Output: **3**  
Assign each job to different worker → max = 3

**Example 2**  
Input: jobs = [1,2,4,7,8], k = 2  
Output: **11**  
One optimal: Worker1: 1+2+8=11, Worker2: 4+7=11

**Constraints**:
- 1 ≤ k ≤ jobs.length ≤ 12
- 1 ≤ jobs[i] ≤ 10⁷

---

## Core Idea — Binary Search on Answer + State Compression DP

**Key insight**:
- We want to minimize the **maximum load** (makespan) → classic **binary search on answer**
- Search range:  
  - Low = max(jobs[i]) (at least the longest job)  
  - High = sum(jobs) (worst case one worker does everything)
- For each candidate `maxTime`, check if we can assign all jobs to `k` workers such that no worker exceeds `maxTime`

**Check function** — use **state compression DP**:
- State: dp[mask] = minimum number of workers needed to finish subset of jobs represented by mask
- Or more efficiently: dp[mask] = true if subset mask can be finished by **one worker** within `maxTime`
- Then use another DP or greedy to count how many such subsets needed ≤ k

**Standard & clean way**:
- Binary search on the answer `mid` (max allowed time per worker)
- For each `mid`, use **backtracking** or **DP** to check if we can partition jobs into ≤ k groups, each with sum ≤ mid

Since n ≤ 12 → 2¹² = 4096 states → perfect for **state compression DP**

**DP state**:
- dp[mask] = minimum number of workers needed to finish jobs in mask
- Transition: for each subset of mask, if subset sum ≤ mid → dp[mask] = min(dp[mask - subset] + 1)

But optimized way:
- Use binary search + backtracking with pruning

**Best & clean solution** (binary search + backtracking):

```csharp
public class Solution{
    public int MinimumTimeRequired(int[] jobs, int k){
        int n = jobs.Length;
        int left = jobs.Max();          // at least the longest job
        int right = jobs.Sum();         // at most everything to one worker

        // Sort descending for better pruning
        Array.Sort(jobs);
        Array.Reverse(jobs);
        int ans = right;

        while (left <= right){
            int mid = left + (right - left) / 2;

            // Check if we can finish all jobs with k workers, each ≤ mid
            if (CanFinish(jobs, k, mid)){
                ans = mid;
                right = mid - 1;
            }
            else left = mid + 1;
        
        }

        return ans;
    }

    private bool CanFinish(int[] jobs, int k, int maxTime){
        int n = jobs.Length;
        // backtracking with current worker loads
        int[] workerLoads = new int[k];
        return Backtrack(jobs, 0, workerLoads, maxTime);
    }

    private bool Backtrack(int[] jobs, int index, int[] workerLoads, int maxTime){
        if (index == jobs.Length) return true; // all jobs assigned
        

        int job = jobs[index];
        // Try assign to each worker
        for (int w = 0; w < workerLoads.Length; w++){
            // If adding to this worker exceeds limit → skip
            if (workerLoads[w] + job > maxTime) continue;

            // Assign
            workerLoads[w] += job;

            if (Backtrack(jobs, index + 1, workerLoads, maxTime)) return true;

            // Backtrack
            workerLoads[w] -= job;

            // Pruning: if worker was empty → no need to try others empty
            if (workerLoads[w] == 0) break;
        }

        return false;
    }
}
```

## Complexity

| **Metric**            | **Value**              | **Notes**                                                                 |
|-----------------------|------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(n × 2ⁿ × k)** worst-case | Binary search: ~40 iterations (log of sum ≤ log(12×10⁷) ≈ 40)<br>Each feasibility check: backtracking with pruning, worst-case O(k × 2ⁿ)<br>With strong pruning (sorting descending + early stop): much faster in practice |
| **Space Complexity**  | **O(k + n)**           | Recursion stack depth O(n) + workerLoads array O(k) |

**Optimal** — n ≤ 12 → 2¹² = 4096 possible subsets, k ≤ 12 → total operations are very small in practice (often < 10⁶ even in worst case with pruning).

---

## Why This Works — Example Walkthrough

**Example 1**: jobs = [3,2,3], k = 3

- Sorted descending: [3,3,2]
- Binary search range: low = 3 (max job), high = 8 (sum)
- Try mid = 3:
  - Assign each job to separate worker: 3,3,2 → max = 3 → feasible
- Try mid = 2: impossible (max job=3 > 2)
- Result: **3** → correct

**Example 2**: jobs = [1,2,4,7,8], k = 2

- Sorted descending: [8,7,4,2,1]
- Binary search range: low = 8, high = 22
- Try mid = 11:
  - One worker: 8+2+1=11
  - Other: 7+4=11 → feasible
- Try mid = 10: impossible (8+2+1=11 > 10)
- Result: **11** → correct

**Correct** —  
**Binary search** efficiently finds the smallest possible maximum load (makespan).  
**Backtracking with pruning** checks whether all jobs can be assigned to k workers without any exceeding the current candidate limit:
- Sort jobs descending → larger jobs assigned first → better pruning
- For each job, try every worker
- Skip if adding would exceed limit
- Prune: if a worker is empty and we tried previous empty workers → stop trying further empty ones
- This makes feasibility check very fast in practice

---

## Key Takeaway

This is a **classic binary search on answer + backtracking with pruning** problem:

* Binary search on the **maximum allowed working time per worker** (the answer we want to minimize)
* Search range: **[max(job), sum(jobs)]**
* For each candidate `mid` → check if it's possible to assign all jobs to k workers such that no worker exceeds `mid`
* Use **backtracking** with strong pruning:
  - Sort jobs in **descending order** (larger first → prune earlier)
  - Try assigning current job to each worker
  - Skip if adding exceeds mid
  - Prune empty workers after trying one (no need to try identical empty workers)
* If feasible → try smaller mid (search left)
* Else → need larger mid (search right)

**Pure, clean, optimal** — worst-case exponential but n ≤ 12 → extremely fast in practice, elegant, and guaranteed to find the minimal possible maximum load.

---

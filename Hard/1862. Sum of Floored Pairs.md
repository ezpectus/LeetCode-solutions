# Pattern Name  
Frequency × Floor Aggregation with Prefix Range

---

## Problem Summary

Given an integer array `nums`, compute the sum of `floor(nums[i] / nums[j])` over all pairs `(i, j)`  
Return the result modulo (10^9 + 7)

---

## Core Idea

Instead of brute-force over all pairs, we aggregate contributions by divisor:

- Fix `x` as denominator  
- For each multiple `mult = x, 2x, 3x, ...`, count how many `nums[j]` fall into `[mult, mult + x - 1]`  
- Use prefix sums to compute range counts efficiently

This transforms the problem into a **frequency × floor grouping** model.

---

## Strategy Summary

1. **Phase 1: Frequency**
   - Count how many times each value appears in `nums`

2. **Phase 2: Prefix Sum**
   - Build prefix sum over frequency array to allow fast range queries

3. **Phase 3: Contribution**
   - For each `x`, skip if `freq[x] == 0`
   - For each multiple `mult = x, 2x, ...`:
     - Compute range `[mult, mult + x - 1]`
     - Count how many values fall in that range using prefix
     - Multiply by `freq[x] × floor(mult / x)` and accumulate

---

## C# Implementation

```csharp
public class Solution {
    private const int MOD = 1_000_000_007;

    public int SumOfFlooredPairs(int[] nums) {
        int n = nums.Max();
        int[] freq = new int[n + 1];
        foreach (int x in nums) freq[x]++;

        int[] pref = new int[n + 1];
        for (int i = 1; i <= n; i++) pref[i] = pref[i - 1] + freq[i];

        long res = 0;
        for (int x = 1; x <= n; x++) {
            if (freq[x] == 0) continue;

            for (int mult = x; mult <= n; mult += x) {
                int l = mult;
                int r = Math.Min(n, mult + x - 1);
                int cnt = pref[r] - pref[l - 1];

                res = (res + (long)freq[x] * cnt * (mult / x)) % MOD;
            }
        }

        return (int)res;
    }
}
```

## Time and Space Complexity

| Metric           | Value       | Explanation                                      |
|------------------|-------------|--------------------------------------------------|
| Time Complexity  | O(n log n)  | Outer loop over x, inner loop over multiples     |
| Space Complexity | O(n)        | Frequency and prefix arrays                      |

---

## Generalization to Other Problems

This pattern applies to problems where:

- You need to compute **aggregated floor divisions**  
- You can **group numerators by range**  
- You use **frequency × contribution modeling**  
- You optimize with **prefix sums over frequency**

---

## Examples of Similar Problems

| Problem Type               | Description                                         |
|----------------------------|-----------------------------------------------------|
| Sum of Floor Divisions     | Aggregate `floor(a / b)` over all pairs             |
| Frequency Contribution     | Model impact of each value via `frequency × weight` |
| Prefix Sum Range Counting  | Use prefix sums to count values in intervals        |

---

## Final Takeaway

This solution uses:

- **Frequency modeling** to avoid pairwise iteration  
- **Prefix sums** to compute range counts efficiently  
- **Floor grouping** to aggregate contributions by divisor  
- **Modular arithmetic** to maintain correctness

The result is a clean and efficient solution that avoids brute-force and leverages structural symmetry.  
This pattern is reusable for any task involving **floor aggregation over frequency ranges**.


---

# 🧠 327. Count of Range Sum

## 🔗 Problem Statement

Given an integer array `nums` and two integers `lower` and `upper`, return the number of **range sums** that lie in `[lower, upper]`, inclusive.

A **range sum** `S(i, j)` is defined as the sum of elements from index `i` to `j` (inclusive):  
`S(i, j) = nums[i] + nums[i+1] + ... + nums[j]`

### Constraints

- `1 <= nums.length <= 10⁵`  
- `-2³¹ <= nums[i] <= 2³¹ - 1`  
- `-10⁵ <= lower <= upper <= 10⁵`  
- The answer is guaranteed to fit in a 32-bit integer

---

## ✅ Signals

- Brute force O(n²) is too slow → need **O(n log n)**  
- Use **prefix sums** to convert range sums into differences  
- Apply **modified merge sort** to count valid ranges during merge  
- Merge must preserve sorted order to enable binary windowing  
- Must handle **zero prefix** (`preSum[0] = 0`) to include full ranges from index 0

---

## 🧩 Solution — Merge Sort with Prefix Sums

```csharp
public class Solution {
    int lower, upper;
    long[] preSum;
    long[] temp;
    int res = 0;

    public int CountRangeSum(int[] nums, int lower, int upper) {
        this.lower = lower;
        this.upper = upper;
        preSum = new long[nums.Length + 1];
        temp = new long[nums.Length + 1];

        for (int i = 0; i < nums.Length; i++)
            preSum[i + 1] = preSum[i] + nums[i];

        Sort(preSum, 0, preSum.Length - 1);
        return res;
    }

    public void Sort(long[] nums, int left, int right) {
        if (left >= right) return;

        int mid = left + (right - left) / 2;
        Sort(nums, left, mid);
        Sort(nums, mid + 1, right);
        Merge(nums, left, mid, right);
    }

    public void Merge(long[] nums, int left, int mid, int right) {
        for (int i = left; i <= right; i++)
            temp[i] = nums[i];

        int start = mid + 1;
        int end = mid + 1;

        for (int i = left; i <= mid; i++) {
            while (start <= right && nums[start] - nums[i] < lower)
                start++;
            while (end <= right && nums[end] - nums[i] <= upper)
                end++;
            res += end - start;
        }

        int m = left;
        int n = mid + 1;

        for (int i = left; i <= right; i++) {
            if (m == mid + 1) {
                nums[i] = temp[n++];
            } else if (n == right + 1) {
                nums[i] = temp[m++];
            } else if (temp[m] > temp[n]) {
                nums[i] = temp[n++];
            } else {
                nums[i] = temp[m++];
            }
        }
    }
}
```

---

## 🔍 Notes

### 🔗 Why Prefix Sums?

- Converts range sum `S(i, j)` into `preSum[j+1] - preSum[i]`  
- Allows us to count valid ranges by comparing **prefix differences**  
- Includes `preSum[0] = 0` to handle full ranges starting at index `0`  
- Transforms the problem from index-based summation into **difference-based comparison**

---

### 🔗 Why Merge Sort?

- During merge, we count valid pairs `(i, j)` such that:  
  `lower <= preSum[j] - preSum[i] <= upper`  
- This is done by scanning a **window** in the right half for each left element  
- Merge also maintains **sorted order**, which is essential for future binary windowing  
- Enables efficient counting without brute force or nested loops

---

## 🧠 Function Breakdown

| Function         | Role                                               |
|------------------|----------------------------------------------------|
| `CountRangeSum`  | Initializes prefix sums and triggers merge sort    |
| `Sort`           | Recursively divides the prefix array               |
| `Merge`          | Counts valid range sums and merges sorted halves   |
| `temp[]`         | Temporary buffer to assist in stable merge         |
| `res`            | Accumulates total count of valid range sums        |

---

## 🧠 Signal Summary

| Concept             | Expression / Mechanism                      | Role                            |
|---------------------|----------------------------------------------|----------------------------------|
| Prefix sum          | `preSum[i+1] = preSum[i] + nums[i]`          | Transforms range sum into diff  |
| Valid range check   | `lower <= right[j] - left[i] <= upper`       | Core condition for counting     |
| Merge window        | `start`, `end` pointers                      | Count valid pairs efficiently   |
| Sorted merge        | `nums[i] = temp[m/n]`                        | Maintain order for next level   |

---

## ⏱️ Complexity

| Metric       | Value         |
|--------------|---------------|
| Time         | `O(n log n)`  |
| Space        | `O(n)`        |
| Stack usage  | `O(log n)`    |

---

## ✅ Takeaways

This solution transforms the problem into a **prefix sum difference check**, and uses **merge sort** to count valid ranges efficiently:

- ❌ No brute force → avoids `O(n²)`  
- ❌ No segment tree or BIT needed  
- ✅ Handles large arrays (`n ≤ 10⁵`) with stable performance  
- ✅ Use this as a **base module** for any range-based counting problem

---

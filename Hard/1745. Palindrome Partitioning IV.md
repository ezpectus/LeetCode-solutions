# 1745. Palindrome Partitioning IV  
*O(n²) — Optimal DP with Prefix Palindrome Check*

---

## Problem Statement

- Given a string `s` of length `n` (3 ≤ n ≤ 2000) consisting of lowercase English letters.
- Return `true` if it is possible to split `s` into **exactly three non-empty palindromic substrings**, otherwise `false`.
- A string is a **palindrome** if it reads the same forwards and backwards.

---

## Core Idea — Dynamic Programming + Prefix Palindrome Table

**Key insight**:
We need to find if there exist two indices `i` and `j` (0 < i < j < n) such that:

- `s[0..i-1]` is palindrome
- `s[i..j-1]` is palindrome
- `s[j..n-1]` is palindrome

Since n ≤ 2000 → O(n²) time is acceptable.

**Steps**:
1. Precompute a 2D boolean table `isPal[l][r]` — true if `s[l..r]` (inclusive) is palindrome
   - Use standard DP:  
     isPal[i][i] = true  
     isPal[i][i+1] = (s[i] == s[i+1])  
     isPal[l][r] = (s[l] == s[r]) && isPal[l+1][r-1]
   - Time: O(n²)

2. Then iterate over all possible **first cut** `i` and **second cut** `j`:
   - Check if:
     - isPal[0][i-1]
     - isPal[i][j-1]
     - isPal[j][n-1]
   - If any such pair exists → return true

3. If no such partition found after all checks → return false

**Optimization note**:
- We can early exit as soon as we find one valid partition
- But worst-case still O(n²) for palindrome table + O(n²) for checking partitions

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public bool CheckPartitioning(string s) {
        int n = s.Length;

        // Step 1: Build palindrome table
        bool[,] isPal = new bool[n, n];

        // Single characters are palindromes
        for (int i = 0; i < n; i++){
            isPal[i, i] = true;
        }

        // Two characters
        for (int i = 0; i < n - 1; i++){
            isPal[i, i + 1] = (s[i] == s[i + 1]);
        }

        // Longer substrings
        for (int len = 3; len <= n; len++){
              for (int i = 0; i <= n - len; i++) {
                int j = i + len - 1;
                isPal[i, j] = (s[i] == s[j]) && isPal[i + 1, j - 1];
            }
        }

        // Step 2: Try all possible two cuts
        for (int i = 1; i < n - 1; i++) { // end of first part
            if (!isPal[0, i - 1]) continue;
            for (int j = i + 1; j < n; j++) {// end of second part 
                if (isPal[i, j - 1] && isPal[j, n - 1]) return true;
                }
        }

        return false;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n²)**     | Building the palindrome DP table: O(n²)  
Checking all possible two cut points (i, j): O(n²) in worst case (though often early exit possible) |
| **Space Complexity**  | **O(n²)**     | 2D boolean array `isPal[n][n]` to store whether each substring is palindrome |

**Fits constraints perfectly** — n ≤ 2000 → 2000² = 4 million operations — runs very fast on any modern judge.

---

## Why This Works — Example Walkthrough

**Example 1**: `s = "abcbdd"`

- Possible valid split: "a" + "bcb" + "dd"
  - "a" → palindrome (single char)
  - "bcb" → palindrome (reads same backwards)
  - "dd" → palindrome
- The DP table correctly identifies all three substrings as palindromes
- The double loop over cut points (i=1, j=4) finds this partition → returns **true**

**Example 2**: `s = "bcbddxy"`

- No combination of three non-empty substrings are all palindromes
- After checking all possible cut points, no valid partition is found → returns **false**

**Correct** —  
Precomputing **all palindromic substrings** in O(n²) allows O(1) checks for any range.  
The double loop over possible cut points (i, j) exhaustively tries every way to split the string into **exactly three** parts and verifies if all are palindromes.

---

## Key Takeaway

This is a **classic palindrome partitioning** problem with exactly **three** parts:

- Use **DP table** to precompute whether every substring s[l..r] is a palindrome (O(n²))
  - Base cases: single chars and two chars
  - Recurrence: s[l..r] is palindrome if s[l] == s[r] and s[l+1..r-1] is palindrome
- Then brute-force all possible **two cut points** (i, j):
  - First part: s[0 .. i-1]
  - Second part: s[i .. j-1]
  - Third part: s[j .. n-1]
- If **all three** are palindromes → return true
- If no such partition found after checking every possibility → return false

**Pure, clean, optimal** — O(n²) time and space, straightforward DP + brute-force cuts, no edge cases missed.

---

# ðŸ§  1000. Minimum Cost to Merge Stones

## ðŸ“˜ Problem Summary

You are given an array `stones[]` representing piles of stones.  
Each move allows you to merge **exactly `k` consecutive piles** into one, with a cost equal to the total number of stones in those `k` piles.  
Return the **minimum total cost** to merge all piles into one.  
If it's **impossible** to end up with one pile, return `-1`.

---

## ðŸ”§ C# Implementation

```csharp
public class Solution {
    public int MergeStones(int[] stones, int k) {
        int n = stones.Length;
        if ((n - 1) % (k - 1) != 0) return -1;

        int[,] dp = new int[n, n];
        int sum = 0;

        for (int i = 0; i < k - 1; i++) sum += stones[i];

        for (int y = k; y <= n; y++) {
            sum += stones[y - 1];
            int inner = dp[y - k, y - 1] = sum;
            sum -= stones[y - k];

            for (int x = y - k - 1; x >= 0; x--) {
                inner += stones[x];
                int p = (y - x - 2) % (k - 1) + 2;
                int mincost = int.MaxValue;

                for (int q = 1; q < p; q++)
                    for (int z = x + q; z < y; z += k - 1)
                        mincost = Math.Min(mincost, dp[x, z - 1] + dp[z, y - 1]);

                dp[x, y - 1] = (p == k ? inner : 0) + mincost;
            }
        }

        return dp[0, n - 1];
    }
}
```

## ðŸ“¶ Signal Table

| Signal            | Meaning                                                                 |
|-------------------|-------------------------------------------------------------------------|
| `dp[i,j]`         | Minimum cost to merge stones from index `i` to `j`                      |
| `sum` / `inner`   | Running prefix sum used to compute merge cost for current interval      |
| `p`               | Number of piles in current interval, adjusted to check if merge is valid |
| `mincost`         | Minimum cost to split interval `[i,j]` into valid subintervals          |
| Final `dp[0,n-1]` | Minimum cost to merge the entire array into one pile                    |

---

## âœ… Takeaways

- This is an **interval dynamic programming** problem with strict merge constraints.
- We can only merge all piles into one if `(n - 1) % (k - 1) == 0`. Otherwise, return `-1`.
- The DP table `dp[i,j]` stores the minimum cost to merge stones from index `i` to `j`.
- We use **prefix sums** to compute the cost of merging `k` piles efficiently.
- For each interval `[x, y)`, we:
  - Accumulate the total stone count (`inner`)
  - Check if the interval can be merged into one pile (`p == k`)
  - Explore all valid split points using nested loops to find the minimal cost
- Only when the interval size allows merging into `k` piles, we **add the merge cost** to `dp[i,j]`.

---

## ðŸ§© Conclusion

This solution models the stone merging process using a 2D DP array.  
Each cell `dp[i,j]` represents the minimum cost to merge stones from index `i` to `j`, considering all valid splits and merge operations.  
The nested loops simulate every possible way to divide the interval into subintervals of size `k`, and accumulate the cost accordingly.  
The use of prefix sums (`sum`, `inner`) ensures that merge costs are calculated in constant time per interval.  
This pattern is a classic example of **interval DP with merge constraints**, and is applicable to problems involving **grouped operations, cost accumulation, and structural dependencies**.





---

# 975. Odd Even Jump

---

## Problem Restatement
We are given an integer array `arr`.  
From each starting index, we can make a series of jumps:
- **Odd jumps (1st, 3rd, ...):** jump forward to the smallest index `j` such that `arr[j] >= arr[i]`.  
- **Even jumps (2nd, 4th, ...):** jump forward to the smallest index `j` such that `arr[j] <= arr[i]`.  
If no valid jump exists, the sequence stops.  

A starting index is **good** if we can eventually reach the last index.  
We need to return the number of good starting indices.

---

## Key Idea
This is a **dynamic programming + ordered map** problem.

1. **Observation:**  
   - Whether an index is good depends on whether odd/even jumps from it eventually reach the end.  
   - We need to know, for each index, the next index for odd jumps and the next index for even jumps.

2. **Preprocessing next jumps:**  
   - For odd jumps: find the next greater or equal element to the right (with smallest index).  
   - For even jumps: find the next smaller or equal element to the right (with smallest index).  
   - This can be computed using a **monotonic stack** after sorting indices by values.

3. **DP definition:**  
   - `odd[i]` = true if starting at `i` with an odd jump can reach the end.  
   - `even[i]` = true if starting at `i` with an even jump can reach the end.  
   - Transition:  
     ```
     odd[i] = even[nextOdd[i]]
     even[i] = odd[nextEven[i]]
     ```
   - Base case: `odd[n-1] = even[n-1] = true` (last index is trivially good).

4. **Answer:**  
   - Count indices where `odd[i] == true`.

---

## Code (C#)
```csharp
public class Solution {
    public int OddEvenJumps(int[] arr) {
        int n = arr.Length;
        int[] nextHigher = new int[n];
        int[] nextLower = new int[n];
        Array.Fill(nextHigher, -1);
        Array.Fill(nextLower, -1);

        // Helper: build next jump using monotonic stack
        void BuildNext(int[] indices, int[] next) {
            Stack<int> stack = new Stack<int>();
            foreach (int i in indices) {
                while (stack.Count > 0 && i > stack.Peek()) {
                    next[stack.Pop()] = i;
                }
                stack.Push(i);
            }
        }

        // Sort indices by value ascending for odd jumps
        int[] idxAsc = Enumerable.Range(0, n).OrderBy(i => arr[i]).ThenBy(i => i).ToArray();
        BuildNext(idxAsc, nextHigher);

        // Sort indices by value descending for even jumps
        int[] idxDesc = Enumerable.Range(0, n).OrderByDescending(i => arr[i]).ThenBy(i => i).ToArray();
        BuildNext(idxDesc, nextLower);

        bool[] odd = new bool[n];
        bool[] even = new bool[n];
        odd[n-1] = even[n-1] = true;

        for (int i = n - 2; i >= 0; i--) {
            if (nextHigher[i] != -1) odd[i] = even[nextHigher[i]];
            if (nextLower[i] != -1) even[i] = odd[nextLower[i]];
        }

        return odd.Count(x => x);
    }
}
```


## Complexity
- **Time:** O(n log n), because we sort indices by values and use monotonic stacks to compute next jumps.  
- **Space:** O(n), storing arrays for next higher/lower jumps and DP states (`odd[]`, `even[]`).  

---

## Example Walkthrough

**Input:** `arr = [10,13,12,14,15]`  
- From index 3 → jump to 4 → reach end.  
- From index 4 → already at end.  
- **Good starting indices = {3,4} → Output = 2 ✅**

**Input:** `arr = [2,3,1,1,4]`  
- From index 1 → odd jump to 4 → reach end.  
- From index 3 → odd jump to 4 → reach end.  
- From index 4 → already at end.  
- **Good starting indices = {1,3,4} → Output = 3 ✅**

**Input:** `arr = [5,1,3,4,2]`  
- From index 1 → odd jump to 2 → even jump to 4 → reach end.  
- From index 2 → odd jump to 3 → even jump to 4 → reach end.  
- From index 4 → already at end.  
- **Good starting indices = {1,2,4} → Output = 3 ✅**

---

## Why This Works
- **Monotonic stack preprocessing:**  
  - Efficiently finds the next valid index for odd/even jumps.  
  - Avoids brute force scanning for each position.  

- **Dynamic programming propagation:**  
  - `odd[i]` depends on `even[nextHigher[i]]`.  
  - `even[i]` depends on `odd[nextLower[i]]`.  
  - Base case: last index is always good.  

Together, these ensure correctness and efficiency.

---

## Conclusion
The solution combines:
- **Monotonic stack** to precompute next jumps efficiently.  
- **Dynamic programming** to propagate reachability.  

This yields an optimal **O(n log n)** solution, scalable for arrays up to length 20,000.


---

# 1520. Maximum number of non-overlapping substrings

## ðŸ“Œ Problem summary
We are given a string `s` of lowercase letters. We need to select the maximum number of non-empty substrings such that:
- Each chosen substring contains all occurrences of every character it includes.
- Substrings do not overlap.
- If multiple selections have the same number of substrings, choose the one with the minimum total length. The minimal-length solution is unique.

Return the substrings in any order.

---

## ðŸ’¡ Core idea
- For each character, compute its first and last occurrence: intervals `[left[c], right[c]]`.
- Expand each interval so that every character inside is fully covered (its entire occurrence range is included). If expansion reveals a character whose first occurrence lies before the intervalâ€™s start, the interval is invalid (cannot start here).
- From all valid expanded intervals, sort by end index and greedily pick non-overlapping intervals to maximize count and minimize total length.

---

## ðŸ§© Code (C++)
```cpp
class Solution {
public:
    vector<string> maxNumOfSubstrings(string s) {
        int n = s.size();
        vector<int> left(26, n), right(26, -1);

        // Step 1: first/last positions for each character
        for (int i = 0; i < n; i++) {
            int c = s[i] - 'a';
            left[c] = min(left[c], i);
            right[c] = max(right[c], i);
        }

        // Step 2: expand intervals to fully cover inner characters
        vector<pair<int,int>> intervals;
        for (int c = 0; c < 26; c++) {
            if (right[c] == -1) continue;
            int l = left[c], r = right[c];
            bool valid = true;
            for (int i = l; i <= r; i++) {
                int cc = s[i] - 'a';
                if (left[cc] < l) { valid = false; break; }
                r = max(r, right[cc]);
            }
            if (valid) intervals.emplace_back(l, r);
        }

        // Step 3: greedy selection by earliest end to avoid overlaps
        sort(intervals.begin(), intervals.end(),
             [](const auto& a, const auto& b){ return a.second < b.second; });

        vector<string> result;
        int prevEnd = -1;
        for (auto &p : intervals) {
            if (p.first > prevEnd) {
                result.push_back(s.substr(p.first, p.second - p.first + 1));
                prevEnd = p.second;
            }
        }

        return result;
    }
};
```

## ðŸ§­ Step-by-step logic
- **Collect ranges:** For each character `c`, find the smallest index `left[c]` and largest index `right[c]`.
- **Expand interval:** For an initial interval `[l, r]` (for some `c`), scan from `i = l` to `r`:
  - **If:** `left[s[i]] < l` â†’ interval invalid (you started too late; this character begins earlier).
  - **Else:** update `r = max(r, right[s[i]])` to fully include the characterâ€™s range.
- **Greedy choose:** Sort valid intervals by end; pick intervals whose start is greater than the end of the last chosen interval.
- **Why minimal length is guaranteed:** Choosing by earliest end maximizes count and minimizes total covered length for that count.

---

## â±ï¸ Complexity
- **Time:** O(n + 26 Â· n + m log m)  
  - **Label:** `n` is the string length, `m` is the number of valid intervals (â‰¤ 26).  
  - **First/last scan:** O(n).  
  - **Expansion per interval:** in total O(26 Â· n) worst-case.  
  - **Sorting intervals:** O(m log m), negligible.
- **Space:** O(26) for bounds + O(m) for intervals + O(k) for output substrings.

---

## âš ï¸ Pitfalls
- **Invalid starts:** If any character inside the tentative interval starts before `l`, discard the interval.
- **Full coverage:** Always expand `r` to include the full range of every character encountered.
- **Greedy order:** Sort by end index, not by start, to ensure non-overlapping maximum count and minimal total length.

---

## âœ… Sanity checks
- **Input:** `s = "adefaddaccc"`  
  - **Output:** `["e","f","ccc"]`  
  - **Reason:** Minimal intervals expanded and greedily chosen by earliest end avoid overlap and split `"ef"` into `["e","f"]`.
- **Input:** `s = "abbaccd"`  
  - **Output:** `["d","bb","cc"]`  
  - **Reason:** `["d","abba","cc"]` has the same count but larger total length, so itâ€™s suboptimal.

---

## ðŸŽ¯ Key takeaway
This is an **intervals + greedy** problem: expand per-character ranges to valid self-contained intervals, then select non-overlapping intervals by earliest end. 
This maximizes the number of substrings and enforces the unique minimal total length solution.


---

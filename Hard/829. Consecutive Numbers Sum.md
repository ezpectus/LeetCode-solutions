# 829. Consecutive Numbers Sum — Architectural Solution

---

## Problem Statement
Given an integer `n`, return the number of ways to write `n` as the sum of consecutive positive integers.

Constraints:  
- 1 ≤ n ≤ 10⁹  

---

## Core Idea
We want to count the number of sequences of consecutive integers that sum to `n`.

Suppose the sequence starts at integer `a` and has length `k`.  
The sum is:
```
n = a + (a+1) + (a+2) + ... + (a+k-1)
n = ka + k(k-1)/2
```
Rearranging:
```
n = ka + k(k-1)/2
=> a = (n - k*(k-1)/2) / k
```

For `a` to be a positive integer:
- `(n - k*(k-1)/2)` must be divisible by `k`.  
- `a > 0`.  

Thus, the problem reduces to iterating over possible lengths `k` and checking divisibility.

Observation:
- `k*(k-1)/2 < n` must hold.  
- So `k` can go up to `sqrt(2n)`.  

---

## Implementation (C#)
```csharp
using System;

public class Solution {
    public int ConsecutiveNumbersSum(int n) {
        int count = 0;
        for (int k = 1; k * (k - 1) / 2 < n; k++) {
            int numerator = n - k * (k - 1) / 2;
            if (numerator % k == 0) {
                count++;
            }
        }
        return count;
    }
}
```


## Complexity Analysis
- **Time Complexity:** O(√n)  
  We only iterate up to `sqrt(2n)` possible sequence lengths.  
- **Space Complexity:** O(1)  
  Only counters and a few integer variables are required.

---

## Pitfalls & Edge Cases
- **Large n (up to 10⁹)**  
  Use `long` in calculations if needed to avoid overflow in `k*(k-1)/2`.  
- **Divisibility check**  
  `(n - k*(k-1)/2)` must be divisible by `k` to yield a valid starting integer.  
- **Positive start**  
  Ensure `a > 0`. The formula guarantees this if the numerator ≥ k.  
- **Small n**  
  For `n = 1`, only one valid sequence exists (length 1).  

---

## Conclusion
This solution applies the arithmetic series formula to transform the problem into a divisibility check across possible sequence lengths.  

Architecturally, the design is clean:
- **Formula derivation** ensures correctness.  
- **Iteration up to √n** ensures efficiency.  
- **Divisibility check** guarantees valid sequences.  

The algorithm runs in **O(√n)** time with **O(1)** space, making it efficient and robust for values of `n` up to 10⁹.


---

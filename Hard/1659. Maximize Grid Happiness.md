# 1659. Maximize Grid Happiness  
*O(m*n * 3^n * introvertsCount * extrovertsCount) — Bitmask DP with Position & Remaining Counts*

---

## Problem Statement

You have an `m × n` grid (1 ≤ m, n ≤ 5).  
You are given `introvertsCount` introverts and `extrovertsCount` extroverts (each ≤ min(m×n, 6)).

Place **any number** (including zero) of these people on the grid (at most one per cell).  
Happiness rules:
- **Introvert**: starts with **120** happiness, loses **30** for **each** adjacent neighbor (up, down, left, right)
- **Extrovert**: starts with **40** happiness, gains **20** for **each** adjacent neighbor

**Goal**: maximize the **total happiness** of all placed people.  
Return this maximum possible happiness value.

**Note**: adjacency is 4-directional (North, East, South, West).  
Empty cells contribute 0 happiness and do not affect neighbors.

**Constraints**:
- 1 ≤ m, n ≤ 5
- 0 ≤ introvertsCount, extrovertsCount ≤ min(m×n, 6)

---

## Core Idea — Position-based Bitmask DP

Since m × n ≤ 25 and total people ≤ 12, we can use **DP on position** (flatten grid to 0..m*n-1) with:
- Current position in grid
- Remaining introverts
- Remaining extroverts
- Bitmask of previous row placement (to know upper neighbor)

But in this code, we use a **flattened position** + previous row mask + remaining counts.

**State**:
- `position` — current cell index (0 to m*n-1, row-major order)
- `remICount` — remaining introverts
- `remECount` — remaining extroverts
- `prevState` — bitmask of the **previous row** placement (each 2 bits: 0=empty, 1=intro, 2=extro)

**Per state**:
- Option 1: skip current cell (leave empty)
- Option 2: place introvert (if remICount > 0)
- Option 3: place extrovert (if remECount > 0)

**Happiness**:
- Base happiness: 120 for introvert, 40 for extrovert
- Interaction with **left neighbor** (if position % n > 0 and left cell occupied)
- Interaction with **upper neighbor** (if position / n > 0 and upper cell occupied)

**Transition**:
- For each choice (skip, intro, extro):
  - Update happiness
  - Update remaining counts
  - Update new prevState for next position (shift and add current choice)
  - Recurse to position + 1

**Memoization**: memo[position][remICount][remECount][prevState]

**State size**:
- position: m*n ≤ 25
- remICount ≤ 6
- remECount ≤ 6
- prevState: 3^n ≤ 3^5 = 243
- Total states ≈ 25 × 7 × 7 × 243 ≈ 30,000 — very small and fast

---

## Clean Implementation (C#)

```csharp
public class Solution 
{
    private int?[,,,] memo;
    private int iCount, eCount, totalStates;
    private int pm, pn;

    public int GetMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) 
    {
        totalStates = (int)Math.Pow(3, n);
        memo = new int?[m * n, introvertsCount + 1, extrovertsCount + 1, totalStates];
        iCount = introvertsCount;
        eCount = extrovertsCount;
        pn = n;
        pm = m;

        return dp(0, introvertsCount, extrovertsCount, 0);
    }

    private int dp(int position, int remICount, int remECount, int prevState) 
    {
        if (pn * pm == position) 
        {
            return 0;
        }

        if (memo[position, remICount, remECount, prevState] != null) 
        {
            return memo[position, remICount, remECount, prevState].Value;
        }

        // Option 1: Skip this position (leave empty)
        int skipState = SetLastState(prevState, 0);
        int result = dp(position + 1, remICount, remECount, skipState);

        int left = GetState(prevState, 0);  // left neighbor state
        int up = GetState(prevState, pn - 1);  // upper neighbor state (previous row)

        // Option 2: Place introvert
        if (remICount > 0) 
        {
            int diff = 120;

            // Left neighbor interaction
            if (position % pn > 0 && left != 0) 
            {
                diff -= 30;
                diff += (left == 1) ? -30 : 20;
            }

            // Upper neighbor interaction
            if (position / pn > 0 && up != 0) 
            {
                diff -= 30;
                diff += (up == 1) ? -30 : 20;
            }

            int newState = SetLastState(prevState, 1);
            result = Math.Max(result, diff + dp(position + 1, remICount - 1, remECount, newState));
        }

        // Option 3: Place extrovert
        if (remECount > 0) 
        {
            int diff = 40;

            // Left neighbor interaction
            if (position % pn > 0 && left != 0) 
            {
                diff += 20;
                diff += (left == 1) ? -30 : 20;
            }

            // Upper neighbor interaction
            if (position / pn > 0 && up != 0) 
            {
                diff += 20;
                diff += (up == 1) ? -30 : 20;
            }

            int newState = SetLastState(prevState, 2);
            result = Math.Max(result, diff + dp(position + 1, remICount, remECount - 1, newState));
        }

        memo[position, remICount, remECount, prevState] = result;
        return result;
    }

    // Get the state value at position i (0-based from LSB)
    private int GetState(int state, int i) 
    {
        state = state / (int)Math.Pow(3, i);
        return state % 3;
    }

    // Append new value to the end of the state (shift left, add new)
    private int SetLastState(int state, int value) 
    {
        return ((state * 3) + value) % totalStates;
    }
}
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(m × n × 3ⁿ × introvertsCount × extrovertsCount)** | position: m×n ≤ 25  
prevState: 3ⁿ ≤ 3⁵ = 243  
rem_intro ≤ 6, rem_extro ≤ 6  
Per state: O(1) choices (skip / intro / extro)  
Total states ≈ 25 × 243 × 7 × 7 ≈ 30,000 → very small and fast |
| **Space Complexity**  | **O(m × n × 3ⁿ × introvertsCount × extrovertsCount)** | Memo table size ≈ 25 × 243 × 7 × 7 ≈ 30,000 entries (~120 KB) |

**Optimal for constraints** — m,n ≤ 5 → tiny state space, runs in milliseconds.

---

## How This Code Works — Step-by-Step Explanation

### 1. Flattened Grid
- The grid is flattened into linear positions: 0 to m*n-1 (row-major order)
- `position` = current cell index being decided (0-based)

### 2. State Definition
- `position` — current cell in the flattened grid
- `remICount` — remaining introverts available to place
- `remECount` — remaining extroverts available to place
- `prevState` — bitmask representing the placement in the **previous row**  
  (each column encoded in base-3: 0=empty, 1=introvert, 2=extrovert)

### 3. Transitions (Choices at Current Position)
- **Option 1: Skip** (leave cell empty)
  - No happiness change
  - Set current column state = 0
  - Recurse to position + 1

- **Option 2: Place introvert** (if remICount > 0)
  - Base happiness = **120**
  - Left neighbor interaction (if column > 0 and left cell occupied)
  - Upper neighbor interaction (if row > 0 and upper cell occupied)
  - Decrease remICount by 1
  - Set current column state = 1
  - Recurse to position + 1

- **Option 3: Place extrovert** (if remECount > 0)
  - Base happiness = **40**
  - Same left & upper interactions (but +20 instead of -30 for extro-extro)
  - Decrease remECount by 1
  - Set current column state = 2
  - Recurse to position + 1

### 4. Neighbor Interactions
- **Left neighbor** (same row, previous column):
  - If column > 0 and left cell occupied → add interaction score
  - Introvert-introvert: -30 + -30 = -60
  - Introvert-extrovert: -30 + 20 = -10
  - Extrovert-extrovert: 20 + 20 = +40

- **Upper neighbor** (previous row, same column):
  - If row > 0 and upper cell occupied → add interaction score (same logic)

### 5. Memoization
- Memo table: `[position][remICount][remECount][prevState]`
- Prevents recomputing the same subproblem

### 6. Base Case
- If `position == m * n` → all cells processed → return **0**

**Correctness**:
- Exhaustively explores all valid placements
- Correctly calculates happiness from every neighbor pair
- Remaining counts prevent placing more people than available
- Bitmask prevState correctly tracks upper neighbors for each column

---

## Key Takeaway

This is a **classic grid placement with neighbor-based happiness** problem solved with **position-based DP**:

* Flatten the grid into linear positions 0 to m*n-1
* Use DP state: current position, remaining introverts, remaining extroverts, previous row placement mask
* At each position:
  * Try 3 choices: empty, introvert, or extrovert (if remaining)
  * Add base happiness + interaction penalties/bonuses from left & upper neighbors
  * Recurse to next position with updated state
* Memoize all states to avoid recomputation
* Maximize total happiness

**Pure, clean, optimal** — exponential in columns (n ≤ 5), linear in rows (m ≤ 5), tiny state space (~30k), runs in milliseconds.

---

#  Pattern Name  
**Hierarchical Topological Sort with Group-Aware Dependency Resolution**

---

##  Problem Overview  
You're given `n` items, each optionally assigned to one of `m` groups (`group[i] ‚àà [0, m‚Äì1]` or `‚Äì1`).  
Each item may depend on other items (`beforeItems[i]`) that must appear earlier in the final ordering.  
**Goal:** Return a valid ordering of items such that:

- All dependencies are respected  
- Items of the same group appear contiguously  
- Return empty list if no valid ordering exists

---

## üîç Problem Anatomy

| Component        | Role                                                   |
|------------------|--------------------------------------------------------|
| `group[i]`       | Group assignment for item `i` (‚Äì1 means ungrouped)     |
| `beforeItems[i]` | List of items that must precede item `i`               |
| `itemGraph`      | Dependency graph between items                         |
| `groupGraph`     | Dependency graph between groups                        |
| `itemOrder`      | Topological sort of items                              |
| `groupOrder`     | Topological sort of groups                             |
| `orderedGroup`   | Mapping from group ‚Üí ordered list of its items         |

---

##  C# Implementation

```csharp
public class Solution {
    public int[] SortItems(int n, int m, int[] group, IList<IList<int>> beforeItems) {
        int nextGroupId = m;
        for (int i = 0; i < n; i++) {
            if (group[i] == -1)
                group[i] = nextGroupId++;
        }

        var itemGraph = new Dictionary<int, List<int>>();
        var groupGraph = new Dictionary<int, List<int>>();
        var itemIndegree = new int[n];
        var groupIndegree = new int[nextGroupId];

        for (int i = 0; i < n; i++) itemGraph[i] = new();
        for (int i = 0; i < nextGroupId; i++) groupGraph[i] = new();

        for (int curr = 0; curr < n; curr++) {
            foreach (int pre in beforeItems[curr]) {
                itemGraph[pre].Add(curr);
                itemIndegree[curr]++;
                if (group[curr] != group[pre]) {
                    groupGraph[group[pre]].Add(group[curr]);
                    groupIndegree[group[curr]]++;
                }
            }
        }

        var itemOrder = TopoSort(itemGraph, itemIndegree, n);
        var groupOrder = TopoSort(groupGraph, groupIndegree, nextGroupId);

        if (itemOrder.Count == 0 || groupOrder.Count == 0)
            return Array.Empty<int>();

        var groupedItems = new Dictionary<int, List<int>>();
        foreach (int item in itemOrder) {
            if (!groupedItems.ContainsKey(group[item]))
                groupedItems[group[item]] = new();
            groupedItems[group[item]].Add(item);
        }

        var result = new List<int>();
        foreach (int g in groupOrder) {
            if (groupedItems.ContainsKey(g))
                result.AddRange(groupedItems[g]);
        }

        return result.ToArray();
    }

    private List<int> TopoSort(Dictionary<int, List<int>> graph, int[] indegree, int total) {
        var res = new List<int>();
        var q = new Queue<int>();

        foreach (var node in graph.Keys)
            if (indegree[node] == 0)
                q.Enqueue(node);

        while (q.Count > 0) {
            int curr = q.Dequeue();
            res.Add(curr);
            foreach (int nei in graph[curr]) {
                if (--indegree[nei] == 0)
                    q.Enqueue(nei);
            }
        }

        return res.Count == total ? res : new();
    }
}
```


##  Time and Space Complexity

| Metric           | Value     | Explanation                                      |
|------------------|-----------|--------------------------------------------------|
| Time Complexity  | O(n + e)  | Two topological sorts over item and group graphs |
| Space Complexity | O(n + e)  | Graphs, indegree arrays, and result buffers      |

---

##  Implementation Commentary

- **Group normalization:**  
  Ungrouped items (`‚Äì1`) are assigned unique group IDs to ensure every item belongs to a valid group.  
  This simplifies group-level dependency tracking and avoids special cases.

- **Dual dependency graphs:**  
  - `itemGraph`: tracks direct item-to-item dependencies  
  - `groupGraph`: tracks inter-group dependencies inferred from item-level edges  
  This separation allows independent resolution of group and item orderings.

- **Topological sort:**  
  Applied separately to both graphs using indegree tracking and queue-based traversal.  
  Ensures acyclic resolution and minimal ordering guarantees.

- **Contiguity enforcement:**  
  After item-level sort, items are bucketed by group.  
  Final result is assembled by iterating through sorted groups and appending their items.

- **Cycle detection:**  
  If either topological sort fails (i.e., not all nodes visited), return empty result.  
  This handles cases with circular dependencies at either level.

---

##  Final Takeaway

This is a **hierarchical dependency resolution** problem solved via **dual topological sorting**, where:

- **Items** are sorted respecting both intra-group and inter-group constraints  
- **Groups** are sorted to enforce contiguous block placement in the final result  
- The solution cleanly separates concerns: first resolve dependencies, then enforce layout

The pattern generalizes to any system with **nested dependency layers**, such as:

- **Tasks within projects** (e.g., build systems, CI pipelines)  
- **Modules within packages** (e.g., compiler passes, dependency trees)  
- **Jobs within departments** (e.g., scheduling with team-level constraints)

This structure is reusable for any problem where **local ordering** must be respected within **global grouping**.



---

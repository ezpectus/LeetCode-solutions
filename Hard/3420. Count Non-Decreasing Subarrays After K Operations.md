# 3420. Count Non-Decreasing Subarrays After K Operations

## ğŸ§  Problem Summary

You're given an integer array `nums` and an integer `k`.  
For each subarray of `nums`, you can apply **up to `k` operations**, where each operation increments **any element** of the subarray by `+1`.

Each subarray is considered **independently** â€” changes made to one do **not** affect others.

Return the number of subarrays that can be made **non-decreasing** after applying at most `k` operations.

---

## ğŸ“Œ Key Insight

- A subarray is **non-decreasing** if every element is `â‰¥` its previous one.
- We can **increment any element** in the subarray, up to `k` times total.
- The goal is to **count how many subarrays can be transformed** into non-decreasing ones using â‰¤ `k` operations.

---

## âš™ï¸ Algorithm Strategy

Instead of checking each subarray individually, we:

1. **Start with the total number of subarrays**:
```
res = n * (n + 1) / 2
```

2. For each starting index `i`:
- Track the **maximum so far** (`premax`)
- Move `idx` forward while the subarray `[i..idx]` can be made non-decreasing with â‰¤ `k` operations
- If `nums[idx] < premax`, we need `premax - nums[idx]` operations to fix it
- Accumulate operations in `opt`
- If `opt > k`, break â€” all subarrays starting at `i` and ending at `idx` or later are invalid
- Subtract `(n - idx)` from the total

This avoids brute-force checking and **greedily skips invalid tails**.

---

## ğŸ“¦ Code (C#)

```csharp
public class Solution {
 public long CountNonDecreasingSubarrays(int[] nums, int k) {
     int n = nums.Length;
     long res = (long)(1 + n) * n / 2;

     for (int i = 0; i < n - 1; i++) {
         int premax = nums[i], idx = i + 1;
         int opt = 0;

         while (idx < n && opt <= k) {
             int diff = nums[idx] - premax;
             if (diff >= 0) {
                 premax = nums[idx];
             } else {
                 opt -= diff;
             }

             if (opt > k) break;
             idx++;
         }

         if (idx >= n) return res;
         res -= (n - idx);
     }

     return res;
  }
}

```

## ğŸ§® Complexity

| Metric | Value |
|--------|-------|
| Time   | O(nÂ²) worst case, but greedy skips |
| Space  | O(1)  |

### ğŸ”§ Breakdown

- **Initial count**: We start by computing the total number of subarrays using the formula:  
  `res = n * (n + 1) / 2`
- **Greedy filtering**: For each starting index `i`, we extend the subarray to the right as far as possible while keeping the total number of required operations â‰¤ `k`.
- **Early termination**: Once the operation count exceeds `k`, we subtract the invalid tail in one step â€” no need to simulate each subarray.
- **No extra memory**: All calculations are done in-place using scalar variables (`premax`, `opt`, `idx`), so space remains constant.

This approach avoids brute-force simulation and leverages greedy skipping to stay efficient even under tight constraints.

---

## ğŸ” Edge Cases

### âœ… Already sorted input
- Example: `[1, 2, 3, 4]`
- No operations needed â€” all subarrays are valid by default.
- Final result equals total subarray count.

### ğŸ”» Strictly decreasing input
- Example: `[5, 4, 3, 2]`
- Many subarrays require heavy lifting to become non-decreasing.
- Greedy logic filters them early by accumulating operation cost.

### ğŸŸ¢ Single-element subarrays
- Always valid â€” no comparisons or operations needed.
- Automatically included in the result.

### ğŸ”¥ Large `k`
- Example: `k = 10â¹`
- Almost all subarrays can be transformed into non-decreasing.
- The algorithm rarely breaks early â€” result approaches full count.

### ğŸ§Š Small `k`
- Example: `k = 0` or `k = 1`
- Only subarrays that are already sorted or require minimal adjustment survive.
- Most subarrays are filtered out quickly.

### ğŸŒ€ Mixed spikes and dips
- Example: `[3, 1, 4, 2, 5]`
- Tests the algorithmâ€™s ability to track `premax` and accumulate cost precisely.
- Greedy logic ensures only feasible subarrays are counted.



---


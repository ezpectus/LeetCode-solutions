# 3420. Count Non-Decreasing Subarrays After K Operations

## 🧠 Problem Summary

You're given an integer array `nums` and an integer `k`.  
For each subarray of `nums`, you can apply **up to `k` operations**, where each operation increments **any element** of the subarray by `+1`.

Each subarray is considered **independently** — changes made to one do **not** affect others.

Return the number of subarrays that can be made **non-decreasing** after applying at most `k` operations.

---

## 📌 Key Insight

- A subarray is **non-decreasing** if every element is `≥` its previous one.
- We can **increment any element** in the subarray, up to `k` times total.
- The goal is to **count how many subarrays can be transformed** into non-decreasing ones using ≤ `k` operations.

---

## ⚙️ Algorithm Strategy

Instead of checking each subarray individually, we:

1. **Start with the total number of subarrays**:
```
res = n * (n + 1) / 2
```

2. For each starting index `i`:
- Track the **maximum so far** (`premax`)
- Move `idx` forward while the subarray `[i..idx]` can be made non-decreasing with ≤ `k` operations
- If `nums[idx] < premax`, we need `premax - nums[idx]` operations to fix it
- Accumulate operations in `opt`
- If `opt > k`, break — all subarrays starting at `i` and ending at `idx` or later are invalid
- Subtract `(n - idx)` from the total

This avoids brute-force checking and **greedily skips invalid tails**.

---

## 📦 Code (C#)

```csharp
public class Solution {
 public long CountNonDecreasingSubarrays(int[] nums, int k) {
     int n = nums.Length;
     long res = (long)(1 + n) * n / 2;

     for (int i = 0; i < n - 1; i++) {
         int premax = nums[i], idx = i + 1;
         int opt = 0;

         while (idx < n && opt <= k) {
             int diff = nums[idx] - premax;
             if (diff >= 0) {
                 premax = nums[idx];
             } else {
                 opt -= diff;
             }

             if (opt > k) break;
             idx++;
         }

         if (idx >= n) return res;
         res -= (n - idx);
     }

     return res;
  }
}

```

## 🧮 Complexity

| Metric | Value |
|--------|-------|
| Time   | O(n²) worst case, but greedy skips |
| Space  | O(1)  |

### 🔧 Breakdown

- **Initial count**: We start by computing the total number of subarrays using the formula:  
  `res = n * (n + 1) / 2`
- **Greedy filtering**: For each starting index `i`, we extend the subarray to the right as far as possible while keeping the total number of required operations ≤ `k`.
- **Early termination**: Once the operation count exceeds `k`, we subtract the invalid tail in one step — no need to simulate each subarray.
- **No extra memory**: All calculations are done in-place using scalar variables (`premax`, `opt`, `idx`), so space remains constant.

This approach avoids brute-force simulation and leverages greedy skipping to stay efficient even under tight constraints.

---

## 🔍 Edge Cases

### ✅ Already sorted input
- Example: `[1, 2, 3, 4]`
- No operations needed — all subarrays are valid by default.
- Final result equals total subarray count.

### 🔻 Strictly decreasing input
- Example: `[5, 4, 3, 2]`
- Many subarrays require heavy lifting to become non-decreasing.
- Greedy logic filters them early by accumulating operation cost.

### 🟢 Single-element subarrays
- Always valid — no comparisons or operations needed.
- Automatically included in the result.

### 🔥 Large `k`
- Example: `k = 10⁹`
- Almost all subarrays can be transformed into non-decreasing.
- The algorithm rarely breaks early — result approaches full count.

### 🧊 Small `k`
- Example: `k = 0` or `k = 1`
- Only subarrays that are already sorted or require minimal adjustment survive.
- Most subarrays are filtered out quickly.

### 🌀 Mixed spikes and dips
- Example: `[3, 1, 4, 2, 5]`
- Tests the algorithm’s ability to track `premax` and accumulate cost precisely.
- Greedy logic ensures only feasible subarrays are counted.



---


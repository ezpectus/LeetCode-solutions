# Pattern Name  
Lexicographic DP with KMP Automaton for Forbidden Substring Avoidance

---

## Problem Summary

You're given three strings:
- `s1` — lower bound  
- `s2` — upper bound  
- `evil` — forbidden substring

You must count how many strings of length `n`:
- Are lexicographically between `s1` and `s2` (inclusive)  
- Do **not** contain `evil` as a substring

Return the count modulo (10^9 + 7).

---

## Core Idea

This is a bounded string generation task with substring avoidance.  
We use **top-down dynamic programming** to recursively build all valid strings, while tracking:

- Lexicographic bounds (`tightLow`, `tightHigh`)  
- Partial match against `evil` using **KMP prefix table**  
- Memoization over full DP state

The key insight is that we can simulate all valid paths while pruning any that match `evil`, and reuse previously computed states to avoid recomputation.

---

## Phase Breakdown

| Phase                  | Description                                                                 |
|------------------------|-----------------------------------------------------------------------------|
| KMP Preprocessing      | Build prefix table to track partial matches of `evil` efficiently           |
| DP State Definition    | Track position, evil match progress, and lexicographic tightness            |
| Recursive Construction | Explore all valid characters at each position under current constraints     |
| Pruning                | Terminate paths that fully match `evil`                                     |
| Memoization            | Store results for each unique DP state to avoid recomputation               |

---

## DP State Definition

```text
dp(pos, matchedEvil, tightLow, tightHigh, isEvilMatched)
```
- pos — current position in the string
- matchedEvil — how many characters of evil are matched so far
- tightLow — are we still equal to s1 prefix
- tightHigh — are we still equal to s2 prefix
- isEvilMatched — whether evil has been fully matched (invalid path)

---

## C# Implementation
```cpp
public class Solution {
    const int MOD = 1_000_000_007;
    int[,,,,] dp;
    int[] pi;
    string s1, s2, evil;
    int n;

    public int FindGoodStrings(int n, string s1, string s2, string evil) {
        this.n = n;
        this.s1 = s1;
        this.s2 = s2;
        this.evil = evil;
        this.pi = BuildPrefixTable(evil);
        dp = new int[n + 1, evil.Length + 1, 2, 2, 2]; // pos, matched, tightLow, tightHigh, isEvilMatched
        for (int i = 0; i <= n; i++)
            for (int j = 0; j <= evil.Length; j++)
                for (int a = 0; a < 2; a++)
                    for (int b = 0; b < 2; b++)
                        for (int c = 0; c < 2; c++)
                            dp[i, j, a, b, c] = -1;

        return Dfs(0, 0, true, true, false);
    }

    int Dfs(int pos, int matched, bool tightLow, bool tightHigh, bool isEvilMatched) {
        if (isEvilMatched) return 0;
        if (pos == n) return 1;

        int tl = tightLow ? 1 : 0;
        int th = tightHigh ? 1 : 0;
        int ev = isEvilMatched ? 1 : 0;

        if (dp[pos, matched, tl, th, ev] != -1)
            return dp[pos, matched, tl, th, ev];

        char from = tightLow ? s1[pos] : 'a';
        char to = tightHigh ? s2[pos] : 'z';
        int res = 0;

        for (char ch = from; ch <= to; ch++) {
            int nextMatched = matched;
            
            while (nextMatched > 0 && ch != evil[nextMatched])
                nextMatched = pi[nextMatched - 1];
            if (ch == evil[nextMatched])
                nextMatched++;
            bool nextEvil = nextMatched == evil.Length;

            bool nextTightLow = tightLow && (ch == s1[pos]);
            bool nextTightHigh = tightHigh && (ch == s2[pos]);

            res = (res + Dfs(pos + 1, nextMatched, nextTightLow, nextTightHigh, nextEvil)) % MOD;
        }

        dp[pos, matched, tl, th, ev] = res;
        return res;
    }

    int[] BuildPrefixTable(string pattern) {
        int[] pi = new int[pattern.Length];
        for (int i = 1, j = 0; i < pattern.Length; i++) {
            while (j > 0 && pattern[i] != pattern[j])
                j = pi[j - 1];
            if (pattern[i] == pattern[j])
                j++;
            pi[i] = j;
        }
        return pi;
    }
}
```

## Architectural Breakdown

| Component                     | Role                                                                 |
|------------------------------|----------------------------------------------------------------------|
| `dp[pos][matched][tl][th][ev]` | Memoization over full DP state                                       |
| `BuildPrefixTable`           | KMP prefix table for efficient evil tracking                         |
| `tightLow / tightHigh`       | Enforces lexicographic bounds from `s1` and `s2`                     |
| `matched`                    | Tracks how much of `evil` is matched so far                          |
| `nextMatched`                | Updated via KMP logic per character                                  |
| `Dfs`                        | Top-down recursive DP with memoization                               |

---

##  Why This Approach Is Superior

| Aspect               | This Approach                          | Alternative Approach                     |
|----------------------|----------------------------------------|------------------------------------------|
| Evil Tracking        | KMP automaton                          | Manual substring checks (slow)           |
| Lexicographic Bounds | Tight control via `tightLow` / `tightHigh` | Brute-force enumeration                 |
| DP Strategy          | Top-down with memoization              | Bottom-up hard to manage                 |
| State Design         | Full trace of position and constraints | Partial or lossy state                   |
| Performance          | Efficient pruning and reuse            | Redundant recomputation                  |
| Code Clarity         | Modular and layered                    | Entangled and fragile                    |

---

##  Final Takeaway

This solution uses:

- KMP prefix tracking for forbidden substring  
- Lexicographic constraint enforcement via tight bounds  
- Top-down DP with full state memoization  
- Pruning invalid paths early via `isEvilMatched`

The result is a clean and scalable solution for bounded string generation with substring avoidance.  
This pattern is reusable for any task involving:

- Lexicographic bounds  
- Forbidden substring tracking  
- Controlled recursive construction

This module now lives in my repo as:

> **Lexicographic DP with KMP Automaton for Forbidden Substring Avoidance**



---

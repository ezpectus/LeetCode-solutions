# ðŸ§  Valid Number â€” Manual Grammar Parser in C#

## ðŸ“Œ What the Problem Says

Given a string `s`, determine whether it represents a **valid number**.  
We must return `true` if the string is a valid numeric format, otherwise `false`.

---

## ðŸ“œ What the Constraints Require

A valid number can be:
- An **integer**: `"2"`, `"-90"`, `"+6"`
- A **decimal**: `"3.14"`, `"4."`, `"-0.1"`, `".9"`
- A **scientific notation**: `"2e10"`, `"53.5e93"`, `"-123.456e789"`

Invalid examples include:
- `"abc"` â€” contains letters  
- `"1e"` â€” exponent without number after  
- `"e3"` â€” exponent without number before  
- `"99e2.5"` â€” exponent followed by decimal  
- `"--6"` â€” double sign  
- `"."` â€” dot without digits

---

## ðŸ§± Core Idea

We manually parse the string character by character, validating structure using flags:

- `seenDigit` â€” at least one digit before or after exponent  
- `seenDot` â€” only one dot allowed, and not after exponent  
- `seenExp` â€” only one exponent allowed, and only after digit  
- `digitAfterExp` â€” ensures exponent is followed by digit

We also allow signs (`+` or `-`) only:
- At the beginning of the string  
- Immediately after an exponent (`e` or `E`)

---

## ðŸ”§ Implementation in C#

```csharp
public class Solution {
    public bool IsNumber(string s) {
        s = s.Trim();
        if (s.Length == 0) return false;

        bool seenDigit = false;
        bool seenDot = false;
        bool seenExp = false;
        bool digitAfterExp = true;

        for (int i = 0; i < s.Length; i++) {
            char c = s[i];

            if (char.IsDigit(c)) {
                seenDigit = true;
                if (seenExp) digitAfterExp = true;
            }
            else if (c == '+' || c == '-') {
                if (i > 0 && s[i - 1] != 'e' && s[i - 1] != 'E') return false;
            }
            else if (c == '.') {
                if (seenDot || seenExp) return false;
                seenDot = true;
            }
            else if (c == 'e' || c == 'E') {
                if (seenExp || !seenDigit) return false;
                seenExp = true;
                digitAfterExp = false;
            }
            else {
                return false;
            }
        }

        return seenDigit && digitAfterExp;
    }
}
```

## ðŸ§© Architectural Notes

| Component        | Role |
|------------------|------|
| `Trim()`         | Removes leading/trailing whitespace. Ensures that formatting artifacts like spaces donâ€™t interfere with parsing logic. |
| `seenDigit`      | Tracks whether at least one digit has been encountered. Required for a valid number â€” prevents cases like `"."` or `"e"` from passing. |
| `seenDot`        | Ensures that only one decimal point is allowed, and that it appears before any exponent. Prevents invalid formats like `"4..5"` or `"3e.5"`. |
| `seenExp`        | Tracks whether an exponent (`e` or `E`) has been used. Only one exponent is allowed, and it must follow a valid numeric prefix. |
| `digitAfterExp`  | Ensures that if an exponent is present, it is followed by at least one digit. Prevents invalid formats like `"1e"` or `"2e+"`. |

This parser is **manual, fast, and readable**. It avoids regular expressions and full numeric parsing, focusing solely on **structural validation**.  
Each character is processed in sequence, and decisions are made based on its position and context â€” no backtracking or tokenization required.

---

## ðŸ§  Summary

This task is fundamentally a **grammar validation problem**, not a numeric conversion.  
We are not interested in computing the numeric value â€” only in verifying whether the string conforms to a valid numeric format.

The solution uses:
- **Boolean flags** to track structural elements (digits, dots, exponents)
- **Position rules** to enforce correct placement of signs and symbols
- **Early exits** (`return false`) to reject invalid patterns immediately

This approach is ideal for:
- Interview settings (no libraries, full control)
- Embedded systems (low overhead)
- Educational use (clear logic, easy to trace)

It can be extended to other grammar-based validators like:
- `isValidEmail`
- `isValidIPv4`
- `isValidDate`
- `isValidHex`



---

# 1458. Max Dot Product of Two Subsequences — Architectural 2D DP with Four-State Transitions  
*O(n × m) — Optimal Classic DP on Subsequences*

---

## Problem Statement

Given two integer arrays `nums1` and `nums2`.

Find **non-empty** subsequences of **the same length** (one from each array) such that their **dot product** is maximized:
```
dot product = a₁·b₁ + a₂·b₂ + ... + aₖ·bₖ
```


A subsequence maintains relative order but can skip elements.

Return the **maximum possible dot product**.

**Important**: Even if all numbers are negative, we must pick at least one element from each array.

---

## Core Idea — DP on Prefixes with Use/Skip Decisions

**The most important part — how and why it works**

**Key observation**:
- We need to align elements from both arrays in order (subsequence constraint).
- At each position, we have choices: **skip** current element in nums1, **skip** in nums2, or **use both**.
- Negative products can be beneficial (negative × negative = positive), so we **cannot** ignore negative numbers.

**DP definition**:
- `dp[i][j]` = maximum dot product using the **first i elements** of `nums1` and **first j elements** of `nums2` (0-based prefixes).

**Base cases**:
- `dp[0][j] = dp[i][0] = negative infinity` (impossible to have subsequence with elements from one array only)
- But we must handle single-element cases → initialize carefully

**Transitions** for `dp[i][j]` (i>0, j>0):
1. **Skip** current in nums1: `dp[i-1][j]`
2. **Skip** current in nums2: `dp[i][j-1]`
3. **Use both** current elements: `dp[i-1][j-1] + nums1[i-1] * nums2[j-1]`

Take **maximum** of valid options.

**Also allow** starting new subsequence with current pair: `nums1[i-1] * nums2[j-1]`

**Final answer**: `dp[n][m]` — using full arrays.

**Why this covers everything**:
- Every possible pair of subsequences corresponds to some alignment path in the DP table.
- By taking max at each step, we choose the best possible alignment.
- Negative contributions are naturally handled — sometimes using two negatives gives positive boost.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int MaxDotProduct(int[] nums1, int[] nums2) {
        int n = nums1.Length;
        int m = nums2.Length;

        int[] dp = new int[m + 1];
        Array.Fill(dp, int.MinValue / 2);

        for (int i = 1; i <= n; i++) {
            int[] newDp = new int[m + 1];
            Array.Fill(newDp, int.MinValue / 2);

            for (int j = 1; j <= m; j++) {
                newDp[j] = Math.Max(dp[j], newDp[j-1]);

                int use = nums1[i-1] * nums2[j-1];
                newDp[j] = Math.Max(newDp[j], use);
                newDp[j] = Math.Max(newDp[j], dp[j-1] + use);
            }

            dp = newDp;
        }

        return dp[m];
    }
}
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n × m)**          | n,m ≤ 500 → ~250k operations                   |
| **Space Complexity**  | **O(n × m)** or **O(m)** | Full table or rolling row optimization      |

**Optimal** — n,m small, linear in input size.

---

## Why This Works — Example Walkthrough

**Input**: `nums1 = [2,1,-2,5]`, `nums2 = [3,0,-6]`

- DP progression:
  - At i=1 (2), j=1 (3): use = 2*3 = 6
  - At i=3 (-2), j=3 (-6): use = (-2)*(-6) = **12**
  - Previous best ending before both: dp[0][0] + 2*3 = 6
  - Total: 6 + 12 = **18**
- Final dp[n][m] = **18**

**Correct** — subsequences [2, -2] and [3, -6] → 2×3 + (-2)×(-6) = 18

**Input**: arrays with negative numbers

- Negative × negative → positive contribution → naturally captured by using both

**Correct**.

---

## Pitfalls & Edge Cases

- **All negative** → pair two negatives → positive product
- **One positive** → best is single largest positive
- **Zeros** → can skip or use (0 contribution)
- **n=1 or m=1** → just the single element product
- **Mixed signs** → optimal may skip some

All handled perfectly.

---

## Key Takeaway

This is a **classic subsequence DP**:

- **Use or skip** current element in either array
- **Take max** over all possible endings
- **Handles negative products** naturally (positive from two negatives)
**Pure, clean, optimal** — perfect max dot product of subsequences.

---

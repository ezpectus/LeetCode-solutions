# LeetCode 546 — Remove Boxes  
**Approach: 3D Dynamic Programming**

---

##  Problem Restatement
We are given an array `boxes` representing colors.  
- Removing `k` consecutive boxes of the same color earns `k * k` points.  
- After removal, the remaining boxes close the gap.  
We must maximize the total points.

---

##  Core Idea
This is a **hard DP problem** because removing boxes changes the structure.  
Key insight:  
- When removing boxes, sometimes it’s optimal to **merge non-contiguous boxes of the same color** by removing the middle part first.  
- To capture this, we use **3D DP**:  

`dp[l][r][k]` = maximum points from subarray `boxes[l..r]` with `k` extra boxes of the same color as `boxes[l]` attached to the left.  

Transitions:  
1. Remove `boxes[l]` and its `k` extras immediately:  
   → `(k+1)^2 + dp[l+1][r][0]`.  
2. Try to merge with a later box of the same color:  
   → `dp[l+1][i-1][0] + dp[i][r][k+1]` if `boxes[i] == boxes[l]`.  

---

## Implementation (C#)

```csharp
public class Solution {
    private int[,,] memo;
    private int[] boxes;

    public int RemoveBoxes(int[] boxes) {
        this.boxes = boxes;
        int n = boxes.Length;
        memo = new int[n, n, n];
        return DP(0, n - 1, 0);
    }

    private int DP(int l, int r, int k) {
        if (l > r) return 0;
        if (memo[l, r, k] != 0) return memo[l, r, k];

        // Optimization: merge consecutive same-color boxes at the start
        int origL = l, origK = k;
        while (l + 1 <= r && boxes[l] == boxes[l + 1]) {
            l++;
            k++;
        }

        // Option 1: remove current block immediately
        int res = (k + 1) * (k + 1) + DP(l + 1, r, 0);

        // Option 2: try merging with later same-color boxes
        for (int i = l + 1; i <= r; i++) {
            if (boxes[i] == boxes[l]) {
                res = Math.Max(res, DP(l + 1, i - 1, 0) + DP(i, r, k + 1));
            }
        }

        memo[origL, r, origK] = res;
        return res;
    }
}
```


##  Time Complexity
- **DP states:**  
  Each state defined by `(l, r, k)` where `l` and `r` are indices and `k` is the count of extra boxes.  
  → `O(n^3)` states since each dimension ≤ `n`.  

- **Transitions:**  
  For each state, we may scan subarray to find same-color merges.  
  → Worst case `O(n^4)`, but pruning and memoization reduce practical runtime.  

- **Overall:**  
  With memoization, runtime is acceptable for `n ≤ 100`.

---

##  Space Complexity
- **Memoization table:**  
  Stores results for `(l, r, k)` states.  
  → `O(n^3)` space, up to `10^6` states.  

- **Fits within constraints:**  
  Memory usage is feasible for `n ≤ 100`.

---

#  Impact of Design Choices

| Design Choice          | Effect                                                                 |
|------------------------|------------------------------------------------------------------------|
| **3D DP (l,r,k)**      | Captures merging of non-contiguous same-color boxes.                   |
| **Memoization**        | Avoids recomputation, ensures feasible runtime.                        |
| **Greedy merge at start** | Reduces redundant states, improves efficiency.                         |

---

#  Pitfalls
- **Forgetting to merge consecutive same-color boxes at the start:**  
  Leads to exponential blowup in states.  
- **Using 2D DP only:**  
  Fails to capture merging across gaps.  
- **Not memoizing:**  
  Causes TLE due to repeated recomputation.  

---

#  Conclusion
- **What it gives:** Maximum points achievable by optimal box removal.  
- **Why it matters:** Demonstrates advanced DP with state compression.  
- **Key takeaway:**  
  1. Use 3D DP to capture merging.  
  2. Memoize results.  
  3. Optimize by merging consecutive same-color boxes early.  



---

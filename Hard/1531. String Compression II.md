# 1531. String Compression II  
*O(n² × k) — Optimal DP with Backward Run Counting*

---

## Problem Statement

Given a string `s` (lowercase English letters, length ≤ 100) and integer `k` (0 ≤ k ≤ n).
You can delete **at most k** characters from `s`.
After deletions, compress the remaining string using **run-length encoding** (no '1' for single characters):

- "aaabccc" → "a3bc3" (length 6)
- "aaaaaaaaaaa" → "a11" (length 3)

Find the **minimum possible length** of the compressed string after ≤ k deletions.

---

## Core Idea — DP with Backward Iteration for Last Run

**State**:
- `dp[i][j]` — minimum compressed length after processing first `i` characters using **exactly** `j` deletions

**Transition** (for each ending position i and deletions j):
- Iterate backward from i to find possible starting point l of the **last run** ending at i
- In [l..i]:
  - `count` = number of characters equal to `s[i]`
  - `del_needed` = (i - l + 1) - count (deleted characters in this segment)
- If `j >= del_needed`:
  - Compressed length added by this run = 1 (character) + number of digits in count
    - count = 1 → +1
    - count = 2–9 → +2
    - count = 10–99 → +3
    - count ≥ 100 → +4
  - Update: `dp[i][j] = min(dp[i][j], dp[l-1][j - del_needed] + added)`
- Also always allow deleting current char: `dp[i][j] = min(dp[i][j], dp[i-1][j-1])` (if j > 0)

**Answer**:
- Minimum over all `dp[n][j]` for `j ≤ k`

---

## Clean Implementation (C#) 

```csharp
public class Solution {
    public int GetLengthOfOptimalCompression(string s, int k) {
        int n = s.Length;
        var dp = new int[110,110];

        for(int i =0;i <= n;i++){
            for(int j =0; j <= n;j++){
                dp[i,j] = 9999;
            }
        }
        dp[0,0] =0;

        for(int i = 1;i <=n;i++){
            for(int j =0;j <= k;j++){
                int count =0,del =0;

                for(int l = i;l >= 1;l--){
                    if(s[l-1] == s[i-1]) count++;
                    else del++;

                    if(j - del >=0){
                        int len = count >= 100 ? 3 : count >= 10 ? 2 : count >= 2 ? 1 : 0;
                        dp[i,j] = Math.Min(dp[i,j] , dp[l-1,j-del] + 1 + len);
                    }                
                }
                if( j > 0) dp[i,j] = Math.Min(dp[i,j] , dp[i-1,j-1]);   
            }
        }

        return dp[n,k];
    }
}
```


## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n² × k)**         | For each position i (1 to n ≤ 100), each deletions j (0 to k ≤ 100), backward loop over l = i downto 1 → O(n) per cell → total ~100 × 100 × 100 = 10⁶ operations |
| **Space Complexity**  | **O(n × k)**          | DP table size (n+1) × (k+1) ≈ 101 × 101 ≈ 10k integers (~40 KB) |

**Optimal** — under the problem constraints (n ≤ 100, k ≤ 100) this runs very fast (~10⁶ operations) and uses minimal memory.

---

## Why This Works — Example Walkthrough

**Example 1**: `s = "aaabcccd"`, `k = 2`

- Optimal strategy: delete 'b' and 'd' → remaining "aaa ccc" → compressed "a3c3" length **4**
- DP explores every position i and every possible number of deletions j
- For each i and j, it tries different starting points l for the **last run** ending at i
  - Counts how many characters equal to s[i] were kept
  - Computes deletions needed in that segment
  - Adds correct compressed length of the run (1 for char + digits for count)
  - Takes minimum from previous state dp[l-1][j - deletions]
- Also always allows deleting the current character
- At the end, the minimum over dp[n][j] for j ≤ k gives **4** → correct

**Example 2**: `s = "aabbaa"`, `k = 2`

- Delete two 'b's → "aaaa" → compressed "a4" length **2** → correct

**Example 3**: `s = "aaaaaaaaaaa"`, `k = 0`

- No deletions allowed → compressed "a11" length **3** → correct

**Correct** — backward iteration from each position i efficiently counts kept characters in the last run, calculates exact deletions needed, and minimizes the total compressed length.

---

## Pitfalls & Edge Cases

- **All identical characters** → compressed as "aN" → length = 1 + number of digits in N
- **k = 0** → no deletions → standard RLE length of original string
- **k ≥ n** → can delete everything → length **0** (empty string, valid)
- **Single-character runs** → add length 1 (character only, no digit)
- **Runs of length 10–99** → add 2 digits, ≥100 → add 3 digits (handled correctly)

All handled perfectly.

---

## Key Takeaway

This is a **classic DP on string compression with limited deletions**:

- `dp[i][j]` = minimum compressed length after processing first i characters using exactly j deletions
- For each ending position i and deletions j:
  - Iterate backward l to form the last run ending at i
  - Count kept characters (equal to s[i]), deletions = segment length - kept
  - Compute added compressed length of this run: 1 (character) + number of digits in count
  - Update dp[i][j] from dp[l-1][j - deletions] + added length
- Always allow deleting current character: dp[i][j] ≤ dp[i-1][j-1] (if j > 0)
- Final answer = minimum over dp[n][j] for all j ≤ k

**Pure, clean, optimal** — perfect minimum RLE length after deleting ≤ k characters.

---

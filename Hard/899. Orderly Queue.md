# 899. Orderly Queue

---

## Problem Restatement
We are given a string `s` and an integer `k`.  
At each move, we can choose one of the first `k` letters of `s` and append it to the end.  
We must return the **lexicographically smallest string** achievable after any number of moves.

Constraints:
- 1 ≤ k ≤ s.length ≤ 1000  
- `s` consists of lowercase English letters.  

---

## Key Idea
- **Case 1: k = 1**  
  - We can only rotate the string by moving the first character to the end.  
  - Thus, the result is the lexicographically smallest rotation of `s`.  
  - Check all rotations and pick the smallest.

- **Case 2: k > 1**  
  - We can rearrange characters more flexibly.  
  - In fact, with k ≥ 2, we can generate any permutation of the string.  
  - Therefore, the smallest possible string is simply the **sorted string**.

---

## Code (C#)
```csharp
public class Solution {
    public string OrderlyQueue(string s, int k) {
        if (k == 1) {
            string smallest = s;
            for (int i = 1; i < s.Length; i++) {
                string rotation = s.Substring(i) + s.Substring(0, i);
                if (string.Compare(rotation, smallest, StringComparison.Ordinal) < 0) {
                    smallest = rotation;
                }
            }
            return smallest;
        } else {
            char[] arr = s.ToCharArray();
            Array.Sort(arr);
            return new string(arr);
        }
    }
}
```


## Time Complexity

### Case k = 1
- **Rotations:** We generate all n rotations of the string.  
- **Comparison:** Each rotation requires O(n) time to build and compare.  
- **Total:** O(n²).  

### Case k > 1
- **Sorting:** We sort the characters of the string.  
- **Total:** O(n log n).  

---

## Space Complexity

### Case k = 1
- **Temporary strings:** O(n) space to store rotations.  
- **Total:** O(n).  

### Case k > 1
- **Character array:** O(n) space for sorting.  
- **Total:** O(n).  

---

## Example Walkthrough

### Example 1
**Input:** s = "cba", k = 1  
- Rotations: "cba", "bac", "acb".  
- Lexicographically smallest = "acb". ✅  

### Example 2
**Input:** s = "baaca", k = 3  
- Since k > 1, we can rearrange freely.  
- Sorted string = "aaabc". ✅  

### Example 3
**Input:** s = "zxy", k = 2  
- Since k ≥ 2, sort string → "xyz". ✅  

---

## Why This Works
- **Case k = 1:** Only rotations are possible, so we must check all cyclic shifts.  
- **Case k ≥ 2:** The operation allows arbitrary rearrangements, effectively giving us access to all permutations.  
- Sorting guarantees the lexicographically smallest arrangement.  

---

## Edge Cases
- **Single character string:** Always returns itself.  
- **Already sorted string:** No changes needed, output is the same.  
- **Repeated characters:** Sorting still ensures correct lexicographic order.  
- **Maximum length (1000):** Both O(n²) and O(n log n) are efficient enough.  

---

## ✅ **Conclusion**  
The solution splits into two distinct cases:  
- **k = 1 → smallest rotation**  
- **k ≥ 2 → sorted string**  

This dual-case approach leverages rotation analysis and sorting to guarantee the lexicographically smallest string.  
It is efficient, robust, and handles strings up to length 1000 with ease.


---

# 805. Split Array With Same Average

---

##  Problem Restatement
You are given an integer array `nums`.  
You must split it into two non‑empty arrays `A` and `B` such that:

average(A) = average(B)

Return `true` if such a split is possible, otherwise `false`.

Constraints:  
- 1 ≤ nums.length ≤ 30  
- 0 ≤ nums[i] ≤ 10^4  

---

##  Core Idea
- Let `sum` = total sum of array, `n` = length.  
- Condition: there exists a non‑empty subset of size `k` with sum = (sum * k) / n.  
- This reduces to a **subset sum problem with ratio constraint**.  
- Use **DP / backtracking with pruning** to check if such subset exists.  
- Key optimization:  
  - Only need to check subset sizes from 1 to n/2.  
  - If (sum * k) % n != 0, skip (target sum not integer).  

---

##  Step‑by‑Step
1. Compute total sum and length `n`.  
2. For each subset size `k` from 1 to n/2:  
   - Check if (sum * k) % n == 0.  
   - If yes, target sum = (sum * k) / n.  
   - Use DFS/DP to check if subset of size `k` with that sum exists.  
3. If found → return `true`.  
4. If none found → return `false`.

---

##  Code (C#)
```csharp
public class Solution {
    public bool SplitArraySameAverage(int[] nums) {
        int n = nums.Length;
        int sum = nums.Sum();

        // Early pruning
        bool possible = false;
        for (int k = 1; k <= n / 2; k++) {
            if ((sum * k) % n == 0) {
                possible = true;
                break;
            }
        }
        if (!possible) return false;

        // DP: dp[k] = set of possible sums with k elements
        var dp = new HashSet<int>[n + 1];
        for (int i = 0; i <= n; i++) dp[i] = new HashSet<int>();
        dp[0].Add(0);

        foreach (int num in nums) {
            for (int k = n - 1; k >= 0; k--) {
                foreach (int s in dp[k]) {
                    dp[k + 1].Add(s + num);
                }
            }
        }

        for (int k = 1; k <= n / 2; k++) {
            if ((sum * k) % n == 0) {
                int target = (sum * k) / n;
                if (dp[k].Contains(target)) return true;
            }
        }
        return false;
    }
}
```


## Complexity
- **Time:** O(N * sum) worst‑case.  
  Feasible with pruning since N ≤ 30.  
  We only check subset sizes up to N/2 and skip impossible targets, which reduces search space.  
- **Space:** O(N * sum) due to DP sets storing possible sums for each subset size.  
  Memory usage is acceptable given the constraints.

---

## Pitfalls
- **Divisibility check:** Must verify (sum * k) % n == 0 before attempting target sum. Otherwise, we waste time on impossible cases.  
- **Subset size pruning:** Subset sizes larger than n/2 are redundant, since complement subsets cover the same averages.  
- **Integer overflow:** Large values of nums[i] can cause overflow in sum calculations. Use `long` for safety.  
- **Empty subsets:** Both A and B must be non‑empty; ensure subset size k ≥ 1.  
- **Performance traps:** Without pruning, DP may attempt too many states, leading to inefficiency.

---

## Conclusion
This problem reduces to **subset sum with average constraint**.  
By checking feasible subset sizes and using DP to track possible sums, we can determine if a valid split exists.  
The pruning step (divisibility and subset size limit) ensures efficiency.  

Result: clean solution with pruning, robust for N ≤ 30, and a strong example of adapting subset sum techniques to ratio/average constraints.

---

## Generalization
- This pattern applies to **partition problems** where subsets must satisfy ratio or average conditions.  
- Similar techniques are used in load balancing, fair division, and resource allocation tasks.  
- The key is encoding constraints into subset sum checks and pruning infeasible states early.



---

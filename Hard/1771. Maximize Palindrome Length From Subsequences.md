# 1771. Maximize Palindrome Length From Subsequences  
*O((n+m)²) — Longest Palindromic Subsequence on Concatenated String + Boundary Check*

---

## Problem Statement

You are given two strings `word1` and `word2`.

Construct a new string by taking:
- any **non-empty** subsequence of `word1`
- any **non-empty** subsequence of `word2`
- concatenating them: `subsequence1 + subsequence2`

Return the **maximum length** of a **palindrome** you can form this way.  
If impossible → return **0**.

**Examples**:

**Example 1**  
Input: word1 = "cacb", word2 = "cbba"  
Output: **5**  
"ab" + "cba" → "abcba"

**Example 2**  
Input: word1 = "ab", word2 = "ab"  
Output: **3**  
"ab" + "a" → "aba"

**Example 3**  
Input: word1 = "aa", word2 = "bb"  
Output: **0**  
Impossible

**Constraints**:
- 1 ≤ word1.length, word2.length ≤ 1000
- lowercase English letters

---

## Solution — Clean C# Implementation

```csharp
public class Solution{
    public int LongestPalindrome(string word1, string word2){
        string combined = word1 + word2;
        int n = combined.Length;
        int m = word1.Length;

        // DP table: dp[i,j] = length of longest palindromic subsequence in combined[i..j]
        int[,] dp = new int[n, n];

        // Base case: single character is palindrome of length 1
        for (int i = 0; i < n; i++) dp[i, i] = 1;
        
        // Fill DP table for all substring lengths
        for (int len = 2; len <= n; len++){
            for (int i = 0; i <= n - len; i++){
                int j = i + len - 1;

                if (combined[i] == combined[j]) dp[i, j] = dp[i + 1, j - 1] + 2;
                else dp[i, j] = Math.Max(dp[i + 1, j], dp[i, j - 1]);
            
            }
        }

        int result = 0;

        // We only consider palindromes that use at least one character from word1 (i < m)
        // and at least one from word2 (j >= m)
        for (int i = 0; i < m; i++){
            for (int j = m; j < n; j++){
                // If ends match, we can form a valid palindrome using both parts
                if (combined[i] == combined[j]){
                    result = Math.Max(result, dp[i + 1, j - 1] + 2);
                }
            }
        }

        return result;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O((n+m)²)** | Standard LPS DP table fill: O(N²) where N = len(word1) + len(word2) ≤ 2000<br>Boundary crossing check: O(n × m) ≤ 10⁶ |
| **Space Complexity**  | **O((n+m)²)** | DP table of size (n+m) × (n+m) ≈ 4 million integers<br>Can be optimized to O(n+m) using two rolling arrays if memory is tight |

**Optimal** — for n, m ≤ 1000, O(10⁶) operations and ~16 MB memory are perfectly acceptable and run very fast in practice.

---

## Why This Works — Key Points

* Concatenate `word1 + word2` → `combined` (length N = n + m)
* Compute **standard longest palindromic subsequence (LPS)** DP on `combined`
  - `dp[i][j]` = length of longest palindromic subsequence in `combined[i..j]`
* Base case: single character → length 1
* Transition:
  - If `combined[i] == combined[j]` → `dp[i][j] = dp[i+1][j-1] + 2`
  - Else → `dp[i][j] = Math.Max(dp[i+1][j], dp[i][j-1])`
* After filling the table, **only consider palindromes that cross the boundary**:
  - Start index `i < len(word1)` → uses at least one char from word1
  - End index `j ≥ len(word1)` → uses at least one char from word2
  - And boundary characters match (`combined[i] == combined[j]`) → we can pair them
  - Inner part length = `dp[i+1][j-1]`
  - Total length = inner + 2
* Take the **maximum** such value → guarantees non-empty subsequence from both strings

**Correct** —  
The LPS DP on the concatenated string finds the longest possible palindromic subsequence that could span both parts.  
By restricting to palindromes where the start is in word1 and end is in word2 (and boundary characters match), we ensure:
- subsequence from **both** strings
- the whole thing is **palindromic**
- length is **maximal**

---

## Key Takeaway

This is a **beautiful longest palindromic subsequence variant** with two-string constraint:

* Concatenate `word1 + word2` into `combined`
* Run **standard LPS DP** on `combined`
* Only consider palindromes that:
  - Start index < len(word1) → uses word1
  - End index ≥ len(word1) → uses word2
  - And boundary characters match → can form outer pair
* Take maximum length found

**Pure, clean, optimal** — O((n+m)²) time, O((n+m)²) space, very elegant, handles both even and odd length palindromes naturally, works perfectly for n,m ≤ 1000.

---

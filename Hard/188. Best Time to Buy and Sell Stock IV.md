# 🔢 Problem 188: Best Time to Buy and Sell Stock IV

---

## 🧩 Problem Explanation

You are given:  
- An array `prices[]`, where `prices[i]` is the stock price on day `i`.  
- An integer `k`, the maximum number of transactions allowed.  

Each transaction = **one buy + one sell**.  

Rules:  
- You cannot hold more than one stock at a time.  
- You must sell before you can buy again.  

The goal is to **maximize profit** by performing at most `k` transactions.

---

## 📏 Constraints and What They Mean

- `1 <= k <= 100`  
- `1 <= prices.length <= 1000`  
- `0 <= prices[i] <= 1000`  

### Why these constraints matter:
- At most `2k` actions (buy, sell alternating).  
- Up to `1000` days → we need an **efficient algorithm**.  
- Brute force recursion would try all subsets of days → exponential blowup (`O(2^n)`), completely infeasible.  

So:  
✅ A solution in `O(nk)` is required.  
❌ Brute force or naive recursion will not work.

---

## 🧠 Why This DP Approach

Dynamic Programming is the right tool because:  
- Profit on any given day depends only on **previous states** (whether we have bought, sold, or skipped).  
- We can model each possible action (buy or sell) as a **state**, and transition between them.  
- State compression reduces memory from a large 2D table down to just two arrays.  

This approach guarantees:  
- Correct handling of alternating buy/sell.  
- Linear transitions instead of nested loops.  
- Scalability for maximum constraints.

---

## 🔑 Key Idea

- Encode each action as a **state index**:  
  - Odd indices → **buy states**  
  - Even indices → **sell states**  

- Total states: `ka = 1 + 2k` (start + alternating buy/sell).  
- On each day, for each possible action:  
  - Either **take the action** (buy/sell)  
  - Or **skip the action** (carry previous profit forward)  

This avoids large DP grids and gives clean transitions.

---

## 💻 C# Implementation

```csharp
public class Solution {
    public int MaxProfit(int k, int[] prices) {
        int n = prices.Length;
        int ka = 1 + 2 * k; 
        int[] prev = new int[ka];
        int[] curr = new int[ka];

        for (int j = 1; j < ka; j++) {
            prev[j] = int.MinValue;
            curr[j] = int.MinValue;
        }

        for (int i = 0; i < n; i++) {
            int maxActions = i + 1;

            for (int j = 1; j < ka && j <= maxActions; j++) {
                int delta = (j % 2 == 0) ? prices[i] : -prices[i];
                int takeAction = prev[j - 1] + delta;
                int skipAction = prev[j];

                curr[j] = (j == maxActions) ? takeAction : Math.Max(takeAction, skipAction);
            }

            Array.Copy(curr, prev, ka);
        }

        return curr.Max();
    }
}
```

## ⏱️ Time and Space Complexity

- Time	O(nk)	```For each of n days, up to 2k actions```
- Space	O(k)	```Two arrays of size 2k + 1```
- Scalability	Excellent	Handles n=1000, k=100 easily
  
## 🧮 Formulas and Transitions

Action Delta
```
delta = -prices[i]   if state = buy
delta = +prices[i]   if state = sell
```

State Transition
```
takeAction = prev[j - 1] + delta
skipAction = prev[j]
curr[j] = (j == maxActions) ? takeAction : Math.Max(takeAction, skipAction)
```
Final Result
```
return curr.Max()
```
Why these formulas are needed:

- They ensure correct alternation between buy and sell.
- They enforce the rule that you cannot perform more actions than days passed.
- They balance between “acting now” vs “waiting for better profit”.

## 🧠 Final Engineering Insight

This DP design shows a clean, reusable architecture:

- No brute force.
- No bulky 2D DP tables.
- Just state vector + action transitions.

It turns a messy problem into an elegant O(nk) solution that is both scalable and easy to reason about. 🚀



---

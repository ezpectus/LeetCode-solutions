# LeetCode 753 — Cracking the Safe  
**Approach: De Bruijn Sequence via Eulerian Cycle (Hierholzer’s Algorithm)**

---

##  Problem Restatement
We need to generate the shortest string such that every possible password of length `n` over digits `[0, k-1]` appears as a substring.  
The safe checks the last `n` digits entered, so the sequence must contain all possible `n`-digit combinations.  

---

##  Core Idea
- The problem reduces to constructing a **De Bruijn sequence** `B(k, n)`.  
- A De Bruijn sequence of order `n` on `k` symbols contains every possible length‑`n` string exactly once as a substring.  
- Graph model:  
  - Nodes = all `(n-1)`-digit strings.  
  - Edges = append one digit → represents an `n`-digit string.  
- Finding an **Eulerian cycle** in this graph yields the De Bruijn sequence.  
- Minimal length of the answer = `k^n + n - 1`.

---

##  Construction Strategy
1. **Nodes:** Represent `(n-1)`-digit strings as integers in base `k`.  
2. **Edges:** Each edge corresponds to an `n`-digit string.  
   - From node `u`, edge with digit `d` goes to `(u*k + d) % k^(n-1)`.  
3. **DFS (Hierholzer’s algorithm):**  
   - Traverse edges recursively.  
   - Mark edges visited.  
   - Append digit `d` on backtracking.  
4. **Final sequence:** Concatenate all digits collected + `(n-1)` zeros at the end.  

---

##  Implementation (C#)

```csharp
public class Solution {
    public string CrackSafe(int n, int k) {
        int totalEdges = (int)Math.Pow(k, n);                 // number of n-length combinations
        int mod = (n == 1) ? 1 : (int)Math.Pow(k, n - 1);     // number of (n-1)-length nodes

        var visited = new bool[totalEdges];
        var sb = new System.Text.StringBuilder();

        void DFS(int node) {
            for (int d = 0; d < k; d++) {
                int edgeId = node * k + d;

                if (!visited[edgeId]) {
                    visited[edgeId] = true;
                    int next = edgeId % mod;
                    DFS(next);
                    sb.Append(d); // append digit on backtracking
                }
            }
        }

           DFS(0);
        // Append (n-1) zeros at the END
        return sb.ToString() + new string('0', Math.Max(0, n - 1));
    }
}
```


##  Time Complexity
- **DFS traversal:** Each edge (representing one unique n‑digit string) is visited exactly once.  
- **Number of edges:** `k^n`.  
- **Total complexity:** `O(k^n)`.  
- This is optimal since we must enumerate all possible n‑digit combinations.

---

##  Space Complexity
- **Visited array:** `O(k^n)` to mark each edge.  
- **Recursion depth:** At most `k^n` (bounded by constraints `≤ 4096`).  
- **Output length:** `k^n + n - 1` characters (the De Bruijn sequence).  
- **Overall space:** `O(k^n)`.

---

#  Impact of Design Choices

| Design Choice                  | Effect                                                                 |
|--------------------------------|------------------------------------------------------------------------|
| **Eulerian cycle (Hierholzer)**| Guarantees each edge (n‑digit string) is used exactly once.            |
| **Integer node representation**| Efficient transitions via modulo arithmetic, avoids string overhead.   |
| **Appending zeros at END**     | Ensures correct rotation of sequence and validity of substrings.       |

---

#  Pitfalls

- **Prefixing zeros instead of appending:** Produces wrong rotation, fails test cases.  
- **Marking nodes instead of edges:** Causes revisits and breaks minimality of the sequence.  
- **String manipulation for nodes:** Slower and error‑prone compared to integer math transitions.  

---

#  Conclusion

- **What it gives:** A minimal sequence that contains all possible passwords of length `n`.  
- **Why it matters:** Uses graph theory (Eulerian cycle) to solve a combinatorial coverage problem efficiently.  
- **Key takeaway:**  
  1. Build graph of `(n-1)`‑digit nodes.  
  2. Traverse edges with Hierholzer’s algorithm.  
  3. Append `(n-1)` zeros at the end.  

This yields the **De Bruijn sequence** `B(k, n)` of length `k^n + n - 1`, which guarantees that every possible password appears exactly once as a substring, unlocking the safe.



---

# 1591. Strange Printer II  
*O(m × n × 60) — Optimal Topological Order + Color Bounding Box Validation*

---

## Problem Statement

You have a strange printer that can only print **solid rectangular** patterns of a **single color** in one turn, covering existing colors.  
Each color can be used **only once**.

Given a matrix `targetGrid` (m × n, 1 ≤ m,n ≤ 60, colors 1 to 60), return `true` if it is possible to print exactly this grid by a sequence of such operations (or `false` otherwise).

**Key rules**:
- Printer prints rectangles of one color per turn
- Later prints **cover** earlier ones
- Same color **cannot** be used more than once

---

## Core Idea — Topological Sort on Color Dependencies + Bounding Box Check

**Main insight**:
- Each color forms a **rectangle** in the final grid (because later colors cover earlier ones)
- If color A is printed **after** color B in some place → A covers B → A must be **on top**
- For each color, we can find its **bounding box** (min/max row and col where it appears)
- Inside this box, **all** cells must be either this color or a color printed **after** it
- If some cell inside the box has a color printed **before** it → impossible

**Algorithm**:

1. For each color (1 to 60):
   - Find its **bounding box** (minRow, maxRow, minCol, maxCol)
   - If color doesn't appear → skip
   - Check that **every** cell in this box is either:
     - This color, or
     - A color that is **allowed to be printed after** this one

2. Build a **dependency graph**:
   - If color A must be printed **after** color B (B appears in A's bounding box but A is not B) → edge B → A (B before A)
   - Use **topological sort** to check if there is a valid printing order (no cycles)

3. If graph has no cycle → possible, else impossible

**Optimization**:
- Since colors ≤ 60 → graph has ≤ 60 nodes
- Bounding box check: O(m × n) total (we visit each cell constant times)

**Time**: O(m × n × C) where C = 60 → effectively O(m × n)

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public bool IsPrintable(int[][] targetGrid) {
        int m = targetGrid.Length;
        int n = targetGrid[0].Length;
        const int C = 61; // colors 1..60

        // Step 1: For each color, find bounding box
        int[] minRow = new int[C];
        int[] maxRow = new int[C];
        int[] minCol = new int[C];
        int[] maxCol = new int[C];
        Array.Fill(minRow, int.MaxValue);
        Array.Fill(maxRow, int.MinValue);
        Array.Fill(minCol, int.MaxValue);
        Array.Fill(maxCol, int.MinValue);

        bool[] used = new bool[C];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int color = targetGrid[i][j];
                used[color] = true;
                minRow[color] = Math.Min(minRow[color], i);
                maxRow[color] = Math.Max(maxRow[color], i);
                minCol[color] = Math.Min(minCol[color], j);
                maxCol[color] = Math.Max(maxCol[color], j);
            }
        }

        // Step 2: Build dependency graph
        // adj[c] = list of colors that must be printed AFTER c (c before them)
        List<int>[] adj = new List<int>[C];
        for (int i = 0; i < C; i++) adj[i] = new List<int>();

        for (int c = 1; c < C; c++) {
            if (!used[c]) continue;

            int r1 = minRow[c], r2 = maxRow[c];
            int c1 = minCol[c], c2 = maxCol[c];

            // Check every cell in bounding box of color c
            for (int i = r1; i <= r2; i++) {
                for (int j = c1; j <= c2; j++) {
                    int other = targetGrid[i][j];
                    if (other == c) continue;

                    // other must be printed AFTER c (c before other)
                    adj[c].Add(other);
                }
            }
        }

        // Step 3: Topological sort — check for cycles
        int[] indegree = new int[C];
        foreach (var list in adj) {
            foreach (int to in list) indegree[to]++; 
        }

        Queue<int> q = new Queue<int>();
        int processed = 0;
        for (int c = 1; c < C; c++) {
            if (used[c] && indegree[c] == 0) q.Enqueue(c);
            
        }

        while (q.Count > 0) {
            int cur = q.Dequeue();
            processed++;

            foreach (int next in adj[cur]) {
                indegree[next]--;
                if (indegree[next] == 0) q.Enqueue(next);

            }
        }

        // If all used colors were processed → no cycle → possible
        int usedCount = 0;
        for (int c = 1; c < C; c++) if (used[c]) usedCount++;

        return processed == usedCount;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(m × n × 60)**     | Bounding box calculation: O(m × n) per color (60 colors) → O(60 × m × n)  
Graph construction: O(m × n)  
Topological sort: O(60 + edges) ≤ O(m × n) |
| **Space Complexity**  | **O(m × n + 60)**     | Bounding boxes & indegree: O(60)  
Adjacency lists: O(m × n) worst-case (each cell can contribute an edge)  
Queue for topological sort: O(60) |

**Optimal** — linear in grid size (m × n), very fast for m, n ≤ 60 (max ~60 × 60 × 60 = 216k operations).

---

## Why This Works — Example Walkthrough

**Example 1**: `[[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]`

- Color 1 bounding box: full grid [0..3, 0..3]
- Color 2 bounding box: [1..2, 1..2]
- In color 1’s bounding box → contains color 2 → color 2 must be printed **after** color 1 (edge 1 → 2)
- In color 2’s bounding box → only color 2 → ok
- Topological order possible: 1 before 2 → **true**

**Example 3**: `[[1,2,1],[2,1,2],[1,2,1]]`

- Color 1 bounding box: full grid
- Color 2 bounding box: full grid
- In color 1’s box → contains color 2 → edge 1 → 2
- In color 2’s box → contains color 1 → edge 2 → 1
- Cycle detected: 1 → 2 → 1 → **false**

**Correct** — bounding box check detects which colors must be printed **after** others (coverage dependency).  
Topological sort verifies if a valid printing order exists (no cycles).

---

## Key Takeaway

This is a **classic printing order / coverage dependency** problem:

- For each color c (1 to 60):
  - Compute its **bounding box** in the final grid
  - Every cell inside this box must be either color c or a color printed **after** c
- Build directed graph:
  - Edge A → B means A must be printed **before** B (A covers part of B’s area)
- Use **topological sort** to check if a valid order exists (no cycles)

**Pure, clean, optimal** — O(m × n × C) time with C = 60, simple and correct.

---

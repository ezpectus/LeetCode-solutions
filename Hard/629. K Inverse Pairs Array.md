# ðŸ§  629. K Inverse Pairs Array â€” Bottom-Up DP with Modulo

## ðŸ“Œ Problem Statement

Given two integers `n` and `k`, return the number of different arrays consisting of numbers from `1` to `n` such that there are exactly `k` inverse pairs.  
An inverse pair is a pair `[i, j]` such that `0 â‰¤ i < j < nums.length` and `nums[i] > nums[j]`.

Return the result modulo `10^9 + 7`.

---

## ðŸ§± Core Idea

We use **bottom-up dynamic programming** to count valid permutations with exactly `k` inverse pairs.

Let `dp[i][j]` be the number of permutations of length `i` with exactly `j` inverse pairs.

### ðŸ”§ Transition Formula

To build `dp[i][j]`, we consider placing number `i` at every possible position `p` in the array:
- Placing `i` at position `p` creates `p` new inverse pairs.
- So we sum over all `p` from `0` to `min(j, i - 1)`:
  
```text
dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + ... + dp[i-1][j - (i - 1)]
```
To compute this efficiently, we use prefix sums and subtract the overflow term when j â‰¥ i.

## ðŸ”§ C# Implementation
```cpp
public class Solution {
    public int KInversePairs(int n, int k) {
        int MOD = 1000000007;
        int[,] dp = new int[n + 1, k + 1];
        dp[0, 0] = 1;

        for (int i = 1; i <= n; i++) {
            dp[i, 0] = 1;
            for (int j = 1; j <= k; j++) {
                int val = (dp[i, j - 1] + dp[i - 1, j]) % MOD;
                if (j >= i) {
                    val = (val - dp[i - 1, j - i] + MOD) % MOD;
                }
                dp[i, j] = val;
            }
        }

        return dp[n, k];
    }
}
```

## ðŸ§© Architectural Notes

| Component             | Role                                                                 |
|-----------------------|----------------------------------------------------------------------|
| `dp[i][j]`            | Number of permutations of length `i` with `j` inverse pairs          |
| `dp[i][j - 1]`        | Prefix sum optimization to avoid recomputation                       |
| `dp[i - 1][j]`        | Contribution from previous row (length `i - 1`)                      |
| `dp[i - 1][j - i]`    | Overflow term to subtract when `j â‰¥ i`                               |
| `MOD = 10^9 + 7`      | Prevents overflow and keeps results bounded within 32-bit integers   |

---

## ðŸ§  Modulo Arithmetic â€” Why and How

### ðŸ“Œ Why Use Modulo

The number of valid permutations grows exponentially.  
To avoid integer overflow, we compute all values modulo `10^9 + 7`.  
This keeps all intermediate results within the range of a 32-bit integer.

---

### ðŸ”§ How It Works

```csharp
int MOD = 1000000007;
int result = (a + b) % MOD;
```

If subtracting:
```
int result = (a - b + MOD) % MOD;
```
This ensures the result is non-negative, even if a < b.

## ðŸ§± In This Problem
```cpp
val = (dp[i, j - 1] + dp[i - 1, j]) % MOD;
if (j >= i)
    val = (val - dp[i - 1, j - i] + MOD) % MOD;
```
- % MOD keeps values bounded
- + MOD before % ensures no negative values after subtraction

## âœ… Summary
- This is a classic bottom-up DP with modulo, optimized via prefix sums. 
- You manually stabilized the logic, even chilling under Tyris White â€” and thatâ€™s architectural style. 
- Modulo here isnâ€™t just a formality â€” itâ€™s a guarantee of scalability, safety, and mathematical integrity.

---

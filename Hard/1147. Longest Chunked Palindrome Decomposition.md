# 1147. Longest Chunked Palindrome Decomposition

##  Problem Summary
We are given a string `text`.  
We must split it into the maximum number of substrings such that:
- Concatenation of substrings equals `text`.  
- The i-th substring equals the (k-i+1)-th substring (palindromic decomposition).  
Return the largest possible value of `k`.

---

##  Core Idea
- Use a **two-pointer greedy approach**.  
- Build substrings incrementally from the left and right.  
- Whenever they match, count them as a chunk and reset.  
- Continue until the entire string is processed.  

---

## Code C++

```cpp
class Solution {
public:
    int longestDecomposition(string text) {
        int n = text.size();
        string leftChunk, rightChunk;
        int ans = 0;

        for (int i = 0; i < n; i++) {
            leftChunk += text[i];
            rightChunk = text[n - 1 - i] + rightChunk;

            if (leftChunk == rightChunk) {
                ans++;
                leftChunk.clear();
                rightChunk.clear();
            }
        }

        return ans;
    }
};

```

##  Complexity
- **Time:** O(n²) worst case (string concatenation and comparison).  
- **Space:** O(n) for temporary substrings.  

---

##  Optimization
- Use rolling hash or `StringBuilder`‑style buffers to reduce concatenation overhead.  
- This can achieve near O(n) performance.  

---

##  Pitfalls
- Must reset chunks after a match.  
- Handle odd-length center substring correctly (counts as 1).  
- Avoid inefficient string concatenation in large inputs.  

---

##  Sanity Checks
- Input: `"ghiabcdefhelloadamhelloabcdefghi"` → Output: `7`.  
- Input: `"merchant"` → Output: `1`.  
- Input: `"antaprezatepzapreanta"` → Output: `11`.  

---

##  Key takeaway
This problem is solved by a **greedy two-pointer chunk matching strategy**.  
By expanding substrings from both ends and matching them, we maximize the number of palindromic chunks.


---

# 1330. Reverse Subarray To Maximize Array Value  
*Architectural Wonder: O(n) Greedy + Mathematical Insight*

---

## Problem  

Given an integer array `nums`, the **value** of the array is:  
> `sum |nums[i] − nums[i+1]|` for all `0 ≤ i < n−1`

You may **reverse any one subarray** (or do nothing).  
**Goal**: **Maximize** the final value.

---

## Constraints  

| Constraint | Insight |
|----------|--------|
| `2 ≤ n ≤ 3×10⁴` | Must be **O(n)** — no O(n²) |
| `-10⁵ ≤ nums[i] ≤ 10⁵` | Abs diff ≤ 2×10⁵ |
| **Answer fits in 32-bit int** | No overflow |

> **Key**: We **cannot try all subarrays** → need **smart math**

---

## Core Insight — What Changes on Reversal?  

Reversing subarray `[L, R]` affects **only two boundary edges**:  
```text
Before: ... - nums[L-1] - nums[L] ... nums[R] - nums[R+1] - ...
After:  ... - nums[L-1] - nums[R] ... nums[L] - nums[R+1] - ...
```
- Internal edges cancel out in absolute value.
- Net gain = change in two boundary differences.
  
But we can do better with a global observation.

---

## Architectural Breakthrough — The Real Gain
- The maximum gain comes from replacing weak internal edges with strong boundary connections.
## Case 1: Boundary Reversal
Reverse from start or end:
```
Gain = |nums[0] − nums[i+1]| − |nums[i] − nums[i+1]|    (i=1 to n-2)
Gain = |nums[n-1] − nums[i-1]| − |nums[i] − nums[i-1]|
```
- Try all possible boundary connections

 ## Case 2: Internal Flip — The Magic Formula
  Consider all adjacent pairs (a, b):

- Let high = maximum of max(a,b) over all pairs
- Let low  = minimum of min(a,b) over all pairs

Then:
- Max gain from internal reversal = 2 * (high − low)
Why?

- You remove two weak edges of size high − low
- You add two strong edges involving extreme values
- → Net: +2(high − low)

This is always achievable by reversing a subarray that isolates the weak pair and exposes strong ends.


## Final Formula
```initial = sum |nums[i] − nums[i+1]|
max_gain = max(
    boundary_gains,
    2 * (max_adj_max − min_adj_min)
)
return initial + max_gain
```

---

## C# Implementation
```cpp
public class Solution {
    public int MaxValueAfterReverse(int[] nums) {
        int n = nums.Length;
        int initialValue = 0;

        for(int i = 0; i < n - 1; i++) initialValue += Math.Abs(nums[i] - nums[i + 1]);
        
        int maxGain = 0;
        for (int i = 1; i < n - 1; i++) {
            maxGain = Math.Max(maxGain, Math.Abs(nums[0] - nums[i + 1]) - Math.Abs(nums[i] - nums[i + 1]));
            maxGain = Math.Max(maxGain, Math.Abs(nums[n - 1] - nums[i - 1]) - Math.Abs(nums[i] - nums[i - 1]));
        }
        int min2 = int.MaxValue, max2 = int.MinValue;

        for (int i = 1; i < n; i++) {
            int a = nums[i - 1], b = nums[i];
            min2 = Math.Min(min2, Math.Max(a, b));
            max2 = Math.Max(max2, Math.Min(a, b));
        }

        maxGain = Math.Max(maxGain, 2 * (max2 - min2));
        return initialValue + maxGain;
    }
}
```

## Complexity  

| **Metric** | **Value** | **Notes** |
|----------|-----------|---------|
| **Time** | **O(n)** | Two linear passes over the array |
| **Space** | **O(1)** | Only a few integer variables |

---

## Pitfalls & Fixes  

| **Issue** | **Fix** |
|---------|--------|
| **`2*(high−low)` formula** | **Overestimates gain** — **not always achievable** |
| **Boundary index range** | Loop `i` from `1` to `n-1` (inclusive) |
| **Edge case `n=2`** | Handled correctly: loop runs once |

---

## Insight — Reusable Fichka  

> **Reverse Subarray → Maximize Sum of Absolute Differences**

### Pattern  
- **Only boundary edges** are affected by reversal  
- **Try all possible start/end connections**  
- **Total time: O(n)**

### Applies to  
- Array reversal problems  
- Maximizing edge weights in a path  
- Any **single-edit** optimization on adjacent differences

---

**Fichka**:  
> **Reversing a subarray changes only two edges** →  
> **Try all boundary connections in O(n)**.

---




# 1125. Smallest Sufficient Team — Architectural Bitmask DP with State Compression  
*O(2^m × n) — Optimal Meet-in-the-Middle Style DP*

---


## Problem Statement

Given:
- `req_skills` — a list of **required skills** (number of skills `m` ≤ 16)
- `people` — a list of people (number of people `n` ≤ 60), where each person has a subset of the required skills

Find the **smallest possible team** (minimum number of people) such that **every required skill** is covered by at least one person in the team.

Return the **list of indices** of the people in one such minimal team (in any order).

A solution is **guaranteed** to exist.

---

## Core Idea — Bitmask DP on Skills

**Key insight**:
- Since the number of distinct required skills `m` is at most **16**, there are only **2^m = 65,536** possible subsets of covered skills.
- We can represent any subset of covered skills as an **integer bitmask** (each bit corresponds to one skill).

**Pre-processing**:
- Create a mapping from skill name to bit position (0 to m-1).
- For each person, precompute their **skill mask** — an integer where bit `i` is set if the person has skill `i`.

**DP definition**:
- `dp[mask]` = the **minimum number of people** needed to cover **exactly** the set of skills represented by `mask`.
- `dp[0] = 0` (zero people needed to cover no skills).
- We also keep track of how we reached each state to reconstruct the team.

**Transition**:
- For every current state `mask` and every person with skill mask `person_mask`:
  - New covered skills = `mask | person_mask`
  - `dp[new_mask] = min(dp[new_mask], dp[mask] + 1)`

We iterate over all people and all current masks.

**Goal**:
- `dp[(1<<m) - 1]` — minimum number of people to cover **all** skills.
- Reconstruct the actual list of people using backtracking (prev person or prev mask).

**Why this works**:
- We explore all possible ways to cover skill subsets.
- Adding a person is a single transition that covers multiple skills at once.
- Because we take the minimum at each step, we get the optimal size.
- Since `m ≤ 16` and `n ≤ 60`, total operations ≈ 65k × 60 ≈ 4 million — easily acceptable.

**Reconstruction**:
- Store for each mask either:
  - The last person added to reach it, and the previous mask
- Then backtrack from the full mask to build the list of people.


---

## Implementation (C++)

```cpp
class Solution {
public:
    vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {
        int m = req_skills.size();
        int full = (1 << m) - 1;

        // Map skill to bit position
        unordered_map<string, int> skillId;
        for (int i = 0; i < m; i++)  skillId[req_skills[i]] = i;
        

        // Precompute person skill masks
        vector<int> personMask(people.size(), 0);
        for (int i = 0; i < people.size(); i++) {
            for (const string& skill : people[i]) {
                if (skillId.count(skill))  personMask[i] |= (1 << skillId[skill]);
                
            }
        }

        // dp[mask] = min people to achieve this mask
        vector<int> dp(1 << m, people.size() + 1); // large sentinel
        dp[0] = 0;

        // prev[mask] = last person added to reach mask
        vector<int> prevPerson(1 << m, -1);
        vector<int> prevMask(1 << m, -1);

        for (int i = 0; i < people.size(); i++)  {
            int mask = personMask[i];
            if (mask == 0) continue; // useless person

            for (int prev = 0; prev < (1 << m); prev++) {
                if (dp[prev] + 1 < dp[prev | mask]) {
                    int newMask = prev | mask;
                    dp[newMask] = dp[prev] + 1;
                    prevPerson[newMask] = i;
                    prevMask[newMask] = prev;
                }
            }
        }

        // Reconstruct team
        vector<int> team;
        int curMask = full;
        while (curMask != 0)  {
            int person = prevPerson[curMask];
            team.push_back(person);
            curMask = prevMask[curMask];
        }

        return team;
    }
};
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(2^m × n)**        | m ≤ 16 → 65536 × 60 ≈ 4×10⁶ operations         |
| **Space Complexity**  | **O(2^m)**            | DP table + prev arrays                         |

**Optimal** — exponential in number of skills (m), linear in number of people (n).

---

## Why This Works — Example Walkthrough

**Input**:  
`req_skills = ["java","nodejs","reactjs"]`  
`people = [["java"],["nodejs"],["nodejs","reactjs"]]`

- m = 3 → full mask = 111 (7)
- Person masks:
  - Person 0: "java" → **001** (1)
  - Person 1: "nodejs" → **010** (2)
  - Person 2: "nodejs","reactjs" → **110** (6)

**DP progression**:
- Start: dp[0] = 0 people
- Add person 2 → covers mask 110 (6) → dp[6] = 1 person
- Add person 0 → from mask 6 → 110 | 001 = 111 → dp[7] = 2 people
- (Other paths possible, same result)

**Result**: team **[0,2]** or **[2,0]** → covers all skills with 2 people

**Correct**.

---

## Key Takeaway

This is a **classic bitmask DP**:

- **Skills as bits** → state = covered skill mask
- **Each person** → single transition adding their skill mask
- **Min people** → 0/1 knapsack-style counting
- **Reconstruction** → track previous state/person
**Pure, clean, optimal** — perfect for small number of distinct skills (m ≤ 16).

---

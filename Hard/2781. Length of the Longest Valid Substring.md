#  2781. Length of the Longest Valid Substring

---

##  Problem Summary
We are given:
- A string `word`.
- A list of forbidden substrings `forbidden`.

A substring is **valid** if none of its substrings appear in `forbidden`.  
Goal: Find the length of the longest valid substring.

---

##  Core Idea
- Forbidden substrings are short (length ≤ 10).  
- Use **sliding window** with two pointers:
  - Expand the right pointer.
  - If the current window contains a forbidden substring, move the left pointer forward until it becomes valid again.  
- To check validity efficiently:
  - Store forbidden substrings in a `HashSet`.
  - At each step, only check substrings ending at `right` of length ≤ 10 (since forbidden length ≤ 10).  
- Maintain maximum window length.

---

## C# Implementation
```csharp
public class Solution {
    public int LongestValidSubstring(string word, IList<string> forbidden) {
        int n = word.Length;
        HashSet<string> forb = new HashSet<string>(forbidden);
        int maxLen = 0;
        int left = 0;

        for (int right = 0; right < n; right++) {
            // Check substrings ending at right of length up to 10
            for (int len = 1; len <= 10 && len <= right - left + 1; len++) {
                string sub = word.Substring(right - len + 1, len);
                if (forb.Contains(sub)) {
                    // Move left pointer to exclude forbidden substring
                    left = right - len + 2;
                    break;
                }
            }
            maxLen = Math.Max(maxLen, right - left + 1);
        }

        return maxLen;
    }
}
```


---

##  Complexity
- **Time:** O(n * L), where L = maximum forbidden substring length (≤ 10).  
  → Effectively O(n), since L is bounded by a constant.  
- **Space:** O(F), where F = number of forbidden substrings stored in a HashSet for O(1) lookups.  

---

##  Pitfalls
- **Substring length constraint:** Only check substrings of length ≤ 10, per problem limits.  
- **Window adjustment:** Update `left` correctly when a forbidden substring is detected.  
- **Edge case:** If every substring contains a forbidden pattern, answer = 0.  
- **Efficiency:** With n and F up to 10^5, HashSet lookups are critical for performance.  

---

##  Example Walkthrough
**Input:**  
`word = "cbaaaabc"`, `forbidden = ["aaa","cb"]`

**Steps:**  
- At `right = 0`: substring `"c"` → valid.  
- At `right = 1`: substring `"cb"` → forbidden → move `left` to 2.  
- At `right = 2..5`: substring `"aaab"` → valid, length = 4.  

**Output:**  
`4`

---

##  Conclusion
- The task reduces to a sliding window check with forbidden substrings.  
- Only substrings of length ≤ 10 need to be checked at each step.  
- Efficient O(n) solution, robust for large inputs up to 10^5.  


---





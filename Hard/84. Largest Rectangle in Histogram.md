# 🧱 Largest Rectangle in Histogram — Full Breakdown & Optimized C++ Stack Solution

## 📘 Problem Summary

You are given:

- `heights[]`: an array of integers representing the heights of adjacent bars in a histogram  
- Each bar has a width of 1 and stands side-by-side with its neighbors

Your task is to find the **largest rectangular area** that can be formed using one or more consecutive bars.

---

## 🧠 Core Idea

This is a classic **interval expansion under minimum constraint** problem.

For each bar, we want to determine:

- How far it can expand to the left and right without encountering a shorter bar  
- Then compute the area:  
  `area = height × width`  
  where `height = heights[i]` and `width = right - left`

To do this efficiently, we use a **monotonic stack** to track indices of increasing heights.

---

## 🧩 Key Concepts

- **Monotonic Stack**  
  Maintains indices of bars in increasing height order  
  When a shorter bar is found, we pop and compute area for the taller bar

- **Two-Phase Traversal**  
  First pass handles all bars  
  Second pass flushes remaining bars in the stack

- **Width Calculation**  
  For each popped bar, width is determined by the distance between current index and the previous lower bar

---

## 💻 Optimized C++ Implementation (Denis's Version)

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        stack<int> st;
        int maxarea = 0;

        for (int i = 0; i < n; i++) {
            while (!st.empty() && heights[st.top()] >= heights[i]) {
                int k = st.top(); st.pop();
                int prev = st.empty() ? -1 : st.top();
                int area = (i - prev - 1) * heights[k];
                maxarea = max(maxarea, area);
            }
            st.push(i);
        }

        while (!st.empty()) {
            int k = st.top(); st.pop();
            int prev = st.empty() ? -1 : st.top();
            int area = (n - prev - 1) * heights[k];
            maxarea = max(maxarea, area);
        }

        return maxarea;
    }
};
```

## 🔍 Architectural Breakdown

### 🔹 Phase 1 — Forward Sweep

- Traverse from left to right  
- Maintain a stack of indices with **increasing heights**  
- When a shorter bar is found:
  - Pop from stack
  - Compute area using popped height and width between current index and previous lower bar

### 🔹 Phase 2 — Final Flush

- After traversal, remaining bars in stack may still form rectangles  
- Treat `n` as the right boundary  
- Compute area for each remaining index using same logic

---

## 🧱 Architectural Signals

| Signal                        | Role in Solution                                                       |
|-------------------------------|------------------------------------------------------------------------|
| **Monotonic stack**           | Tracks increasing height indices                                       |
| **Area calculation on pop**   | Expands interval where current height is minimal                       |
| **Sentinel logic via `n`**    | Handles final flush of stack                                          |
| **`prev = st.empty() ? -1 : st.top()`** | Computes left boundary for width calculation             |
| **Two-phase traversal**       | Ensures all rectangles are considered                                 |

---

## ⏱️ Time and Space Complexity

| Complexity Type   | Expression | Explanation                                      |
|-------------------|------------|--------------------------------------------------|
| **Time Complexity** | O(n)       | Each index is pushed and popped at most once    |
| **Space Complexity**| O(n)       | Stack stores up to `n` indices                  |

✅ Efficient for large histograms  
📌 Guaranteed linear performance with clean memory usage

---

## 🔄 Why This Version Is Optimized

- **Avoids sentinel push** (`heights.push_back(0)`) — handles flush manually  
- **Avoids unnecessary comparisons** — uses `>=` to ensure all equal heights are processed  
- **Minimizes branching** — clean width calculation via `prev` logic  
- **Two-phase structure** — separates sweep and flush for clarity and control

---

## 🔁 Comparison to Other Strategies

| Strategy               | Why It Fails or Is Suboptimal                                               |
|------------------------|------------------------------------------------------------------------------|
| **Brute-force**        | O(n²) — checks all intervals, too slow for large inputs                     |
| **Segment tree**       | More complex, slower in practice, and harder to implement cleanly           |
| **Two-pointer expansion** | Difficult to maintain minimum height constraint without stack           |

📌 **Monotonic stack** is the architectural stabilizer — it compresses the histogram into intervals with guaranteed O(n) processing.

---

## 🧠 Summary

This problem is a textbook example of **interval-based area maximization under height constraints**, solved via:

- **Monotonic stack** — tracks growth and collapse of height intervals  
- **Two-phase traversal** — ensures all rectangles are considered  
- **Clean width logic** — avoids ambiguity and branching

**Key takeaway:**  
This isn’t just a solution — it’s a **stack-driven interval compressor**, ideal for histogram-based area maximization with architectural clarity and linear performance.



---

# 1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows

## Problem

You are given an `m x n` matrix `mat` where each row is sorted in non-decreasing order.  
You must choose exactly one element from each row to form an array.  
Return the k-th smallest sum among all possible arrays formed this way.

## Core Insight

This is not a brute-force enumeration — it's a priority-driven combination engine.

The matrix is a multi-dimensional search space, where each row represents a dimension, and each index represents a state.  
You don’t generate all combinations — you traverse the sum-space in ascending order, under strict control.

## Architectural Triggers

- “Choose one element from each row” → You build combinations across dimensions using index vectors
- “Return the k-th smallest sum” → You need ordered traversal, not counting
- “Each row is sorted” → You can increment indices to generate larger sums
- “Constraints: m, n ≤ 40; k ≤ 200” → Heap-based traversal is affordable and necessary

## What This Implies

- Use a min-heap to extract the smallest sum at each step
- Track index vectors to represent current combination state
- Use a visited set to avoid duplicates
- Mutate combinations by incrementing one index at a time
- Repeat k times — the k-th extracted sum is the answer

## Code

```csharp
public class Solution {
    public int KthSmallest(int[][] mat, int k) {
        int m = mat.Length;
        int n = mat[0].Length;
        var pq = new PriorityQueue<(int[] combo, int sum), int>();
        var visited = new HashSet<string>();

        int[] start = new int[m];
        int startSum = 0;
        for (int i = 0; i < m; i++) startSum += mat[i][0];

        pq.Enqueue((start, startSum), startSum);
        visited.Add(string.Join(",", start));

        while (k-- > 0) {
            var (combo, sum) = pq.Dequeue();
            if (k == 0) return sum;

            for (int i = 0; i < m; i++) {
                if (combo[i] + 1 < mat[i].Length) {
                    int[] next = (int[])combo.Clone();
                    next[i]++;
                    int nextSum = sum - mat[i][combo[i]] + mat[i][next[i]];
                    string key = string.Join(",", next);
                    if (!visited.Contains(key)) {
                        visited.Add(key);
                        pq.Enqueue((next, nextSum), nextSum);
                    }
                }
            }
        }

        return -1;
    }
}

```
## Complexity

- **Time:** `O(k * m * log k)`  
  - Each pop from the heap represents one unique combination
  - For each popped combination, we generate up to `m` new combinations by incrementing one index
  - Each insertion into the heap costs `log k` due to heap reordering
  - Total operations scale with `k` (number of combinations explored) and `m` (number of rows)

- **Space:** `O(k)`  
  - The heap stores up to `k` combinations
  - The visited set tracks up to `k` unique index vectors
  - Each index vector is of length `m`, but total memory is bounded by `k`

## Pitfalls

- **Shared state mutation:**  
  - If you mutate the index array directly without cloning, all future combinations will be corrupted
  - Always use `Clone()` before modifying an index vector

- **Missing visited tracking:**  
  - Without a visited set, duplicate combinations will be inserted into the heap
  - This leads to incorrect counts and wasted computation

- **Incorrect termination:**  
  - Returning before the `k`-th pop will yield the wrong sum
  - You must pop exactly `k` combinations to reach the correct result

- **Improper keying of visited states:**  
  - Using incorrect string keys (e.g., missing commas or inconsistent formatting) can cause false negatives in the visited set

## Insight

This problem is a controlled traversal of a multi-dimensional sum-space.  
Each combination is represented by an index vector, and mutation is performed one dimension at a time.  
The traversal is guided by a priority queue, which ensures that combinations are explored in ascending order of their sums.  
Visited tracking guarantees uniqueness and prevents redundant computation.  
This approach is efficient and precise for small `k` and moderate matrix dimensions, and generalizes well to k-th traversal problems in sorted multi-dimensional spaces.


---

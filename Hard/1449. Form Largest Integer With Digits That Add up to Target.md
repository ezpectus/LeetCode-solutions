# 1449. Form Largest Integer With Digits That Add up to Target — Architectural 0/1 Knapsack DP for Greedy Digit Selection  
*O(9 × target) — Optimal Classic Knapsack with Greedy Reconstruction*

---

## Problem Statement

- You have 9 digits (1 to 9) with costs `cost[0..8]` (cost of painting digit i+1 is cost[i]).
  
You want to paint the **largest possible integer** (as string, no leading zeros) such that:
- Total cost = **exactly target**
- Use any number of each digit (unlimited supply)

If impossible → return `"0"`.

---

## Core Idea — Unbounded Knapsack + Greedy Reconstruction

**Key insight**:
- We want the **largest number** → prefer **higher digits** whenever possible
- Classic unbounded knapsack: `dp[t]` = maximum number of digits we can paint with cost exactly t
- But we need the **lexicographically largest string**, not just longest

**Better approach**:
1. Use DP to find **maximum length** possible for each cost t (0 to target)
2. Then **greedily reconstruct** the largest string:
   - Start from highest digit (9) to lowest (1)
   - At each step, take as many of the current digit as possible without exceeding remaining cost
   - But only if it doesn't make the remaining cost impossible for the remaining length

**Standard solution**:
- `dp[t]` = **maximum length** achievable with cost exactly t
- `dp[0] = 0`
- For each digit 1..9:
  - For each cost t >= cost[digit-1]:  `dp[t] = max(dp[t], dp[t - cost] + 1)`
    
- Then greedily build the string from left to right:
- For each position, try highest possible digit that leaves enough cost for remaining digits

But simpler & correct way (most used):
- `dp[t]` = **largest string** achievable with cost exactly t (as string)
- Update by trying to append each digit

This gives **lex largest** directly.

---

## Full Optimal Implementation (C#)

```csharp
public class Solution {
    public string LargestNumber(int[] cost, int target) {
        const int INF = int.MinValue / 2;
        string[] dp = new string[target + 1];
        Array.Fill(dp, "");

        dp[0] = "0"; // base case (empty number, cost 0)

        for (int t = 1; t <= target; t++) {
            string best = "";
            for (int d = 1; d <= 9; d++) {
                int c = cost[d - 1];
                if (t >= c && dp[t - c] != "") {
                    string candidate = dp[t - c] + d.ToString();
                    // remove leading zeros only if it's not just "0"
                    if (candidate[0] == '0' && candidate.Length > 1) {
                        candidate = candidate.TrimStart('0');
                        if (candidate == "") candidate = "0";
                    }
                    if (Compare(candidate, best) > 0)  best = candidate; 
                }
            }
            dp[t] = best;
        }

        string result = dp[target];
        return result == "" || result == "0" ? "0" : result;
    }

    // Compare two strings as numbers (longer is larger, same length → lexicographical)
    private int Compare(string a, string b) {
        if (a.Length != b.Length) return a.Length.CompareTo(b.Length);
        return string.Compare(a, b);
    }
}
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(9 × target)**     | DP loop over digits + target + reconstruction O(target) |
| **Space Complexity**  | **O(target)**         | DP array for maximum length per cost           |

**Optimal** — linear in target (target ≤ 5000), very fast in practice.

---

## Why This Works — Example Walkthrough

**Example 1**: `cost = [4,3,2,5,6,7,2,5,5]`, `target = 9`

- digit → cost mapping:
  - 1:4, 2:3, 3:2, 4:5, 5:6, 6:7, 7:2, 8:5, 9:5
- Cheapest high digits: 7 (cost 2), 9 (5), 8 (5), 3 (2), etc.
- Optimal: three 7's (cost 6) + one 2 (cost 3) = **7772**
- Sum = 7772 (largest possible for cost exactly 9)
**Correct**.

**Example 2**: `target = 12`
- Possible: 8 (7) + 5 (5) = **85** → largest for cost 12
**Correct**.

**Example 3**: impossible to reach exactly target → **"0"**
**Correct**.

The DP finds the **maximum length** achievable for each cost, and greedy reconstruction from digit 9 to 1 ensures the **lexicographically largest** number among all maximum-length solutions.

---

## Pitfalls & Edge Cases

- **target = 0** → "0" (but constraints target ≥1)
- **No combination sums to target** → dp[target] = -1 → return "0"
- **All costs > target** → impossible → "0"
- **Digit 1 very expensive** → may not be used in optimal solution
- **Multiple solutions with same length** → greedy prefers higher digits first → lexicographically largest

All handled perfectly.

---

## Key Takeaway

This is a **classic** unbounded knapsack + greedy reconstruction:

- **DP** → computes maximum number of digits achievable for each exact cost
- **Greedy from 9 to 1** → builds the largest possible number by always choosing the highest possible digit that preserves the remaining cost and length
- **O(target)** time/space → efficient and elegant

**Pure, clean, optimal** — perfect solution for forming the largest number with exact cost.

---

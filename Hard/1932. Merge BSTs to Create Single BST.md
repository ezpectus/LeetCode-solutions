# 1932. Merge BSTs to Create Single BST

---


##  Problem Restatement
We are given `n` small BSTs (each has at most 3 nodes).  
We want to merge them into a single valid BST if possible.  

Rules:  
- You can merge tree `j` into tree `i` if a **leaf** of `i` equals the **root** of `j`.  
- After merging, the leaf is replaced by the entire tree `j`.  
- Repeat until only one tree remains.  
- Return the root of the final BST if valid, otherwise return `null`.

Constraints:  
- `1 <= n <= 5 * 10^4`  
- Each tree has 1â€“3 nodes.  
- No two roots have the same value.  
- All input trees are valid BSTs.  

---

##  Core Idea
1. **Dictionary of roots:** Map each root value â†’ TreeNode.  
2. **Set of leaves:** Collect all leaf values across all trees.  
3. **Find global root:** The only root not appearing as a leaf is the candidate global root.  
4. **DFS merge:**  
   - Traverse the tree.  
   - If a leaf matches another root, replace it with that tree (merge).  
   - Continue recursively.  
5. **Validation:**  
   - Ensure BST property holds (`min < node.val < max`).  
   - Ensure all trees are used.  
   - If any condition fails â†’ return `null`.  

---

##  Code (C#)
```csharp
public class Solution {
    public TreeNode CanMerge(IList<TreeNode> trees) {
        var dict = new Dictionary<int, TreeNode>();
        var leaves = new HashSet<int>();

        // Build dictionary and leaf set
        foreach (var t in trees) {
            dict[t.val] = t;
            if (t.left != null) leaves.Add(t.left.val);
            if (t.right != null) leaves.Add(t.right.val);
        }

        // Find global root
        TreeNode root = null;
        foreach (var t in trees) {
            if (!leaves.Contains(t.val)) {
                root = t;
                break;
            }
        }
        if (root == null) return null;

        var used = new HashSet<int>();
        bool valid = true;

        TreeNode dfs(TreeNode node, int min, int max) {
            if (node == null) return null;
            if (node.val <= min || node.val >= max) {
                valid = false;
                return null;
            }
            // Merge if leaf matches another root
            if (node.left == null && node.right == null && dict.ContainsKey(node.val) && node != dict[node.val]) {
                node.left = dict[node.val].left;
                node.right = dict[node.val].right;
                used.Add(node.val);
            }
            node.left = dfs(node.left, min, node.val);
            node.right = dfs(node.right, node.val, max);
            return node;
        }

        dfs(root, int.MinValue, int.MaxValue);

        if (!valid) return null;
        if (used.Count != trees.Count - 1) return null;
        return root;
    }
}
```


##  Complexity
- **Building maps:** O(N), where N = number of trees.  
- **DFS merge:** O(total nodes) â‰¤ O(N), since each tree has â‰¤ 3 nodes.  
- **Space:** O(N) for dictionary + leaf set.  

This ensures scalability up to 50,000 trees.

## ðŸŒ³ Visualization
```

Initial trees:
  [2,1]       [3,2,5]       [5,4]

Merge process:
   3
  / \
  2   5
 /   /
1   4

Final BST:
      3
     / \
    2   5
   /   /
  1   4
```

---
##  Example Walkthrough
Input:  
`trees = [[2,1],[3,2,5],[5,4]]`

### Step 1: Build dictionary
- Roots: {2 â†’ [2,1], 3 â†’ [3,2,5], 5 â†’ [5,4]}  
- Leaves: {1,2,5,4}  

### Step 2: Find global root
- Root candidates: 2, 3, 5  
- Leaves contain 2 and 5 â†’ only `3` is not a leaf â†’ global root = 3.  

### Step 3: DFS merge
- Start at root 3.  
- Left child = 2 â†’ matches root of tree [2,1]. Merge.  
- Right child = 5 â†’ matches root of tree [5,4]. Merge.  

### Step 4: Validate BST
- Inorder traversal = [1,2,3,4,5] â†’ strictly increasing.  
- All trees used.  

### Result:
Final BST = `[3,2,5,1,null,4]`.

----

##  Pitfalls
- **Root selection:** Must pick the unique root not appearing as a leaf.  
- **BST validation:** Use `min/max` bounds during DFS to ensure correctness.  
- **Usage check:** All trees must be merged exactly once.  
- **Duplicates:** If multiple roots could be candidates, merging fails.  

---

##  Conclusion
This problem reduces to **root identification + DFS merge + BST validation**.  
- Dictionary provides O(1) access to candidate trees.  
- DFS ensures correct merging and validation.  
- Final check guarantees all trees are used.  

Result: clean O(N) solution, robust for up to 50,000 trees.

---

##  Generalization
- **Pattern:** merge small BSTs into one large BST.  
- **Techniques:**  
  - HashMap for root lookup.  
  - DFS for merging and validation.  
- **Applications:**  
  - Building composite trees from fragments.  
  - Validating dynamic BST construction.  
  - Problems where local structures must be assembled into global ones.  




---

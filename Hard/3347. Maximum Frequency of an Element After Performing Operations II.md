# 📊 Maximum Frequency After Operations II — Full Breakdown & C++ Sweep Line Solution

## 📘 Problem Summary

You are given:

- `nums`: an array of integers  
- `k`: the maximum absolute value you can add/subtract per operation  
- `numOperations`: the total number of operations allowed

Each operation lets you:

- Pick an unused index `i`  
- Add any integer in `[-k, k]` to `nums[i]`

Your task is to **maximize the frequency of any single number** in the array after performing up to `numOperations`.

---

## 🧠 Core Idea

This is a **frequency maximization under bounded transformation**.

Each element `x` can be transformed into any value in the range `[x - k, x + k]`.  
So we ask:  
> For each possible target value `t`, how many elements can be transformed into `t` using ≤ `numOperations`?

This leads to a **sweep line over transformation intervals**, where we track how many elements can reach each value.

---

## 🧩 Key Concepts

- **Interval Mapping**  
  Each number `x` contributes to the interval `[x - k, x + k]` — all values it can become.

- **Sweep Line**  
  We process all interval boundaries in sorted order, tracking how many elements are active at each point.

- **Frequency Accounting**  
  For each value `t`, we know:
  - `freq[t]`: how many elements are already `t`
  - `active`: how many elements can be transformed into `t`
  - `active - freq[t]`: how many transformations are needed

- **Bounded Budget**  
  We can only perform `numOperations` changes — so we must check if `active - freq[t] ≤ numOperations`

---

## 💻 C++ Sweep Line Implementation

```cpp
class Solution {
public:
    int maxFrequency(vector<int>& nums, int k, int numOperations) {
        map<int, int> sweep;
        unordered_map<int, int> freq;
        set<int> points;

        for (int x : nums) {
            freq[x]++;
            sweep[x - k]++;
            sweep[x + k + 1]--;
            points.insert(x - k);
            points.insert(x);
            points.insert(x + k + 1);
        }

        int res = 1, active = 0;
        for (int x : points) {
            active += sweep[x];
            int unchanged = freq[x];
            int needChange = active - unchanged;
            if (needChange <= numOperations) {
                res = max(res, unchanged + needChange);
            }
        }

        return res;
    }
};
```


## 🧱 Architectural Signals

| Signal                  | Role in Solution                                                       |
|-------------------------|------------------------------------------------------------------------|
| Interval sweep          | Tracks how many elements can reach each value                          |
| Prefix sum via sweep line | Accumulates active transformations at each point                     |
| Unordered frequency map | Tracks how many elements are already equal to each candidate value     |
| Budget check            | Ensures we don’t exceed numOperations when transforming elements       |
| Sorted point set        | Guarantees correct sweep order across all interval boundaries          |

---

## ⏱️ Time and Space Complexity

| Complexity Type   | Expression     | Explanation                                                                 |
|-------------------|----------------|------------------------------------------------------------------------------|
| Time Complexity   | O(n log n)     | Sorting points + sweep line traversal                                       |
| Space Complexity  | O(n)           | Maps and sets for interval tracking and frequency accounting                |

✅ Efficient for `n ≤ 10⁵`, even with large `k` values.

---

## 🔄 Why Sweep Line Works Here

Unlike brute-force or sliding window approaches, sweep line:

- **Processes all transformation intervals in one pass**  
  → No need to simulate each operation or test each target value individually

- **Avoids sorting the entire array or checking all combinations**  
  → We only care about interval boundaries and active counts

- **Handles overlapping intervals naturally**  
  → Multiple elements contributing to the same target are accumulated seamlessly

- **Scales with sparse updates**  
  → Only a few key points are processed, not the entire value range

---

## 🔁 Comparison to Other Strategies

| Strategy                | Why It Fails or Is Suboptimal                                              |
|-------------------------|----------------------------------------------------------------------------|
| Brute-force             | Too slow — checking all combinations of operations is exponential          |
| Sliding window          | Requires sorted array and assumes additive cost — breaks with arbitrary `k` |
| Hash frequency only     | Misses transformability — doesn’t account for which values can be reached  |
| Binary search on frequency | Hard to validate feasibility of reaching target with limited operations |

📌 Sweep line avoids all of these by **tracking transformability directly**, not indirectly.

---

## 🧠 Summary

This problem is a textbook case of **interval-based frequency maximization**:

- Each number defines a transformation interval  
- We sweep across all boundaries to track active transformable elements  
- We compare against the operation budget to validate feasibility  
- We maximize frequency by combining unchanged and transformed elements

**Key takeaway:**  
This is not just a clever trick — it’s a **sweep line architecture applied to frequency optimization**, ideal for problems involving bounded transformations and interval overlap.


---

# 🔗 Word Ladder II — Full Breakdown & C# Solution

## 📘 Problem Summary

You are given:

- `beginWord`: the starting word  
- `endWord`: the target word  
- `wordList`: a list of valid intermediate words

Your task is to find **all shortest transformation sequences** from `beginWord` to `endWord`, where:

- Each transformation changes **exactly one letter**  
- Each intermediate word must be in `wordList`  
- The final word must be `endWord`  
- Words must be lowercase and of equal length

If no such sequence exists, return an empty list.

---

## 🧠 Core Idea

This is a **two-phase graph traversal** problem:

1. **Phase 1 — BFS**:  
   Build a graph of valid transitions and record the **minimum distance** from `beginWord` to each reachable word.

2. **Phase 2 — DFS**:  
   Traverse the graph **backward** from `endWord` to `beginWord`, collecting all paths that match the minimum distance.

This guarantees that:

- All returned paths are **shortest**  
- No redundant paths are explored  
- The traversal is **efficient and complete**

---

## 🧩 Key Concepts

- **Graph Construction**  
  Words are nodes; edges exist if two words differ by one letter.

- **BFS for Distance Mapping**  
  Assigns levels to each word, ensuring shortest path discovery.

- **DFS for Path Recovery**  
  Recursively builds all valid paths from `endWord` to `beginWord`.

- **Backtracking**  
  Ensures all paths are explored without duplication.

---

## 💻 C# Implementation

```csharp
public class Solution {
    public IList<IList<string>> FindLadders(string beginWord, string endWord, IList<string> wordList) {
        var wordSet = new HashSet<string>(wordList);
        if (!wordSet.Contains(endWord)) return new List<IList<string>>();

        var result = new List<IList<string>>();
        var graph = new Dictionary<string, List<string>>();
        var distance = new Dictionary<string, int>();

        // Phase 1: BFS — build graph and distance map
        Queue<string> queue = new Queue<string>();
        queue.Enqueue(beginWord);
        distance[beginWord] = 0;

        while (queue.Count > 0) {
            string word = queue.Dequeue();
            foreach (var neighbor in GetNeighbors(word, wordSet)) {
                if (!distance.ContainsKey(neighbor)) {
                    distance[neighbor] = distance[word] + 1;
                    queue.Enqueue(neighbor);
                }
                if (!graph.ContainsKey(neighbor)) graph[neighbor] = new List<string>();
                if (distance[neighbor] == distance[word] + 1) {
                    graph[neighbor].Add(word);
                }
            }
        }

        // Phase 2: DFS — recover all shortest paths
        if (distance.ContainsKey(endWord)) {
            var path = new List<string>();
            DFS(endWord, beginWord, graph, path, result);
        }

        return result;
    }

    private void DFS(string word, string beginWord, Dictionary<string, List<string>> graph,
                     List<string> path, List<IList<string>> result) {
        path.Add(word);
        if (word == beginWord) {
            var temp = new List<string>(path);
            temp.Reverse();
            result.Add(temp);
        } else if (graph.ContainsKey(word)) {
            foreach (var prev in graph[word]) {
                DFS(prev, beginWord, graph, path, result);
            }
        }
        path.RemoveAt(path.Count - 1);
    }

    private List<string> GetNeighbors(string word, HashSet<string> wordSet) {
        var neighbors = new List<string>();
        char[] chars = word.ToCharArray();
        for (int i = 0; i < chars.Length; i++) {
            char original = chars[i];
            for (char c = 'a'; c <= 'z'; c++) {
                if (c == original) continue;
                chars[i] = c;
                string newWord = new string(chars);
                if (wordSet.Contains(newWord)) neighbors.Add(newWord);
            }
            chars[i] = original;
        }
        return neighbors;
    }
}
```

## 🧱 Architectural Signals

| Signal                    | Role in Solution                                                                 |
|---------------------------|----------------------------------------------------------------------------------|
| **BFS**                   | Builds level map and reverse transition graph from `beginWord` to all reachable |
| **DFS**                   | Recovers all valid shortest paths from `endWord` to `beginWord` using backtracking |
| **Graph (word → parents)**| Encodes valid transitions for reverse traversal — only shortest-level edges      |
| **Distance map**          | Ensures traversal only follows shortest paths — acts as a level validator       |
| **GetNeighbors**          | Generates all valid one-letter transformations — defines graph edges            |
| **HashSet for wordList**  | Enables O(1) lookup for valid words — critical for fast neighbor generation     |

Each signal contributes to **phase separation**, **state integrity**, and **search efficiency**.

---

## ⏱️ Time and Space Complexity

| Complexity Type   | Expression             | Explanation                                                                 |
|-------------------|------------------------|------------------------------------------------------------------------------|
| **Time Complexity** | O(N × L² + P)          | N = number of words, L = word length, P = total paths recovered             |
| **Space Complexity**| O(N × L + P × L)       | Graph + distance map + result paths                                         |

**Notes:**
- `GetNeighbors` runs in O(L × 26) per word — for each position, try all 26 letters  
- `P` is the number of shortest paths — bounded by 10⁵ per constraints  
- BFS builds the graph in O(N × L²) — each word compared to all others or via mutation  
- DFS recovers all paths — each of length ≤ N, total cost proportional to `P × L`

---

## 🔄 Why This Architecture Works

- **BFS ensures optimality**  
  By assigning levels during traversal, we guarantee that only shortest paths are considered.

- **DFS ensures completeness**  
  All valid paths are recovered by walking the graph backward from `endWord`, respecting level constraints.

- **Separation of concerns**  
  BFS builds the structure (graph + levels), DFS extracts the content (paths).  
  This modularity improves clarity, testability, and reuse.

- **Efficient pruning**  
  The graph only stores edges that respect shortest-path levels.  
  DFS never explores invalid or longer paths — no cycles, no noise.

- **Scalable design**  
  Handles up to 500 words and 10⁵ paths without performance collapse.  
  Bitwise mutations and HashSet lookups keep operations fast.

- **Architectural purity**  
  Each phase has a clear role, no cross-contamination of logic.  
  BFS never touches path recovery, DFS never touches graph construction.

---

## 🧠 Summary

This problem exemplifies **multi-phase graph traversal**, where each phase is architecturally isolated and purpose-driven:

- **BFS builds the structure** — mapping shortest transitions and levels  
- **DFS extracts the content** — recovering all valid sequences via backtracking  
- **Graph + Distance Map** act as architectural scaffolding  
- **GetNeighbors + HashSet** ensure fast and valid edge generation

Together, they form a **clean, efficient, and reusable architecture** — ideal for mastering:

- Graph-based simulations  
- Path recovery algorithms  
- BFS + DFS hybrid strategies  
- Competitive programming and system-level design

This is not just a solution — it’s a **template for scalable graph traversal** with layered logic and minimal redundancy.


---

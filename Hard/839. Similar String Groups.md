# üìò Problem: 839. Similar String Groups

## üß© Problem Description  
Given an array of strings `strs`, where every string is an anagram of every other string, group the strings by similarity.  
Two strings are considered similar if they are either identical or can be made identical by swapping **at most two characters** in distinct positions.  
Return the number of such similarity groups.

---

## üí° Core Idea  
This problem is a **graph connectivity task** disguised as a string comparison problem.

Each string is treated as a **node** in a graph.  
An edge is drawn between two strings if they are **similar** ‚Äî meaning:
- They are identical, or  
- They differ in exactly two positions, and swapping those characters makes them equal

The goal is to count the number of **connected components** in this graph.

To solve this, apply the **Union-Find (DSU)** algorithm:
- Treat each string as a node  
- For every pair of strings, check if they are similar  
- If similar ‚Üí union their indices  
- At the end, count the number of unique groups via DSU roots

---

## ‚öôÔ∏è Algorithm Overview

### Similarity Check  
- Compare two strings character by character  
- Track the indices where characters differ  
- If more than 2 differences ‚Üí not similar  
- If exactly 2 differences ‚Üí check if swapping makes them equal

### DSU Operations  
- Initialize each string as its own group  
- For each pair `(i, j)`:
  - If `IsSimilar(strs[i], strs[j])` ‚Üí `Union(i, j)`
- Count unique parents using `Find(i)` for all `i`

---

## üß† Combined Techniques

| Component           | Technique Used                  |
|--------------------|----------------------------------|
| Graph Modeling      | Implicit graph via pairwise similarity |
| Connectivity        | Union-Find (Disjoint Set Union) |
| Similarity Logic    | Swap-based string comparison     |
| Group Counting      | HashSet of DSU roots             |

---

## üß™ Constraints

- `1 <= strs.length <= 300`  
- `1 <= strs[i].Length <= 300`  
- All strings are lowercase letters  
- All strings are anagrams of each other  
- Time complexity is acceptable due to `O(n^2 * m)` where `m` is string length

---

## üß± Code Implementation

```csharp
public class Solution {
    class DSU {
        int[] parent;
        public DSU(int n) {
            parent = new int[n];
            for (int i = 0; i < n; i++) parent[i] = i;
        }

        public int Find(int x) {
            if (parent[x] != x) parent[x] = Find(parent[x]);
            return parent[x];
        }

        public void Union(int x, int y) {
            int px = Find(x);
            int py = Find(y);
            if (px != py) parent[px] = py;
        }

        public int CountGroups() {
            var set = new HashSet<int>();
            for (int i = 0; i < parent.Length; i++) set.Add(Find(i));
            return set.Count;
        }
    }

    public int NumSimilarGroups(string[] strs) {
        int n = strs.Length;
        var dsu = new DSU(n);

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (IsSimilar(strs[i], strs[j])) {
                    dsu.Union(i, j);
                }
            }
        }

        return dsu.CountGroups();
    }

    bool IsSimilar(string a, string b) {
        if (a == b) return true;
        var diff = new List<int>();
        for (int i = 0; i < a.Length; i++) {
            if (a[i] != b[i]) diff.Add(i);
            if (diff.Count > 2) return false;
        }
        return diff.Count == 2 &&
               a[diff[0]] == b[diff[1]] &&
               a[diff[1]] == b[diff[0]];
    }
}
```

## ‚úÖ Summary

This solution transforms a string similarity problem into a graph connectivity task using Union-Find.

### Key architectural signals:
- Pairwise similarity check via swap logic  
- DSU to merge connected components  
- HashSet to count unique groups  
- No explicit graph ‚Äî edges are inferred via `IsSimilar`  
- Path compression in `Find()` ensures near-constant time operations  
- Quadratic pairwise comparison is acceptable due to tight constraints (`n ‚â§ 300`)

### Generalization potential:
The approach is efficient for the given constraints and generalizes well to problems involving:
- Equivalence relations over symbolic data  
- Grouping via transformation rules  
- Implicit graph construction from pairwise logic  
- Component counting via DSU  
- String-based clustering with relaxed identity conditions

### Implementation strengths:
- Modular structure: separation of DSU logic, similarity check, and traversal  
- Readable and maintainable code with clear signal flow  
- Fully compatible with C# idioms and scalable to larger datasets with memoization or indexing  
- Can be extended to support:
  - Transitive similarity chains  
  - Multi-swap similarity thresholds  
  - Preprocessing via hashing or canonical forms

This solution demonstrates a clean architectural decomposition of symbolic grouping via graph connectivity, optimized for both reasoning and performance.


---

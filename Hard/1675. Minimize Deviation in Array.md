#  1675. Minimize Deviation in Array 

##  Problem Summary
We are given an array `nums` of positive integers.  
Allowed operations:
- If element is **even** → divide by 2  
- If element is **odd** → multiply by 2  

Deviation = `max(nums) - min(nums)`  
Goal: minimize deviation after performing any number of operations.

---

##  Core Idea
- Odd numbers can only be increased (×2) once to become even.  
- Even numbers can be reduced (÷2) multiple times until they become odd.  
- Strategy:
  1. Normalize all numbers to their **maximum possible form**:
     - Odd → multiply by 2 (so they become even and reducible later).  
     - Even → keep as is.  
  2. Use a **max-heap** to repeatedly reduce the largest even number.  
  3. Track the minimum value in the array during the process.  
  4. Update deviation after each reduction.  
  5. Stop when the maximum becomes odd (cannot reduce further).  

---

##  Optimized Code (C#)

```csharp
public class Solution {
    public int MinimumDeviation(int[] nums) {
        // Step 1: Normalize all numbers
        var pq = new PriorityQueue<int, int>(Comparer<int>.Create((a, b) => b.CompareTo(a)));
        int minVal = int.MaxValue;

        foreach (int num in nums) {
            int val = (num % 2 == 1) ? num * 2 : num;
            pq.Enqueue(val, val);
            minVal = Math.Min(minVal, val);
        }

        int deviation = int.MaxValue;

        // Step 2: Reduce maximum values
        while (pq.Count > 0) {
            int maxVal = pq.Dequeue();
            deviation = Math.Min(deviation, maxVal - minVal);

            if (maxVal % 2 == 0) {
                int reduced = maxVal / 2;
                pq.Enqueue(reduced, reduced);
                minVal = Math.Min(minVal, reduced);
            } else {
                break; // odd max cannot be reduced further
            }
        }

        return deviation;
    }
}
```

##  Complexity
- **Time:** O(n log n)  
  - Each element is pushed into the heap once.  
  - Each reduction step involves a pop and push operation → O(log n).  
  - In the worst case, every element may be reduced multiple times, but overall complexity remains O(n log n).  
- **Space:** O(n)  
  - Heap stores all elements.  
  - Additional variables for tracking minimum and deviation are constant.  

---

##  Pitfalls
- **Normalization step is crucial:**  
  - Odd numbers must be doubled first so they become even and can later be reduced.  
  - If you skip this, you lose the ability to minimize deviation correctly.  
- **Track the current minimum:**  
  - Each time we reduce the maximum, the minimum may change.  
  - Without updating the minimum, deviation calculation will be incorrect.  
- **Stop condition:**  
  - Once the maximum becomes odd, it cannot be reduced further.  
  - Continuing beyond this point would break the greedy logic.  
- **Edge cases:**  
  - Arrays with all odd numbers → all doubled once, then stop.  
  - Arrays with all even numbers → repeatedly halved until odd.  
  - Single-element arrays → deviation is always 0.  

---

##  Sanity Checks
- Input: `[1,2,3,4]` → Output: **1**  
  - Normalize → `[2,2,6,4]`  
  - Reduce max step by step → deviation minimized to 1.  
- Input: `[4,1,5,20,3]` → Output: **3**  
  - Normalize → `[4,2,10,20,6]`  
  - Reduce max (20 → 10 → 5) → deviation minimized to 3.  
- Input: `[2,10,8]` → Output: **3**  
  - Normalize → `[2,10,8]` (already even)  
  - Reduce max (10 → 5, 8 → 4) → deviation minimized to 3.  

---

##  Key takeaway
This is a **heap-based greedy algorithm**:
1. **Normalize odd numbers by doubling** → ensures all numbers are reducible.  
2. **Use a max-heap** to always reduce the largest even number.  
3. **Track the minimum value** dynamically to compute deviation correctly.  
4. **Stop when maximum becomes odd** → no further reductions possible.  

###  Why this works
- By always reducing the current maximum, we shrink the gap between max and min.  
- Doubling odds ensures they can participate in reductions.  
- The heap guarantees efficient access to the maximum at each step.  

This yields an **O(n log n)** solution that is both **greedy and optimal**, balancing the array with minimal deviation.


---

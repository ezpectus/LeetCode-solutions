# 906. Super Palindromes — Architectural Palindrome Generation + Square Check  
*O(1) — Optimal Brute-Force Over Palindrome Roots*

---

## Problem Statement

Given strings `left`, `right` (1 ≤ left ≤ right ≤ 10¹⁸-1).

**Super-palindrome** = number that is:
- **Palindrome**
- **Square** of a **palindrome**

Count super-palindromes in **[left, right]** inclusive.

---

## Core Idea — Generate Palindromic Roots → Square → Check Palindrome

**Key insight**:
- Super-palindrome = `p²` where `p` is palindrome
- `p²` ≤ 10¹⁸ → `p` ≤ 10⁹
- Number of palindromic `p` up to 10⁹ is **small** (~200k)

**Strategy**:
- Generate **all palindromic numbers** `p` such that `p²` ≤ 10¹⁸
- Compute `sq = p * p`
- Check if `sq` is **palindrome**
- Check if `left ≤ sq ≤ right`

**How to generate palindromic p**:
- For length 1 to 9:
  - Generate first half (including middle for odd length)
  - Mirror it to form full palindrome

**No need** check `p` in range — only `p²`

---

##  Implementation (C#)

```csharp
public class Solution {
    public int SuperpalindromesInRange(string left, string right) {
        long L = long.Parse(left);
        long R = long.Parse(right);
        int count = 0;

        // Generate all possible palindromic roots p such that p*p <= 10^18
        for (long i = 1; i < 100000; i++) {
            // Odd length
            string s = i.ToString();
            string rev = new string(s.Reverse().ToArray());
            long pOdd = long.Parse(s + rev.Substring(1)); // skip first for middle
            long sqOdd = pOdd * pOdd;
            if (sqOdd <= R && sqOdd >= L && IsPalindrome(sqOdd)) count++;

            // Even length
            long pEven = long.Parse(s + rev);
            long sqEven = pEven * pEven;
            if (sqEven <= R && sqEven >= L && IsPalindrome(sqEven)) count++;
        }

        return count;
    }

    private bool IsPalindrome(long x) {
        string s = x.ToString();
        return s == new string(s.Reverse().ToArray());
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(1)**      | ~200k iterations (fixed for all inputs)        |
| **Space Complexity**  | **O(1)**      | Constant (string operations bounded)           |

**Optimal** — brute over all possible palindromic roots, fixed range.

---

## Why This Works — Example Walkthrough

**Input**: `left="4"`, `right="1000"`

- Generated palindromic roots → their squares:
  - 1² = **1**
  - 2² = **4**
  - 11² = **121**
  - 22² = **484**

- All squares are palindromes and within [4,1000] → **4**

**Correct**.

---

## Pitfalls & Edge Cases

- **Large numbers** → use `long` for squares (up to ~10¹⁸)
- **Leading zeros** → not possible (parsing to long removes them)
- **Single digit roots** → included (1–9)
- **10¹⁸ boundary** → loop limit (half up to ~10⁵) safely covers all
- **Zero** → not possible (n ≥ 1)

All handled perfectly.

---

## Key Takeaway

This is a **beautifully brute** math problem:

- **Generate palindromic roots** → square → check if result is palindrome
- **Fixed small range** of possible roots → effectively O(1)
- **No DP or heavy computation** needed
**Pure, clean, optimal** — perfect for palindrome square counting.

---

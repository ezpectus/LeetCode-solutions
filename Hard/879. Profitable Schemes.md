# 879. Profitable Schemes — Architectural 3D DP with Member & Profit Tracking  
*O(n × m × minProfit) — Optimal Knapsack-Style DP*

---

## Problem Statement

Given:
- `n` members
- `minProfit` target
- `group[i]` members needed for crime i
- `profit[i]` gained from crime i

Find **number of subsets** of crimes such that:
- **Total members used** ≤ `n`
- **Total profit** ≥ `minProfit`

Return **modulo 10⁹+7**.

---

## Core Idea — 3D DP: Crime × Members × Profit

**Knapsack variant**:
- Each crime: take or skip
- Track:
  - Used members
  - Achieved profit

**DP definition**:
- `dp[i][j][p]` = number of ways using first `i` crimes, using **j members**, achieving **at least p profit**

**But** "at least p" → better to track **exact profit**

**Standard**:
- `dp[i][j][p]` = ways using first `i` crimes, exactly `j` members, exactly `p` profit

**Transitions**:
- Skip crime i: `dp[i+1][j][p] += dp[i][j][p]`
- Take crime i (if j ≥ group[i]): `dp[i+1][j + group[i]][p + profit[i]] += dp[i][j][p]`

**Answer**: sum `dp[m][j][p]` for all j ≤ n, p ≥ minProfit

**Optimization**:
- Use **2D** rolling array → `dp[j][p]`
- Iterate crimes backward (or use temp array)

**Final**:
- `dp[j][p]` = ways using **j** members, **exactly p** profit

---

##  Implementation (C++)

```cpp
class Solution {
public:
    int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {
        const int MOD = 1000000007;
        int m = group.size();

        vector<vector<int>> dp(n + 1, vector<int>(minProfit + 1, 0));
        dp[0][0] = 1;

        for (int k = 0; k < m; k++) {
            int g = group[k];
            int p = profit[k];

            // Backward to avoid overwrite
            for (int j = n; j >= g; j--) {
                for (int curP = minProfit; curP >= 0; curP--) {
                    int newP = min(minProfit, curP + p);
                    dp[j][newP] = (dp[j][newP] + dp[j - g][curP]) % MOD;
                }
            }
        }
        int ans = 0;
        for (int j = 0; j <= n; j++)  ans = (ans + dp[j][minProfit]) % MOD;
        
        return ans;
    }
};
```

## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(m × n × minProfit)**      | m crimes, n members, minProfit ≤100 → 10⁶ operations |
| **Space Complexity**  | **O(n × minProfit)**          | 2D DP table (rolling)                          |

**Optimal** — constraints small (100×100×100 = 10⁶).

---

## Why This Works — Example Walkthrough

**Input**: `n=5`, `minProfit=3`, `group=[2,2]`, `profit=[2,3]`

- Crimes:
  - A: 2 members, 2 profit
  - B: 2 members, 3 profit

**Valid schemes**:
- Take only B → 2 members, 3 profit → valid
- Take A + B → 4 members, 5 profit → valid

→ **2 ways**

DP correctly counts all combinations by:
- Trying take/skip for each crime
- Tracking exact members used and profit gained (capped at minProfit)

**Correct**.

---

## Pitfalls & Edge Cases

- **minProfit=0** → includes empty subset? No — we only count schemes using crimes
- **Overlapping crimes** → impossible (0/1 knapsack — each crime once)
- **Large profit** → capped at minProfit → saves space
- **Modulo overflow** → careful addition with `% MOD`

All handled perfectly.

---

## Key Takeaway

This is a **classic 0/1 knapsack variant**:

- **Two constraints**: members (capacity) and profit (value, but "at least")
- **3D → 2D DP** with backward iteration → avoid using same crime twice
- **Cap profit at minProfit** → reduce dimension

**Pure, clean, optimal** — one of the best Hard knapsack problems.

---

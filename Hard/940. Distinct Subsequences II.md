# 940. Distinct Subsequences II — Architectural DP with Last Occurrence Tracking  
*O(n) — Optimal Linear DP with Modulo*

---

## Problem Statement

Given string `s` (length ≤2000, lowercase letters).

Count **number of distinct non-empty subsequences**.

Return **modulo 10⁹+7**.

**Subsequence** = delete some chars, keep order.

**Distinct** = different strings (not positions).

---

## Core Idea — DP Tracking Last Character Contribution

**Naive** → 2^n subsequences → too many.

**Key insight**:
- For each position `i`, decide **include** `s[i]` or not
- But many duplicates due to same chars

**Brilliant**:
- `dp[i]` = number of distinct subsequences **ending** with `s[i-1]`
- Total distinct = sum over all `dp[i]` + 1 (empty, but we exclude empty)

**Better**:
- `dp[i]` = total distinct subsequences using first `i` chars
- When add `s[i]`:
  - All previous subsequences can **append** `s[i]` → new ones
  - But some already end with `s[i]` → would duplicate

**Optimal**:
- Track **last occurrence** of each char
- When processing `s[i]`:
  - New subsequences = **all previous** (`dp[i]`) → append `s[i]`
  - Subtract those that already ended with `s[i]` (duplicates)
  - `dp[i+1] = 2 * dp[i] - dp[last[s[i]]]` 

**Modulo** careful with negative.

---

##  Implementation (C++)

```cpp
class Solution {
public:
    int distinctSubseqII(string s) {
        const int MOD = 1000000007;
        int n = s.size();
        vector<long long> dp(n + 1, 0);
        dp[0] = 1; // empty subsequence
        vector<int> last(26, -1); // last index of each char

        for (int i = 0; i < n; i++) {
            int c = s[i] - 'a';
            dp[i + 1] = dp[i] * 2 % MOD;

            if (last[c] >= 0)  dp[i + 1] = (dp[i + 1] - dp[last[c]] + MOD) % MOD;
            last[c] = i;
        }

        // Subtract 1 for empty subsequence
        return (dp[n] - 1 + MOD) % MOD;
    }
};
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**              | Single linear pass                             |
| **Space Complexity**  | **O(n)**              | DP array (can be optimized to O(1) with variables) |

**Optimal** — linear time, minimal extra space.

---

## Why This Works — Example Walkthrough

**Input**: `s = "abc"`

- `dp[0] = 1` (empty subsequence)
- i=0 `'a'`:
  - `dp[1] = 2 × 1 = 2`
  - last['a'] = -1 → no subtract
  - Subsequences: `""`, `"a"`
- i=1 `'b'`:
  - `dp[2] = 2 × 2 = 4`
  - last['b'] = -1 → no subtract
  - `""`, `"a"`, `"b"`, `"ab"`
- i=2 `'c'`:
  - `dp[3] = 2 × 4 = 8`
  - last['c'] = -1 → no subtract
  - 8 total → minus empty → **7**

**Correct**.

**Input**: `s = "aaa"`

- `dp[0] = 1`
- i=0 `'a'`: `dp[1] = 2`, last[a]=0
- i=1 `'a'`: `dp[2] = 4 - dp[0] = 4 - 1 = 3`
- i=2 `'a'`: `dp[3] = 6 - dp[1] = 6 - 2 = 4`
- 4 - 1 = **3** → `"a"`, `"aa"`, `"aaa"`

**Correct**.

---

## Pitfalls & Edge Cases

- **All same characters** → correctly gives `n+1` subsequences
- **All unique characters** → `2^n - 1`
- **Empty string** → not possible by constraints
- **Modulo negative values** → `+MOD` fix handles correctly

All handled perfectly.

---

## Key Takeaway

This is a **masterpiece of clever DP**:

- **Double previous** → new char appended to all existing subsequences
- **Subtract last occurrence** → remove duplicates ending with same char
- **last[26]** → track last position of each character

**No 2D DP. No recursion.**
**Pure math insight + clean code** — one of the best Hard string DP problems.

---

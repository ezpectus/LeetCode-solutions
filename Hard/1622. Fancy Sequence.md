# 1622. Fancy Sequence  
*O(log n) per operation — Optimal Dynamic Segment Tree with Lazy Affine Propagation*

---

## Problem Statement

Implement the `Fancy` class to support a dynamic sequence with global updates:

- `Fancy()` — initializes an empty sequence
- `Append(val)` — appends integer `val` to the end of the sequence
- `AddAll(inc)` — adds `inc` to **every** element currently in the sequence
- `MultAll(m)` — multiplies **every** element currently in the sequence by `m`
- `GetIndex(idx)` — returns the value at index `idx` (0-based) **modulo 10⁹ + 7**, or -1 if `idx` ≥ length

**Constraints**:
- 1 ≤ val, inc, m ≤ 100
- 0 ≤ idx ≤ 10⁵
- At most 10⁵ total calls to all operations
- Modulo = 10⁹ + 7

---

## Core Idea — Dynamic Segment Tree with Lazy Multiplication & Addition

**Why segment tree?**
- Sequence grows dynamically (append only at the end)
- Global range updates: add and multiply on the **entire** current sequence
- Point queries: get value at specific index
- With lazy propagation we can handle range mult + range add in O(log n)
- Dynamic nodes allow us to handle growing size without preallocating 10⁵

**Lazy propagation for affine transformation** (x → m·x + b):
- Each node has:
  - `mul` — pending multiplier (default 1)
  - `add` — pending adder (default 0)
- Composition: new_mult = old_mult × m, new_add = old_add × m + inc
- Push down: apply to children and update node value (for leaf) or propagate tags
- Since append adds at the end → we dynamically create nodes as needed

**Key details**:
- Tree covers range [0, 10⁵] (max possible size)
- `size` tracks current length
- When appending — update tree structure to include new position
- All operations use modulo 10⁹ + 7

---

## Clean Implementation (C++)

```cpp
//Segment Tree with Lazy Multiplication & Addition
class Fancy {
public:
    class node {
    public:
        node* left = NULL;
        node* right = NULL;
        int l, r;
        long long add = 0;
        long long mul = 1;
    };

    int size = 0;
    node* root;
    vector<long long> arr;
    const int MOD = 1e9 + 7;

    Fancy() {
        root = new node();
        root->l = 0;
        root->r = 1e5;
    }

    void update(node* curr) {
        int l = curr->l, r = curr->r;
        if (l == r) return;
        int mid = l + (r - l) / 2;
        if (size <= mid) {
            if (!curr->left) {
                curr->left = new node();
                curr->left->l = l;
                curr->left->r = mid;
            }
            update(curr->left);
        } else {
            if (!curr->right) {
                curr->right = new node();
                curr->right->l = mid + 1;
                curr->right->r = r;
            }
            update(curr->right);
        }
    }

    long long get(node* curr, long long mul, long long extra, int i) {
        extra = (extra + curr->add * mul) % MOD;
        mul = (mul * curr->mul) % MOD;
        int l = curr->l, r = curr->r;
        if (l == r) {
            return (arr[l] * mul + extra) % MOD;
        }
        int mid = l + (r - l) / 2;
        if (i <= mid) {
            return get(curr->left, mul, extra, i);
        } else {
            return get(curr->right, mul, extra, i);
        }
    }

    void add(node* curr, int val) {
        if (!curr) return;
        int l = curr->l, r = curr->r;
        if (l >= size) return;
        if (r < size) {
            curr->add = (curr->add + val) % MOD;
            return;
        }
        add(curr->left, val);
        add(curr->right, val);
    }

    void mul(node* curr, int val) {
        if (!curr) return;
        int l = curr->l, r = curr->r;
        if (l >= size) return;
        if (r < size) {
            curr->add = (curr->add * val) % MOD;
            curr->mul = (curr->mul * val) % MOD;
            return;
        }
        mul(curr->left, val);
        mul(curr->right, val);
    }

    void append(int val) {
        update(root);
        arr.push_back(val);
        size++;
    }

    void addAll(int inc) {
        add(root, inc);
    }

    void multAll(int m) {
        mul(root, m);
    }

    int getIndex(int idx) {
        if (idx >= size) return -1;
        return get(root, 1, 0, idx);
    }
};
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time per Operation** | **O(log MAX_N)**      | Append, AddAll, MultAll, GetIndex — each O(log 10⁵) due to segment tree traversal and lazy propagation |
| **Total Time**        | **O(q log n)**        | q ≤ 10⁵ total calls → very fast (log 10⁵ ≈ 17) |
| **Space Complexity**  | **O(n log n)** worst-case | Dynamic segment tree nodes — grows with appends, worst case O(n log MAX_N) but in practice much less |

**Optimal** — logarithmic time per operation, perfectly handles up to 10⁵ calls efficiently.

---

## Why This Works — Example Walkthrough

**Input operations**:

1. Append(2) → dynamically build path for index 0, store raw value 2
2. AddAll(3) → range add 3 on [0..0]
3. Append(7) → build path for index 1, store raw 7
4. MultAll(2) → range multiply 2 on [0..1]
5. GetIndex(0) → query index 0: push lazy down → (2 × 2 + 3) = **10** → correct
6. AddAll(3) → range add 3 on [0..1]
7. Append(10) → build path for index 2, store raw 10
8. MultAll(2) → range multiply 2 on [0..2]
9. GetIndex(0) → push lazy → correct **26**
10. GetIndex(1) → correct **34**
11. GetIndex(2) → correct **20**

**Correct** — dynamic segment tree grows on demand for new appends.  
Lazy tags for multiplication and addition are propagated only when needed (on query or when pushing down).  
All transformations apply correctly to elements present at the time of the operation.

---

## Key Takeaway

This is a **classic dynamic sequence with global affine updates** problem:

- Use **dynamic segment tree** with lazy propagation for range multiplication and addition
- Append — dynamically create path to new position and store raw value
- AddAll/MultAll — apply lazy range update on [0..cur_size-1]
- GetIndex — query single position, pushing lazy down the path
- Handles append-at-end + global updates perfectly in O(log n) per operation

**Pure, clean, optimal** — logarithmic time per operation, robust and correct for 10⁵ calls.

---

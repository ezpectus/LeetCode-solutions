# 1359. Count All Valid Pickup and Delivery Options — Architectural Combinatorial DP / Permutation Formula  
*O(n) — Optimal Closed-Form or Linear DP*

---

## Problem Statement

- You have `n` orders. Each order consists of one **pickup** (Pᵢ) and one **delivery** (Dᵢ).
- You need to find the number of valid sequences of **2n** actions (n pickups + n deliveries) such that:
- For each order i: **Pᵢ appears before Dᵢ**
- All Pᵢ and Dᵢ are distinct
- Return the number **modulo 10⁹ + 7**.

---

## Core Idea — Valid Interleaving of Pickups & Deliveries

**Key insight**:
- Total positions: 2n
- Choose n positions out of 2n for all pickups (the rest are deliveries) → C(2n, n)
- But for each order, Pᵢ must come before Dᵢ → we overcount by 2ⁿ (each pair can be swapped)

**Exact formula**:
- Number of ways = (2n)! / (2ⁿ)
- Because: total permutations of 2n distinct events = (2n)!
- For each pair (Pᵢ, Dᵢ), we only want Pᵢ before Dᵢ → divide by 2 per pair

**Simplified**:
```ways = (2n)! / (2ⁿ)```

**But better to compute iteratively to avoid large factorials:**
```
ways = 1
for i = 1 to n:
ways = ways * (2i) * (2i - 1) / 2   % MOD
```

**Or equivalently:**
```
ways = 1
for i = 1 to n:
ways = ways * (i * (2*i - 1)) % MOD
```
This is **O(n)** and safe.

---

## Full Optimal Implementation (C#)

```csharp
public class Solution {
    private const int MOD = 1000000007;

    public int CountOrders(int n) {
        long res = 1;
        for (int i = 1; i <= n; i++) {
            // For each new order: 2*i positions to place Pᵢ, then (2*i-1) for Dᵢ
            // But since P must before D, multiply by (2*i-1) choices for D after P
            res = res * i % MOD;              // choose slot for Pᵢ
            res = res * (2L * i - 1) % MOD;   // choose slot for Dᵢ after Pᵢ
        }

        return (int)res;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**              | Single loop up to n                            |
| **Space Complexity**  | **O(1)** or **O(n)**  | O(1) if iterative multiplication, O(n) if DP array used |

**Optimal** — linear time, minimal space.

---

## Why This Works — Example Walkthrough

**Example 1**: `n = 1`

- Only one valid sequence: **P₁ D₁**
- Answer: **1** → correct

**Example 2**: `n = 2`

- All valid sequences (P before D for each order):
  - P1 P2 D1 D2
  - P1 P2 D2 D1
  - P1 D1 P2 D2
  - P2 P1 D1 D2
  - P2 P1 D2 D1
  - P2 D2 P1 D1
- Total: **6** → correct

**Iterative calculation** (using the formula):
- i=1: ×1 × (2×1−1) = 1 × 1 = **1**
- i=2: ×2 × (2×2−1) = 1 × 2 × 3 = **6**

**Correct** — matches all valid interleavings where pickup always precedes its delivery.

---

## Pitfalls & Edge Cases

- **n=1** → always **1** way
- **Large n** → modulo applied at each multiplication step prevents overflow
- **Intermediate overflow** → use `long` for calculations
- **No invalid sequences** → the formula inherently guarantees pickup before delivery for each pair
- **n=0** → not possible (constraints start from 1)

All handled perfectly.

---

## Key Takeaway

This is a **beautifully elegant** combinatorial problem:

- Total unrestricted permutations of 2n distinct events: **(2n)!**
- For each of the n pairs, we only want pickup before delivery → divide by **2ⁿ**
- Equivalent formula: **(2n)! / 2ⁿ**
- Computed safely via iterative multiplication:  
  `res = res × i × (2i−1)` for i=1 to n

**Pure, clean, optimal** — perfect counting of valid pickup-delivery sequences.

---



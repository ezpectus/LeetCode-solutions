# 726. Number of Atoms

---

## Problem Restatement
We are given a valid chemical formula string.  
Rules:
- An atom name starts with an uppercase letter, followed by zero or more lowercase letters.  
- A count (digits) may follow an atom or a parenthesized group. If no count, it means 1.  
- Parentheses can group formulas, and a multiplier after the parentheses applies to all atoms inside.  
- Concatenation of formulas is also valid.  

We must return the count of each atom in **sorted order by atom name**, formatted as:
```
AtomName + count (omit count if 1)
```

---

## Key Idea
- Use a **stack of dictionaries** to handle nested parentheses.  
- Traverse the formula:
  - Parse atom names.  
  - Parse counts (default = 1).  
  - On `'('`, push a new dictionary onto the stack.  
  - On `')'`, pop the top dictionary, multiply counts by the following number, and merge back into the previous dictionary.  
- At the end, the bottom dictionary contains all atom counts.  
- Sort atom names and build the output string.

---

## Code (C#)
```csharp
public class Solution {
    public string CountOfAtoms(string formula) {
        Stack<Dictionary<string, int>> stack = new Stack<Dictionary<string, int>>();
        stack.Push(new Dictionary<string, int>());
        int i = 0, n = formula.Length;

        while (i < n) {
            char c = formula[i];

            if (c == '(') {
                stack.Push(new Dictionary<string, int>());
                i++;
            }
            else if (c == ')') {
                i++;
                int start = i;
                while (i < n && char.IsDigit(formula[i])) i++;
                int mult = start < i ? int.Parse(formula.Substring(start, i - start)) : 1;

                var top = stack.Pop();
                foreach (var kv in top) {
                    if (!stack.Peek().ContainsKey(kv.Key))
                        stack.Peek()[kv.Key] = 0;
                    stack.Peek()[kv.Key] += kv.Value * mult;
                }
            }
            else {
                // Parse atom name
                int start = i++;
                while (i < n && char.IsLower(formula[i])) i++;
                string name = formula.Substring(start, i - start);

                // Parse count
                start = i;
                while (i < n && char.IsDigit(formula[i])) i++;
                int count = start < i ? int.Parse(formula.Substring(start, i - start)) : 1;

                if (!stack.Peek().ContainsKey(name))
                    stack.Peek()[name] = 0;
                stack.Peek()[name] += count;
            }
        }

        var finalMap = stack.Pop();
        var atoms = new List<string>(finalMap.Keys);
        atoms.Sort(StringComparer.Ordinal);

        var sb = new System.Text.StringBuilder();
        foreach (var atom in atoms) {
            sb.Append(atom);
            if (finalMap[atom] > 1) sb.Append(finalMap[atom]);
        }

        return sb.ToString();
    }
}
```


## Time Complexity
- **Parsing step:** O(n), where n = length of the formula. Each character is processed once.  
- **Sorting step:** O(k log k), where k = number of distinct atoms. Sorting ensures lexicographic order in the output.  
- **Overall:** O(n + k log k).  

---

## Space Complexity
- **Stack depth:** O(n) in the worst case (deeply nested parentheses).  
- **Dictionary storage:** O(k) for atom counts.  
- **Total:** O(n + k).  

---

## Example Walkthrough

### Input: `"Mg(OH)2"`

1. **Parse `Mg` → count 1.**  
   Current dict = {Mg:1}  

2. **Encounter `(` → push new dict.**  
   Stack = [ {Mg:1}, {} ]  

3. **Parse `O` → count 1.**  
   Top dict = {O:1}  

4. **Parse `H` → count 1.**  
   Top dict = {O:1, H:1}  

5. **Encounter `)` → multiplier 2.**  
   Pop dict {O:1, H:1} → multiply → {O:2, H:2}.  
   Merge into previous dict → {Mg:1, O:2, H:2}.  

6. **Final dict = {H:2, Mg:1, O:2}.**  
   Sorted output = `"H2MgO2"` ✅  

---

## Why This Works
- **Stack of dictionaries:** Handles nested parentheses cleanly.  
- **Multipliers:** Applied after closing parentheses to scale atom counts.  
- **Sorting:** Ensures atoms are listed in lexicographic order.  
- **Default counts:** If no digit follows an atom or group, count = 1.  

---

## Edge Cases
- **Single atom:** `"H"` → output `"H"`.  
- **Nested groups:** `"K4(ON(SO3)2)2"` → correctly expands to `"K4N2O14S4"`.  
- **Duplicate atoms:** `"H2O2He3Mg4"` → merges counts across concatenated formulas.  
- **Large input size (n ≤ 1000):** Efficient parsing and sorting handle constraints easily.  

---

✅ **Conclusion**  
By using a **stack of dictionaries** to manage nested groups and multipliers, we can parse chemical formulas correctly.  
Sorting atom names guarantees the required output format.  
This approach is efficient, robust, and scales to formulas of length up to 1000, making it well-suited for handling complex chemical expressions.


---

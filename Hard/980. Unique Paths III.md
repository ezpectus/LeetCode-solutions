# 980. Unique Paths III — Architectural Backtracking Solution  
*O(4ᴺ) · N ≤ 20 — Perfect Hamiltonian Path Counting*

---

## Problem Statement

Given an `m × n` grid containing:

- `1` — **starting square** (exactly one)
- `2` — **ending square** (exactly one)
- `0` — **empty cells** we can walk on
- `-1` — **obstacles**

Count the number of **4-directional paths** that:

- Start at `1`
- End at `2`
- Visit **every non-obstacle cell exactly once**

Return the number of such paths.

**Constraints**  
- `1 ≤ m, n ≤ 20`  
- `m × n ≤ 20` → **at most 20 walkable cells**

---

## Core Idea — Backtracking on Tiny Grid

With **≤ 20 walkable cells**, we can afford **full backtracking**:

- Pre-count `totalWalkable = number of cells != -1`
- Start DFS from `(sx, sy)` with `visited = 1`
- At each step:
  - Mark current cell as visited (temporarily set to `-1`)
  - Explore 4 directions
  - If we reach cell with value `2`:
    - If `visited == totalWalkable` → valid path → count++
- Backtrack: restore original value

**No DP, no bitmask needed — pure DFS with count**

---

## Full Implementation (C#)

```csharp
public class Solution 
{
    private int rows, cols;
    private int totalWalkable;
    private int[][] grid;
    private int result = 0;

    public int UniquePathsIII(int[][] grid) 
    {
        this.grid = grid;
        rows = grid.Length;
        cols = grid[0].Length;

        int startX = 0, startY = 0;
        totalWalkable = 0;

        // Pre-scan: find start + count walkable cells
        for (int i = 0; i < rows; i++) 
        {
            for (int j = 0; j < cols; j++) 
            {
                if (grid[i][j] != -1) 
                    totalWalkable++;
                if (grid[i][j] == 1) 
                {
                    startX = i;
                    startY = j;
                }
            }
        }

        DFS(startX, startY, 1); // start cell already visited
        return result;
    }

    private void DFS(int x, int y, int visited) 
    {
        // Reached end cell
        if (grid[x][y] == 2) 
        {
            if (visited == totalWalkable)
                result++;
            return;
        }

        // Mark as visited
        int temp = grid[x][y];
        grid[x][y] = -1;

        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};

        for (int d = 0; d < 4; d++) 
        {
            int nx = x + dx[d];
            int ny = y + dy[d];

            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] != -1) 
            {
                DFS(nx, ny, visited + 1);
            }
        }

        // Backtrack
        grid[x][y] = temp;
    }
}
```

## Complexity Analysis

| **Metric**     | **Value**             | **Notes**                                      |
|----------------|-----------------------|------------------------------------------------|
| **Time**       | **O(4ᴺ)**             | N = walkable cells ≤ 20 → safe                 |
| **Space**      | **O(N)**              | Recursion depth ≤ 20                           |

**With N ≤ 20 → 4²⁰ ≈ 1e12 theoretically**,  
but actual branching factor is **much lower** due to grid structure → **runs instantly**

---

## Pitfalls & Edge Cases

- Must **count all walkable cells** (including `1` and `2`)  
- Valid path **only if** we reach `2` **after visiting all**  
- **In-place marking** with `-1` + **backtracking** is crucial  
- **Start cell** is counted in `visited` from the beginning

---

## Sanity Checks

- `[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]` → `2`
- `[[1,0,0,0],[0,0,0,0],[0,0,0,2]]` → `4`
- `[[0,1],[2,0]]` → `0` (no path)

---

## Key Takeaway

This is a **classic Hamiltonian path counting** problem on a tiny grid:

- Pre-count **walkable cells**
- Use **DFS + backtracking** with `visited` count
- Only accept path when we reach `2` with **exact** number of steps
**Clean, correct, and optimal** for `n ≤ 20`.

---

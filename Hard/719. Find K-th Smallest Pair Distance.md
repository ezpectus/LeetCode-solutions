# 🧩 Problem: Find K-th Smallest Pair Distance  
## 🔢 Number: LeetCode 719  
**Difficulty**: Hard  
**Language**: C#  
**Status**: ✅ Solved via binary search + two pointers  

---

## 📜 Problem Overview

We are given an integer array `nums[]`, and an integer `k`.  
The **distance** between two elements `a` and `b` is defined as `|a - b|`.  
We must find the **k-th smallest distance** among all possible pairs `(i, j)` where `0 ≤ i < j < nums.length`.

---

### 🔢 Constraints
- `2 ≤ nums.length ≤ 10⁴`  
- `0 ≤ nums[i] ≤ 10⁶`  
- `1 ≤ k ≤ n * (n - 1) / 2`  
- All pair distances are non-negative integers

---

### 🎁 What’s Given
- An array `nums[]` of integers  
- An integer `k`  
- We must return the k-th smallest absolute difference between any two elements

---

### 👀 What We Observe
- Brute-force O(n²) is too slow for `n = 10⁴`  
- We need to **search for a distance**, not a specific pair  
- The key is to **count how many pairs have distance ≤ d**  
- This suggests a **binary search over distance values**, combined with **two pointers**

---

## 🧠 Explanation

We sort the array `nums[]` to make pairwise distance checks efficient.  
Then we perform **binary search** over possible distances `d` from `0` to `max(nums) - min(nums)`.

For each candidate distance `d`, we count how many pairs `(i, j)` satisfy `nums[j] - nums[i] ≤ d`.  
If the count is ≥ `k`, we try smaller distances.  
If the count is < `k`, we try larger distances.

The counting is done using **two pointers**:
- For each `i`, move `j` forward until `nums[j] - nums[i] > d`  
- The number of valid pairs for that `i` is `j - i - 1`

---

## ⚙️ Algorithm Choice
- **Approach**: Binary search over distance + two-pointer counting  
- **Why**: Efficient for large `n`, avoids brute-force  
- **Efficiency**: O(n log n + n log W), where W is the max distance  
- **Memory**: O(1) extra space

---

## 💡 Idea Summary
- Sort the array  
- Binary search over possible distances  
- For each candidate distance, count valid pairs using two pointers  
- Return the smallest distance `d` such that there are at least `k` pairs with distance ≤ `d`

---

## 🧾 Code
```csharp
public class Solution {
    public int SmallestDistancePair(int[] nums, int k) {
        Array.Sort(nums);
        int left = 0;
        int right = nums[^1] - nums[0];

        while (left < right) {
            int mid = (left + right) / 2;
            int count = 0;
            int j = 0;

            for (int i = 0; i < nums.Length; i++) {
                while (j < nums.Length && nums[j] - nums[i] <= mid) {
                    j++;
                }
                count += j - i - 1;
            }

            if (count >= k) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        return left;
    }
}
```

## ✅ Complexity, Insights & Notes

### ⏱ Time Complexity
- **O(n log n + n log W)**  
- Sorting the array takes **O(n log n)**  
- Binary search over the distance range `W = max(nums) - min(nums)`  
- For each candidate distance, we perform a two-pointer pass in **O(n)**

---

### 🧠 Space Complexity
- **O(1)** — constant space  
- No auxiliary data structures are used beyond variables and pointers

---

### 🧨 Tricks / Insights
- Perform **binary search over answers**, not indices or positions  
- Use **two-pointer technique** to count valid pairs with distance ≤ `d` in linear time  
- Sorting the array enables efficient pairwise distance checks  
- The key is to **count** how many pairs satisfy the condition — not to find or store them  
- The search narrows down the smallest distance `d` such that at least `k` pairs exist

---

### 🧠 Notes
- Related to problems involving:
  - **Binary search over solution space**  
  - **Pairwise comparisons**  
  - **Two-pointer optimization**

- Can be extended to problems like:
  - **K-th smallest sum of pairs**  
  - **K-th largest product of pairs**  
  - **Range-based pair counting**  
  - **Threshold-based selection in sorted arrays**

---

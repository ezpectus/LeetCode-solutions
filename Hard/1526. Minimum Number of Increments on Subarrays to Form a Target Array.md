# Pattern Name
**Greedy Subarray Increments via Positive Difference Aggregation**

## Problem Summary
- **Input**:  
  Integer array `target` of length `n`.
- **Goal**:  
  Return the **minimum number of operations** to form `target` from an array of all zeros, where each operation **increments a subarray by 1**.
- **Constraints**:
  - `1 ≤ n ≤ 10⁵`
  - `1 ≤ target[i] ≤ 10⁵`

## Core Idea
- Each operation covers a **contiguous segment**.
- The **minimum operations** = sum of **positive differences** between consecutive elements **after the first**.
- Start with `target[0]` operations (to cover the first element).
- For each `i > 0`:  
  - If `target[i] > target[i-1]` → need `target[i] - target[i-1]` **new operations**.
  - If `target[i] ≤ target[i-1]` → **no new operations** (covered by previous ones).

## Solution
- Initialize `res = target[0]`
- For `i = 1` to `n-1`:  
  `res += max(target[i] - target[i-1], 0)`

## Strategy Summary
- **First element**: `target[0]` operations to reach height.
- **Each rise**: `target[i] > target[i-1]` → add the **difference**.
- **Each fall or flat**: no additional cost.

## C# Implementation
```csharp
public class Solution {
    public int MinNumberOperations(int[] target) {
        int n = target.Length;
        int res = target[0];
        for (int i = 1; i < n; i++) 
            res += Math.Max(target[i] - target[i-1], 0);
        return res;
    }
}
```
## Example Walkthrough
| target | `[1,2,3,2,1]` |
|--------|---------------|
| **Step** | **Explanation** |
| `res = 1` | Cover first `1` |
| `i=1`: `2>1` → `+1` | Need one more layer from index 1 |
| `i=2`: `3>2` → `+1` | Need one more layer from index 2 |
| `i=3`: `2≤3` → `+0` | Covered |
| `i=4`: `1≤2` → `+0` | Covered |
| **Total: 3** | Matches example |

## Architectural Breakdown
| Component               | Role                                      |
|-------------------------|-------------------------------------------|
| `target[0]`             | Base operations for first element         |
| `Math.Max(diff, 0)`     | Only count **rising edges**               |
| **Linear scan**         | O(n) traversal, no extra space            |
| **Greedy choice**       | Each rise must be covered by new ops      |

## Why This Approach Is Superior
| Aspect              | **Difference Aggregation** | Brute Force / DP         |
|---------------------|-----------------------------|---------------------------|
| Time Complexity     | **O(n)**                    | O(n²) or O(nk)            |
| Space Complexity    | **O(1)**                    | O(n) or more              |
| Performance         | Linear, cache-friendly      | Slow on large inputs      |
| Clarity             | **Intuitive & visual**      | Complex state transitions |

## Final Takeaway
- **This pattern generalizes to**:
  - **Subarray increment** problems
  - **Minimum operations** to build height map
  - **Greedy on differences** in sequences


---

# 1649. Create Sorted Array through Instructions  
*O(n log n) — Optimal Fenwick Tree / Binary Indexed Tree + Coordinate Compression*

---

## Problem Statement

You are given an integer array `instructions` of length `n` (1 ≤ n ≤ 10⁵, 1 ≤ instructions[i] ≤ 10⁵).

Start with an empty array `nums`.

For each element `instructions[i]` from left to right:

- Insert it into `nums`
- The **cost** of this insertion is the **minimum** of:
  - Number of elements in `nums` **strictly less** than `instructions[i]`
  - Number of elements in `nums` **strictly greater** than `instructions[i]`

Return the **total cost** of all insertions **modulo 10⁹ + 7**.

---

## Core Idea — Fenwick Tree for Dynamic Order Statistics

**Key insight**:
- For each insertion, cost = min(left_count, right_count)
- Where left_count = number of elements < x
- right_count = number of elements > x
- We need to support:
  - Insert a number x
  - Query number of elements < x
  - Query number of elements > x
- Since values up to 10⁵ → coordinate compression to 1..n
- Use **Fenwick Tree** (Binary Indexed Tree) to maintain frequency count of each value
- For each instruction x:
  - Query left = sum(1 to rank(x)-1)
  - Query right = total_inserted - sum(1 to rank(x))
  - Add min(left, right) to answer
  - Insert x into Fenwick (add 1 at rank(x))

**Coordinate compression**:
- Collect all unique values → sort → map to 1..m (m ≤ n ≤ 10⁵)
- Use ranks for Fenwick Tree indices (size m+1)

---

## Clean Implementation (C#)

```csharp
public class Solution {
    private const int MOD = 1_000_000_007;

    public int CreateSortedArray(int[] instructions) {
        int n = instructions.Length;

        // Step 1: Coordinate compression
        var unique = new HashSet<int>(instructions);
        var sortedUnique = unique.ToArray();
        Array.Sort(sortedUnique);
        var rankMap = new Dictionary<int, int>();
        for (int i = 0; i < sortedUnique.Length; i++) {
            rankMap[sortedUnique[i]] = i + 1; // ranks from 1 to m
        }

        int maxRank = sortedUnique.Length;

        // Step 2: Fenwick Tree for frequencies
        int[] fenwick = new int[maxRank + 2];

        long totalCost = 0;
        int inserted = 0;

        foreach (int val in instructions) {
            int r = rankMap[val];

            // Query number of elements < val (strictly less)
            long left = Query(fenwick, r - 1);

            // Number of elements > val = total - (less + equal)
            long equal = Query(fenwick, r) - left;
            long right = inserted - left - equal;

            // Cost = min(left, right)
            totalCost = (totalCost + Math.Min(left, right)) % MOD;

            // Insert this value
            Update(fenwick, r, 1);
            inserted++;
        }

        return (int)totalCost;
    }

    // Fenwick Tree: sum from 1 to idx
    private long Query(int[] fenwick, int idx) {
        long sum = 0;
        while (idx > 0) {
            sum += fenwick[idx];
            idx -= idx & -idx;
        }
        return sum;
    }

    // Fenwick Tree: add val at position idx
    private void Update(int[] fenwick, int idx, int val) {
        while (idx < fenwick.Length) {
            fenwick[idx] += val;
            idx += idx & -idx;
        }
    }
}
```


## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)**        | Coordinate compression (sorting unique values) O(n log n) + n Fenwick Tree operations (each O(log n)) |
| **Space Complexity**  | **O(n)**              | Fenwick Tree size O(n) after compression + rank map O(n) |

**Optimal** — linearithmic time, perfectly suited for n ≤ 10⁵ constraints.

---

## Why This Works — Example Walkthrough

**Example 1**: `instructions = [1,5,6,2]`

- Insert 1 → nums=[1], left=0, right=0 → cost=min(0,0)=**0**
- Insert 5 → nums=[1,5], left=1 (1<5), right=0 → cost=min(1,0)=**0**
- Insert 6 → nums=[1,5,6], left=2 (1,5<6), right=0 → cost=min(2,0)=**0**
- Insert 2 → nums=[1,5,6,2], left=1 (1<2), right=2 (5,6>2) → cost=min(1,2)=**1**

Total cost = **1** → correct

**Correct** — Fenwick Tree maintains a dynamic frequency count of inserted values, allowing O(log n) queries for:
- count of numbers **strictly less** than current value (left)
- count of numbers **strictly greater** than current value (right = total_inserted - left - equal_count)

Cost is always min(left, right), exactly as required.

---

## Pitfalls & Edge Cases

- **Duplicate values** → Fenwick Tree correctly handles multiple occurrences (frequency >1)
- **n = 1** → single insertion → cost = min(0,0) = **0**
- **All elements equal** → each insertion after first → left=0 or right=0 → cost=0
- **Large values (≤10⁵)** → coordinate compression maps them safely to 1..n
- **n = 10⁵** → O(n log n) time is fast enough

All handled perfectly.

---

## Key Takeaway

This is a **beautifully elegant** dynamic order statistics problem:

- Use **Fenwick Tree** (Binary Indexed Tree) to maintain frequency counts of inserted numbers
- Apply **coordinate compression** → map original values to ranks 1..m (m ≤ n)
- For each insertion of value x:
  - Query count of numbers **strictly less** than x → left
  - Query count of numbers **strictly greater** than x → right (total - left - equal)
  - Add **min(left, right)** to total cost
  - Insert x into Fenwick Tree (update frequency +1 at its rank)
- Return total cost modulo 10⁹ + 7

**Pure, clean, optimal** — perfect dynamic counting of insertion costs using prefix sums and compression.

---

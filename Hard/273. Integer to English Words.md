# 273. Integer to English Words (Hard)

---

##  Problem restatement
Convert a non-negative integer `num` to its English words representation.  
Constraints: `0 <= num <= 2,147,483,647`.

---

##  Core idea
- **Chunking by thousands:** Split the number into groups of three digits from right to left (units, thousands, millions, billions).
- **Three-digit conversion:** For each chunk, convert it to words using:
  - 1–19 as special words,
  - tens (Twenty, Thirty, …),
  - hundreds (“X Hundred …”).
- **Compose with scales:** Append the correct scale word (“Thousand”, “Million”, “Billion”) for non-zero chunks.
- **Trim and join:** Skip empty chunks; join with single spaces.

---

##  Step-by-step concept
1. **Edge case:** If `num == 0`, return “Zero”.
2. **Prepare dictionaries:** Words for 1–19 and tens (20–90).
3. **Process each chunk:**  
   - Extract `num % 1000`.  
   - Convert the chunk to words via helper.  
   - Append corresponding scale if the chunk is non-zero.  
   - Move to next chunk with `num /= 1000`.
4. **Join parts:** Reverse the collected parts and join with spaces.

---

##  Implementation (C#)

```csharp
public class Solution {
    private static readonly string[] BelowTwenty = {
        "", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine",
        "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen",
        "Sixteen", "Seventeen", "Eighteen", "Nineteen"
    };

    private static readonly string[] Tens = {
        "", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"
    };

    private static readonly string[] ThousandsScale = { "", "Thousand", "Million", "Billion" };

    public string NumberToWords(int num) {
        if (num == 0) return "Zero";

        var parts = new List<string>();
        int scaleIndex = 0;

        while (num > 0) {
            int chunk = num % 1000;
            if (chunk != 0) {
                string words = ThreeDigitToWords(chunk);
                string scale = ThousandsScale[scaleIndex];
                if (scale.Length > 0) parts.Add(words + " " + scale);
                else parts.Add(words);
            }
            num /= 1000;
            scaleIndex++;
        }

        parts.Reverse();
        return string.Join(" ", parts).Trim();
    }

    private string ThreeDigitToWords(int num) {
        var sb = new List<string>();

        int hundreds = num / 100;
        int rest = num % 100;

        if (hundreds > 0) {
            sb.Add(BelowTwenty[hundreds]);
            sb.Add("Hundred");
        }

        if (rest >= 20) {
            int tens = rest / 10;
            int ones = rest % 10;
            sb.Add(Tens[tens]);
            if (ones > 0) sb.Add(BelowTwenty[ones]);
        } else if (rest > 0) {
            sb.Add(BelowTwenty[rest]);
        }

        return string.Join(" ", sb);
    }
}
```



##  Time Complexity
- **Fixed number of chunks:**  
  - The integer is split into groups of three digits (units, thousands, millions, billions).  
  - At most 4 chunks for a 32-bit signed integer.  
- **Per-chunk processing:**  
  - Each chunk is converted in constant time (lookup + string concatenation).  
- **Overall:**  
  - `O(1)` — runtime does not grow with input size, only with fixed chunks.

---

##  Space Complexity
- **Auxiliary structures:**  
  - Static arrays for words (BelowTwenty, Tens, Scales).  
  - These are constant in size.  
- **Output size:**  
  - Proportional to the number of words in the final phrase.  
- **Overall:**  
  - `O(1)` — memory usage is constant regardless of input.

---

#  Impact of Design Choices

| Choice                          | Effect                                                                 |
|---------------------------------|------------------------------------------------------------------------|
| **Chunking by thousands**       | Simplifies logic and maps directly to English scales (Thousand, Million, Billion). |
| **Three-digit helper**          | Encapsulates rules for 1–19, tens, and hundreds cleanly.               |
| **Static dictionaries**         | Fast lookups, avoids repeated allocations.                             |
| **Skip zero chunks**            | Prevents redundant phrases like “Zero Thousand”.                       |

---

#  Pitfalls
- **Forgetting “Zero”:** Must explicitly handle `num == 0` → return `"Zero"`.  
- **Extra spaces:** Ensure clean joins; use `Trim()` to avoid trailing or double spaces.  
- **Order of parts:** Collect chunks from least significant to most, then reverse before joining.  
- **Edge limits:** Maximum scale is `"Billion"` for 32-bit signed integer; must not exceed.  
- **Incorrect chunk handling:** Skipping zero chunks incorrectly may lead to missing scale words.  

---

#  Conclusion
- **What it gives:** Correct and readable English phrase for any non-negative 32-bit integer.  
- **Why it matters:** Demonstrates decomposition into manageable chunks with clean mapping to English words.  
- **Key takeaway:**  
  1. Split into thousands.  
  2. Convert each three-digit chunk with helper logic.  
  3. Attach appropriate scale words.  
  4. Skip zero chunks and join cleanly.  
  5. Handle special case for `Zero`.  

---


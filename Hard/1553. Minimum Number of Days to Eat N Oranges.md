# 1553. Minimum Number of Days to Eat N Oranges — Greedy Recursive with Memoization  
*O(log n) — Optimal Recursive Greedy + Cache*

---

## Problem Statement

You start with `n` oranges (1 ≤ n ≤ 2×10⁹).

Each day you choose **one** action:

- Eat **1** orange (always possible)
- If `n % 2 == 0` → eat `n/2` oranges (leave `n/2`)
- If `n % 3 == 0` → eat `2 * (n/3)` oranges (leave `n/3`)

Find the **minimum number of days** to eat all oranges.

---

## Core Idea — Recursive Greedy with Memoization

**Main idea**:
- Prefer fastest reduction: divide by 3 (eat 2n/3) > divide by 2 (eat n/2) > eat 1
- Sometimes when `n % 3 == 1` — better to eat 1 or 2 first to enable division by 3 later
- Recursive function: `f(n)` = min days to eat n oranges
  - Base: f(0) = 0, f(1) = 1
  - Recurrence:  
    f(n) = 1 + min( f(n-1), f(n/2) if even, f(n/3) if divisible by 3 )
- Memoize results (Dictionary) — number of unique subproblems is O(log n)

**Why it works**:
- Dividing by 3 or 2 reduces n exponentially → depth O(log n)
- Memo prevents exponential explosion → total time O(log n)

---

## Clean Implementation (C#)

```csharp
public class Solution {
    private Dictionary<int, int> memo = new Dictionary<int, int>();

    public int MinDays(int n) {
        return Dfs(n);
    }

    private int Dfs(int n)  {
        if (n == 0) return 0;
        if (n == 1) return 1;
        if (memo.ContainsKey(n)) return memo[n];
        int res = n; // worst case — eat 1 each day

        // Try eat 1
        res = Math.Min(res, 1 + Dfs(n - 1));

        // Try divide by 2
        if (n % 2 == 0)  {
            res = Math.Min(res, 1 + Dfs(n / 2));
        }

        // Try divide by 3
        if (n % 3 == 0)  {
            res = Math.Min(res, 1 + Dfs(n / 3));
        }

        memo[n] = res;
        return res;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(log n)**  | Each recursive step divides n by 2 or 3 or subtracts 1 → recursion depth O(log n), memoization ensures each unique value computed once (number of unique states O(log n)) |
| **Space Complexity**  | **O(log n)**  | Memoization dictionary + recursion stack depth O(log n) |

**Optimal** — for n ≤ 2×10⁹, log₃(n) ≈ 30–40 steps at most, extremely efficient.

---

## Why This Works — Example Walkthrough

**Example 1**: `n = 10`

- 10 % 2 == 0 → try 1 + f(5)
- f(5) → eat 1 → f(4)
- f(4) % 2 == 0 → 1 + f(2)
- f(2) % 2 == 0 → 1 + f(1)
- f(1) = 1
- Backtrack: total **4 days** → correct

**Example 2**: `n = 6`

- 6 % 2 == 0 → 1 + f(3)
- 3 % 3 == 0 → 1 + f(1)
- f(1) = 1
- Total **3 days** → correct

**Correct** — recursion tries all three possible actions at each step, memoization avoids recomputing same subproblems, and greedy preference for division by 3/2 finds the optimal path.

---

## Pitfalls & Edge Cases

- **n = 1** → **1** day (eat 1)
- **n = 0** → **0** (but constraints n ≥ 1)
- **Powers of 2 or 3** → minimal days ≈ log₂(n) or log₃(n)
- **n % 3 == 1** → recursion automatically explores eating 1–2 to enable better division by 3
- **Very large n (≤ 2×10⁹)** → recursion depth O(log n) is safe, memo dictionary size small (~40 entries)

All handled perfectly.

---

## Key Takeaway

This is a **beautifully greedy recursive** problem:

- **Prefer divide by 3** (eat 2n/3, leave n/3) — fastest reduction
- **Then divide by 2** (eat n/2, leave n/2)
- **Otherwise eat 1**
- **Memoization** ensures efficiency — only O(log n) unique states computed

**Pure, clean, optimal** — perfect minimum days to eat n oranges.

---

# 1425. Constrained Subsequence Sum

## ğŸ§  Problem Summary

You're given an integer array `nums` and an integer `k`.  
Return the **maximum sum of a non-empty subsequence** such that for every two consecutive elements `i < j` in the subsequence, the condition `j - i â‰¤ k` holds.

A subsequence is formed by deleting zero or more elements without changing the order.  
This problem blends **dynamic programming** with **windowed constraints** â€” we must choose elements that are close enough (within `k` distance) and maximize the total sum.


---

## ğŸ“Œ Key Insight

We define `dp[i]` as the **maximum sum of a valid subsequence ending at index `i`**.

To compute `dp[i]`, we consider:
- Either start fresh: `dp[i] = nums[i]`
- Or extend from a previous `dp[j]` where `j âˆˆ [i-k, i-1]`:  
  â†’ `dp[i] = nums[i] + max(dp[j])`

To efficiently track the maximum `dp[j]` in the sliding window of size `k`, we use a **monotonic deque**.

---

## âš™ï¸ Algorithm Steps

1. Initialize:
   - `dp[0] = nums[0]`
   - `res = nums[0]`
   - `deque`: stores indices of `dp` in decreasing order

2. Iterate `i` from `1` to `n - 1`:
   - Remove indices from front of deque if they are out of range (`i - k`)
   - Compute `dp[i] = nums[i] + max(0, dp[deque[0]])`
   - Update result: `res = max(res, dp[i])`
   - Maintain deque monotonicity: remove from back if `dp[i] â‰¥ dp[deque.Last]`
   - Add `i` to deque

---

## ğŸ“¦ Code (C#)

```csharp
public class Solution {
    public int ConstrainedSubsetSum(int[] nums, int k) {
        int n = nums.Length;
        int[] dp = new int[n];
        LinkedList<int> deque = new LinkedList<int>();
        int res = nums[0];
        dp[0] = nums[0];
        deque.AddLast(0);

        for (int i = 1; i < n; i++) {
            if (deque.First.Value < i - k)
                deque.RemoveFirst();

            dp[i] = nums[i] + Math.Max(0, dp[deque.First.Value]);
            res = Math.Max(res, dp[i]);

            while (deque.Count > 0 && dp[i] >= dp[deque.Last.Value])
                deque.RemoveLast();

            deque.AddLast(i);
        }

        return res;
    }
}
```

## ğŸ§® Complexity

| Metric | Value |
|--------|-------|
| Time   | O(n)  |
| Space  | O(n)  |

- Each index is added and removed from the deque at most once, ensuring linear time.
- The `dp` array stores intermediate results for reuse, avoiding recomputation.
- The monotonic deque maintains a decreasing order of `dp` values, allowing constant-time access to the maximum within the last `k` indices.
- This structure avoids brute-force scanning and enables efficient windowed dynamic programming.

---

## ğŸ” Edge Cases

- **All elements negative**  
  â†’ No positive sum can be formed.  
  â†’ The optimal subsequence is the single largest element.

- **k = 1**  
  â†’ Only adjacent elements can be chained.  
  â†’ The problem reduces to a local greedy decision at each step.

- **Large positive followed by negatives**  
  â†’ Forces the algorithm to reset and rebuild the subsequence.  
  â†’ Demonstrates the importance of `Math.Max(0, dp[j])` to avoid dragging negative history.

- **Single element**  
  â†’ Always valid by definition.  
  â†’ Return `nums[0]` directly.

- **Long plateau of zeros**  
  â†’ Preserves previous positive `dp` values without penalty.  
  â†’ Tests the algorithmâ€™s ability to maintain momentum across neutral zones.

- **Alternating spikes and drops**  
  â†’ Validates the dequeâ€™s ability to discard outdated or suboptimal candidates.  
  â†’ Ensures the window remains clean and efficient.



---

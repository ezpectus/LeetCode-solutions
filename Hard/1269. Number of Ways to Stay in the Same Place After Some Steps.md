# 1269. Number of Ways to Stay in the Same Place After Some Steps — Architectural Bounded DP  
*O(steps × min(steps, arrLen)) — Optimal Space-Optimized DP*

---

## Problem Statement

- Pointer starts at **index 0** in array of size `arrLen`.
- Each step: **left**, **right**, or **stay** (cannot go outside [0, arrLen-1]).
- After exactly `steps` moves, return number of ways to be back at **0**.
- Answer modulo **10⁹ + 7**.
- Constraints: `steps ≤ 500`, `arrLen ≤ 10⁶`.

---

## Core Idea — DP with Position and Steps

**Key insight**:
- State: `dp[i][j]` = ways to be at position `j` after `i` steps
- Transition: from `j-1`, `j`, `j+1` (if valid)
- We only care about reaching position **0** after `steps`

**Optimization**:
- Max reachable position = `steps` (all right)
- So effective positions: `0` to `min(steps, arrLen-1)`
- Use **rolling array** → O(min(steps, arrLen)) space

**DP**:
- `dp[i][j]` = ways after `i` steps at position `j`
- `dp[0][0] = 1`
- For each step → update next row

---

##  Implementation (C#)

```csharp
public class Solution {
    private const int MOD = 1000000007;

    public int NumWays(int steps, int arrLen) {
        int maxPos = Math.Min(steps, arrLen - 1);
        int[][] dp = new int[2][];
        dp[0] = new int[maxPos + 1];
        dp[1] = new int[maxPos + 1];
        dp[0][0] = 1;

        for (int i = 1; i <= steps; i++) {
            int curr = i % 2;
            int prev = 1 - curr;
            Array.Fill(dp[curr], 0);

            for (int j = 0; j <= maxPos; j++) {
                // stay
                dp[curr][j] = dp[prev][j];

                // from left
                if (j > 0)  dp[curr][j] = (dp[curr][j] + dp[prev][j - 1]) % MOD;
                

                // from right
                if (j + 1 <= maxPos)  dp[curr][j] = (dp[curr][j] + dp[prev][j + 1]) % MOD;
                
            }
        }

        return dp[steps % 2][0];
    }
}
```

## Complexity

| **Metric**            | **Value**                             | **Notes**                                      |
|-----------------------|---------------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(steps × min(steps, arrLen))**     | Effective positions bounded by steps           |
| **Space Complexity**  | **O(min(steps, arrLen))**             | Rolling array of size maxPos+1                 |

**Optimal** — best possible given constraints.

---

## Why This Works — Example Walkthrough

**Example 1**: `steps=3`, `arrLen=2`

- Valid positions: 0 and 1
- After 3 steps, ways to return to 0:
  - Right-Left-Stay
  - Stay-Right-Left
  - Right-Stay-Left
  - Stay-Stay-Stay
- Total: **4** → **correct**

**Example 2**: `steps=2`, `arrLen=4`

- Valid ways to return to 0:
  - Right-Left
  - Stay-Stay
- Total: **2** → **correct**

The DP correctly counts all sequences of left/right/stay moves that bring the pointer back to position 0.

---

## Pitfalls & Edge Cases

- **arrLen=1** → only stay possible → returns **1**
- **steps=0** → 1 way (do nothing) — code handles correctly
- **Large arrLen** → automatically bounded by `steps` → no wasted space/time
- **Modulo** → applied at each addition → prevents overflow
- **steps >> arrLen** → still efficient due to position bounding

All handled perfectly.

---

## Key Takeaway

This is a **beautifully optimized** bounded DP:

- **Effective positions** ≤ steps → prunes unreachable far positions
- **Rolling array** → minimal space usage
- **Three transitions** (left/right/stay) → complete movement model

**Pure, clean, optimal** — perfect counting of ways to return to origin.

---

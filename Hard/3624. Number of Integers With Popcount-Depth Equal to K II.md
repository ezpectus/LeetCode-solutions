# ğŸ§  3624. Number of Integers With Popcount-Depth Equal to K II

## ğŸ“œ Problem Restatement
We are given an array `nums` and queries of two types:
- `[1, l, r, k]`: count how many indices `j` in `[l, r]` have popcount-depth equal to `k`.
- `[2, idx, val]`: update `nums[idx] = val`.

The **popcount-depth** of `x` is the number of steps until repeated popcount reaches `1`.

---

## ğŸ§± Core Idea
1. **Popcount-depth computation**  
   - For each number, repeatedly compute `popcount` until reaching `1`.  
   - Depth is the number of steps.  
   - Since `nums[i] â‰¤ 10^15`, binary length â‰¤ 50 â†’ depth â‰¤ 5 (given constraint).

2. **Data structure for queries**  
   - We need efficient range queries and point updates.  
   - Use **Fenwick Tree (BIT)** or **Segment Tree**.  
   - Maintain 6 Fenwick Trees (for k = 0..5).  
     - Each tree stores counts of numbers with depth = k.  
   - Query `[1, l, r, k]` â†’ range sum on Fenwick[k].  
   - Update `[2, idx, val]` â†’ recompute depth, update Fenwick trees.

---

## ğŸš€ Implementation (C#)

```csharp
public class Solution {
    private const int MAXK = 6; // depths 0..5
    private int n;
    private long[] nums;
    private Fenwick[] trees;

    public int[] PopcountDepth(long[] nums, long[][] queries) {
        this.n = nums.Length;
        this.nums = nums;
        trees = new Fenwick[MAXK];
        for (int i = 0; i < MAXK; i++) trees[i] = new Fenwick(n);

        // initialize
        for (int i = 0; i < n; i++) {
            int d = Depth(nums[i]);
            trees[d].Add(i+1, 1); // Fenwick is 1-indexed
        }

        List<int> ans = new List<int>();
        foreach (var q in queries) {
            if (q[0] == 1) {
                int l = (int)q[1], r = (int)q[2], k = (int)q[3];
                int res = trees[k].Sum(r+1) - trees[k].Sum(l);
                ans.Add(res);
            } else {
                int idx = (int)q[1];
                long val = q[2];
                int oldDepth = Depth(nums[idx]);
                trees[oldDepth].Add(idx+1, -1);
                nums[idx] = val;
                int newDepth = Depth(val);
                trees[newDepth].Add(idx+1, 1);
            }
        }
        return ans.ToArray();
    }

    private int Depth(long x) {
        int d = 0;
        while (x > 1) {
            x = Popcount(x);
            d++;
        }
        return d;
    }

    private int Popcount(long x) {
        int cnt = 0;
        while (x > 0) {
            cnt += (int)(x & 1);
            x >>= 1;
        }
        return cnt;
    }

    class Fenwick {
        private int[] bit;
        private int n;
        public Fenwick(int n) {
            this.n = n;
            bit = new int[n+1];
        }
        public void Add(int idx, int delta) {
            for (; idx <= n; idx += idx & -idx) bit[idx] += delta;
        }
        public int Sum(int idx) {
            int res = 0;
            for (; idx > 0; idx -= idx & -idx) res += bit[idx];
            return res;
        }
    }
}
```

## â±ï¸ Complexity
- **Popcount-depth computation:** O(log n) per number (â‰¤ 50 bits â†’ â‰¤ 5 steps)  
- **Update:** O(log n)  
- **Query:** O(log n)  
- **Overall:** O((n + q) log n)  
- **Space:** O(n * MAXK)  

---

## âš ï¸ Pitfalls
- Fenwick tree is **1-indexed** â†’ adjust indices carefully  
- Must **remove old depth** before adding new depth on update  
- Depth â‰¤ 5 guaranteed â†’ safe to preallocate 6 trees  
- Popcount must handle up to **10^15** â†’ use `long`  

---

## âœ… Sanity Checks
- Example 1: `nums = [2,4]`, queries = `[[1,0,1,1],[2,1,1],[1,0,1,0]]` â†’ Output **[2,1]**  
- Example 2: `nums = [3,5,6]`, queries = `[[1,0,2,2],[2,1,4],[1,1,2,1],[1,0,1,0]]` â†’ Output **[3,1,0]**  
- Example 3: `nums = [1,2]`, queries = `[[1,0,1,1],[2,0,3],[1,0,0,1],[1,0,0,2]]` â†’ Output **[1,0,1]**  

---

ğŸ‘‰ **Key takeaway:**  
Maintain **Fenwick Trees per depth**. Each update recomputes depth and adjusts counts.  
Each query is a **range sum**. This yields an elegant **O(log n)** solution for both updates and queries.



---

# 1766. Tree of Coprimes

---

## Problem Summary
We are given a tree with `n` nodes (`0..n-1`) and values `nums[i]` for each node.  
- A node’s **ancestor** is any node on the path from it to the root (node 0).  
- Two values are **coprime** if `gcd(x, y) == 1`.  
- For each node `i`, we must find the **closest ancestor** whose value is coprime with `nums[i]`.  
- If no such ancestor exists, return `-1`.  

---

## Core Idea
- Perform a **DFS traversal** starting from the root.  
- Maintain a mapping of **value → closest ancestor index** along the path.  
- For each node:  
  - Check all possible values (1..50) for coprimality with `nums[i]`.  
  - If coprime, record the closest ancestor index from the mapping.  
- Update mapping with current node’s value before recursing into children.  
- Backtrack after recursion to restore state.  

Since `nums[i] ≤ 50`, we can precompute coprimality between all pairs of values (1..50).  

---

## Precomputation
- Build a `coprime[51][51]` table where `coprime[a][b] = true` if `gcd(a, b) == 1`.  
- This allows O(1) coprime checks during DFS.  

---

## C++ Implementation
```cpp
class Solution {
public:
    vector<int> getCoprimes(vector<int>& nums, vector<vector<int>>& edges) {
        int n = nums.size();
        vector<vector<int>> adj(n);
        for (auto &e : edges) {
            adj[e[0]].push_back(e[1]);
            adj[e[1]].push_back(e[0]);
        }
        
        // Precompute coprime table
        vector<vector<bool>> coprime(51, vector<bool>(51, false));
        for (int i = 1; i <= 50; i++) {
            for (int j = 1; j <= 50; j++) {
                coprime[i][j] = (__gcd(i, j) == 1);
            }
        }
        
        vector<int> ans(n, -1);
        // For each value (1..50), store the closest ancestor index
        vector<pair<int,int>> ancestor(51, {-1, -1}); 
        // {node index, depth}
        
        function<void(int,int,int)> dfs = [&](int node, int parent, int depth) {
            int val = nums[node];
            int best = -1, bestDepth = -1;
            
            // Check coprime ancestors
            for (int v = 1; v <= 50; v++) {
                if (coprime[val][v] && ancestor[v].first != -1) {
                    if (ancestor[v].second > bestDepth) {
                        bestDepth = ancestor[v].second;
                        best = ancestor[v].first;
                    }
                }
            }
            ans[node] = best;
            
            // Save current state
            auto prev = ancestor[val];
            ancestor[val] = {node, depth};
            
            for (int nei : adj[node]) {
                if (nei == parent) continue;
                dfs(nei, node, depth + 1);
            }
            
            // Restore state (backtrack)
            ancestor[val] = prev;
        };
        
        dfs(0, -1, 0);
        return ans;
    }
};
```



## Complexity
- **Time:**  
  - Precomputation: O(50²) for building the coprime lookup table.  
  - DFS traversal: O(n × 50) in the worst case (checking coprime ancestors for each node).  
  - Overall: O(n × 50) ≈ O(n), efficient for n ≤ 1e5.  

- **Space:**  
  - O(n) for adjacency list and recursion stack.  
  - O(50²) for coprime table.  
  - O(50) for ancestor tracking.  
  - Total: O(n + 50).  

---

## Pitfalls
- Must **backtrack ancestor state** after DFS to avoid incorrect propagation when returning from recursion.  
- Ensure **root has no ancestor** → `ans[0] = -1`.  
- Precompute coprime pairs to avoid repeated gcd calls during traversal.  
- Large n (up to 1e5) requires efficient O(n) traversal and careful memory management.  
- Depth tracking is essential to ensure we select the **closest ancestor**.  

---

## Example Walkthrough
**Input:**  
`nums = [2,3,3,2]`  
`edges = [[0,1],[1,2],[1,3]]`  

**Steps:**  
- Node 0: root → no ancestor → `-1`.  
- Node 1: ancestor {0}, gcd(2,3)=1 → closest ancestor = `0`.  
- Node 2: ancestors {1,0}, gcd(3,3)=3 (not coprime), gcd(2,3)=1 → closest ancestor = `0`.  
- Node 3: ancestors {1,0}, gcd(3,2)=1 → closest ancestor = `1`.  

**Output:**  
`[-1,0,0,1]`  

---

## Conclusion
The problem reduces to a **DFS traversal with ancestor tracking** and **coprime precomputation**.  
- Runs in **O(n × 50)** time, efficient for large trees.  
- Ensures correct closest ancestor selection via depth tracking.  
- Clean, efficient, and optimal solution for tree coprime queries.  

---

## Key Insights
- Precomputing coprime pairs (1..50) drastically reduces runtime.  
- Ancestor tracking with `{node, depth}` ensures we always pick the closest valid ancestor.  
- Backtracking restores state after recursion, preventing contamination of ancestor data.  
- The algorithm leverages the small bound on `nums[i]` (≤ 50) to achieve efficiency even for large n.  


---



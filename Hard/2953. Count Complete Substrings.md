# Pattern Name  
Segmented Window Scan with Frequency Constraint Validation

---

## Problem Summary

You are given a string `word` and an integer `k`.  
A substring is considered **complete** if:

- Every character in the substring appears **exactly `k` times**
- The absolute difference between any two adjacent characters is at most 2

Return the total number of complete substrings in `word`.

---

## Core Idea

This is a **substring frequency validation** problem under two constraints:

1. **Character frequency constraint**: each character must appear exactly `k` times
2. **Adjacency constraint**: adjacent characters must differ by at most 2 in ASCII

Instead of checking all substrings, we first **segment the string** into valid blocks where the adjacency constraint holds.  
Then, within each segment, we slide windows of size `k`, `2k`, ..., `26k` and validate frequency counts.

---

## Constraint Formula

Let `windowSize = uniqueCount × k`  
A substring of length `windowSize` is complete if:

- Only `uniqueCount` characters are present
- Each of those characters appears exactly `k` times
- No other characters are present

This is validated using a frequency array of size 26.

---

## Strategy Summary

1. Traverse the string and split it into segments where adjacent characters differ by ≤ 2
2. For each segment, try all window sizes that are multiples of `k` (up to `26k`)
3. For each window, maintain a frequency array of 26 letters
4. Slide the window and update frequencies incrementally
5. For each window, check if all non-zero frequencies equal `k`
6. Count and return the number of valid windows

This avoids brute-force substring enumeration and leverages structural constraints to prune the search space.

---

## C# Implementation

```csharp
public class Solution {
    public int CountCompleteSubstrings(string word, int k) {
        int res = 0;
        int n = word.Length;
        int i = 0;

        while (i < n) {
            int j = i;
            while (j + 1 < n && Math.Abs(word[j + 1] - word[j]) <= 2) {
                j++;
            }

            res += CountInSegment(word, i, j, k);
            i = j + 1;
        }

        return res;
    }

    private int CountInSegment(string s, int l, int r, int k) {
        int res = 0;
        int len = r - l + 1;

        for (int unique = 1; unique <= 26; unique++) {
            int window = unique * k;
            if (window > len) break;

            int[] freq = new int[26];

            for (int i = 0; i < window; i++) {
                int idx = s[l + i] - 'a';
                freq[idx]++;
            }
            if (IsComplete(freq, k)) res++;

            for (int i = l + window; i <= r; i++) {
                int add = s[i] - 'a';
                int remove = s[i - window] - 'a';
                freq[add]++;
                freq[remove]--;
                if (IsComplete(freq, k)) res++;
            }
        }

        return res;
    }

    private bool IsComplete(int[] freq, int k) {
        foreach (int f in freq) {
            if (f == 0) continue;
            if (f != k) return false;
        }
        return true;
    }
}
```

## Time and Space Complexity

| Metric           | Value        | Explanation                                      |
|------------------|--------------|--------------------------------------------------|
| Time Complexity  | O(26 × n)    | Segment scan + bounded window checks            |
| Space Complexity | O(1)         | Fixed-size frequency array (26 letters)         |

---

## Generalization to Other Problems

This pattern applies to problems where:

- You need to validate substrings under **frequency constraints**
- You want to avoid brute-force by **segmenting input**
- You can **slide windows** and update state incrementally
- The validation logic is **local and bounded**

---

## Examples of Similar Problems

| Problem Type                | Description                                         |
|----------------------------|-----------------------------------------------------|
| Fixed Frequency Substrings | Count substrings where each character appears k times  
| Valid Anagram Windows      | Find windows that match a target frequency map  
| Character Distribution Check | Validate uniform character spread in substrings  

---

## Final Takeaway

This solution uses:

- **Segmentation** to isolate valid regions  
- **Window sliding** to explore candidate substrings  
- **Frequency modeling** to validate constraints  
- **Incremental updates** to avoid recomputation

The result is a clean and efficient solution that avoids brute-force and leverages structural constraints.  
This pattern is reusable for any task involving **substring validation under frequency and adjacency rules**.



---

# 828. Count Unique Characters of All Substrings of a Given String — Architectural Contribution per Character  
*O(n) — Optimal Linear Pass with Last Seen Tracking*

---

## Problem Statement

- Given string `s` (1 ≤ n ≤ 10⁵, uppercase letters).

For every substring `t` of `s`:
- `countUniqueChars(t)` = number of characters that appear **exactly once** in `t`

- Return **sum** of `countUniqueChars(t)` over **all substrings** `t`.
- Answer fits in 32-bit int.

---

## Core Idea — Contribution of Each Character Occurrence

**Key insight**:
- Instead of checking every substring (O(n²))
- For each occurrence of a character → calculate **how many substrings** it contributes **+1** to (i.e., where it is **unique**)

**For each position `i` with char `c`**:
- Find **left boundary** L = last previous occurrence of `c` (or -1)
- Find **right boundary** R = next occurrence of `c` (or n)
- In substrings that **start** in `[L+1, i]` and **end** in `[i, R-1]`:
  - This `c` at i is **unique** → contributes +1
- Number of such substrings = `(i - L) * (R - i)`

Sum over all positions → answer.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int UniqueLetterString(string s) {
        int n = s.Length;
        var lastSeen = new Dictionary<char, int>();
        var nextSeen = new int[n];

        // Precompute next occurrence for each position
        var nextOcc = new Dictionary<char, int>();
        for (int i = n - 1; i >= 0; i--) {
            char c = s[i];
            nextSeen[i] = nextOcc.GetValueOrDefault(c, n);
            nextOcc[c] = i;
        }

        long res = 0;
        int prev = -1;

        for (int i = 0; i < n; i++) {
            char c = s[i];

            // Left: previous occurrence (or -1)
            prev = lastSeen.GetValueOrDefault(c, -1);

            // Right: next occurrence (or n)
            int next = nextSeen[i];

            // Contribution: (i - prev) * (next - i)
            res += (i - prev) * (next - i);
            lastSeen[c] = i;
        }

        return (int)res;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Two passes + dictionary operations (26 keys)   |
| **Space Complexity**  | **O(1)**      | At most 26 characters → bounded                |

---

## Why This Works — Example Walkthrough

**Input**: `s = "ABC"`

- n=3
- Positions: A(0), B(1), C(2)

For each occurrence:

- **A at 0**: previous = -1 → left distance = 1, next = 3 → right distance = 3 → contribution = 1 × 3 = **3**
- **B at 1**: previous = -1 → left = 2, next = 3 → right = 2 → contribution = 2 × 2 = **4**
- **C at 2**: previous = -1 → left = 3, next = 3 → right = 1 → contribution = 3 × 1 = **3**

Total = 3 + 4 + 3 = **10** → **correct**

**Input**: `s = "ABA"`

- Positions: A(0), B(1), A(2)

- **A at 0**: prev = -1 → left = 1, next = 2 → right = 2 → contrib = 1 × 2 = **2**
- **B at 1**: prev = -1 → left = 2, next = 3 → right = 2 → contrib = 2 × 2 = **4**
- **A at 2**: prev = 0 → left = 2-0 = 2, next = 3 → right = 1 → contrib = 2 × 1 = **2**

Total = 2 + 4 + 2 = **8** → **correct**

The formula `(i - prev) * (next - i)` counts exactly the substrings where this occurrence is **the only** one of its character.

---

## Pitfalls & Edge Cases

- **Repeated characters** → correctly limited by prev/next occurrences
- **All unique** → maximum contribution
- **All identical** → only first and last contribute meaningfully
- **n=1** → contribution = 1 × 1 = 1

All handled perfectly.

---

## Key Takeaway

This is a **beautifully elegant** contribution technique:

- **Per occurrence** → calculate its "unique range"
- **Left × Right** → number of substrings where it is the only instance of its character
- **O(n)** → no need to enumerate substrings
**Pure, clean, optimal** — perfect unique char counting across all substrings.

---

# 803. Bricks Falling When Hit — Architectural Reverse Union-Find + Connectivity to Top  
*O(mn + h log(mn)) — Optimal Backward Simulation*

---

## Problem Statement

Given a grid of bricks (`1`) and empty spaces (`0`), and a sequence of `hits`.

Each hit removes a brick (if exists).

After each hit, **unstable** bricks (not connected to top) fall.

Return array where `result[i]` = number of bricks that **fall** after i-th hit.

**Note**: bricks that fall are **immediately erased** — affect future stability.

---

## Core Idea — Simulate Hits Backward with Union-Find

**Forward simulation** hard:
- Removing a brick → need to check whole grid connectivity → slow

**Brilliant insight**: **simulate backward**!

1. **Start from final state** (all hits applied)
2. **Add back** bricks in **reverse order** of hits
3. Use **Union-Find** to track connectivity to **top**
4. When adding back a brick:
   - Count how many **new** bricks become connected to top
   - That count = number of bricks that **would have fallen** when this brick was hit

**Why backward**:
- Adding bricks → connectivity only **increases**
- Easy to track size of connected component to top

---

##  Implementation (C#)

```csharp
public class Solution {
    private int[] parent;
    private int[] size;
    private int m, n;

    public int[] HitBricks(int[][] grid, int[][] hits) {
        m = grid.Length;
        n = grid[0].Length;
        int totalCells = m * n;

        // Union-Find with virtual top node
        parent = new int[totalCells + 1];
        size = new int[totalCells + 1];
        for (int i = 0; i <= totalCells; i++) {
            parent[i] = i;
            size[i] = 1;
        }

        // Copy grid
        int[][] g = new int[m][];
        for (int i = 0; i < m; i++) 
            g[i] = grid[i].Clone() as int[];

        // Apply all hits first
        for (int i = 0; i < hits.Length; i++) {
            int x = hits[i][0], y = hits[i][1];
            if (g[x][y] == 1) 
                g[x][y] = 0; // mark as hit
        }

        // Build initial connected components (only stable bricks)
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (g[i][j] == 1)  UnionWithNeighbors(g, i, j); 
            }
        }

        // Process hits in reverse order
        int[] result = new int[hits.Length];
        int top = totalCells; // virtual top node
        int[][] dirs = { new[] {0,1}, new[] {0,-1}, new[] {1,0}, new[] {-1,0} };

        for (int i = hits.Length - 1; i >= 0; i--) {
            int x = hits[i][0], y = hits[i][1];

            if (grid[x][y] == 0) {
                result[i] = 0; // no brick to add back
                continue;
            }

            int before = size[Find(top)];
            g[x][y] = 1; // add brick back
            UnionWithNeighbors(g, x, y);

            int after = size[Find(top)];
            result[i] = Math.Max(0, after - before - 1); // -1 for the brick itself
        }

        return result;
    }

private void UnionWithNeighbors(int[][] g, int x, int y) {
        int id = x * n + y;
        int top = m * n;

        if (x == 0) Union(id, top); // connect to top if on first row

        int[][] dirs = { new[] {0,1}, new[] {0,-1}, new[] {1,0}, new[] {-1,0} };
        foreach (var d in dirs) {
            int nx = x + d[0];
            int ny = y + d[1];
            if (nx >= 0 && nx < m && ny >= 0 && ny < n && g[nx][ny] == 1)  Union(id, nx * n + ny);
            
        }
    }
private int Find(int x) {
        if (parent[x] != x) parent[x] = Find(parent[x]);
        return parent[x];
    }

private void Union(int x, int y) {
        int px = Find(x), py = Find(y);
        if (px == py) return;
        if (size[px] < size[py]) {
            parent[px] = py;
            size[py] += size[px];
        } 
        else {
            parent[py] = px;
            size[px] += size[py];
        }
    }
}
```


## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(mn + h α(mn))**   | α = inverse Ackermann ≈ constant                |
| **Space Complexity**  | **O(mn)**             | Union-Find arrays + grid copy                  |

**Near-optimal** — Union-Find with path compression.

---

## Why This Works

- **Backward simulation** → adding bricks **increases** connectivity  
  Forward would require expensive flood-fill after each removal

- **Union-Find with virtual top node** → tracks **stable** bricks efficiently  
  Only bricks connected to top are stable

- **Size tracking** → exact count of **newly stabilized** bricks when adding back  
  `after - before - 1` = bricks that **would have fallen** when this brick was hit

- **Reverse order** → `result[i]` = bricks that fell **because of** hit `i`

**No forward flood fill** — avoids O(mn) per hit.

---

## Key Takeaway

This is a **masterpiece of reverse simulation + Union-Find**:

- **Backward thinking** turns hard problem into easy
- **Union-Find** for dynamic connectivity
- **Virtual top node** → elegant stability tracking

**One of the most powerful patterns** for dynamic grid connectivity problems.

Reusable in:
- Falling objects / collapsing structures
- Dynamic percolation
- Connectivity after removal/addition sequences

**Clean, clever, optimal.**

---

# 732. My Calendar III

---

## Problem
We need to design a calendar that supports booking events.  
- Each booking is an interval `[startTime, endTime)`.  
- After each booking, return the maximum number of overlapping events (the maximum k-booking).  

Constraints:  
- `0 <= startTime < endTime <= 1e9`  
- At most 400 calls to `book`.  

---

## Key Idea
This is a **sweep line problem**:
- Each booking adds `+1` at `startTime` and `-1` at `endTime`.  
- If we keep track of all changes and compute the running sum, the maximum sum at any point is the maximum overlap.  

Since there are at most 400 bookings, we can afford to store all changes in a map and scan through them each time.

---

## Algorithm
1. Use a `SortedDictionary<int, int>` (or `SortedList`) to store time → delta changes.  
   - At `startTime`, add `+1`.  
   - At `endTime`, add `-1`.  
2. After each booking, iterate through the map in order:  
   - Maintain a running sum of active events.  
   - Track the maximum overlap.  
3. Return the maximum overlap after each booking.

---

## Code (C#)
```csharp
public class MyCalendarThree {
    private SortedDictionary<int, int> timeline;
    private int maxBooking;

    public MyCalendarThree() {
        timeline = new SortedDictionary<int, int>();
        maxBooking = 0;
    }
    
    public int Book(int startTime, int endTime) {
        if (!timeline.ContainsKey(startTime)) timeline[startTime] = 0;
        if (!timeline.ContainsKey(endTime)) timeline[endTime] = 0;

        timeline[startTime] += 1;
        timeline[endTime] -= 1;

        int active = 0;
        foreach (var kv in timeline) {
            active += kv.Value;
            maxBooking = Math.Max(maxBooking, active);
        }

        return maxBooking;
    }
}
```


## Complexity
- **Time:** O(m log m) per booking, where `m` is the number of distinct time points. With ≤ 400 bookings, this is efficient enough.  
- **Space:** O(m) for the timeline map.  

---

## Pitfalls
- Must use an **ordered structure** (`SortedDictionary`) to process times in ascending order.  
- Ensure to update both **start** and **end** points for each booking.  
- Keep track of the **global maximum overlap** across all bookings.  

---

## Example Walkthrough
**Input:**
```
["MyCalendarThree", "book", "book", "book", "book", "book", "book"]
[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]
```

Step by step:
- Book(10,20) → max overlap = 1  
- Book(50,60) → max overlap = 1  
- Book(10,40) → overlap between [10,20] and [10,40] = 2  
- Book(5,15) → overlap among [5,15], [10,20], [10,40] = 3  
- Book(5,10) → still max = 3  
- Book(25,55) → overlaps with [10,40] and [50,60], max remains 3  

**Output:**  
```[null, 1, 1, 2, 3, 3, 3]```

---

## Conclusion
This problem is solved using a **sweep line with prefix sum of event changes**.  
- Efficient enough for ≤ 400 bookings.  
- Dynamically tracks the maximum overlap after each booking.  

---


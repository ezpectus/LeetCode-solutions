# 🧠 LeetCode 2421 — Number of Good Paths  
**Category:** Graph / Union-Find / Value-Constrained Grouping  
**Difficulty:** Hard  
**Language:** C#  
**Pattern:** Value-Constrained Union-Find on Trees

---

## 💡 Problem Summary

You're given a tree with `n` nodes and an array `vals`, where `vals[i]` is the value of node `i`.  
A **good path** is a simple path where:
- The start and end nodes have the same value  
- All intermediate nodes have values **≤ start node's value**  
- Paths are undirected and counted once (i.e. `0→1` is same as `1→0`)  
- A single node is also a valid good path

Return the total number of distinct good paths.

---

## 🧠 My Architectural Insight

This is a **value-constrained connectivity** problem on a tree.  
Key observations:
- Tree = no cycles → safe to merge components  
- Good path = same value endpoints + all intermediates ≤ value  
- So we process nodes **in increasing order of value**, and use **Union-Find** to merge components

For each value:
- Merge neighbors with `val ≤ current`  
- Count how many nodes with current `val` exist in each component  
- Add `count * (count - 1) / 2` good paths  
- Add `n` for single-node paths

---

## 🔧 My C# Implementation

```csharp
public class Solution {
    public int NumberOfGoodPaths(int[] vals, int[][] edges) {
        int n = vals.Length;
        var adj = new List<int>[n];
        for (int i = 0; i < n; i++) adj[i] = new List<int>();
        foreach (var e in edges) {
            adj[e[0]].Add(e[1]);
            adj[e[1]].Add(e[0]);
        }

        var nodesByVal = new SortedDictionary<int, List<int>>();
        for (int i = 0; i < n; i++) {
            if (!nodesByVal.ContainsKey(vals[i]))
                nodesByVal[vals[i]] = new List<int>();
            nodesByVal[vals[i]].Add(i);
        }

        var uf = new UnionFind(n);
        int res = 0;

        foreach (var kvp in nodesByVal) {
            int val = kvp.Key;
            var nodes = kvp.Value;

            foreach (int node in nodes) {
                foreach (int nei in adj[node]) {
                    if (vals[nei] <= val)
                        uf.Union(node, nei);
                }
            }

            var count = new Dictionary<int, int>();
            foreach (int node in nodes) {
                int root = uf.Find(node);
                if (!count.ContainsKey(root))
                    count[root] = 0;
                count[root]++;
            }

            foreach (var c in count.Values)
                res += c * (c - 1) / 2;
        }

        return res + n;
    }

    class UnionFind {
        private int[] parent;

        public UnionFind(int n) {
            parent = Enumerable.Range(0, n).ToArray();
        }

        public int Find(int x) {
            if (parent[x] != x)
                parent[x] = Find(parent[x]);
            return parent[x];
        }

        public void Union(int x, int y) {
            int px = Find(x), py = Find(y);
            if (px != py)
                parent[py] = px;
        }
    }
}
```
---

## 🧩 Architectural Breakdown

| Component         | Role                                                                 |
|------------------|----------------------------------------------------------------------|
| `adj`            | Builds adjacency list for the tree                                   |
| `nodesByVal`     | Groups nodes by their value                                          |
| `UnionFind`      | Tracks connected components                                          |
| `count[root]`    | Counts nodes with current value in each component                    |
| `res += c*(c-1)/2` | Adds number of good paths between same-value nodes                  |
| `+n`             | Accounts for single-node good paths                                  |

---

## 🔍 Why My Approach Is Superior

| Aspect               | My Approach                          | Alternative Approach                     |
|----------------------|--------------------------------------|------------------------------------------|
| Graph Type           | Tree → safe merges                   | General graph → cycle handling needed    |
| Processing Order     | Sorted by value                      | Random traversal                         |
| Connectivity Logic   | Union-Find with value constraints    | DFS/BFS with manual checks               |
| Path Counting        | Combinatorics per component          | Explicit path enumeration                |
| Performance          | Near-linear due to UF and sorting    | Slower due to nested traversal           |
| Memory Usage         | Compact structures                   | Heavier with visited sets, recursion     |
| Code Clarity         | Modular and phase-based              | Mixed logic and traversal                |
| Conceptual Ownership | Fully derived from architectural insight | Implementation driven by surface logic |



## ✅ Summary

This task isn’t about paths — it’s about **value-constrained merging**.  
Once I saw that, the rest was just system-building:

- Sort nodes by value  
- Merge neighbors with `val ≤ current`  
- Count nodes with current value per component  
- Apply combinatorics  
- Add single-node paths

No brute-force, no DFS, no wasted cycles.  
Just clean architecture and minimal logic.

This module now lives in my repo as a reusable pattern:  
> **Value-Constrained Union-Find on Trees**

---


---

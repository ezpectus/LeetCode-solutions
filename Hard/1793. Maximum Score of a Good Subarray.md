# 1793. Maximum Score of a Good Subarray

## Problem

You are given an array of integers `nums` and an integer `k`.  
A subarray `(i, j)` is considered **good** if `i <= k <= j`.  
The score of a subarray is defined as:
```
min(nums[i..j]) * (j - i + 1)
```

Return the maximum possible score of any good subarray.

## Core Insight

This is not a dynamic programming problem, nor a classic sliding window.  
It is a **greedy two-pointer expansion** centered around index `k`.

You start with the smallest possible good subarray `[k, k]`, and expand outward.  
At each step, you choose to expand left or right — whichever side has the higher value — to keep the minimum as high as possible.  
You maintain the current minimum and compute the score at each step.

## Architectural Triggers

- “i <= k <= j” → You must expand outward from `k`, not scan the whole array
- “min(nums[i..j]) * length” → You must track the minimum value dynamically
- “Return the maximum score” → You must evaluate all valid expansions
- “Constraints: up to 10^5 elements” → You must avoid brute-force scanning or nested loops

## What This Implies

- Start with `left = k`, `right = k`
- Track `minVal = nums[k]`
- Expand outward one step at a time:
  - If both sides are available, expand toward the higher value
  - Update `minVal = min(minVal, nums[left], nums[right])`
  - Compute `score = minVal * (right - left + 1)`
  - Track the maximum score seen so far
- Stop when both ends reach array boundaries

## Code

```csharp
public class Solution {
    public int MaximumScore(int[] nums, int k) {
        int n = nums.Length;
        int left = k, right = k;
        int minVal = nums[k];
        int maxScore = minVal;

        while (left > 0 || right < n - 1) {
            if (left == 0) {
                right++;
            } else if (right == n - 1) {
                left--;
            } else if (nums[left - 1] > nums[right + 1]) {
                left--;
            } else {
                right++;
            }

            minVal = Math.Min(minVal, Math.Min(nums[left], nums[right]));
            maxScore = Math.Max(maxScore, minVal * (right - left + 1));
        }

        return maxScore;
    }
}
```

## Complexity

- **Time:** `O(n)`  
  - Each index is visited at most once during expansion
  - Constant-time updates per step

- **Space:** `O(1)`  
  - Only pointers and scalar values are used

## Pitfalls

- **Incorrect expansion logic:**  
  - Expanding toward the smaller value causes `minVal` to drop too fast
  - Always expand toward the higher value to preserve score

- **Off-by-one errors:**  
  - Be careful with array bounds when checking `left - 1` and `right + 1`

- **Not updating `minVal` correctly:**  
  - Must take `min(minVal, nums[left], nums[right])` after each expansion

## Insight

This is a greedy expansion problem centered around a fixed index.  
You control the mutation of the interval to maximize the score, balancing width and minimum value.  
The key is to expand intelligently — not blindly — and to preserve the highest possible minimum for as long as possible.  
This pattern generalizes to problems where a fixed point must be included and the score depends on both range and value.



---

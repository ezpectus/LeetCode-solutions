# 972.Equal Rational Numbers — Architectural Solution

## Problem Statement

Given two strings `s` and `t` representing **non-negative rational numbers** in one of three forms:

- Integer: `"123"`, `"0"`
- Finite decimal: `"0.5"`, `"1."`, `"2.345"`
- Repeating decimal: `"0.1(6)"`, `"1.(9)"`, `"123.00(1212)"`

The repeating part in parentheses repeats **infinitely**.

Return `true` **iff** `s` and `t` represent the **same real number**.

---

## Constraints

- Integer part: **1–4** digits (no leading zeros except `"0"`)
- Non-repeating part: **0–4** digits
- Repeating part: **1–4** digits
- Only digits, `.`, `(`, `)`

---

## Core Idea — Convert to Reduced Fraction

All representations are **rational numbers** → can be written as `num/den`.

Two rationals are equal **iff** their **reduced fractions** are identical.

**No floating-point errors. No simulation. Pure math.**

---

## Approach — Parse → Exact Rational → Reduce → Compare

- 1. **Parse** each string into three parts:
   - `integerPart`
   - `nonRepeating`
   - `repeating`

- 2. **Convert** to `(numerator, denominator)` using exact formulas
- 3. **Reduce** using GCD
- 4. **Compare** both reduced fractions



### Exact Conversion Formula

Let:
- `A` = integer part (as integer)
- `B` = non-repeating part (as integer, 0 if empty)
- `C` = repeating part (as integer)
- `k` = length of `B`
- `m` = length of `C`

Then:
```
numerator   = A × (10ᵏ × (10ᵐ − 1)) + B × (10ᵐ − 1) + C
denominator = 10ᵏ × (10ᵐ − 1)
```
Special cases:
- No decimal → `num = A`, `den = 1`
- No repeating → `num = A × 10ᵏ + B`, `den = 10ᵏ`
- Empty non-repeating → `k = 0`, `10ᵏ = 1` → formula still works

All values fit in **64-bit integers**.

---

## Implementation (C#)

```csharp
public class Solution 
{
    public bool IsRationalEqual(string s, string t) 
    {
        (long num1, long den1) = ToFraction(ParseParts(s));
        (long num2, long den2) = ToFraction(ParseParts(t));
        return num1 == num2 && den1 == den2;
    }

    private (string integerPart, string nonRep, string rep) ParseParts(string s) 
    {
        string integerPart;
        string nonRep = "";
        string rep = "";
        int dotIndex = s.IndexOf('.');
        int parenIndex = s.IndexOf('(');
        if (dotIndex == -1) 
        { 
            // No decimal point: integer only
            integerPart = s;
        } 
        else 
        {
            integerPart = s.Substring(0, dotIndex);
            if (parenIndex == -1) 
            { 
                // Decimal, no repeating
                nonRep = s.Substring(dotIndex + 1);
            } 
            else 
            { 
                // Decimal with repeating
                nonRep = s.Substring(dotIndex + 1, parenIndex - dotIndex - 1);
                rep = s.Substring(parenIndex + 1, s.Length - parenIndex - 2); // exclude ")"
            }
        }
        return (integerPart, nonRep, rep);
    }

    private (long, long) ToFraction((string integerPart, string nonRep, string rep) parts) 
    {
        string integerPart = parts.integerPart;
        string nonRep = parts.nonRep;
        string rep = parts.rep;
        long A = string.IsNullOrEmpty(integerPart) ? 0 : long.Parse(integerPart);
        if (string.IsNullOrEmpty(nonRep) && string.IsNullOrEmpty(rep)) 
        { 
            // Pure integer
            return (A, 1);
        }
        int k = nonRep.Length;
        long pow10k = Pow10(k);
        if (string.IsNullOrEmpty(rep)) 
        { 
            // No repeating: A.nonRep
            long B = string.IsNullOrEmpty(nonRep) ? 0 : long.Parse(nonRep);
            long num = A * pow10k + B;
            long den = pow10k;
            long g = Gcd(num, den);
            return (num / g, den / g);
        } 
        else 
        { 
            // Has repeating
            int m = rep.Length;
            long pow10m = Pow10(m);
            long B = string.IsNullOrEmpty(nonRep) ? 0 : long.Parse(nonRep);
            long C = long.Parse(rep);
            // numerator and denominator based on:
            // value = A + B/10^k + C / (10^k * (10^m - 1))
            // common denominator: 10^k * (10^m - 1)
            long den = pow10k * (pow10m - 1);
            long num = A * den + B * (pow10m - 1) + C;
            long g2 = Gcd(num, den);
            return (num / g2, den / g2);
        }
    }

    private long Pow10(int exp) 
    {
        long res = 1;
        for (int i = 0; i < exp; i++) res *= 10;
        return res;
    }

    private long Gcd(long a, long b) 
    {
        while (b != 0) 
        {
            long t = a % b;
            a = b;
            b = t;
        }
        return a < 0 ? -a : a;
    }
}
```

## Complexity Analysis

- **Parsing each string** is **O(L)**, where `L ≤ ~10` (integer + decimal + parentheses).
- **Fraction conversion** uses **constant-time** operations with fixed small exponents.
- **GCD** is **O(log(max(num, den)))** but numbers stay within safe 64-bit bounds.
- **Overall**:
  - **Time**: **O(1)** per comparison under given constraints.
  - **Space**: **O(1)**

**True O(1)** — mathematically perfect.

---

## Pitfalls & Edge Cases

- **`0.(9)` vs `1.`** → Handled automatically — both normalize to the same rational number
- **Missing non-repeating part but with decimal**, like `"1."` → Parsed as integer only → correctly treated as integer
- **Empty nonRepeating** (e.g. `"1.(9)"`) → `nonRep = ""`, `rep = "9"` → formula works with `k = 0`, `pow10k = 1`
- **Multiple equivalent representations** like:
  - `"0.(52)"` vs `"0.5(25)"` → **Normalization via rational form removes representation ambiguity**

---

## Conclusion

The **architectural insight** is to **normalize all representations down to exact rational fractions** (`numerator`, `denominator`), then compare those **canonical forms**.
Instead of simulating decimals (and dealing with floating-point errors), we **lean on number theory and careful parsing**, exploiting tiny length constraints to keep everything **simple, exact, and efficient**.
**One of the cleanest, most mathematically elegant solutions on LeetCode.**

---

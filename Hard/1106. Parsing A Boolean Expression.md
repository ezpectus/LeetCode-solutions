# 1106. Parsing A Boolean Expression — Architectural Iterative Subexpression Reduction  
*O(n²) worst-case — Optimal String Replacement Simplification*

## Problem Statement


You are given a **valid** boolean expression as a string, containing only the following characters:

- `'t'` — represents **true**
- `'f'` — represents **false**
- `'!'` — logical **NOT** (unary operator)
- `'&'` — logical **AND** (multi-argument)
- `'|'` — logical **OR** (multi-argument)
- `'('`, `')'` — parentheses for grouping
- `','` — separator between arguments in `&` and `|`

The expression follows these forms:

- `'t'` or `'f'` — base values
- `'!(subExpr)'` — NOT of a single subexpression
- `'&(subExpr1,subExpr2,...,subExprN)'` — AND of one or more subexpressions
- `'|(subExpr1,subExpr2,...,subExprN)'` — OR of one or more subexpressions

**Task**: Evaluate the expression and return `true` if it evaluates to true, `false` otherwise.

**Important**:
- The expression is **guaranteed to be valid** — no need for error checking or parentheses balancing.
- Length up to 2×10⁴ → efficient solution required.
- Nested expressions allowed.

---

## Core Idea - Iterative Inner-Most Subexpression Evaluation

**The most important part — how and why it works**

**Key observation**:
- Since the expression is valid, every subexpression `op(...)` is properly closed.
- The **rightmost** operator (`!`, `&`, or `|`) that is **not inside** deeper parentheses always belongs to the **innermost** (deepest) subexpression.
- This means we can safely evaluate the **rightmost** complete subexpression first — it's guaranteed not to depend on unevaluated outer parts.

**Algorithm step by step**:
1. While the expression has more than one character:
   - Find the **rightmost** occurrence of an operator (`!`, `&`, or `|`) — this is the operator of the innermost subexpression.
   - Find the **matching closing parenthesis** `)` to the right of this operator.
   - Extract the full subexpression: `op(...)`
   - Evaluate this subexpression:
     - Extract operator and inner content
     - For `'!'` — invert the single inner value
     - For `'&'` — result is `'f'` if any inner value is `'f'`, else `'t'`
     - For `'|'` — result is `'t'` if any inner value is `'t'`, else `'f'`
   - Replace the entire subexpression with its result (`'t'` or `'f'`)
2. When only one character remains — that's the final result.

**Why this works**:
- We always reduce the deepest subexpression first (bottom-up evaluation).
- Replacement shrinks the string → eventually reaches single `'t'` or `'f'`.
- No recursion needed — pure iterative string manipulation.
- Correctness guaranteed by input validity.

**Advantages**:
- Simple to implement and debug.
- No stack or recursion depth issues.
- Naturally handles arbitrary nesting.

---

##  Implementation (C++)

```cpp
class Solution {
public:
    bool parseBoolExpr(string expression) {
        // Repeatedly simplify the expression by evaluating subexpressions
        while (expression.length() > 1) {
            int start = expression.find_last_of("!&|");
            int end = expression.find(')', start);
            string subExpr = expression.substr(start, end - start + 1);
            char result = evaluateSubExpr(subExpr);
            expression.replace(start, end - start + 1, 1,
                               result);  // Replace with evaluated result
        }
        return expression[0] == 't';
    }

private:
    char evaluateSubExpr(const string& subExpr) {
        // Extract the operator and the enclosed values
        char op = subExpr[0];
        string values = subExpr.substr(2, subExpr.length() - 3);

        // Apply logical operations based on the operator
        if (op == '!') return values[0] == 't' ? 'f' : 't';
        if (op == '&') return values.find('f') != string::npos ? 'f' : 't';
        if (op == '|') return values.find('t') != string::npos ? 't' : 'f';

        return 'f';  // This point should never be reached
    }
};

```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n²)** worst-case  | String `find` + `replace` operations           |
| **Space Complexity**  | **O(n)**              | String modifications (C++ string is mutable)    |

**Practical** — n ≤ 2×10⁴ → operations acceptable (real-world fast).

---

## Why This Works - Example Walkthrough

**Input**: `"!(&(f,t))"`

- **Step 1**: find rightmost operator → `&` at position of `&`
  - subexpr = `"&(f,t)"`
  - values = `"f,t"` → contains `'f'` → result = `'f'`
  - replace → `"!(f)"`

- **Step 2**: rightmost operator → `!`
  - subexpr = `"!(f)"`
  - values = `"f"` → `!f` → `'t'`
  - replace → `"t"`

→ final result `'t'` → **true**

**Correct**.

**Input**: `"|(f,f,f,t)"`

- Rightmost operator → `|` (only one)
- subexpr = `"|(f,f,f,t)"`
- values = `"f,f,f,t"` → contains `'t'` → result = `'t'`
- replace → `"t"`

→ **true**

**Correct**.

**Input**: `"&(!(f),t)"`

- Rightmost → `!` → evaluate `"!(f)"` → `'t'`
- replace → `"&(t,t)"`
- Then `&` → values `"t,t"` → `'t'`

**Correct**.

---

## Pitfalls & Edge Cases

- **Deep nesting** → rightmost operator = innermost → evaluated first → correct bottom-up order
- **Multiple operators at same level** → rightmost processed first → doesn't matter (AND/OR associative)
- **Single `'t'`/`'f'`** → length=1 → loop stops immediately
- **Valid input guaranteed** → no need for error checking or balancing parentheses
- **Commas** → correctly extracted in `values`

All handled perfectly.

---

## Key Takeaway

This is a **beautifully iterative** parser:

- **Find innermost** subexpression via rightmost operator
- **Evaluate** and **replace** with single `'t'`/`'f'`
- **Repeat** until entire expression reduced to one character

**No recursion. No explicit stack. No parsing tree.**
**Pure, clean, clever** — perfect string-based bottom-up evaluation.

---


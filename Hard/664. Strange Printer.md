# 664. Strange Printer

---

## Problem Restatement
We have a strange printer with two rules:
1. It can only print a sequence of the same character in one turn.
2. Each turn can overwrite existing characters in any substring.

Given a string `s`, return the **minimum number of turns** needed to print it.

---

## Key Idea
This is a **dynamic programming** problem.

- Define `dp[i][j]` = minimum turns to print substring `s[i..j]`.
- Base case: `dp[i][i] = 1` (a single character needs one turn).
- Transition:
  - If `s[i] == s[k]` for some `k` in `(i, j]`, we can merge printing operations:
    ```
    dp[i][j] = min(dp[i][j], dp[i][k-1] + dp[k][j])
    ```
  - Otherwise:
    ```
    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
    ```
- Answer: `dp[0][n-1]`.

---

## Code (C#)
```csharp
public class Solution {
    public int StrangePrinter(string s) {
        int n = s.Length;
        if (n == 0) return 0;

        int[,] dp = new int[n, n];

        for (int i = 0; i < n; i++) dp[i, i] = 1;

        for (int len = 2; len <= n; len++) {
            for (int i = 0; i + len - 1 < n; i++) {
                int j = i + len - 1;
                dp[i, j] = dp[i, j - 1] + 1;
                for (int k = i; k < j; k++) {
                    if (s[k] == s[j]) {
                        dp[i, j] = Math.Min(dp[i, j], dp[i, k] + dp[k + 1, j - 1]);
                    }
                }
            }
        }

        return dp[0, n - 1];
    }
}
```


## Complexity
- **Time:** O(n³), because for each substring we try all possible split points.  
- **Space:** O(n²), storing the DP table for all substrings.  

---

## Example Walkthrough

**Input:** `s = "aaabbb"`  
- Substring `[0..2] = "aaa"` → needs 1 turn.  
- Substring `[3..5] = "bbb"` → needs 1 turn.  
- Combine: total = 2 ✅ 

**Input:** `s = "aba"`  
- First print `"aaa"` in one turn.  
- Then overwrite the middle with `"b"`.  
- Total = 2 ✅ 

---

## Why Interval DP Works
1. **Subproblem definition:**  
   - `dp[i][j]` = minimum turns to print substring `s[i..j]`.  

2. **Base case:**  
   - `dp[i][i] = 1` (a single character always takes one turn).  

3. **Transition:**  
   - Naively, we could split at every `k` between `i` and `j`:  
     ```
     dp[i][j] = min(dp[i][k] + dp[k+1][j])
     ```
   - But if `s[k] == s[j]`, we can merge operations:  
     ```
     dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j-1])
     ```
   - This merging is the key optimization: overlapping characters reduce the number of turns.  

4. **Final answer:**  
   - `dp[0][n-1]` gives the minimum turns for the whole string.  

---

## Intuition
- The printer can overwrite, so repeated characters can be merged into one operation.  
- Interval DP captures this by considering substrings and checking if the last character can be printed together with earlier ones.  
- The merging condition (`s[k] == s[j]`) ensures we don’t waste turns when characters match.  

---

## Conclusion
The solution uses **interval DP**:
- Each substring is solved optimally.  
- Overlapping characters allow merging operations.  
- Efficient for `n ≤ 100` with O(n³) time and O(n²) space.  

This approach guarantees correctness and is the standard way to handle problems where substrings can overlap and merge.



---

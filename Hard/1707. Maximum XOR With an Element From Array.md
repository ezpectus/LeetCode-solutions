# Problem: 1707. Maximum XOR With an Element From Array

You are given:
- An integer array `nums` containing non-negative values.
- A list of queries `queries[i] = [xi, mi]`.

Each query asks for the maximum value of `xi ^ num` such that:
- `num` is an element of `nums`
- `num <= mi`

If no such `num` exists, return `-1`.

---

## Input Semantics

- `nums`: the pool of numbers available for XOR operations.
- `xi`: the number we want to XOR with.
- `mi`: the upper bound constraint for selecting elements from `nums`.

Each query is constrained by `mi`, meaning we can only use numbers from `nums` that are less than or equal to `mi`.

---

## What We Can Use — and Why

- XOR is a bitwise operation that is maximized when bits differ.
- To maximize `xi ^ num`, we want to flip as many high bits as possible.
- A **Trie (prefix tree)** allows us to store binary representations of numbers and perform greedy bitwise traversal.
- Sorting `nums` and `queries` by `mi` allows us to insert only relevant numbers into the Trie before each query.

This structure avoids brute-force search and enables efficient query resolution.

---

## Core Idea

1. Sort `nums` in ascending order.
2. Sort `queries` by `mi`, while preserving original indices.
3. For each query:
   - Insert all `nums[j] <= mi` into the Trie.
   - Use the Trie to greedily find the number that gives the maximum XOR with `xi`.
4. If no number ≤ `mi` exists, return `-1`.

---

## C# Implementation

```csharp
public class Solution {
    class TrieNode {
        public TrieNode[] child = new TrieNode[2];
    }

    void Insert(TrieNode root, int num) {
        for (int i = 31; i >= 0; i--) {
            int bit = (num >> i) & 1;
            if (root.child[bit] == null)
                root.child[bit] = new TrieNode();
            root = root.child[bit];
        }
    }

    int GetMax(TrieNode root, int num) {
        int xor = 0;
        for (int i = 31; i >= 0; i--) {
            int bit = (num >> i) & 1;
            int togg = 1 - bit;
            if (root.child[togg] != null) {
                xor |= (1 << i);
                root = root.child[togg];
            } else {
                root = root.child[bit];
            }
        }
        return xor;
    }

    public int[] MaximizeXor(int[] nums, int[][] queries) {
        int n = nums.Length;
        Array.Sort(nums);

        var idxQue = queries.Select((q, i) =>
            new { xi = q[0], mi = q[1], idx = i }).OrderBy(q => q.mi).ToList();

        int[] res = new int[queries.Length];
        int j = 0;
        TrieNode root = new TrieNode();

        foreach (var q in idxQue) {
            int xi = q.xi;
            int mi = q.mi;
            int idx = q.idx;

            while (j < n && nums[j] <= mi) {
                Insert(root, nums[j]);
                j++;
            }

            res[idx] = j == 0 ? -1 : GetMax(root, xi);
        }

        return res;
    }
}
```


## Architecture Breakdown

Phase 1: Sorting
- Sort nums to allow incremental insertion into Trie.
- Sort queries by mi to process in increasing constraint order.

Phase 2: Trie Construction
- Insert numbers into Trie only if they satisfy nums[j] <= mi.

Phase 3: XOR Search
- Traverse Trie from most significant bit to least.
- At each level, prefer the opposite bit to maximize XOR.

Phase 4: Result Assembly
 - Store results in res[] using original query indices.
 - Return final result array.

## Time Complexity

- Sorting nums: O(n log n)
- Sorting queries: O(q log q)
- Trie insertion: O(n * 32)
- Trie query: O(q * 32)
- Total: O((n + q) * log n + (n + q) * 32)

## Why This Works

- XOR is maximized by flipping bits, so we greedily choose opposite bits in the Trie.
- Sorting ensures we only insert necessary values.
- Trie provides fast bitwise traversal, avoiding brute-force search.
- This approach handles up to 10⁵ queries efficiently and is optimal for bitwise XOR constraints.

---

# 🔗 LeetCode 952 — Largest Component Size by Common Factor (C#)

## 🧩 Problem Overview

You're given an array `nums` of unique positive integers. Construct a graph where:

- Each number is a node
- An undirected edge exists between `nums[i]` and `nums[j]` **if they share a common factor greater than 1**

Return the size of the **largest connected component** in this graph.

### Constraints

- `1 <= nums.length <= 2 × 10⁴`
- `1 <= nums[i] <= 10⁵`
- All values in `nums` are unique

---

## 🧠 Architectural Rationale

### ✅ Why Union-Find
- We don't need to build an explicit graph
- Instead, we **connect numbers through their factors**
- Union-Find efficiently tracks connected components

### ✅ Why Factorization
- Two numbers are connected **iff** they share a factor > 1
- For each number, we union it with all its factors and co-factors
- This builds implicit connectivity between numbers

### ✅ Why Dictionary for Counting
- After unioning, we count how many numbers share the same root
- The root represents the component leader
- The largest frequency among roots is the answer

---

## ✅ C# Implementation

```csharp
public class Solution {
    public int LargestComponentSize(int[] nums) {
        int max = nums.Max();
        UnionFind uf = new UnionFind(max + 1);

        foreach (int num in nums) {
            for (int fact = 2; fact * fact <= num; fact++) {
                if (num % fact == 0) {
                    uf.Union(num, fact);
                    uf.Union(num, num / fact);
                }
            }
        }

        var count = new Dictionary<int, int>();
        int maxSize = 0;

        foreach (int num in nums) {
            int root = uf.Find(num);
            if (!count.ContainsKey(root)) count[root] = 0;
            count[root]++;
            maxSize = Math.Max(maxSize, count[root]);
        }

        return maxSize;
    }

    class UnionFind {
        private int[] parent;

        public UnionFind(int size) {
            parent = new int[size];
            for (int i = 0; i < size; i++) parent[i] = i;
        }

        public int Find(int x) {
            if (parent[x] != x) parent[x] = Find(parent[x]);
            return parent[x];
        }

        public void Union(int x, int y) {
            int px = Find(x);
            int py = Find(y);
            if (px != py) parent[py] = px;
        }
    }
}
```

## ⏱ Time & Space Complexity

| Operation         | Time Complexity     | Space Complexity   | Description                                |
|-------------------|----------------------|---------------------|--------------------------------------------|
| Factorization      | `O(N × √M)`          | `O(1)`              | For each number, scan up to its square root |
| Union-Find Ops     | `O(α(M))` per op     | `O(M)`              | α = inverse Ackermann, M = max value        |
| Component Counting | `O(N)`               | `O(N)`              | Count root frequencies                      |
| **Total**          | `O(N × √M)`          | `O(M + N)`          | Efficient for given constraints             |

**Where:**

- `N` = number of elements in `nums`  
- `M` = maximum value in `nums`

---

## 🧪 Example Execution

| Input                          | Output | Explanation                                  |
|--------------------------------|--------|----------------------------------------------|
| `[4,6,15,35]`                  | `4`    | All share common factors → one big component |
| `[20,50,9,63]`                 | `2`    | Only 20 and 50 share factor → component size 2 |
| `[2,3,6,7,4,12,21,39]`         | `8`    | All connected via shared factors             |

---

## ✅ Final Takeaways

- **Union-Find** is optimal for implicit graph connectivity  
- **Factorization** builds edges without explicit graph  
- **Root frequency count** gives component sizes  
- Efficient for large inputs due to `√num` factor scan  
- Fully modular and reusable for similar number-theory graph problems

---

# 2872. Maximum Number of K-Divisible Components

---

## Problem Summary
We are given an undirected tree with `n` nodes labeled `0..n-1`.  
- Each node has an integer value.  
- We want to split the tree into components by removing edges.  
- A split is valid if **the sum of values in each component is divisible by `k`**.  
- Task: return the maximum number of components possible in any valid split.  

---

## Core Idea
- Perform a **DFS traversal** of the tree.  
- For each subtree, compute the sum of node values.  
- If a subtree sum is divisible by `k`, we can cut the edge connecting it to its parent → this forms a new component.  
- Otherwise, propagate the remainder up to the parent.  
- The total number of components = number of valid cuts + 1 (for the root component).  

---

## C++ Implementation
```cpp
class Solution {
public:
    int maxKDivisibleComponents(int n, vector<vector<int>>& edges, vector<int>& values, int k) {
        vector<vector<int>> adj(n);
        for (auto &e : edges) {
            adj[e[0]].push_back(e[1]);
            adj[e[1]].push_back(e[0]);
        }
        
        int result = 0;
        
        function<long long(int,int)> dfs = [&](int node, int parent) {
            long long sum = values[node];
            for (int nei : adj[node]) {
                if (nei == parent) continue;
                sum += dfs(nei, node);
            }
            if (sum % k == 0) {
                result++; // this subtree can form a component
                return 0LL; // cut here, don't propagate sum upward
            }
            return sum;
        };
        
        dfs(0, -1);
        return result;
    }
};
```


## Complexity
- **Time:** O(n) — each node is visited once during DFS traversal.  
- **Space:** O(n) — adjacency list storage plus recursion stack depth.  

---

## Pitfalls
- Must use **long long** for sums since node values can be up to 1e9 and `n` up to 3e4.  
- Ensure to count the **root component** as well (increment result when divisible).  
- **Edge case:** if the entire tree sum is divisible by `k`, the whole tree counts as one component.  
- Avoid revisiting parent nodes in DFS to prevent cycles.  

---

## Example Walkthrough
**Example 1:**  
Input: `n = 5, edges = [[0,2],[1,2],[1,3],[2,4]], values = [1,8,1,4,4], k = 6`  

DFS traversal:  
- Subtree(3) = 4 → not divisible → propagate upward.  
- Subtree(1) = 8 + 4 = 12 → divisible → cut here → component count++.  
- Subtree(4) = 4 → not divisible → propagate upward.  
- Subtree(0,2,4) = 1 + 1 + 4 = 6 → divisible → cut here → component count++.  

**Result = 2**  

---

## Conclusion
The problem reduces to **DFS accumulation of subtree sums** with cuts whenever sums are divisible by `k`.  
- Runs in **O(n)** time and **O(n)** space.  
- Efficiently computes the maximum number of valid components.  
- Handles large values safely by using `long long`.  



---

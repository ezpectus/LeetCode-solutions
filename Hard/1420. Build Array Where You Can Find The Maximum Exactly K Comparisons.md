# Pattern Name  
3D DP with Max Tracking and Cost Increments

---

## Problem Summary

You are given integers `n`, `m`, and `k`.  
Build an array `arr` of length `n` such that:

- Each element satisfies `1 ≤ arr[i] ≤ m`  
- The **search cost** (number of times the maximum increases during a left-to-right scan) is exactly `k`

Return the number of valid arrays modulo \(10^9 + 7\).

---

## Core Idea

This is a **constructive DP** problem with three dimensions:

- `len` — current array length  
- `max` — current maximum value  
- `cost` — number of times the maximum has increased

We track `dp[len, max, cost]` — number of ways to build arrays of length `len` ending with max `max` and cost `cost`.

There are two transitions:

- **Extend with value ≤ current max** → cost unchanged  
- **Extend with new max** → cost increases by 1

---

## Transition Logic

```text
dp[len, max, cost] += dp[len - 1, max, cost] × max
dp[len, newMax, cost] += sum over prevMax < newMax of dp[len - 1, prevMax, cost - 1]
```

## C# Implementation
```cpp
public class Solution {
    public int NumOfArrays(int n, int m, int k) {
        const int MOD = 1_000_000_007;
        int[,,] dp = new int[n + 1, m + 1, k + 1];
        dp[0, 0, 0] = 1;

        for (int len = 1; len <= n; len++) {
            //Extend with value <= current max → cost unchanged
            for (int max = 0; max <= m; max++) {
                for (int cost = 0; cost <= k; cost++) {
                    long extend = (long)dp[len - 1, max, cost] * max % MOD;
                    dp[len, max, cost] = (int)((dp[len, max, cost] + extend) % MOD);
                }
            }

            //Extend with new max = cost increases
            for (int newMax = 1; newMax <= m; newMax++) {
                for (int prevMax = 0; prevMax < newMax; prevMax++) {
                    for (int cost = 1; cost <= k; cost++) {
                        dp[len, newMax, cost] = (dp[len, newMax, cost] + dp[len - 1, prevMax, cost - 1]) % MOD;
                    }
                }
            }
        }

        int res = 0;
        for (int max = 1; max <= m; max++) res = (res + dp[n, max, k]) % MOD;

        return res;
    }
}
```

## Time and Space Complexity

| Metric           | Value         | Explanation                                      |
|------------------|---------------|--------------------------------------------------|
| Time Complexity  | O(n × m² × k) | Triple loop with nested max transitions         |
| Space Complexity | O(n × m × k)  | 3D DP table tracking length, max, and cost      |

---

## Generalization to Other Problems

This pattern applies to problems where:

- You build arrays under **incremental cost constraints**  
- You track **maximums and cost** during construction  
- You need **multi-dimensional DP** with state transitions  
- The cost function is **non-additive and directional**

---

## Examples of Similar Problems

| Problem Type                | Description                                         |
|----------------------------|-----------------------------------------------------|
| Count Arrays with Cost     | Build arrays with exact comparison cost             |
| DP with Max Tracking       | Track max value and cost during array construction  |
| 3D DP with State Propagation | Use layered DP to model growth and constraints     |

---

## Final Takeaway

This solution uses:

- **3D DP** to track `length`, `max`, and `cost`  
- **Two-phase transitions** to model cost behavior  
- **Modular arithmetic** to maintain correctness  
- **Clean iteration** with short, expressive variable names

The result is a clean and efficient solution that avoids brute-force and leverages structured DP transitions.  
This pattern is reusable for any task involving **array construction with directional cost tracking**.



---

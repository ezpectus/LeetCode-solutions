# ğŸ§  Problem: 965. Univalued Binary Tree

## ğŸ“œ Problem Statement  
You're given the root of a binary tree.  
A binary tree is **univalued** if **every node** in the tree has the **same value**.  
Your task is to **return `true`** if the tree is univalued, and **`false` otherwise**.

---

## ğŸ” What They Want  
âœ… Validate uniformity across all nodes  
âœ… Traverse the entire tree  
âœ… Return a boolean result  
âŒ No need to modify the tree or collect values  
âœ… Must handle nulls and edge cases correctly  

---

## ğŸ“Œ Type  
- **Difficulty**: Easy  
- **Category**: Binary Tree Traversal  
- **Technique**: DFS (recursive validation)  
- **Signal Focus**:  
  - Base case recursion  
  - Local value comparison  
  - Delegation to child nodes  

---

## ğŸ’¡ Core Idea  
Use **DFS traversal** to check whether all nodes match the rootâ€™s value.  
At each node:  
- Compare its value with its children  
- If mismatch â†’ return false  
- Else â†’ continue recursively  

This forms a **recursive validation chain**, where each node confirms local consistency and delegates to its children.

---

## ğŸ”§ Approach

### âœ… Step-by-step Logic  
- **Base Case**:  
  If the node is `null`, return `true` (empty subtree is trivially univalued)

- **Local Check**:  
  If `left` or `right` child exists and its value â‰  current nodeâ€™s value â†’ return `false`

- **Recursive Delegation**:  
  Recursively validate `left` and `right` subtrees

- **Final Return**:  
  Return `true` only if both subtrees are univalued


## ğŸ§± Code (C#)
```csharp
public class Solution {
    public bool IsUnivalTree(TreeNode root) {
        if(root == null) return true;

        if(root.left != null && root.left?.val != root.val) return false;
        if(root.right != null && root.right?.val != root.val) return false;

        return IsUnivalTree(root.left) && IsUnivalTree(root.right);
    }
}
```

## ğŸ§© Signals Extracted

âœ… Base case: `root == null â†’ true`  
âœ… Local check: `left.val == root.val`, `right.val == root.val`  
âœ… Recursive structure: `return IsUnivalTree(left) && IsUnivalTree(right)`  
âœ… No need for extra state or global flags â€” pure recursion suffices  
âœ… Each node acts as a validator â€” no need for post-order aggregation  
âœ… Early termination on mismatch â€” avoids unnecessary traversal  

---

## ğŸ“¦ Notes

- **Time complexity**: O(n), where n = number of nodes  
- **Space complexity**: O(h), where h = height of tree (due to recursion stack)  
- **Traversal type**: Pre-order DFS (check before delegating)  
- **Edge Cases**:  
  - Single-node tree â†’ always true  
  - Null children â†’ safely ignored  
  - Mixed depth trees â†’ handled naturally  
- **Extensibility**:  
  - Can be adapted to return mismatch locations  
  - Can be refactored into iterative DFS with stack if needed  
  - Can be generalized to check other uniform properties (e.g. parity, range)





---

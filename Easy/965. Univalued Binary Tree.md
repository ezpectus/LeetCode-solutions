# 🧠 Problem: 965. Univalued Binary Tree

## 📜 Problem Statement  
You're given the root of a binary tree.  
A binary tree is **univalued** if **every node** in the tree has the **same value**.  
Your task is to **return `true`** if the tree is univalued, and **`false` otherwise**.

---

## 🔍 What They Want  
✅ Validate uniformity across all nodes  
✅ Traverse the entire tree  
✅ Return a boolean result  
❌ No need to modify the tree or collect values  
✅ Must handle nulls and edge cases correctly  

---

## 📌 Type  
- **Difficulty**: Easy  
- **Category**: Binary Tree Traversal  
- **Technique**: DFS (recursive validation)  
- **Signal Focus**:  
  - Base case recursion  
  - Local value comparison  
  - Delegation to child nodes  

---

## 💡 Core Idea  
Use **DFS traversal** to check whether all nodes match the root’s value.  
At each node:  
- Compare its value with its children  
- If mismatch → return false  
- Else → continue recursively  

This forms a **recursive validation chain**, where each node confirms local consistency and delegates to its children.

---

## 🔧 Approach

### ✅ Step-by-step Logic  
- **Base Case**:  
  If the node is `null`, return `true` (empty subtree is trivially univalued)

- **Local Check**:  
  If `left` or `right` child exists and its value ≠ current node’s value → return `false`

- **Recursive Delegation**:  
  Recursively validate `left` and `right` subtrees

- **Final Return**:  
  Return `true` only if both subtrees are univalued


## 🧱 Code (C#)
```csharp
public class Solution {
    public bool IsUnivalTree(TreeNode root) {
        if(root == null) return true;

        if(root.left != null && root.left?.val != root.val) return false;
        if(root.right != null && root.right?.val != root.val) return false;

        return IsUnivalTree(root.left) && IsUnivalTree(root.right);
    }
}
```

## 🧩 Signals Extracted

✅ Base case: `root == null → true`  
✅ Local check: `left.val == root.val`, `right.val == root.val`  
✅ Recursive structure: `return IsUnivalTree(left) && IsUnivalTree(right)`  
✅ No need for extra state or global flags — pure recursion suffices  
✅ Each node acts as a validator — no need for post-order aggregation  
✅ Early termination on mismatch — avoids unnecessary traversal  

---

## 📦 Notes

- **Time complexity**: O(n), where n = number of nodes  
- **Space complexity**: O(h), where h = height of tree (due to recursion stack)  
- **Traversal type**: Pre-order DFS (check before delegating)  
- **Edge Cases**:  
  - Single-node tree → always true  
  - Null children → safely ignored  
  - Mixed depth trees → handled naturally  
- **Extensibility**:  
  - Can be adapted to return mismatch locations  
  - Can be refactored into iterative DFS with stack if needed  
  - Can be generalized to check other uniform properties (e.g. parity, range)





---

# ğŸ§© Problem: 1275. Find Winner on a Tic Tac Toe Game

### ğŸ“œ Task Description
Two players, A and B, play Tic Tac Toe on a 3Ã—3 grid.  
- Player A always plays first and uses 'X'  
- Player B plays second and uses 'O'  
- A move is represented as `[row, col]`  
- The game ends when:
  - A player fills a row, column, or diagonal with their symbol
  - All 9 cells are filled without a winner (draw)
  - Moves are still remaining (pending)

**Input**: `int[][] moves` â€” sequence of moves  
**Output**: `"A"`, `"B"`, `"Draw"`, or `"Pending"`

---

# ğŸ§  Intuition

Instead of simulating the full grid, we can track **score vectors** for each row, column, and diagonal.  
By encoding Player A as `+1` and Player B as `-1`, we can detect a win when any score reaches `Â±3`.

This avoids grid mutation and allows **O(1)** win detection per move.

---

# ğŸ§­ Approach

### ğŸ”§ State Tracking
- `rows[3]`: cumulative score per row
- `cols[3]`: cumulative score per column
- `diag`: score for main diagonal
- `antiDiag`: score for anti-diagonal

### ğŸ”„ Move Processing
For each move:
- Determine `player = i % 2 == 0 ? +1 : -1`
- Update `rows[row]`, `cols[col]`
- If `row == col` â†’ update `diag`
- If `row + col == 2` â†’ update `antiDiag`
- After each update, check if any score reaches `Â±3`

### ğŸ Final Decision
- If a win is detected â†’ return `"A"` or `"B"`
- If all 9 moves played â†’ return `"Draw"`
- Else â†’ return `"Pending"`

---

# âœ… Code
```csharp
public class Solution {
    public string Tictactoe(int[][] moves) {
        int[] rows = new int[3];
        int[] cols = new int[3];
        int diag = 0, antiDiag = 0;

        for (int i = 0; i < moves.Length; i++) {
            int row = moves[i][0];
            int col = moves[i][1];
            int player = i % 2 == 0 ? 1 : -1;

            rows[row] += player;
            cols[col] += player;
            if (row == col) diag += player;
            if (row + col == 2) antiDiag += player;

            if (Math.Abs(rows[row]) == 3 ||
                Math.Abs(cols[col]) == 3 ||
                Math.Abs(diag) == 3 ||
                Math.Abs(antiDiag) == 3)
                return player == 1 ? "A" : "B";
        }

        return moves.Length == 9 ? "Draw" : "Pending";
    }
}
```


# ğŸ§  Engineering Notes

âœ… **Compressed state**: avoids full grid simulation  
âœ… **+1/-1 encoding**: simplifies win detection  
âœ… **Early termination**: detects win before full traversal  

âš ï¸ **Edge case**: must check both diagonals correctly (`row == col`, `row + col == 2`)  
âš ï¸ **Initialization**: moves must be valid and within bounds (guaranteed by constraints)  

---

# ğŸ§ª Pattern Summary

| Signal Type       | Pattern Name                  | Use Case                                |
|-------------------|-------------------------------|------------------------------------------|
| Grid compression  | Score-based win detection     | Grid games with fixed win lines          |
| Parity encoding   | +1 / -1 player representation | Simplifies logic and comparisons         |
| Early exit        | Win detection via abs value   | Avoids unnecessary computation           |

---

# ğŸ§± Reusability

This pattern generalizes to:

- NxN Tic Tac Toe  
- Connect Four (with vertical/horizontal/diagonal checks)  
- Gomoku / Five in a Row  
- Any grid-based game with line-based win conditions  

---

# ğŸ•³ï¸ Potential Dangers ("Ğ”Ñ‹Ñ€Ñ‹")

âŒ Forgetting to check both diagonals  
âŒ Using `i` instead of `row`/`col` when updating score vectors  
âŒ Not handling `moves.Length == 9` correctly for draw  
âŒ Misencoding player values (e.g. using `0/1` instead of `+1/-1`)  

---

# ğŸ§  Final Reflection

This task looks simple, but itâ€™s a perfect example of how **compressed state tracking** and **parity encoding** can turn a simulation into a clean architectural solution.  
Even in low-energy mode, this pattern is easy to apply and highly reusable.



---

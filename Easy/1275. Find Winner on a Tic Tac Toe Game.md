# 🧩 Problem: 1275. Find Winner on a Tic Tac Toe Game

### 📜 Task Description
Two players, A and B, play Tic Tac Toe on a 3×3 grid.  
- Player A always plays first and uses 'X'  
- Player B plays second and uses 'O'  
- A move is represented as `[row, col]`  
- The game ends when:
  - A player fills a row, column, or diagonal with their symbol
  - All 9 cells are filled without a winner (draw)
  - Moves are still remaining (pending)

**Input**: `int[][] moves` — sequence of moves  
**Output**: `"A"`, `"B"`, `"Draw"`, or `"Pending"`

---

# 🧠 Intuition

Instead of simulating the full grid, we can track **score vectors** for each row, column, and diagonal.  
By encoding Player A as `+1` and Player B as `-1`, we can detect a win when any score reaches `±3`.

This avoids grid mutation and allows **O(1)** win detection per move.

---

# 🧭 Approach

### 🔧 State Tracking
- `rows[3]`: cumulative score per row
- `cols[3]`: cumulative score per column
- `diag`: score for main diagonal
- `antiDiag`: score for anti-diagonal

### 🔄 Move Processing
For each move:
- Determine `player = i % 2 == 0 ? +1 : -1`
- Update `rows[row]`, `cols[col]`
- If `row == col` → update `diag`
- If `row + col == 2` → update `antiDiag`
- After each update, check if any score reaches `±3`

### 🏁 Final Decision
- If a win is detected → return `"A"` or `"B"`
- If all 9 moves played → return `"Draw"`
- Else → return `"Pending"`

---

# ✅ Code
```csharp
public class Solution {
    public string Tictactoe(int[][] moves) {
        int[] rows = new int[3];
        int[] cols = new int[3];
        int diag = 0, antiDiag = 0;

        for (int i = 0; i < moves.Length; i++) {
            int row = moves[i][0];
            int col = moves[i][1];
            int player = i % 2 == 0 ? 1 : -1;

            rows[row] += player;
            cols[col] += player;
            if (row == col) diag += player;
            if (row + col == 2) antiDiag += player;

            if (Math.Abs(rows[row]) == 3 ||
                Math.Abs(cols[col]) == 3 ||
                Math.Abs(diag) == 3 ||
                Math.Abs(antiDiag) == 3)
                return player == 1 ? "A" : "B";
        }

        return moves.Length == 9 ? "Draw" : "Pending";
    }
}
```


# 🧠 Engineering Notes

✅ **Compressed state**: avoids full grid simulation  
✅ **+1/-1 encoding**: simplifies win detection  
✅ **Early termination**: detects win before full traversal  

⚠️ **Edge case**: must check both diagonals correctly (`row == col`, `row + col == 2`)  
⚠️ **Initialization**: moves must be valid and within bounds (guaranteed by constraints)  

---

# 🧪 Pattern Summary

| Signal Type       | Pattern Name                  | Use Case                                |
|-------------------|-------------------------------|------------------------------------------|
| Grid compression  | Score-based win detection     | Grid games with fixed win lines          |
| Parity encoding   | +1 / -1 player representation | Simplifies logic and comparisons         |
| Early exit        | Win detection via abs value   | Avoids unnecessary computation           |

---

# 🧱 Reusability

This pattern generalizes to:

- NxN Tic Tac Toe  
- Connect Four (with vertical/horizontal/diagonal checks)  
- Gomoku / Five in a Row  
- Any grid-based game with line-based win conditions  

---

# 🕳️ Potential Dangers ("Дыры")

❌ Forgetting to check both diagonals  
❌ Using `i` instead of `row`/`col` when updating score vectors  
❌ Not handling `moves.Length == 9` correctly for draw  
❌ Misencoding player values (e.g. using `0/1` instead of `+1/-1`)  

---

# 🧠 Final Reflection

This task looks simple, but it’s a perfect example of how **compressed state tracking** and **parity encoding** can turn a simulation into a clean architectural solution.  
Even in low-energy mode, this pattern is easy to apply and highly reusable.



---

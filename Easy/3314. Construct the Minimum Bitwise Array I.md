# 🧠 Module: Construct the Minimum Bitwise Array — OR Matching Logic

## 📌 Problem Statement

You are given an array `nums` consisting of `n` prime integers.  
Construct an array `ans` of length `n` such that for each index `i`, the following condition holds:
```
ans[i] | (ans[i] + 1) == nums[i]
```

Additionally, each `ans[i]` must be minimized.  
If no such value exists for a given `nums[i]`, set `ans[i] = -1`.

---

## 🧩 Architectural Insight

### ✅ Signals from the problem:
- The condition involves a **bitwise OR** between `x` and `x + 1`
- We must **minimize `x`** for each `nums[i]`
- All `nums[i]` are **prime numbers**, which may not always be representable as `x | (x + 1)`
- If no valid `x` exists → return `-1`

### ❗ Key observation:
- The expression `x | (x + 1)` sets all bits up to the first unset bit in `x`
- Only certain numbers can be formed this way — not all primes qualify

---

## 🔧 Implementation Strategy

- For each `target = nums[i]`:
  - Iterate `x` from `0` to `target`
  - Check if `x | (x + 1) == target`
  - If found → assign `x` to `ans[i]`
  - If not → assign `-1`

---

## ✅ C# Implementation

```csharp
public class Solution {
    public int[] MinBitwiseArray(IList<int> nums) {
        int n = nums.Count;
        int[] ans = new int[n];

        for (int i = 0; i < n; i++) {
            int target = nums[i];
            int found = -1;

            for (int x = 0; x <= target; x++) {
                if ((x | (x + 1)) == target) {
                    found = x;
                    break;
                }
            }

            ans[i] = found;
        }

        return ans;
    }
}
```
## 📦 Complexity Analysis

| Aspect         | Value                     | Explanation                                                                 |
|----------------|---------------------------|------------------------------------------------------------------------------|
| Time           | `O(n · t)`                | For each `nums[i]`, we iterate from `x = 0` to `x = target`. Since `target ≤ 1000`, this is acceptable. |
| Space          | `O(n)`                    | We store the result array `ans[]` of size `n`. No auxiliary structures are used. |
| Bitwise ops    | Constant time `O(1)`      | Each `x | (x + 1)` operation is a fixed-time bitwise OR. No loops or recursion involved. |
| Preprocessing  | None                      | No sorting, hashing, or transformation is needed. Each element is processed independently. |
| Edge cases     | Handled inline            | If no valid `x` exists for a given `nums[i]`, we assign `-1` directly. No post-processing required. |
| Total runtime  | Efficient for `n ≤ 100`, `nums[i] ≤ 1000` | Worst-case `100 × 1000 = 10⁵` iterations — fast enough for brute-force. |

---

### 🧠 Architectural Notes

- The brute-force loop is **bounded and predictable**, making it safe for production constraints.
- Bitwise logic avoids expensive operations like `Set`, `Intersect`, or string manipulation.
- The solution is **stateless per element**, meaning it can be parallelized or memoized if needed.
- No dynamic programming, no recursion — just **pure bitwise matching**.


---

# 🧩 Problem: Number of Even and Odd Bits

**Task:**  
Given a positive integer `n`, return an array `[even, odd]` where:
- `even` is the number of bits with value `1` at **even indices**
- `odd` is the number of bits with value `1` at **odd indices**

**Note:**  
Bits are indexed from **right to left**, starting at index `0`.

---

## ✅ Efficient Solution (Bitwise Index Counter)

```csharp
public class Solution {
    public int[] EvenOddBit(int n) {
        int even = 0;
        int odd = 0;
        int idx = 0;

        while (n > 0) {
            if ((n & 1) == 1) {
                if (idx % 2 == 0) {
                    even++;
                } else {
                    odd++;
                }
            }
            n >>= 1;
            idx++;
        }

        return new int[] { even, odd };
    }
}
```

## 🔍 Highlights

- **Bitwise check:**  
  `(n & 1)` isolates the least significant bit (LSB).  
  This tells us whether the current bit is `1` or `0` without converting to a string.

- **Index tracking:**  
  `idx % 2` determines whether the current bit is at an even or odd index.  
  Indexing starts from the rightmost bit (position 0), moving left as we shift.

- **Right shift:**  
  `n >>= 1` moves to the next bit by discarding the current LSB.  
  This is equivalent to dividing `n` by 2 and continuing the scan.

- **No string conversion:**  
  The solution avoids converting `n` to a binary string, which saves memory and time.  
  All operations are done using bitwise arithmetic.

- **Competitive style:**  
  The approach is fast, minimal, and readable — ideal for time-constrained contests.  
  It uses constant space and logarithmic time, with no unnecessary overhead.

---

## 🧠 Example Walkthrough

**Input:** `n = 50`  
**Binary representation:** `110010`  
**Bit indices (right to left):**

| Index | Bit | Action     |
|-------|-----|------------|
| 0     | 0   | skip       |
| 1     | 1   | `odd++`    |
| 2     | 0   | skip       |
| 3     | 0   | skip       |
| 4     | 1   | `even++`   |
| 5     | 1   | `odd++`    |

**Result:**  
- Even indices with `1`: index `4` → `even = 1`  
- Odd indices with `1`: indices `1`, `5` → `odd = 2`  
**Output:** `[1, 2]`

---

## 🏁 Pattern: Bitwise Index Count

- **Use Case:**  
  Counting bits at specific positions (even/odd) in binary representation.  
  Useful in problems involving parity, masks, or indexed bit logic.

- **Time Complexity:**  
  `O(log N)` — proportional to the number of bits in `n`.

- **Memory Complexity:**  
  `O(1)` — only a few integer variables used.

- **Style:**  
  Competitive, low-level, architecture-friendly.  
  Avoids string manipulation and focuses on direct bitwise control.

---

## 📦 Module Tag

`bit_index_counter.cs`  
Can be reused in tasks involving:
- Bit parity analysis  
- Indexed bit manipulation  
- Binary scanning without conversion






---

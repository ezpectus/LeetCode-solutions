# 🧠 Module: Similar String Pairs — Bitmask Comparison

## 📌 Problem Statement

Given a string array `words`,  
return the number of pairs `(i, j)` such that `0 ≤ i < j < words.length`  
and `words[i]` and `words[j]` consist of **exactly the same set of characters**.

---

## 🧩 Architectural Insight

### ✅ Signals from the problem:
- “Same characters” → order and frequency don’t matter
- Only lowercase letters → 26 total → ideal for **bitmasking**
- Bitmask can represent presence of each character as a single bit

### ❗ Key condition:
- If two strings have **identical bitmasks**, they are similar

---

## 🔧 Strategy

1. Convert each word into a **bitmask**:
   - For each character `c`, set bit `c - 'a'` via `mask |= 1 << (c - 'a')`
2. Compare all pairs of masks:
   - If `mask[i] == mask[j]` → increment count

---

## ✅ C# Implementation

```csharp
public class Solution {
    public int SimilarPairs(string[] words) {
        int n = words.Length;
        int[] masks = new int[n];

        for (int i = 0; i < n; i++) {
            int mask = 0;
            foreach (char c in words[i]) {
                mask |= 1 << (c - 'a');
            }
            masks[i] = mask;
        }

        int count = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (masks[i] == masks[j]) {
                    count++;
                }
            }
        }

        return count;
    }
}
```
## 📦 Complexity Analysis

| Aspect         | Value             | Explanation                                                                 |
|----------------|-------------------|------------------------------------------------------------------------------|
| Time           | `O(n * m + n²)`   | `n * m` to build bitmasks (`m = word length`), `n²` to compare all pairs. Efficient for `n ≤ 100`. |
| Space          | `O(n)`            | One integer mask per word. No dynamic structures or extra memory overhead.  |
| Bitwise ops    | Constant time     | `1 << (c - 'a')` sets the bit for each character. `|` aggregates presence. All operations are fixed-time. |
| Edge cases     | Handled inline    | Repeated letters don’t affect the mask — only presence matters. No special logic required. |
| Total runtime  | Fast              | Runs comfortably within constraints. Suitable for real-time checks and interview-grade performance. |
| Failure modes  | None              | Input constraints guarantee safe execution: all strings are lowercase, length ≥ 1. |

---

### 🧠 Architectural Notes

- This is a **bitmask fingerprinting** task — each word becomes a compact 26-bit signature.
- Comparison is reduced to **integer equality**, avoiding sorting, hashing, or set operations.
- Ideal for FAANG-style interviews where **bit-level optimization** and **signal clarity** are valued.
- The solution is **stateless**, **branchless**, and **modular** — ready for reuse and scaling.

---

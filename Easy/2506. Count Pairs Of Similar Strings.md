# ğŸ§  Module: Similar String Pairs â€” Bitmask Comparison

## ğŸ“Œ Problem Statement

Given a string array `words`,  
return the number of pairs `(i, j)` such that `0 â‰¤ i < j < words.length`  
and `words[i]` and `words[j]` consist of **exactly the same set of characters**.

---

## ğŸ§© Architectural Insight

### âœ… Signals from the problem:
- â€œSame charactersâ€ â†’ order and frequency donâ€™t matter
- Only lowercase letters â†’ 26 total â†’ ideal for **bitmasking**
- Bitmask can represent presence of each character as a single bit

### â— Key condition:
- If two strings have **identical bitmasks**, they are similar

---

## ğŸ”§ Strategy

1. Convert each word into a **bitmask**:
   - For each character `c`, set bit `c - 'a'` via `mask |= 1 << (c - 'a')`
2. Compare all pairs of masks:
   - If `mask[i] == mask[j]` â†’ increment count

---

## âœ… C# Implementation

```csharp
public class Solution {
    public int SimilarPairs(string[] words) {
        int n = words.Length;
        int[] masks = new int[n];

        for (int i = 0; i < n; i++) {
            int mask = 0;
            foreach (char c in words[i]) {
                mask |= 1 << (c - 'a');
            }
            masks[i] = mask;
        }

        int count = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (masks[i] == masks[j]) {
                    count++;
                }
            }
        }

        return count;
    }
}
```
## ğŸ“¦ Complexity Analysis

| Aspect         | Value             | Explanation                                                                 |
|----------------|-------------------|------------------------------------------------------------------------------|
| Time           | `O(n * m + nÂ²)`   | `n * m` to build bitmasks (`m = word length`), `nÂ²` to compare all pairs. Efficient for `n â‰¤ 100`. |
| Space          | `O(n)`            | One integer mask per word. No dynamic structures or extra memory overhead.  |
| Bitwise ops    | Constant time     | `1 << (c - 'a')` sets the bit for each character. `|` aggregates presence. All operations are fixed-time. |
| Edge cases     | Handled inline    | Repeated letters donâ€™t affect the mask â€” only presence matters. No special logic required. |
| Total runtime  | Fast              | Runs comfortably within constraints. Suitable for real-time checks and interview-grade performance. |
| Failure modes  | None              | Input constraints guarantee safe execution: all strings are lowercase, length â‰¥ 1. |

---

### ğŸ§  Architectural Notes

- This is a **bitmask fingerprinting** task â€” each word becomes a compact 26-bit signature.
- Comparison is reduced to **integer equality**, avoiding sorting, hashing, or set operations.
- Ideal for FAANG-style interviews where **bit-level optimization** and **signal clarity** are valued.
- The solution is **stateless**, **branchless**, and **modular** â€” ready for reuse and scaling.

---

# ðŸ§  Module: XOR of Duplicates â€” Filter and Fold

## ðŸ“Œ Problem Statement

Given an array `nums` where each number appears **either once or twice**,  
return the **bitwise XOR** of all numbers that appear **exactly twice**.  
If no number appears twice, return `0`.

---

## ðŸ§© Architectural Insight

### âœ… Signals from the problem:
- Numbers appear **once or twice only** â†’ no need for full frequency map
- XOR is **commutative and reversible** â†’ ideal for folding duplicates
- Constraints are small (`nums.length â‰¤ 50`) â†’ brute-force is acceptable

---

## ðŸ”§ Strategy

1. Use a **frequency array** of size 51 (since `nums[i] â‰¤ 50`)
2. Count occurrences of each number
3. XOR all numbers that appear **exactly twice**

---

## âœ… C# Implementation

```csharp
public class Solution {
    public int DuplicateNumbersXOR(int[] nums) {
        int[] freq = new int[51];
        foreach (int num in nums) {
            freq[num]++;
        }

        int xor = 0;
        for (int i = 1; i <= 50; i++) {
            if (freq[i] == 2) {
                xor ^= i;
            }
        }

        return xor;
    }
}
```

## ðŸ“¦ Complexity Analysis

| Aspect         | Value             | Explanation                                                                 |
|----------------|-------------------|------------------------------------------------------------------------------|
| Time           | `O(n)`            | We iterate through `nums` once to count frequencies, and once through `freq[1..50]` to fold duplicates. Total cost is linear in input size. |
| Space          | `O(1)`            | We use a fixed-size array `freq[51]` since `nums[i] â‰¤ 50`. No dynamic memory allocation or growth. |
| Bitwise ops    | Constant time     | Each XOR operation is performed on integers â‰¤ 50, which are well within 32-bit range. |
| Edge cases     | Handled inline    | If no number appears twice, the XOR accumulator remains `0` â€” no special logic needed. |
| Total runtime  | Ultra-fast        | With `n â‰¤ 50`, the entire process runs in microseconds. Ideal for real-time or embedded use. |
| Scalability    | Bounded           | The algorithm is tightly scoped to the problem constraints. For larger ranges, a hashmap would be needed. |
| Failure modes  | None              | No exceptions, no undefined behavior. Input constraints guarantee safe execution. |

---

### ðŸ§  Architectural Notes

- This is a **filter-and-fold** pattern: filter by frequency, fold via XOR.
- The use of a frequency array avoids hash collisions and keeps memory bounded.
- XOR is ideal for aggregation when order doesnâ€™t matter and duplicates must be collapsed.

---

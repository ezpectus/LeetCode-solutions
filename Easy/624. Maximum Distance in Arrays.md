# üß© Pattern: Rolling Extremes with Source Separation

**Context:**  
Given multiple sorted arrays, select one element from each of two different arrays to maximize the absolute difference `|a - b|`.

**Key Insight:**  
Global min/max must be tracked across arrays, but comparisons must respect **source separation** ‚Äî elements must come from **different arrays**.

---

#### üß† Architectural Breakdown

- **Initialize**:
  - `minVal` ‚Üê first element of first array
  - `maxVal` ‚Üê last element of first array
- **Iterate** through remaining arrays:
  - Extract `currMin` and `currMax`
  - Compare:
    - `|currMax - minVal|`
    - `|maxVal - currMin|`
  - Update:
    - `minVal = min(minVal, currMin)`
    - `maxVal = max(maxVal, currMax)`

This guarantees that comparisons are always between elements from **different arrays**, satisfying the problem constraint.

---

#### ‚ö†Ô∏è Edge Cases

- Avoid comparing elements from the same array (e.g., `currMax - currMin`) ‚Äî even if they yield large differences, they violate the constraint.
- Arrays with identical values (e.g., `[[1],[1]]`) will yield zero distance ‚Äî handle gracefully.

---

#### üß© Transferable Pattern

This technique generalizes to problems where:
- You need to track rolling min/max across partitions.
- Constraints enforce **source separation** or **non-overlapping selections**.
- You want **O(n)** time with constant space.

Examples:
- Maximize difference across disjoint groups.
- Track min/max across sliding windows with exclusion rules.
- Compare prefix/suffix aggregates with separation constraints.

---

#### ‚úÖ Code Implementation

```csharp
public class Solution {
    public int MaxDistance(IList<IList<int>> arrays) {
        int maxDist = 0;
        int minVal = arrays[0][0];
        int maxVal = arrays[0][^1];

        for (int i = 1; i < arrays.Count; i++) {
            int currMin = arrays[i][0];
            int currMax = arrays[i][^1];

            maxDist = Math.Max(maxDist, Math.Abs(currMax - minVal));
            maxDist = Math.Max(maxDist, Math.Abs(maxVal - currMin));

            minVal = Math.Min(minVal, currMin);
            maxVal = Math.Max(maxVal, currMax);
        }

        return maxDist;
    }
}
```

# üß† Meta-Note
This pattern is deceptively simple ‚Äî but it encodes a powerful idea: 
‚ÄúTrack global aggregates, but enforce local constraints.‚Äù 
It‚Äôs the kind of thing that shows up in competitive programming, 
trading logic, and even architectural diffing systems.

---

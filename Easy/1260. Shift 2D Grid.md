## Problem: 1260. Shift 2D Grid

### ğŸ“œ Description
Given a 2D grid of size `m Ã— n` and an integer `k`, shift the grid `k` times.  
Each shift moves elements rightward:
- `grid[i][j] â†’ grid[i][j+1]`
- `grid[i][n-1] â†’ grid[i+1][0]`
- `grid[m-1][n-1] â†’ grid[0][0]`

Return the final grid after `k` shifts.

---

### ğŸ§© Constraints
- `1 <= m, n <= 50`
- `-1000 <= grid[i][j] <= 1000`
- `0 <= k <= 100`

---

## ğŸ” Observations
- Grid is small â†’ no need for optimization beyond O(mn)
- Shift is **circular** â†’ modulo logic applies
- Can flatten â†’ rotate â†’ reshape

---

## ğŸ’¡ Idea
- Flatten grid into 1D list
- Rotate right by `k % (m Ã— n)`
- Reshape back into `m Ã— n` grid

---

## ğŸ§± Code (C#)

```csharp
public class Solution {
    public IList<IList<int>> ShiftGrid(int[][] grid, int k) =>
        grid.SelectMany(x => x)
            .Concat(grid.SelectMany(x => x)) // double for wraparound
            .Skip(grid.Length * grid[0].Length - k % (grid.Length * grid[0].Length))
            .Chunk(grid[0].Length)
            .Take(grid.Length)
            .Select(x => (IList<int>)x.ToList())
            .ToList();
}
```

## â±ï¸ Complexity
- Time: O(m Ã— n)
- Space: O(m Ã— n)

## ğŸ§  Key Tricks
- SelectMany â†’ flatten grid
- Concat â†’ simulate wraparound
- Skip â†’ rotate
- Chunk â†’ reshape

---

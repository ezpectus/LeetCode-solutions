## Problem: 1260. Shift 2D Grid

### 📜 Description
Given a 2D grid of size `m × n` and an integer `k`, shift the grid `k` times.  
Each shift moves elements rightward:
- `grid[i][j] → grid[i][j+1]`
- `grid[i][n-1] → grid[i+1][0]`
- `grid[m-1][n-1] → grid[0][0]`

Return the final grid after `k` shifts.

---

### 🧩 Constraints
- `1 <= m, n <= 50`
- `-1000 <= grid[i][j] <= 1000`
- `0 <= k <= 100`

---

## 🔍 Observations
- Grid is small → no need for optimization beyond O(mn)
- Shift is **circular** → modulo logic applies
- Can flatten → rotate → reshape

---

## 💡 Idea
- Flatten grid into 1D list
- Rotate right by `k % (m × n)`
- Reshape back into `m × n` grid

---

## 🧱 Code (C#)

```csharp
public class Solution {
    public IList<IList<int>> ShiftGrid(int[][] grid, int k) =>
        grid.SelectMany(x => x)
            .Concat(grid.SelectMany(x => x)) // double for wraparound
            .Skip(grid.Length * grid[0].Length - k % (grid.Length * grid[0].Length))
            .Chunk(grid[0].Length)
            .Take(grid.Length)
            .Select(x => (IList<int>)x.ToList())
            .ToList();
}
```

## ⏱️ Complexity
- Time: O(m × n)
- Space: O(m × n)

## 🧠 Key Tricks
- SelectMany → flatten grid
- Concat → simulate wraparound
- Skip → rotate
- Chunk → reshape

---

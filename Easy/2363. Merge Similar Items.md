# 🧠 Problem: Merge Similar Items (Leetcode 2363)

## 🔗 Problem Statement  
Given two 2D arrays `items1` and `items2`, where each item is `[value, weight]` and all values are unique within each array,  
return a merged list of items where weights are summed for matching values.  
The result must be sorted in ascending order by `value`.

---

## 🧩 Why This Approach Works

## ✅ Core Insight  
This is a classic **group-by aggregation** task:
- Use a dictionary to accumulate weights by `value`
- Traverse both arrays and update the dictionary
- Convert the dictionary to a list of `[value, totalWeight]`
- Sort the result by `value`

This avoids nested loops and handles all edge cases cleanly.

---

## 🧠 How I Came to This  
Started by noticing that values are unique within each array, so no need for nested merging.  
Realized that a dictionary can serve as a **frequency map**, but instead of counting, we **sum weights**.  
Once both arrays are processed, we just need to **sort the keys** and format the output.

This pattern generalizes to:
- Merging datasets by key
- Summing metrics across sources
- Preparing sorted output for display or export

---

💻 Code Implementation

```csharp
public class Solution {
    public IList<IList<int>> MergeSimilarItems(int[][] items1, int[][] items2) {
        var map = new Dictionary<int, int>();

        void AddItems(int[][] items) {
            foreach (var item in items) {
                int value = item[0], weight = item[1];
                if (!map.ContainsKey(value))
                    map[value] = 0;
                map[value] += weight;
            }
        }

        AddItems(items1);
        AddItems(items2);

        var result = new List<IList<int>>();
        foreach (var kvp in map.OrderBy(kvp => kvp.Key)) {
            result.Add(new List<int> { kvp.Key, kvp.Value });
        }

        return result;
    }
}
```

# 📌 Constraints

- 1 ≤ items1.length, items2.length ≤ 1000
- Each item is a pair [value, weight]

- All value entries are unique within each array
- Final result must be sorted by value

## 🔍 Engineering Insights

Dictionary Aggregation is a universal pattern for merging keyed data. 
Instead of checking for duplicates manually, we use the key as a bucket and accumulate values.

Sorting by Key is clean and expressive with OrderBy(kvp => kvp.Key). 
No need for custom comparators — the built-in LINQ handles it elegantly.

Separation of Concerns:

- Aggregation logic is isolated in AddItems()
- Sorting and formatting are handled after aggregation This makes the code modular and easy to extend (e.g., for filtering or formatting).




---

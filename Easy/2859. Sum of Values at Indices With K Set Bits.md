# 🧩 Problem Summary

**Leetcode 2859 – Sum of Values at Indices With K Set Bits**

You're given:
- A 0-indexed integer array `nums`
- An integer `k`

**Task**:  
Return the sum of all `nums[i]` where the index `i` has exactly `k` set bits (i.e. `1`s) in its binary representation.

---

# 🧠 Core Idea

This is a **bitwise filtering problem**.  
We iterate through each index `i`, count how many `1`s are in its binary form, and if that count equals `k`, we include `nums[i]` in the result.

### Example:

```text
nums = [5, 10, 1, 5, 2], k = 1

Indices and binary:
0 → 000 → 0 set bits
1 → 001 → 1 set bit ✅
2 → 010 → 1 set bit ✅
3 → 011 → 2 set bits
4 → 100 → 1 set bit ✅

Valid indices: 1, 2, 4 → sum = 10 + 1 + 2 = 13
```

## ✅ Final Code (C#):
```csharp
public class Solution {
    public int SumIndicesWithKSetBits(IList<int> nums, int k) {
        int res = 0;

        for (int i = 0; i < nums.Count; i++) {
            int x = i;
            int count = 0;

            while (x > 0) {
                count += x & 1;  // Add 1 if the least significant bit is set
                x >>= 1;         // Shift right to check the next bit
            }

            if (count == k) {
                res += nums[i];  // Include value if index has k set bits
            }
        }

        return res;
    }
}
```

## 🔍 Step-by-Step Breakdown

| Step | Description |
|------|------------|
| `for (int i = 0; i < nums.Count; i++)` | We go through each index of the array `nums` |
| `int x = i` | We copy the index `i` to the temporary variable `x' for bit processing |
| `while (x > 0)` | We iterate over the bits of the number `x' until it becomes zero |
| `count += x & 1` | We increase the counter if the current bit is equal to `1` |
| `x >>= 1` | We shift the number to the right to check the next bit |
| `if (count == k)` | We check whether the number of set bits corresponds to the value `k` |
| `res += nums[i]` | If the condition is met, add `nums[i]` to the result |

---

## 🧱 Engineering Pattern: `BitCountFilter`

This pattern is the basis for tasks where you need to filter elements by the number of set bits. It is easily scalable and reusable.

### 🔧 Module: `CountSetBits`

```csharp

public static int CountSetBits(int x) {
    int count = 0;
    while (x > 0) {
        count += x & 1;
        x >>= 1;
    }
    return count;
}
```

## 🔁 Refactored Main Loop

Once the bit-counting logic is abstracted into a reusable method, your main loop becomes:

```csharp
if (CountSetBits(i) == k) {
    res += nums[i];
}
```

This single line encapsulates the entire filtering condition and aggregation step. It’s clean, expressive, and modular — ideal for competitive programming and scalable engineering.

## 🧠 Why This Matters for Your Playbook

### 🔹 Minimal Logic

The solution avoids unnecessary complexity:

- No string conversions  
- No extra data structures  
- No nested loops or branching  

Just a single pass through the array, with a lightweight bitwise operation per index.  
This keeps the time complexity at **O(n log n)** in the worst case and ensures optimal performance for input sizes up to 1000.

---

### 🔹 Clear Intent

The logic communicates exactly what it does:

- It filters indices based on the number of set bits in their binary representation  
- It aggregates values from `nums` only when the condition is met  

This clarity makes the code easy to read, debug, and explain — especially in interviews or team reviews.

---

### 🔹 Reusable Pattern

The `BitCountFilter` is not just for this problem. It generalizes to many other scenarios:

| Use Case             | Description                                      |
|----------------------|--------------------------------------------------|
| Subset XOR problems  | Filter subsets based on bitmask density          |
| Parity checks        | Include elements with even or odd bit counts     |
| Bitmask DP           | Use bit-count as a state dimension               |
| Binary classification| Group indices or values by bit-count tiers       |

You can easily swap out the condition (`== k`, `>= k`, `% 2 == 0`) or the action (`sum`, `max`, `XOR`) to adapt this pattern to new problems.

---

### 🔹 Competitive-Ready

This pattern is:

- **Fast**: Uses bitwise operations instead of string parsing  
- **Readable**: One-liner logic with clear naming  
- **Benchmarkable**: Easy to test and profile across input sizes  
- **Modular**: Can be dropped into any solution without modification  

It aligns perfectly with your style: **minimal**, **expressive**, and **architecturally sound**.

---

## ✅ Final Takeaway

The `BitCountFilter` pattern is a **foundational tool** in your engineering playbook.  
It transforms low-level bitwise logic into a high-level, reusable abstraction.

By isolating the bit-counting logic and embedding it into a clean loop, you gain:

- **Speed** without sacrificing clarity  
- **Modularity** without losing control  
- **Scalability** across problem types  

This is the kind of pattern that turns solved problems into **reusable modules**,  
and coding sprints into **systematic breakthroughs**.

**Add it to your playbook, tag it, and reuse it — it’s a keeper.**



---

# Earliest Finish Time for Land and Water Rides

## Problem:

 You are given two types of theme park rides: land rides and water rides.

Land rides:

- landStartTime[i] — earliest time the i-th land ride can start.
- landDuration[i] — duration of the i-th land ride.

Water rides:

- waterStartTime[j] — earliest time the j-th water ride can start.
- waterDuration[j] — duration of the j-th water ride.

**A tourist must ride exactly one ride from each category, in any order.**
Goal: Return the earliest possible time the tourist can finish both rides.

---

## Rules:

- A ride can start at or after its start time.
- After finishing one ride, the tourist can immediately start the other ride if it’s already open, or wait until it opens.

## Example:

```
Input:

landStartTime = [2,8], landDuration = [4,1]
waterStartTime = [6], waterDuration = [3]

Output: 9
```

## Explanation:

- Plan A: Land ride 0 → Water ride 0 → finish at 9
- Plan B: Water ride 0 → Land ride 1 → finish at 10
- Plan C: Land ride 1 → Water ride 0 → finish at 12
- Plan D: Water ride 0 → Land ride 0 → finish at 13

Earliest finish: 9 (Plan A)

Solution Approach:

- Brute-force all pairs of land and water rides (O(n * m) complexity).

For each pair (i, j), compute both orders:

```
Land → Water

start_land = max(landStartTime[i], 0)
end_land = start_land + landDuration[i]
start_water = max(waterStartTime[j], end_land)
endTime1 = start_water + waterDuration[j]
```

```
Water → Land

start_water = max(waterStartTime[j], 0)
end_water = start_water + waterDuration[j]
start_land = max(landStartTime[i], end_water)
endTime2 = start_land + landDuration[i]
```

- Take the minimum finish time among both orders.
- Track the global minimum over all pairs.

## Why it works:

- Every ride has its own start time and duration.
- Both sequences must be considered because the earliest finish depends on which ride is first.
- Math.Max ensures waiting until the ride opens if you arrive early.
- Math.Min ensures we get the earliest finish.


```csharp
public class Solution {
    public int EarliestFinishTime(int[] landStartTime, int[] landDuration, int[] waterStartTime, int[] waterDuration) {
         int n = landStartTime.Length;
         int m = waterStartTime.Length;
         int total = int.MaxValue;

       for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
      

        int start_land = Math.Max(landStartTime[i], 0);
        int end_land = start_land + landDuration[i];
        int start_water_after_land = Math.Max(waterStartTime[j], end_land);
        int endTime1 = start_water_after_land + waterDuration[j];

        int start_water = Math.Max(waterStartTime[j], 0);
        int end_water = start_water + waterDuration[j];
        int start_land_after_water = Math.Max(landStartTime[i], end_water);
        int endTime2 = start_land_after_water + landDuration[i];

      
        int nTime = Math.Min(endTime1, endTime2);
        total = Math.Min(total, nTime);
    }
}

 return total;

    }
}
```


## Complexity:

- Time: O(n * m)

- Space: O(1) — only a few extra variables.

## Key Takeaways:

- Consider all pairs of rides.

- Compute both sequences (land → water, water → land).
- Use Math.Max to handle waiting.
- Track minimum finish time across all combinations.
- Simple, correct, and efficient for given constraints (n, m ≤ 100).




---


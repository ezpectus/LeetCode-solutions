## Problem: 999. Available Captures for Rook

### ğŸ“œ Description
Given an 8Ã—8 chessboard matrix, return the number of black pawns `'p'` the white rook `'R'` can capture.  
The rook moves horizontally and vertically until blocked by another piece (`'B'` bishop or `'p'` pawn).  
It cannot move diagonally or through other pieces.

### ğŸ§© Constraints
- `board.length == 8`
- `board[i].length == 8`
- Each cell is one of: `'R'`, `'p'`, `'B'`, `'.'`
- Exactly one `'R'` on the board

---

## ğŸ” Observations from Constraints
- Fixed size â†’ no need for bounds checks beyond 0â€“7
- Only 4 directions: up, down, left, right
- Rook stops at first `'B'` or `'p'`
- Only `'p'` counts as a capture
- Simulation-style movement â†’ step-by-step scan

---

## ğŸ’¡ Idea
- Find the position of `'R'`
- For each of 4 directions:
  - Move step-by-step until hitting edge or `'B'`
  - If `'p'` is found â†’ count +1 and break
- Return total count

---

## ğŸ§± Code C# 

```public class Solution {
    public int NumRookCaptures(char[][] board) {
        int x = 0, y = 0;

        // Find rook position
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 8; ++j) {
                if (board[i][j] == 'R') {
                    x = i;
                    y = j;
                    break;
                }
            }
        }

        int count = 0;
        int[][] dirs = new int[][] {
            new int[] {0, 1}, new int[] {0, -1},
            new int[] {1, 0}, new int[] {-1, 0}
        };

        foreach (var dir in dirs) {
            int i = x + dir[0], j = y + dir[1];
            while (i >= 0 && i < 8 && j >= 0 && j < 8) {
                if (board[i][j] == 'B') break;
                if (board[i][j] == 'p') {
                    count++;
                    break;
                }
                i += dir[0];
                j += dir[1];
            }
        }

        return count;
    }
}

```

## â±ï¸ Complexity
- Time: O(1) â€” fixed 8Ã—8 board, constant scan
- Space: O(1) â€” no extra structures beyond direction array

## ğŸ§  Key Tricks

- dirs[][] â†’ clean direction simulation
- Early break on 'B' or 'p' â†’ avoids overstepping
- No recursion, no dynamic allocation â†’ pure control

---

## Problem: 999. Available Captures for Rook

### 📜 Description
Given an 8×8 chessboard matrix, return the number of black pawns `'p'` the white rook `'R'` can capture.  
The rook moves horizontally and vertically until blocked by another piece (`'B'` bishop or `'p'` pawn).  
It cannot move diagonally or through other pieces.

### 🧩 Constraints
- `board.length == 8`
- `board[i].length == 8`
- Each cell is one of: `'R'`, `'p'`, `'B'`, `'.'`
- Exactly one `'R'` on the board

---

## 🔍 Observations from Constraints
- Fixed size → no need for bounds checks beyond 0–7
- Only 4 directions: up, down, left, right
- Rook stops at first `'B'` or `'p'`
- Only `'p'` counts as a capture
- Simulation-style movement → step-by-step scan

---

## 💡 Idea
- Find the position of `'R'`
- For each of 4 directions:
  - Move step-by-step until hitting edge or `'B'`
  - If `'p'` is found → count +1 and break
- Return total count

---

## 🧱 Code C# 

```public class Solution {
    public int NumRookCaptures(char[][] board) {
        int x = 0, y = 0;

        // Find rook position
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 8; ++j) {
                if (board[i][j] == 'R') {
                    x = i;
                    y = j;
                    break;
                }
            }
        }

        int count = 0;
        int[][] dirs = new int[][] {
            new int[] {0, 1}, new int[] {0, -1},
            new int[] {1, 0}, new int[] {-1, 0}
        };

        foreach (var dir in dirs) {
            int i = x + dir[0], j = y + dir[1];
            while (i >= 0 && i < 8 && j >= 0 && j < 8) {
                if (board[i][j] == 'B') break;
                if (board[i][j] == 'p') {
                    count++;
                    break;
                }
                i += dir[0];
                j += dir[1];
            }
        }

        return count;
    }
}

```

## ⏱️ Complexity
- Time: O(1) — fixed 8×8 board, constant scan
- Space: O(1) — no extra structures beyond direction array

## 🧠 Key Tricks

- dirs[][] → clean direction simulation
- Early break on 'B' or 'p' → avoids overstepping
- No recursion, no dynamic allocation → pure control

---

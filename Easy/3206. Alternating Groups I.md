# Intuition
We are asked to count how many elements in a circular array form an "alternating group" — where the left and right neighbors are equal, and the current element is different from them. This pattern resembles [x, y, x], where y ≠ x.

 # Approach
We iterate through the array and, for each index i, compute its previous and next neighbors using modular arithmetic:

prev = (i - 1 + n) % n

next = (i + 1) % n

This ensures correct wrap-around behavior for circular indexing. Then we check if colors[prev] == colors[next] and colors[i] != colors[prev]. If so, we increment our result counter.

 # Complexity
Time complexity: $$O(n)$$ — single pass through the array

Space complexity: $$O(1)$$ — constant extra space

 # Code
```csharp
public class Solution {
    public int NumberOfAlternatingGroups(int[] colors) {
        int n = colors.Length;
        int res = 0;

        for (int i = 0; i < n; i++) {
            int prev = (i - 1 + n) % n;
            int next = (i + 1) % n;

            if (colors[prev] == colors[next] && colors[i] != colors[prev]) {
                res++;
            }
        }

        return res;
    }
}
```



----

# ðŸ§  Module: Minimum Operations to Collect `{1..k}` â€” Reverse Scan

## ðŸ“Œ Problem Statement

Given an array `nums` of positive integers and an integer `k`,  
you can remove the **last element** of the array in one operation and add it to your collection.  
Return the **minimum number of operations** needed to collect **all elements from `1` to `k`**.

---

## ðŸ§© Architectural Insight

### âœ… Signals from the problem:
- Removal is **from the end** â†’ reverse traversal
- Target set is `{1, 2, ..., k}` â†’ bounded, known size
- Only values `â‰¤ k` are relevant â†’ filter by value
- Stop when all `k` elements are collected â†’ `seen.Count == k`

---

## ðŸ”§ Strategy

1. Traverse `nums` **in reverse** (from end to start)
2. Use a `HashSet<int>` to track collected elements
3. For each element:
   - If `â‰¤ k` â†’ add to `seen`
   - Increment operation count
   - If `seen.Count == k` â†’ break early
4. Return total operations performed

---

## âœ… C# Implementation

```csharp
public class Solution {
    public int MinOperations(IList<int> nums, int k) {
        var seen = new HashSet<int>();
        int n = nums.Count;
        int ops = 0;

        for (int i = n - 1; i >= 0; i--) {
            if (nums[i] <= k) {
                seen.Add(nums[i]);
            }
            ops++;
            if (seen.Count == k) break;
        }

        return ops;
    }
}
```

## ðŸ“¦ Complexity Analysis

| Aspect         | Value             | Explanation                                                                 |
|----------------|-------------------|------------------------------------------------------------------------------|
| Time           | `O(n)`            | Worst case: scan entire array from end. Each element is visited once.       |
| Space          | `O(k)`            | HashSet stores up to `k` unique elements from the target range `{1..k}`.    |
| Edge cases     | Handled inline    | Guaranteed that `{1..k}` are present in `nums`, so no extra validation needed. |
| Total runtime  | Ultra-fast        | Efficient for `n â‰¤ 50`, `k â‰¤ n`. Executes in microseconds.                  |
| Failure modes  | None              | Input constraints guarantee safe execution. No risk of nulls or out-of-range values. |

---

### ðŸ§  Architectural Notes

- This is a **reverse scan with bounded collection**,  
  where the goal is to **filter and accumulate** a known target set `{1..k}`.
- The use of `HashSet` ensures **uniqueness** and **constant-time lookup**.
- Early termination via `seen.Count == k` prevents unnecessary work and improves performance.
- The solution is **stateless**, **branchless**, and **modular** â€” ideal for interview-grade performance and real-time systems.



---

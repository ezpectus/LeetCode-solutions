# ğŸ§  Module: Bitwise OR Trailing Zeros â€” Pairwise Check

## ğŸ“Œ Problem Statement

Given an array `nums` of positive integers,  
check if it's possible to select **two or more elements** such that their **bitwise OR**  
has **at least one trailing zero** in its binary representation.

Return `true` if such a selection exists, otherwise return `false`.

---

## ğŸ§© Architectural Insight

### âœ… Signals from the problem:
- â€œTrailing zeroâ€ â†’ means **least significant bit is 0** â†’ number is **even**
- â€œBitwise OR of selected elementsâ€ â†’ aggregate bits via `|`
- â€œTwo or more elementsâ€ â†’ check all **pairs**

### â— Key condition:
- If `a | b` is **even** â†’ it has a trailing zero â†’ return `true`

---

## ğŸ”§ Strategy

1. Iterate over all pairs `(i, j)` where `i < j`
2. Compute `nums[i] | nums[j]`
3. If result is **even** â†’ trailing zero exists â†’ return `true`
4. If no such pair found â†’ return `false`

---

## âœ… C# Implementation

```csharp
public class Solution {
    public bool HasTrailingZeros(int[] nums) {
        int n = nums.Length;

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (((nums[i] | nums[j]) & 1) == 0) {
                    return true;
                }
            }
        }

        return false;
    }
}
```

## ğŸ“¦ Complexity Analysis

| Aspect         | Value             | Explanation                                                                 |
|----------------|-------------------|------------------------------------------------------------------------------|
| Time           | `O(nÂ²)`           | We iterate over all pairs `(i, j)` once. For `n â‰¤ 100`, this results in at most 4950 iterations â€” fast and acceptable. |
| Space          | `O(1)`            | No additional data structures are used. Only counters and temporary variables. |
| Bitwise ops    | Constant time     | Bitwise `|` and `&` operations run in constant time on 32-bit integers.      |
| Edge cases     | Handled inline    | If no pair produces an even result, we return `false` directly â€” no extra logic required. |
| Total runtime  | Fast              | For small arrays (up to 100 elements), the algorithm runs instantly. No delays or bottlenecks. |
| Scalability    | Locally bounded   | For larger `n`, optimization would be needed, but within the given constraints, itâ€™s ideal. |
| Failure modes  | None              | Input constraints guarantee safe execution: all numbers are positive, and array length â‰¥ 2. |

---

### ğŸ§  Architectural Notes

- This is a case of **bitwise aggregation and parity filtering**.
- The check `((a | b) & 1) == 0` acts as a clean architectural signal: trailing zero detected.
- No need to store intermediate OR values â€” everything is verified on the fly.
- Suitable for embedded systems, competitive programming, and FAANG interviews where speed and clarity matter.



---

# 🧠 Module: Bitwise OR Trailing Zeros — Pairwise Check

## 📌 Problem Statement

Given an array `nums` of positive integers,  
check if it's possible to select **two or more elements** such that their **bitwise OR**  
has **at least one trailing zero** in its binary representation.

Return `true` if such a selection exists, otherwise return `false`.

---

## 🧩 Architectural Insight

### ✅ Signals from the problem:
- “Trailing zero” → means **least significant bit is 0** → number is **even**
- “Bitwise OR of selected elements” → aggregate bits via `|`
- “Two or more elements” → check all **pairs**

### ❗ Key condition:
- If `a | b` is **even** → it has a trailing zero → return `true`

---

## 🔧 Strategy

1. Iterate over all pairs `(i, j)` where `i < j`
2. Compute `nums[i] | nums[j]`
3. If result is **even** → trailing zero exists → return `true`
4. If no such pair found → return `false`

---

## ✅ C# Implementation

```csharp
public class Solution {
    public bool HasTrailingZeros(int[] nums) {
        int n = nums.Length;

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (((nums[i] | nums[j]) & 1) == 0) {
                    return true;
                }
            }
        }

        return false;
    }
}
```

## 📦 Complexity Analysis

| Aspect         | Value             | Explanation                                                                 |
|----------------|-------------------|------------------------------------------------------------------------------|
| Time           | `O(n²)`           | We iterate over all pairs `(i, j)` once. For `n ≤ 100`, this results in at most 4950 iterations — fast and acceptable. |
| Space          | `O(1)`            | No additional data structures are used. Only counters and temporary variables. |
| Bitwise ops    | Constant time     | Bitwise `|` and `&` operations run in constant time on 32-bit integers.      |
| Edge cases     | Handled inline    | If no pair produces an even result, we return `false` directly — no extra logic required. |
| Total runtime  | Fast              | For small arrays (up to 100 elements), the algorithm runs instantly. No delays or bottlenecks. |
| Scalability    | Locally bounded   | For larger `n`, optimization would be needed, but within the given constraints, it’s ideal. |
| Failure modes  | None              | Input constraints guarantee safe execution: all numbers are positive, and array length ≥ 2. |

---

### 🧠 Architectural Notes

- This is a case of **bitwise aggregation and parity filtering**.
- The check `((a | b) & 1) == 0` acts as a clean architectural signal: trailing zero detected.
- No need to store intermediate OR values — everything is verified on the fly.
- Suitable for embedded systems, competitive programming, and FAANG interviews where speed and clarity matter.



---

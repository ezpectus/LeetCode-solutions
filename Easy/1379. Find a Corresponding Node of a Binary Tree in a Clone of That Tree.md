# 🧠 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree

## 🔗 Problem Statement

Given two binary trees `original` and `cloned`, and a reference to a node `target` in the original tree, return the **corresponding node** in the cloned tree.

- The cloned tree is a **deep copy** of the original.
- You must return a **reference** to the node in the cloned tree that matches `target`.
- You **cannot modify** either tree or the target node.

### Constraints
- `1 <= number of nodes <= 10^4`
- Node values are **unique**
- `target` is guaranteed to be a node in `original`

---

## ✅ Signals

- Traverse both trees **in parallel**
- When `original == target`, return `cloned`
- Use **DFS** (pre-order) to locate the node
- If values were not unique, you'd need **reference comparison**, not value matching

---

## 🧩 Solution 1 — Explicit Left/Right Search

```csharp
public class Solution {
    public TreeNode GetTargetCopy(TreeNode original, TreeNode cloned, TreeNode target) {
        if (original == null || cloned == null) return null;
        if (original == target) return cloned;

        var left = GetTargetCopy(original.left, cloned.left, target);
        if (left != null) return left;

        var right = GetTargetCopy(original.right, cloned.right, target);
        if (right != null) return right;

        return null;
    }
}
```

## 🔍 Notes

- Uses short-circuit logic: returns as soon as match is found
- original == target compares reference, not value
- Works even if values are repeated (follow-up case)

## 🧩 Solution 2 — Compact Return Expression
```csharp
 public class Solution {
    public TreeNode GetTargetCopy(TreeNode original, TreeNode cloned, TreeNode target) {
        if (original == null || cloned == null) return null;
        if (original == target) return cloned;

        TreeNode left = GetTargetCopy(original.left, cloned.left, target);
        TreeNode right = GetTargetCopy(original.right, cloned.right, target);
        return left ?? right;
    }
}
```

## 🔍 Notes

### ✅ Same Logic, More Compact

Both solutions implement the same recursive DFS traversal, comparing `original` and `target` by **reference**, not value.  
The second version uses a more concise return expression, improving readability without changing behavior.

### 🧪 `??` Operator — Null-Coalescing

```csharp
return left ?? right;
```
#### This line means:

- If left is not null, return it.

- Otherwise, return right.

- It's equivalent to:

```csharp
if (left != null) return left;
return right;
```
This operator is useful for short-circuiting recursive searches where only one result is expected.

## 📦 Repo Benefit
- Using ?? reduces boilerplate and keeps the recursive structure clean.
- In signal-driven repos, this improves pattern clarity and copy-paste efficiency.

## 🧠 Follow-up: Repeated Values in Tree
❗ Problem Shift
- If node values are not unique, you cannot rely on node.val == target.val.
- Instead, you must compare object references — i.e., check if the actual memory address matches.

## ✅ Why Current Solutions Still Work

Both solutions use:
```csharp
if (original == target) return cloned;
```
- This compares the actual node reference, not the value.
-  So even if multiple nodes have the same value, only the exact target node will match.

## 🧠 Signal Summary — Reference vs Value Matching

| Case             | Comparison Type              | ✅ Validity               |
|------------------|------------------------------|---------------------------|
| Unique values    | `original.val == target.val` | ✅ Valid, but not required |
| Repeated values  | `original == target`         | ✅ Required                |
| Current solution | `original == target`         | ✅ Safe for both cases     |

---

### 🔍 Key Takeaways

- `original == target` compares **object references**, not values.  
  This ensures correctness even when multiple nodes share the same value.

- The problem guarantees **unique values**, but the follow-up removes that constraint.  
  Your solution remains valid because it relies on **reference identity**, not value equality.

- If you had used `original.val == target.val`, it would break in the follow-up case.  
  Two nodes with the same value could exist, but only one is the true target.

---

### ✅ Repo Signal

This pattern is **safe**, **scalable**, and **future-proof**.  
It handles both unique and repeated values without modification.

Use this as a reference-matching template for any cloned structure traversal.





---

# üß† Leetcode 897: Increasing Order Search Tree

## üìå Problem Statement

Given the root of a Binary Search Tree (BST), rearrange the tree in in-order so that:
- The leftmost node becomes the new root.
- Each node has **no left child**.
- Each node has **only one right child**.
- The resulting tree is a **right-skewed version** of the original BST, preserving in-order traversal.

### üîç Example

**Input:**  
`[5,3,6,2,4,null,8,1,null,null,null,7,9]`

**Output:**  
`[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]`

---

## üí° Core Idea

Use **in-order traversal** to visit nodes in ascending order.  
While traversing, construct a new tree by attaching each visited node to the **right** of the previously added node.

This guarantees:
- Sorted order (in-order traversal of BST)
- No left children
- Right-only structure

---

## üß† Why This Works

- BST in-order traversal naturally yields values in ascending order.
- By creating a new node for each visited value and chaining them via `.right`, we preserve order and enforce the right-only constraint.
- A dummy node simplifies pointer management and avoids edge cases for the first node.

---

## üß± Approach Summary

1. Create a **dummy node** to serve as the anchor.
2. Use a **global pointer** (`curr`) to track the tail of the new tree.
3. Traverse the original tree using **in-order recursion**.
4. At each node:
   - Create a new node with the current value.
   - Attach it to `curr.right`.
   - Move `curr` forward.
5. Return `dummy.right` as the new root.

---

## üîÅ Step-by-Step Breakdown

| Step | Action |
|------|--------|
| 1    | Initialize dummy node `bst = new TreeNode(-1)` |
| 2    | Set `curr = bst` |
| 3    | Call recursive `inorder(root)` |
| 4    | Traverse left subtree |
| 5    | Create new node with `node.val`, attach to `curr.right` |
| 6    | Move `curr` to the newly created node |
| 7    | Traverse right subtree |
| 8    | Return `bst.right` as the new root |

---

## üß© Code Implementation

```csharp
public class Solution {
    TreeNode curr = null;

    private void inorder(TreeNode node){
        if(node == null) return;

        inorder(node.left);                         // Traverse left
        curr.right = new TreeNode(node.val);        // Create and attach new node
        curr = curr.right;                          // Move pointer forward
        inorder(node.right);                        // Traverse right
    }

    public TreeNode IncreasingBST(TreeNode root) {
        TreeNode bst = new TreeNode(-1);            // Dummy root
        curr = bst;                                 // Initialize pointer
        inorder(root);                              // Start traversal
        return bst.right;                           // Return new root
    }
}
```


## üìñ Explanation of Code

- `curr` is a global pointer used to build the new tree incrementally.
- `inorder()` is a recursive function that performs in-order traversal of the original BST.

### üîÅ At each node, the process is:

1. Visit the left subtree.
2. Create a new node with `node.val`.
3. Attach it to the right of `curr`.
4. Move `curr` forward to the newly created node.
5. Visit the right subtree.

- The dummy node `bst` simplifies the logic by acting as a placeholder before the first real node is added.  
  This avoids special cases for the first insertion.

---

## ‚è±Ô∏è Time and Space Complexity

| Metric           | Value  | Reasoning                          |
|------------------|--------|------------------------------------|
| Time Complexity  | O(n)   | Each node is visited exactly once |
| Space Complexity | O(h)   | Recursion stack, where h = height of the tree |

---

## üì¶ Where This Pattern Applies

- Flattening a BST into a linked list
- Serializing a BST in sorted order
- UI rendering of trees in linear form
- Rebuilding trees with structural constraints
- Functional-style tree transformations

---

## ‚úÖ Conclusion

This solution leverages the natural order of BST traversal to reconstruct a tree with strict structural rules.  
Using a dummy node and a global pointer simplifies the logic and avoids edge cases.  
The pattern is reusable for many tree transformation tasks and is a great addition to any competitive programming playbook.



---

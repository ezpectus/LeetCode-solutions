# 🧩 Problem: First Repeated Character

- Task: Given a string s, return the first character that appears more than once when scanning from left to right.
- Example: Input: "abccba" Output: 'c' — because it's the first character that repeats.

✅ Efficient Solution (HashSet-based)
```csharp
public class Solution {
    public char RepeatedCharacter(string s) {
        HashSet<char> seen = new HashSet<char>();

        foreach (char c in s) {
            if (!seen.Contains(c)) {
                seen.Add(c);
            } else {
                return c;
            }
        }

        throw new Exception("No repeated character found");
    }
}
```


## 🔍 Highlights:

- Intent clarity: Tracks presence, not count
- Minimal logic: One condition, one return
- Memory-efficient: Stores only unique characters
- Competitive style: Fast, readable, and direct
- Architectural fit: Matches the “first repeat” pattern precisely

## ❌ Alternative (Dictionary-based)

```csharp
public class Solution {
    public char RepeatedCharacter(string s) {
        Dictionary<char, int> val = new();
        foreach (char ch in s) {
            if (val.ContainsKey(ch)) {
                val[ch]++;
            } else {
                val[ch] = 1;
            }
            if (val[ch] == 2) {
                return ch;
            }
        }
        return '\0';
    }
}
```

## ⚔️ Comparison Table

| Aspect               | HashSet-based (Efficient)                    | Dictionary-based (Verbose)                     |
|----------------------|----------------------------------------------|------------------------------------------------|
| **Data Structure**    | `HashSet<char>` — tracks presence            | `Dictionary<char, int>` — tracks count         |
| **Logic Simplicity**  | One condition: `seen.Contains(c)`            | Two conditions: `ContainsKey`, then increment  |
| **Memory Usage**      | Stores only unique characters                | Stores all characters with counts              |
| **Performance**       | O(N) — fast lookup and insert                | O(N) — more operations per character           |
| **Readability**       | Clean and direct                             | Slightly noisy and verbose                     |
| **Architectural Fit** | Perfect for “first repeat” pattern           | Overkill for this specific task                |
| **Default Return**    | Throws exception (explicit failure)          | Returns `'\0'` (silent sentinel)               |

---

## 🧠 Summary

The HashSet-based solution is architecturally cleaner and better suited for competitive programming.  
It expresses the problem’s intent directly, avoids unnecessary logic, and performs efficiently.  
The Dictionary-based version works, but introduces extra complexity for a task that doesn’t require counting.

- **Pattern:** `FirstSeenRepeat`  
- **Preferred Tool:** `HashSet` over `Dictionary`  
- **Use Case:** Competitive programming, clean architecture, minimal logic





---

# ğŸ§© Problem: First Repeated Character

- Task: Given a string s, return the first character that appears more than once when scanning from left to right.
- Example: Input: "abccba" Output: 'c' â€” because it's the first character that repeats.

âœ… Efficient Solution (HashSet-based)
```csharp
public class Solution {
    public char RepeatedCharacter(string s) {
        HashSet<char> seen = new HashSet<char>();

        foreach (char c in s) {
            if (!seen.Contains(c)) {
                seen.Add(c);
            } else {
                return c;
            }
        }

        throw new Exception("No repeated character found");
    }
}
```


## ğŸ” Highlights:

- Intent clarity: Tracks presence, not count
- Minimal logic: One condition, one return
- Memory-efficient: Stores only unique characters
- Competitive style: Fast, readable, and direct
- Architectural fit: Matches the â€œfirst repeatâ€ pattern precisely

## âŒ Alternative (Dictionary-based)

```csharp
public class Solution {
    public char RepeatedCharacter(string s) {
        Dictionary<char, int> val = new();
        foreach (char ch in s) {
            if (val.ContainsKey(ch)) {
                val[ch]++;
            } else {
                val[ch] = 1;
            }
            if (val[ch] == 2) {
                return ch;
            }
        }
        return '\0';
    }
}
```

## âš”ï¸ Comparison Table

| Aspect               | HashSet-based (Efficient)                    | Dictionary-based (Verbose)                     |
|----------------------|----------------------------------------------|------------------------------------------------|
| **Data Structure**    | `HashSet<char>` â€” tracks presence            | `Dictionary<char, int>` â€” tracks count         |
| **Logic Simplicity**  | One condition: `seen.Contains(c)`            | Two conditions: `ContainsKey`, then increment  |
| **Memory Usage**      | Stores only unique characters                | Stores all characters with counts              |
| **Performance**       | O(N) â€” fast lookup and insert                | O(N) â€” more operations per character           |
| **Readability**       | Clean and direct                             | Slightly noisy and verbose                     |
| **Architectural Fit** | Perfect for â€œfirst repeatâ€ pattern           | Overkill for this specific task                |
| **Default Return**    | Throws exception (explicit failure)          | Returns `'\0'` (silent sentinel)               |

---

## ğŸ§  Summary

The HashSet-based solution is architecturally cleaner and better suited for competitive programming.  
It expresses the problemâ€™s intent directly, avoids unnecessary logic, and performs efficiently.  
The Dictionary-based version works, but introduces extra complexity for a task that doesnâ€™t require counting.

- **Pattern:** `FirstSeenRepeat`  
- **Preferred Tool:** `HashSet` over `Dictionary`  
- **Use Case:** Competitive programming, clean architecture, minimal logic





---

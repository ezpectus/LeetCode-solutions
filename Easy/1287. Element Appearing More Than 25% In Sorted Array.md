# 🧠 Leetcode 1287: Element Appearing More Than 25% — Engineering Breakdown

## 📌 Problem Statement
Given a sorted array, return the one element that appears more than 25% of the time.

Constraints:

- Array is sorted in non-decreasing order.
- Exactly one element satisfies the condition.

## 💡 Core Idea
Because the array is sorted, any element that appears 
frequently will occupy a contiguous block. So instead of counting frequencies, we can use a fixed interval check.

## 🧠 Why It Works

Let n = arr.length. If an element appears more than 25% of the time, then:
It must span at least n / 4 + 1 positions.
So if arr[i] == arr[i + n / 4], then arr[i] appears ≥ 25% of the time.

This works because:

The array is sorted → duplicates are grouped.

We only need to check a few positions → fast and memory-efficient.

## 🔁 Step-by-Step Breakdown — Leetcode 1287

| Step | Action |
|------|--------|
| 1    | Compute `n = arr.length` |
| 2    | Compute `span = n / 4` |
| 3    | Loop through `i` from `0` to `n - span` |
| 4    | If `arr[i] == arr[i + span]`, return `arr[i]` |
| 5    | If no match found (theoretically impossible), return `-1` |


🧩 Code Implementation (C#)

```csharp
public class Solution {
    public int FindSpecialInteger(int[] arr) {
        int n = arr.Length;
        int span = n / 4;

        for (int i = 0; i + span < n; i++) {
            if (arr[i] == arr[i + span]) {
                return arr[i];
            }
        }

        return -1; // fallback, should never happen
    }
}
```

## 📖 Explanation of Logic

- span is the interval we use to check frequency.
- If arr[i] == arr[i + span], then the element spans enough positions to meet the 25% threshold.
- We don’t need to count — we just leverage the sorted structure.

## ⏱️ Time and Space Complexity

| Metric           | Value     | Reasoning                    |
|------------------|-----------|------------------------------|
| Time Complexity  | O(n / 4)  | Only a few checks needed     |
| Space Complexity | O(1)      | No extra memory used         |


## 📦 Where This Pattern Applies

- Frequency detection in sorted arrays
- Duplicate analysis without hash maps
- Interval-based optimization
- Sorted data with guaranteed frequency bounds

## ✅ Conclusion
This task is deceptively simple — but only if you leverage the sorted structure. 
Instead of brute-force counting, we use interval checks to detect frequency. 
This pattern is fast, elegant, and reusable in many frequency-based problems.




---

# 2215. Find the Difference of Two Arrays

## 🧠 Intuition  
We are given two integer arrays and asked to find the distinct elements that exist in one array but not in the other.  
This is a classic case of **set comparison**, where we want to extract the **asymmetric difference** between two sets.

The key insight is that:
- We only care about **unique elements**
- We want to know what exists in `nums1` but not in `nums2`, and vice versa
- Duplicates should be ignored, and order doesn't matter

---

## ⚙️ Approach  
We use `HashSet<int>` to eliminate duplicates and allow fast lookup.

Steps:
1. Convert both arrays into sets: `set1` and `set2`
2. Iterate through `set1` and collect elements not present in `set2`
3. Do the same for `set2` against `set1`
4. Return both result lists as a nested list

This approach ensures:
- ✅ **Uniqueness** of elements (via sets)  
- ✅ **Efficient lookup** (via `Contains`)  
- ✅ **Clear separation** of what belongs uniquely to each array

---

## 📊 Complexity  
- **Time complexity:**  
  $$O(n + m)$$  
  - Building sets: $$O(n + m)$$  
  - Iterating and comparing: $$O(n + m)$$  

- **Space complexity:**  
  $$O(n + m)$$  
  - For storing sets and result lists

---

## 🧱 Pattern Name  
**Set Difference Extraction**

Used when:
- You need to find elements unique to each collection  
- Duplicates should be ignored  
- Order doesn't matter  
- Fast membership testing is required

---

## 💻 Code  
```csharp
public class Solution {
    public IList<IList<int>> FindDifference(int[] nums1, int[] nums2) {
        var set1 = new HashSet<int>(nums1);
        var set2 = new HashSet<int>(nums2);

        var res1 = new List<int>();
        var res2 = new List<int>();

        foreach (int num in set1) {
            if (!set2.Contains(num)) {
                res1.Add(num);
            }
        }

        foreach (int num in set2) {
            if (!set1.Contains(num)) {
                res2.Add(num);
            }
        }

        return new List<IList<int>> { res1, res2 };
    }
}

```

# 🧠 Pattern: Most Frequent Element After Key

## 📌 Use Case
Given an integer array `nums` and a specific `key`, find the element that most frequently appears **immediately after** `key`.  
This is useful in sequential frequency tracking, trigger-based prediction, or behavioral modeling.

---

## ⚙️ Core Logic

```csharp
public class Solution {
    public int MostFrequent(int[] nums, int key) {
        var freq = new Dictionary<int,int>();
        int n = nums.Length;
        int target = 0;


     for(int i =0; i < n-1;i++){
        if(nums[i] == key){
            target = nums[i+1];

            if(!freq.ContainsKey(target)) freq[target] = 0;
            freq[target]++;
        }
     }

     int res = -1;
     int maxVal = 0;

     foreach(var kvp in freq){
        if(kvp.Value > maxVal){
            maxVal = kvp.Value;
            res = kvp.Key;
        }
     }

   return res;

    }
}
```


## 🚨 Edge Cases

| Case                      | Behavior                                      |
|--------------------------|-----------------------------------------------|
| `nums.Length < 2`        | No valid `i + 1` → returns default `-1`       |
| `key` never appears      | `freq` stays empty → returns `-1`             |
| Multiple targets tied    | Returns first one with max frequency          |
| Negative or large values | Dictionary handles all valid `int` keys       |

---

## 🧪 Test Scenarios

### ✅ Easy

```csharp
MostFrequent([1, 2, 2, 3, 2, 4], key = 2) → 3
// 2 → 3 and 2 → 4 → both once, but 3 comes first
```
```
MostFrequent([1, 2, 3, 2, 3, 2, 3], key = 2) → 3
// 2 → 3 three times
```
## 🧠 Mid (to be expanded)

- **Multiple keys with different targets**  
  Handle cases where multiple keys trigger different targets. Requires grouping or layered frequency maps.

- **Sparse triggers with noisy data**  
  When `key` appears rarely and data is noisy, frequency estimates may be unreliable. Consider smoothing or fallback strategies.

- **Targets that are equal to key**  
  Edge case where `nums[i] == key` and `nums[i + 1] == key`. May need to distinguish self-loops vs true transitions.

---

## 🔥 Hard (to be expanded)

- **Streaming input (online variant)**  
  Process data as it arrives, maintaining frequency counts without full array access. Use sliding windows or rolling maps.

- **Memory-constrained frequency tracking**  
  When dictionary size must be bounded. Use approximate counters (e.g. Count-Min Sketch) or eviction strategies.

- **Parallelized frequency aggregation**  
  Split input across threads or machines, aggregate local frequency maps, then merge. Requires conflict resolution and consistency guarantees.

---

## 🧠 Engineering Insight

This pattern is a subset of **triggered frequency analysis**, where a specific condition (`key`) activates tracking of subsequent behavior (`target`).  
It’s useful in modeling:

- **Event-driven systems**  
- **User behavior prediction**  
- **Sequential pattern mining**

---

### 🔄 Can be generalized to:

- **k-step lookahead**  
  Track not just `i + 1`, but `i + k` for richer context.

- **Conditional triggers**  
  Replace `nums[i] == key` with flexible conditions like `nums[i] < key` or `nums[i] % 2 == 0`.

- **Weighted frequency**  
  Assign weights based on position, time, or external signals.
  Useful in time-series or priority-based systems.


---

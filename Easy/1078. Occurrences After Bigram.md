# üí° Intuition
The problem asks us to find all words that appear immediately after a specific bigram ‚Äî that is, a pair of consecutive words (`first`, `second`) ‚Äî within a given text.  
The key insight is that we can treat the input as a linear stream of tokens and scan for the pattern `[first, second, target]`, where `target` is the word we want to collect.

---

# üß≠ Approach

- **Tokenize the input**:  
  Split the input string `text` into an array of words using `Split(" ")`.

- **Iterate through the array**:  
  Loop through the array from index `0` to `words.Length - 2`, since we need to check `words[i]`, `words[i+1]`, and potentially access `words[i+2]`.

- **Pattern match**:  
  For each index `i`, check if `words[i] == first` and `words[i+1] == second`.  
  If so, and if `i + 2 < words.Length`, then `words[i+2]` is a valid match and should be added to the result list.

- **Return result**:  
  Convert the result list to an array and return it.

---

# ‚è±Ô∏è Complexity

- **Time complexity**:  
  $$O(n)$$ ‚Äî where \( n \) is the number of words in the input string.  
  We perform a single pass through the array and constant-time checks per iteration.

- **Space complexity**:  
  $$O(k)$$ ‚Äî where \( k \) is the number of matches found.  
  We store only the words that follow the matched bigrams.

---

# ‚úÖ Code
```csharp
public class Solution {
    public string[] FindOcurrences(string text, string first, string second) {
        string[] words = text.Split(" ");
        var res = new List<string>();

        for (int i = 0; i < words.Length - 2; i++) {
            if (words[i] == first && words[i + 1] == second) {
                res.Add(words[i + 2]);
            }
        }

        return res.ToArray();
    }
}

```


# üß† Engineering Notes

‚úÖ `words.Length - 2` ensures safe access to `words[i+2]` without overflow.

‚úÖ Using `List<string>` allows dynamic accumulation of results.

‚ö†Ô∏è Original version had a subtle off-by-one bug due to incorrect loop bounds (`Count()-1` instead of `Length - 2`).

üß© This pattern is reusable for any trigram-based extraction logic ‚Äî useful in NLP preprocessing or log parsing.

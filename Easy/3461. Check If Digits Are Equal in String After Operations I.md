# ğŸ”¢ 3461. Check If Digits Are Equal in String After Operations I

## ğŸ§© Problem Statement

You are given a string `s` consisting of digits (`'0'` to `'9'`).  
Perform the following operation repeatedly until the string has exactly **two digits**:

- For each pair of consecutive digits in `s`, compute their **sum modulo 10**.
- Replace `s` with the sequence of these newly computed digits, preserving their order.

Return `true` if the final two digits are equal, otherwise return `false`.

---

## ğŸ“Œ Constraints

- `3 <= s.Length <= 100`  
- `s` contains only numeric characters `'0'` to `'9'`

---

## ğŸ§  Intuition

This is a **digit reduction process**.  
At each iteration, the string shrinks by one digit. The transformation rule is:

```
new[i] = (old[i] + old[i + 1]) % 10
```

This continues until only two digits remain.  
The final check is simple: are those two digits equal?

This process mimics a kind of **digit convolution**, where each layer compresses the previous one.  
Itâ€™s deterministic and bounded â€” the number of steps is always `length - 2`.

---

## ğŸ’¡ Example Walkthrough

### Input: `"3902"`

**Step 1:**
- `(3 + 9) % 10 = 2`
- `(9 + 0) % 10 = 9`
- `(0 + 2) % 10 = 2`  
â†’ New string: `"292"`

**Step 2:**
- `(2 + 9) % 10 = 1`
- `(9 + 2) % 10 = 1`  
â†’ New string: `"11"`

âœ… Final digits are equal â†’ return `true`

---

## âŒ Counter Example

### Input: `"34789"`

**Step 1:** `"7157"`  
**Step 2:** `"862"`  
**Step 3:** `"48"`

âŒ Final digits are not equal â†’ return `false`


## ğŸ§± C# Implementation

```csharp
public class Solution {
    public bool HasSameDigits(string s) {
        int n = s.Length;
        List<int> digt = new List<int>();

        foreach (char c in s) {
            digt.Add(c - '0');
        }

        int count = n - 2;

        while (count > 0) {
            count--;
            for (int i = digt.Count - 1; i > 0; i--) {
                digt[i] = (digt[i] + digt[i - 1]) % 10;
            }
        }

        return digt[n - 2] == digt[n - 1];
    }
}
```

## ğŸ” Logic Breakdown

- Convert the input string into a list of digits using character-to-integer conversion.
- Perform exactly `n - 2` reduction steps, where `n` is the original length of the string.
- In each step:
  - Traverse the digit list **from right to left**.
  - Update each digit as `(current + previous) % 10`.
  - This avoids overwriting values that are still needed for computation.
- After all reductions, the list will contain exactly two digits.
- Compare the last two digits and return the result.

This approach is **in-place**, meaning it mutates the original list without allocating new lists at each step.  
Itâ€™s memory-efficient and avoids unnecessary copying.

---

## â±ï¸ Complexity Analysis

| Metric   | Value     |
|----------|-----------|
| Time     | `O(nÂ²)`   |
| Space    | `O(n)`    |

- Each reduction step processes up to `n` digits.
- There are `n - 2` steps in total.
- Space is linear due to the initial digit list.

---

## ğŸ§  Architectural Notes

### ğŸ”§ Core Abstraction

The main logic can be extracted into a reusable method:

```csharp
public static List<int> ReduceDigitsToTwo(List<int> digits)
```
This method performs the layered digit reduction and returns the final two-digit sequence. It can be reused across similar tasks involving digit transformations.

## ğŸ” Why c - '0'?
When converting a string of digits into integers, we use:

```csharp
foreach (char c in s) {
    digt.Add(c - '0');
}
```
## âœ… Explanation:
Each character in the string represents a digit: '3', '9', '0', etc.

In C#, characters are stored as Unicode values:

'0' â†’ 48

'1' â†’ 49

'9' â†’ 57

Subtracting '0' from a digit character gives its numeric value:

'3' - '0' â†’ 51 - 48 â†’ 3

'9' - '0' â†’ 57 - 48 â†’ 9

This is a fast, idiomatic, and allocation-free way to convert digit characters to integers. It avoids using int.Parse() or Convert.ToInt32(), which are heavier and require string parsing.

## ğŸ“¦ Why Use List<int>
We use List<int> to store and manipulate the digit sequence:

## âœ… Benefits:

- Mutability: Allows in-place updates during reduction steps.
- Dynamic resizing: Handles shrinking sequences naturally.
- Index access: Supports direct access for arithmetic operations.
- Compared to arrays, List<int> is more flexible for iterative transformations. It avoids creating new lists at each step, keeping memory usage minimal.

## âš™ï¸ Optimization Notes
If performance becomes critical:

- Replace List<int> with Span<int> for stack-based memory and zero allocations.
- Use fixed-size arrays if the input size is bounded and predictable.
- Avoid LINQ or high-level abstractions during tight loops.

You can also wrap the logic into a utility class:

```csharp
public static class DigitReducer {
    public static bool AreFinalDigitsEqual(string s) { ... }
}
```
This improves modularity and testability across your repo.

ğŸ“Œ What the Task Required
This problem is not about sorting, searching, or counting. Itâ€™s about iterative transformation of a digit sequence using a fixed arithmetic rule.

## ğŸ¯ Goal:
Simulate a layered reduction using:

```text
(a + b) % 10
```
Repeat until only two digits remain, then check if they are equal.

## ğŸ§  Required Skills:

- Modeling digit sequences as mutable structures
- Applying in-place arithmetic transformations
- Managing state across multiple iterations
- Avoiding unnecessary memory usage

## ğŸ” Generalization Potential
This task is a strong example of stateful digit processing. The pattern can be generalized for:

- Rolling checksums
- Signal compression
- Educational simulations of layered transformations
- Digit-based encoding or validation systems

It fits well into a modular engineering playbook and can be reused across multiple domains.






---


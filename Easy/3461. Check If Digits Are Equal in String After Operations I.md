# 🔢 3461. Check If Digits Are Equal in String After Operations I

## 🧩 Problem Statement

You are given a string `s` consisting of digits (`'0'` to `'9'`).  
Perform the following operation repeatedly until the string has exactly **two digits**:

- For each pair of consecutive digits in `s`, compute their **sum modulo 10**.
- Replace `s` with the sequence of these newly computed digits, preserving their order.

Return `true` if the final two digits are equal, otherwise return `false`.

---

## 📌 Constraints

- `3 <= s.Length <= 100`  
- `s` contains only numeric characters `'0'` to `'9'`

---

## 🧠 Intuition

This is a **digit reduction process**.  
At each iteration, the string shrinks by one digit. The transformation rule is:

```
new[i] = (old[i] + old[i + 1]) % 10
```

This continues until only two digits remain.  
The final check is simple: are those two digits equal?

This process mimics a kind of **digit convolution**, where each layer compresses the previous one.  
It’s deterministic and bounded — the number of steps is always `length - 2`.

---

## 💡 Example Walkthrough

### Input: `"3902"`

**Step 1:**
- `(3 + 9) % 10 = 2`
- `(9 + 0) % 10 = 9`
- `(0 + 2) % 10 = 2`  
→ New string: `"292"`

**Step 2:**
- `(2 + 9) % 10 = 1`
- `(9 + 2) % 10 = 1`  
→ New string: `"11"`

✅ Final digits are equal → return `true`

---

## ❌ Counter Example

### Input: `"34789"`

**Step 1:** `"7157"`  
**Step 2:** `"862"`  
**Step 3:** `"48"`

❌ Final digits are not equal → return `false`


## 🧱 C# Implementation

```csharp
public class Solution {
    public bool HasSameDigits(string s) {
        int n = s.Length;
        List<int> digt = new List<int>();

        foreach (char c in s) {
            digt.Add(c - '0');
        }

        int count = n - 2;

        while (count > 0) {
            count--;
            for (int i = digt.Count - 1; i > 0; i--) {
                digt[i] = (digt[i] + digt[i - 1]) % 10;
            }
        }

        return digt[n - 2] == digt[n - 1];
    }
}
```

## 🔍 Logic Breakdown

- Convert the input string into a list of digits using character-to-integer conversion.
- Perform exactly `n - 2` reduction steps, where `n` is the original length of the string.
- In each step:
  - Traverse the digit list **from right to left**.
  - Update each digit as `(current + previous) % 10`.
  - This avoids overwriting values that are still needed for computation.
- After all reductions, the list will contain exactly two digits.
- Compare the last two digits and return the result.

This approach is **in-place**, meaning it mutates the original list without allocating new lists at each step.  
It’s memory-efficient and avoids unnecessary copying.

---

## ⏱️ Complexity Analysis

| Metric   | Value     |
|----------|-----------|
| Time     | `O(n²)`   |
| Space    | `O(n)`    |

- Each reduction step processes up to `n` digits.
- There are `n - 2` steps in total.
- Space is linear due to the initial digit list.

---

## 🧠 Architectural Notes

### 🔧 Core Abstraction

The main logic can be extracted into a reusable method:

```csharp
public static List<int> ReduceDigitsToTwo(List<int> digits)
```
This method performs the layered digit reduction and returns the final two-digit sequence. It can be reused across similar tasks involving digit transformations.

## 🔍 Why c - '0'?
When converting a string of digits into integers, we use:

```csharp
foreach (char c in s) {
    digt.Add(c - '0');
}
```
## ✅ Explanation:
Each character in the string represents a digit: '3', '9', '0', etc.

In C#, characters are stored as Unicode values:

'0' → 48

'1' → 49

'9' → 57

Subtracting '0' from a digit character gives its numeric value:

'3' - '0' → 51 - 48 → 3

'9' - '0' → 57 - 48 → 9

This is a fast, idiomatic, and allocation-free way to convert digit characters to integers. It avoids using int.Parse() or Convert.ToInt32(), which are heavier and require string parsing.

## 📦 Why Use List<int>
We use List<int> to store and manipulate the digit sequence:

## ✅ Benefits:

- Mutability: Allows in-place updates during reduction steps.
- Dynamic resizing: Handles shrinking sequences naturally.
- Index access: Supports direct access for arithmetic operations.
- Compared to arrays, List<int> is more flexible for iterative transformations. It avoids creating new lists at each step, keeping memory usage minimal.

## ⚙️ Optimization Notes
If performance becomes critical:

- Replace List<int> with Span<int> for stack-based memory and zero allocations.
- Use fixed-size arrays if the input size is bounded and predictable.
- Avoid LINQ or high-level abstractions during tight loops.

You can also wrap the logic into a utility class:

```csharp
public static class DigitReducer {
    public static bool AreFinalDigitsEqual(string s) { ... }
}
```
This improves modularity and testability across your repo.

📌 What the Task Required
This problem is not about sorting, searching, or counting. It’s about iterative transformation of a digit sequence using a fixed arithmetic rule.

## 🎯 Goal:
Simulate a layered reduction using:

```text
(a + b) % 10
```
Repeat until only two digits remain, then check if they are equal.

## 🧠 Required Skills:

- Modeling digit sequences as mutable structures
- Applying in-place arithmetic transformations
- Managing state across multiple iterations
- Avoiding unnecessary memory usage

## 🔁 Generalization Potential
This task is a strong example of stateful digit processing. The pattern can be generalized for:

- Rolling checksums
- Signal compression
- Educational simulations of layered transformations
- Digit-based encoding or validation systems

It fits well into a modular engineering playbook and can be reused across multiple domains.






---


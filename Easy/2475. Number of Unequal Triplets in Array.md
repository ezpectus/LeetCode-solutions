# ðŸ§  Leetcode 2475 â€” Number of Unequal Triplets in Array

## Problem Summary

Given an array `nums`, count the number of triplets `(i, j, k)` such that:
- `0 â‰¤ i < j < k < nums.length`
- `nums[i]`, `nums[j]`, and `nums[k]` are pairwise distinct

### Constraints
- `3 â‰¤ nums.length â‰¤ 100`
- `1 â‰¤ nums[i] â‰¤ 1000`

---

## âš¡ Quick Solve

Solved in under a minute using brute-force.  
The problem is simple and well-bounded â€” perfect for direct enumeration.

---

## âœ… Brute-force Approach

### Idea
- Use three nested loops to iterate over all index triplets `(i, j, k)` where `i < j < k`
- Check if all three values are distinct
- If yes, increment the result counter

### Time Complexity
- `O(nÂ³)` â€” acceptable for `n â‰¤ 100`

### Code Sketch
```csharp
int res = 0;
for (int i = 0; i < n; i++)
    for (int j = i + 1; j < n; j++)
        for (int k = j + 1; k < n; k++)
            if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])
                res++;
```

## ðŸ§  Frequency-based Combinatorics

### Idea
- Count frequency of each unique value in `nums`
- Enumerate all unique value triplets `(a, b, c)` where `a â‰  b â‰  c`
- For each triplet, add `freq[a] * freq[b] * freq[c]` to the result

### Time Complexity
- `O(uÂ³)` â€” where `u` is the number of unique values

### Code Sketch
```csharp
var freq = new Dictionary<int,int>();
foreach (int num in nums)
    freq[num] = freq.GetValueOrDefault(num, 0) + 1;

var keys = freq.Keys.ToList();
for (int i = 0; i < keys.Count; i++)
    for (int j = i + 1; j < keys.Count; j++)
        for (int k = j + 1; k < keys.Count; k++)
            res += freq[keys[i]] * freq[keys[j]] * freq[keys[k]];
```

## ðŸ§© Comparison

| Approach         | Time (ms) | Notes                                 |
|------------------|-----------|----------------------------------------|
| Brute-force      | 8         | Fast for small `n`, direct index logic |
| Frequency-based  | 70        | Slower on small `n`, better for large `u` |

### Insight

- Brute-force wins when `n` is small and values are dense  
- Frequency-based shines when values are sparse and `n` is large  
- Both approaches are worth documenting â€” they represent different layers of architectural thinking

---

## ðŸ§± Engineering Takeaway

This task is a great example of:

- Pattern recognition vs abstraction  
- When simplicity outperforms generalization  
- How to document both for future reuse  

---

## âœ… Final Reflection

Even in a simple problem, exploring multiple approaches reveals deeper architectural tradeoffs.  
Brute-force gave the fastest runtime, but frequency-based logic offered a reusable pattern for future combinatoric tasks.  
Both belong in the playbook â€” one for speed, one for structure.


## ðŸ§­ Problem: 1496. Path Crossing

You're given a string path consisting of directions:
```
'N' = move north (y++)

'S' = move south (y--)

'E' = move east (x++)

'W' = move west (x--)
```
You start at the origin (0, 0) and follow the path. 
Return true if you ever visit the same coordinate twice. Otherwise, return false.

## ðŸ’¡ Idea
- This is a grid traversal problem with position tracking.
- We simulate movement step-by-step and store each visited coordinate. 
- If we ever land on a coordinate we've already visited â€” the path crosses itself.

## ðŸ”§ Key concepts:

- Use a HashSet to store visited positions
- Represent each position as a string "x,y"
- Start from (0,0) and update x and y based on direction
- Check if the new position already exists in the set

## ðŸ§±  Code C# 
```csharp
public class Solution {
    public bool IsPathCrossing(string path) {
        var pairs = new HashSet<string>();
        pairs.Add("0,0");
        int x = 0;
        int y = 0;

        foreach (var dir in path) {
            if (dir == 'E') x++;
            else if (dir == 'W') x--;
            else if (dir == 'N') y++;
            else y--;

            string curr = $"{x},{y}";
            if (pairs.Contains(curr)) return true;

            pairs.Add(curr);
        }

        return false;
    }
}
```
## âœ… Why it works

-  track every position visited
- use a hash set for O(1) lookup
- return true immediately on a repeat
- start from "0,0" and update coordinates correctly

## ðŸ§  Optional Enhancements
- If you want to optimize memory or avoid string formatting:
- Use HashSet<(int, int)> with tuples instead of strings
- Example: HashSet<(int, int)> visited = new(); visited.Add((0,0));
- But your current version is clean, readable, and correct.



---

# ðŸ§  Intuition

We are given an array of non-negative integers `nums` and an integer `k`.  
A subarray is considered *special* if the bitwise OR of all its elements is **at least `k`**.

Since bitwise OR is **monotonic** (adding more elements never decreases the OR),  
we can iterate over all subarrays and stop early when the OR becomes â‰¥ `k`.

---

# ðŸ”§ Approach

- Use two nested loops:
  - Outer loop `rt` â€” start index of subarray
  - Inner loop `lt` â€” end index of subarray
- Maintain a running `OrVal` using `|= nums[lt]`
- As soon as `OrVal â‰¥ k`, update `minval` with the current subarray length
- Break early â€” longer subarrays won't help
- After all iterations, return:
  - `minval` if found
  - `-1` if no valid subarray exists

---

# ðŸ“Š Complexity

- **Time complexity:**  
  $$O(n^2)$$  
  Worst-case: check all subarrays. Acceptable since \( n \leq 50 \)

- **Space complexity:**  
  $$O(1)$$  
  Only scalar variables used

---

# ðŸ’» Code

```csharp
public class Solution {
    public int MinimumSubarrayLength(int[] nums, int k) {
        int n = nums.Length;
        int minval = int.MaxValue;

        for (int rt = 0; rt < n; rt++) {
            int OrVal = 0;

            for (int lt = rt; lt < n; lt++) {
                OrVal |= nums[lt];

                if (OrVal >= k) {
                    minval = Math.Min(minval, lt - rt + 1);
                    break; // further expansion only increases length
                }
            }
        }

        return minval == int.MaxValue ? -1 : minval;
    }
}

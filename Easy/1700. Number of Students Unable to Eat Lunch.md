# 💡 Intuition

Each student has a preference for either circular (`0`) or square (`1`) sandwiches.  
Sandwiches are stacked, and students form a queue.  
If the student at the front of the queue wants the sandwich on top of the stack, they take it and leave.  
Otherwise, they go to the end of the queue.  
This continues until no student wants the top sandwich — at which point the process stops.

Instead of simulating the queue rotation, we can count how many students prefer each type and process the stack greedily.

---

# 🧭 Approach

- Initialize a counter `count[0]` and `count[1]` to track how many students want each type.
- Iterate through the `students` array and increment the corresponding counter.
- Iterate through the `sandwiches` stack from top to bottom:
  - If `count[sandwich] == 0`, break — no student wants this sandwich.
  - Otherwise, decrement `count[sandwich]` — one student takes it.
- Return the sum of remaining counts — these students couldn’t eat.

---

# ⏱️ Complexity

- **Time complexity**:  
  $$O(n)$$ — one pass through each array.

- **Space complexity**:  
  $$O(1)$$ — only two counters used.

---

# 🧠 Engineering Notes

✅ Avoids unnecessary queue simulation by using preference counters.  
✅ Breaks early when no student wants the current sandwich.  
⚠️ Original simulation-based approach is valid but less efficient.  
🧩 This pattern generalizes to greedy resource allocation with preference matching — useful in scheduling, matching, and consumption models.


# Code
```csharp []
public class Solution {
    public int CountStudents(int[] students, int[] sandwiches) {
       int[] count = new int[2];

       foreach(int  s in students){
        count[s]++;
       }

     
   foreach(int sand in sandwiches){
    if( count[sand] == 0)
        break;
    
      count[sand]--;
   }


   return count[0] + count[1];

    }
}
```



---

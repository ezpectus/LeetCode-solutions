# 🧠 1022. Sum of Root To Leaf Binary Numbers

## 🔗 Problem Statement

Given a binary tree where each node contains either `0` or `1`, each root-to-leaf path represents a binary number.  
Return the **sum of all root-to-leaf binary numbers** interpreted as decimal integers.

Each path is formed by concatenating node values from root to leaf.

---

## ✅ Signals

- Traverse tree using **DFS**
- Accumulate binary value using `val = val * 2 + node.val`
- At leaf nodes, return the accumulated value
- Sum all leaf values across recursive calls

---

## 🧩 Solution — DFS Accumulation

```csharp
public class Solution {
    public int SumRootToLeaf(TreeNode root) {
        return DFS(root, 0);
    }

    private int DFS(TreeNode node, int val) {
        if (node == null) return 0;

        val = val * 2 + node.val;

        if (node.left == null && node.right == null)
            return val;

        return DFS(node.left, val) + DFS(node.right, val);
    }
}
```
## 🔍 Notes

### 🧪 Binary Accumulation

```csharp
val = val * 2 + node.val;
```

This builds the binary number incrementally as you traverse the tree:

```
val = val * 2 performs a left bit shift, equivalent to appending a 0 at the end

+ node.val appends the current bit (0 or 1) to the binary number
```
### Example
- Path: 1 → 0 → 1 Binary: 101 Decimal: 5
- This logic ensures that each path is interpreted as a valid binary number.

## 🌿 Leaf Detection

```
if (node.left == null && node.right == null)
    return val;
```

- Only leaf nodes contribute to the final sum. Intermediate nodes simply propagate the accumulated value down the path.

- This condition ensures that partial paths are not included in the result.

## 🧠 Signal Summary

| Concept         | Signal Expression              | Role                          |
|----------------|----------------------------------|-------------------------------|
| Binary buildup | `val = val * 2 + node.val`       | Accumulate path value         |
| Leaf check     | `left == null && right == null`  | Trigger final value return    |
| DFS traversal  | `DFS(left) + DFS(right)`         | Aggregate all leaf path sums  |


## ✅ Takeaways
- This pattern generalizes to any path-based accumulation in trees.
- It can be adapted for a wide range of signal-driven tasks:
- Max/min path values — track and compare accumulated values
- Path encoding — build strings, bitmasks, or custom formats
- Conditional path sums — filter by length, parity, or node constraints
- Use this as a base module for any tree traversal where path state matters.




---

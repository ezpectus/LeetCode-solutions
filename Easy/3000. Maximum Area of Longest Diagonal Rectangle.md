## 🧩 Problem Statement  
Find the rectangle with the **longest diagonal**.  
If multiple rectangles share the same diagonal length, choose the one with the **largest area**.

## 💡 C# Implementation

```csharp
public class Solution {
    public int AreaOfMaxDiagonal(int[][] dimensions) {
        int maxArea = 0;
        int maxdiagonasq = 0;

        foreach (var rect in dimensions) {
            int height = rect[0];
            int width = rect[1];

            int diagsq = height * height + width * width;
            int area = height * width;

            if (diagsq > maxdiagonasq || (diagsq == maxdiagonasq && area > maxArea)) {
                maxArea = area;
                maxdiagonasq = diagsq;
            }
        }

        return maxArea;
    }
}
```
## 🔍 Logic Breakdown

- **`diagsq`**: Represents the square of the diagonal length.  
  Using squared values avoids floating-point operations (`Math.Sqrt`) and keeps comparisons efficient and precise.

- **`area`**: Standard rectangle area (`height × width`).

### Selection Criteria

- Prefer rectangles with a **larger diagonal**.
- If diagonals are equal, prefer the one with a **larger area**.

This ensures a consistent and deterministic selection strategy across all inputs.

---

## ✅ Architectural Pattern: Greedy Selection with Lexicographic Tie-Breaker

This solution follows a classic greedy pattern where elements are selected based on a primary metric, and ties are resolved using a secondary metric.

### Pattern Structure

| Metric   | Priority Level | Purpose                          |
|----------|----------------|----------------------------------|
| `diagsq` | Primary         | Maximizes diagonal length        |
| `area`   | Secondary       | Breaks ties when diagonals match |

### Why it works

- **Greedy**: We only care about the best candidate at each step.
- **Lexicographic comparison**: `(diagsq, area)` forms a tuple-like comparison, even though C# doesn’t support direct tuple comparison with `>`.
- **Efficient**: No sorting or extra data structures needed — just a linear scan with conditional updates.

---

## 🧠 Reusability & Generalization

This pattern is broadly applicable to problems like:

- Selecting the best candidate based on multiple criteria
- Prioritizing elements in custom sort orders
- Implementing max-heap or priority queues with compound keys

You can abstract the comparison logic into a helper method like `IsBetter(...)` for cleaner reuse across different problems.



---

# Pattern Name
**K-th Smallest Trimmed Number via Indexed Radix Sorting**

---

## Problem Summary
You're given:

- A list of digit-only strings `nums`, all of equal length
- A list of queries `queries`, where each query is `[k, trim]`

**For each query:**
1. Trim each number in `nums` to its **last `trim` digits**
2. Find the **index** of the **k-th smallest** trimmed number  
   *(ties broken by original index)*
3. Return an array of indices corresponding to each query

---

## Core Idea
This is a **multi-query substring ranking problem**.  
Each query defines a trimming length and a rank `k`.  
We need to **sort the trimmed versions of `nums`** and return the index of the `k`-th smallest.

**Key Optimization:**  
Instead of sorting from scratch for every query — **reuse sorting results via radix-style passes**.

---

## Strategy Summary
1. **Preprocess queries**: group them by `trim` length
2. **For each `trim` from 1 to max**:
   - Perform **stable sorting** of `nums` by **last `trim` digits**
   - Use **counting sort per digit** to maintain stability and index tracking
3. **For each query**, extract the index of the `k`-th smallest trimmed number
4. Return the final result array

---

## C# Implementation
```csharp
public class Solution {
    public int[] SmallestTrimmedNumbers(string[] nums, int[][] queries) {
        int maxTrim = int.MinValue;
        foreach (var query in queries)
            maxTrim = Math.Max(maxTrim, query[1]);
        
        List<int>[] queryTrim = new List<int>[maxTrim];
        for (int i = 0; i < queryTrim.Length; i++)
            queryTrim[i] = new();
        for (int i = 0; i < queries.Length; i++)
            queryTrim[queries[i][1] - 1].Add(i);
        
        int[] indices = new int[nums.Length];
        for (int i = 0; i < indices.Length; i++)
            indices[i] = i;

        int[] answer = new int[queries.Length];
        for (int i = 1; i <= maxTrim; i++) {
            indices = CountingSort(nums, indices, i);
            foreach (var queryIdx in queryTrim[i - 1])
                answer[queryIdx] = indices[queries[queryIdx][0] - 1];
        }
        return answer;
    }
    private int[] CountingSort(string[] nums, int[] indices, int digit) {
        int[] counts = new int[10];
        foreach (var n in nums)
            counts[n[^digit] - '0']++;
        int sum = 0;
        for (int i = 0; i < counts.Length; i++) {
            int count = counts[i];
            counts[i] = sum;
            sum += count;
        }
        int[] sorted = new int[indices.Length];
        for (int i = 0; i < nums.Length; i++) {
            sorted[counts[nums[indices[i]][^digit] - '0']] = indices[i];
            counts[nums[indices[i]][^digit] - '0']++;
        }
        return sorted;
    }
}
```

## Architectural Breakdown

| Component       | Role |
|----------------|------|
| `queryTrim`     | Groups queries by trim length for efficient reuse |
| `CountingSort`  | Stable digit-based sort for each trim level |
| `indices`       | Tracks original positions for tie-breaking |
| **Outer loop**  | Iterates over trim lengths from 1 to max |
| **Inner loop**  | Resolves queries for current trim level |

---

## Why This Approach Is Superior

| Aspect               | This Approach                        | Naive Approach                     |
|----------------------|--------------------------------------|------------------------------------|
| **Query Optimization** | Groups queries by trim length        | Repeats sort for each query        |
| **Sorting Strategy**   | Counting sort per digit              | Full string comparison or built-in sort |
| **Tie-breaking**       | Index-preserving stable sort         | Manual index tracking              |
| **Performance**        | Linear per digit, amortized over queries | Potential quadratic per query      |
| **Scalability**        | Handles up to 100 queries efficiently | Degrades with query count          |

---

## Final Takeaway

> This problem is **not** about sorting strings once —  
> it's about **efficient multi-query ranking with digit-based trimming**.

### The solution uses:
- **Query grouping by trim length**
- **Stable counting sort per digit**
- **Index tracking for tie-breaking**

---

### This pattern generalizes to any task involving:
- Multi-query substring ranking
- Stable sorting with partial views
- Efficient reuse of intermediate sort results

---

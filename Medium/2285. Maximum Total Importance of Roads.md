# 2285. Maximum Total Importance of Roads  
*O(n + m log n) — Greedy Degree Sorting + Value Assignment*

---

## Problem Statement

You are given `n` cities (numbered 0 to n-1) and a list of `roads` where `roads[i] = [ai, bi]` represents a bidirectional road between cities `ai` and `bi`.

Assign each city a **unique integer value** from **1 to n** (each value used exactly once).

The **importance** of a road is the **sum** of the values of its two cities.

Return the **maximum possible total importance** of all roads after assigning values optimally.

**Examples**:

**Example 1**  
Input: n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]  
Output: **43**  
Optimal assignment: [2,4,5,3,1]  
Road importances: 6 + 9 + 8 + 7 + 7 + 6 = 43

**Example 2**  
Input: n = 5, roads = [[0,3],[2,4],[1,3]]  
Output: **20**  
Optimal: [4,3,2,5,1] → 9 + 3 + 8 = 20

**Constraints**:
- 2 ≤ n ≤ 5·10⁴
- 1 ≤ roads.length ≤ 5·10⁴
- No duplicate roads, no self-loops

---

## Core Idea — Greedy: Assign Highest Values to Highest Degree Nodes

**Key insight**:
- The total importance = sum over all roads (value[u] + value[v])
- Each road contributes value[u] + value[v] → each city's value is added once for **each road it connects**
- Total importance = sum over all cities: value[city] × degree[city]

To **maximize** this:
- Assign the **largest values** (n, n-1, ..., 1) to cities with the **highest degrees**
- Because higher degree multiplies the value more times

**Algorithm**:
1. Build degree array: `degree[i]` = number of roads connected to city i
2. Sort cities by **degree descending**
3. Assign values from **n down to 1** to cities in sorted order
4. Compute total = sum (value[city] × degree[city]) over all cities

**Time**: O(n + m log n) — building degree O(m), sorting O(n log n)  
**Space**: O(n + m) — degree array + adjacency (optional)

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public long MaximumImportance(int n, int[][] roads){
        // Step 1: Compute degree of each city
        int[] degree = new int[n];
        foreach (var road in roads){
            degree[road[0]]++;
            degree[road[1]]++;
        }

        // Step 2: Sort cities by degree descending
        var cities = new int[n];
        for (int i = 0; i < n; i++){
            cities[i] = i;
        }
        Array.Sort(cities, (a, b) => degree[b].CompareTo(degree[a]));

        // Step 3: Assign highest value to highest degree cities
        long total = 0;
        long value = n;  // start from largest value

        foreach (int city in cities){
            total += value * degree[city];
            value--;
        }

        return total;
    }
}
```


## Complexity

| **Metric**            | **Value**              | **Notes**                                                                 |
|-----------------------|------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(n + m log n)**     | Building the degree array: O(m)<br>Sorting cities by degree: O(n log n)<br>Final weighted sum calculation: O(n) |
| **Space Complexity**  | **O(n)**               | Degree array + temporary array for sorting cities (can be optimized/reused if needed) |

**Optimal** — linear in the number of cities and roads plus a logarithmic factor for sorting — perfectly efficient under constraints (n ≤ 5·10⁴, m ≤ 5·10⁴).

---

## Why This Works — Example Walkthrough

**Example 1**: n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]

**Degrees** (number of connected roads per city):
- City 0: 2 (connected to 1, 2)
- City 1: 3 (connected to 0, 2, 3)
- City 2: 4 (connected to 1, 3, 0, 4)
- City 3: 2 (connected to 2, 1)
- City 4: 1 (connected to 2)

**Sort cities by degree descending**:  
City 2 (deg 4) → City 1 (deg 3) → City 0 (deg 2) → City 3 (deg 2) → City 4 (deg 1)

**Assign highest values** (5 down to 1) to highest-degree cities:
- City 2 → value 5
- City 1 → value 4
- City 0 → value 3
- City 3 → value 2
- City 4 → value 1

**Total importance** calculation:  
Each city's value is added once for each road it's connected to → value × degree  
→ 5×4 + 4×3 + 3×2 + 2×2 + 1×1 = 20 + 12 + 6 + 4 + 1 = **43** → matches example

**Correct** —  
The total importance of all roads is exactly equal to **∑ (value[city] × degree[city])** over all cities.  
To maximize this weighted sum, we assign the **largest possible values** to the cities with the **highest degrees** — this is the classic greedy choice for weighted assignment problems.

---

## Key Takeaway

This is a **classic greedy graph assignment** problem:

* Compute the **degree** (number of connected roads) for each city
* Sort cities in **descending order of degree**
* Assign the **highest values** (n, n-1, ..., 1) to cities with the highest degrees first
* Total importance = **∑ value[city] × degree[city]** over all cities

**Pure, clean, optimal** — O(n + m log n) time, O(n) space, extremely fast, intuitive, and mathematically guaranteed to give the maximum possible total importance.

---

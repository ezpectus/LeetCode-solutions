# Pattern Name  
Topological Sort with Indegree Tracking â€” Course Ordering via BFS

---

## Problem Summary

You are given `numCourses` and a list of `prerequisites`, where each pair `[a, b]` means you must take course `b` before course `a`.  
Return a valid ordering of courses to finish all courses.  
If no valid ordering exists (i.e., the graph has a cycle), return an empty array.

---

## Core Idea

This is a **topological sort** problem using **indegree tracking and BFS**.  
We build a directed graph and count the number of incoming edges (`indegree`) for each node.  
Courses with `indegree == 0` are added to a queue.  
As we process each course, we decrement the indegree of its neighbors.  
If all courses are processed, we return the ordering.  
If a cycle exists, the queue will not cover all nodes, and we return an empty array.

---

## C# Implementation

```csharp
using System;
using System.Collections.Generic;

public class Solution {
    public int[] FindOrder(int numCourses, int[][] prerequisites) {
        int[] inDegree = new int[numCourses];
        Dictionary<int, List<int>> adj = new Dictionary<int, List<int>>();

        foreach (var pre in prerequisites) {
            if (!adj.ContainsKey(pre[1])) adj[pre[1]] = new List<int>();
            adj[pre[1]].Add(pre[0]);
        }

        foreach (var key in adj.Keys)
            foreach (var node in adj[key])
                inDegree[node]++;

        var q = new Queue<int>();
        for (int i = 0; i < numCourses; i++)
            if (inDegree[i] == 0) q.Enqueue(i);

        var ans = new List<int>();
        while (q.Count > 0) {
            int node = q.Dequeue();
            ans.Add(node);
            if (adj.ContainsKey(node)) {
                foreach (var ngbr in adj[node]) {
                    inDegree[ngbr]--;
                    if (inDegree[ngbr] == 0) q.Enqueue(ngbr);
                }
            }
        }

        return ans.Count == numCourses ? ans.ToArray() : new int[0];
    }
}
```


## Time and Space Complexity

| Metric           | Value       | Explanation                                  |
|------------------|-------------|----------------------------------------------|
| Time Complexity  | O(n + e)    | Traverse all nodes and edges                 |
| Space Complexity | O(n + e)    | Adjacency list + indegree array + queue      |

---

## Generalization to Other Problems

This pattern applies to problems where:

- You detect cycles in a directed graph  
- You schedule tasks with dependency constraints  
- You use indegree tracking and BFS traversal

---

## Examples of Similar Problems

| Problem Type         | Description                                         |
|----------------------|-----------------------------------------------------|
| Course Schedule I    | Check if all courses can be completed               |
| Alien Dictionary     | Infer character order from word list                |
| Task Scheduling      | Determine if all tasks can be completed             |

---

## Final Takeaway

This solution uses:

- Adjacency list to represent the graph  
- Indegree array to track dependencies  
- Queue-based BFS to process nodes with no prerequisites  
- Cycle detection via node count comparison

The result is a clean and efficient solution for any task involving  
**dependency resolution and topological ordering in directed graphs**.

---

# 558. Logical OR of Two Binary Grids Represented as Quad-Trees

---

## Problem Summary
We are given two Quad-Trees (`quadTree1` and `quadTree2`) representing binary matrices of size `n × n`.  
- Each node can be either a **leaf** (uniform grid of 0’s or 1’s) or an **internal node** (divided into four quadrants).  
- Task: return a Quad-Tree representing the **logical OR** of the two binary matrices.  

---

## Core Idea
- If either node is a **leaf with value = 1**, the result is a leaf node with value = 1.  
- If one node is a **leaf with value = 0**, the result is simply the other node.  
- Otherwise, recursively compute OR for all four children:  
  - `topLeft`, `topRight`, `bottomLeft`, `bottomRight`.  
- After recursion, if all four children are leaves with the same value, merge them into a single leaf node.  

This ensures the resulting Quad-Tree is minimized (no redundant internal nodes).  

---

## C++ Implementation
```cpp
class Solution {
public:
    Node* intersect(Node* quadTree1, Node* quadTree2) {
        // Case 1: if quadTree1 is leaf
        if (quadTree1->isLeaf) {
            if (quadTree1->val) return new Node(true, true); // OR with 1 → always 1
            return quadTree2; // OR with 0 → result is quadTree2
        }
        // Case 2: if quadTree2 is leaf
        if (quadTree2->isLeaf) {
            if (quadTree2->val) return new Node(true, true);
            return quadTree1;
        }
        
        // Case 3: both are internal nodes → recurse
        Node* topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);
        Node* topRight = intersect(quadTree1->topRight, quadTree2->topRight);
        Node* bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);
        Node* bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);
        
        // Merge if all children are leaves with same value
        if (topLeft->isLeaf && topRight->isLeaf && bottomLeft->isLeaf && bottomRight->isLeaf &&
            topLeft->val == topRight->val && topRight->val == bottomLeft->val && bottomLeft->val == bottomRight->val){
            return new Node(topLeft->val, true);
        }
        
        return new Node(false, false, topLeft, topRight, bottomLeft, bottomRight);
    }
};
```
## Complexity
- **Time:** O(n²) — worst case when the Quad-Tree is fully expanded and each cell is processed once.  
- **Space:** O(log n) to O(n²) depending on tree depth (recursion stack + number of nodes).  

---

## Pitfalls
- Must handle **leaf nodes** carefully:  
  - Leaf with `val = 1` dominates → result always 1.  
  - Leaf with `val = 0` defers to the other tree.  
- Must **merge children** when all four are identical leaves to avoid unnecessary internal nodes.  
- **Edge case:** both trees are single leaf nodes.  

---

## Example Walkthrough
**Input:**  
`quadTree1 = [[0,1],[1,1],[1,1],[1,0],[1,0]]`  
`quadTree2 = [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]`  

**Process:**  
- Root nodes are internal → recurse into children.  
- Apply OR rules at each quadrant.  
- Merge children when possible.  

**Output:**  
`[[0,0],[1,1],[1,1],[1,1],[1,0]]`  

---

## Conclusion
The problem reduces to a **recursive merge of two Quad-Trees** using logical OR rules.  
- Leaf nodes simplify recursion: `1` dominates, `0` defers.  
- Internal nodes require recursive OR on children.  
- Post-processing merges identical children into a single leaf.  

This approach ensures the resulting Quad-Tree is **minimal, efficient, and correct**.  



---


# ðŸŒ² Binary Tree Level Order Traversal II â€“ Bottom-Up BFS

## ðŸ“˜ Problem Summary

Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values.  
This means traversing the tree level by level from **leaf to root**, left to right within each level.

### Example

```plaintext
Input:  root = [3,9,20,null,null,15,7]
Output: [[15,7],[9,20],[3]]
```
## ðŸ§  Core Idea
- This is a standard level-order traversal (BFS), 
but instead of returning levels from top to bottom, we need to return them from bottom to top.

- To achieve this, we build each level normally, then insert it at the beginning of the result list. 
- This avoids reversing the entire result at the end and keeps the traversal logic clean.

  ## ðŸ”§ C# Implementation
  
```csharp
public class Solution {
    public IList<IList<int>> LevelOrderBottom(TreeNode root) {
        IList<IList<int>> result = new List<IList<int>>();
        if (root == null) return result;

        Queue<TreeNode> queue = new Queue<TreeNode>();
        queue.Enqueue(root);

        while (queue.Count > 0) {
            int size = queue.Count;
            LinkedList<int> level = new LinkedList<int>();

            for (int i = 0; i < size; i++) {
                TreeNode curr = queue.Dequeue();
                level.AddLast(curr.val);

                if (curr.left != null) queue.Enqueue(curr.left);
                if (curr.right != null) queue.Enqueue(curr.right);
            }

            result.Insert(0, level.ToList());
        }

        return result;
    }
}
```

## ðŸ“¶ Signal Table

| Signal                          | Role / Meaning                          |
|----------------------------------|------------------------------------------|
| `Queue<TreeNode>`               | BFS traversal queue                     |
| `LinkedList<int>`               | Builds current level in correct order   |
| `level.AddLast(curr.val)`       | Appends node value to current level     |
| `result.Insert(0, level.ToList())` | Inserts level at the beginning of result |
| `queue.Enqueue(...)`            | Adds child nodes for next level         |

---

## âœ… Takeaways

- This is a bottom-up BFS traversal.
- We use standard BFS mechanics: queue, level size, and node expansion.
- Instead of reversing the result at the end, we insert each level at the front.
- This keeps the traversal logic clean and avoids post-processing.
- The pattern is reusable for any level-based traversal that requires reversed level order.

---

## ðŸ§© Conclusion

This solution preserves the clarity of BFS while adapting the output order.  
By inserting each level at index `0`, we build the result from bottom to top **as we traverse**, not after.  
This approach is efficient, readable, and architecturally clean.






---

# 🧠 Problem Statement

You're given an array of integers nums. You can pick any subset of these numbers (including possibly none),
and your goal is to maximize the sum of the selected numbers, 
under the constraint that the sum must be divisible by 3.

Example:
Input: [3, 6, 5, 1, 8]

Output: 18

Explanation: The subset [3, 6, 1, 8] sums to 18, which is divisible by 3 and is the maximum possible such sum.

💻 Code of Solution
```csharp
public class Solution {
    public int MaxSumDivThree(int[] nums) {
        int total = nums.Sum();
        var mod1 = nums.Where(x => x % 3 == 1).OrderBy(x => x).ToList();
        var mod2 = nums.Where(x => x % 3 == 2).OrderBy(x => x).ToList();

        if (total % 3 == 0) return total;

        int opt1 = int.MaxValue;
        int opt2 = int.MaxValue;

        if (total % 3 == 1) {
            if (mod1.Count >= 1) opt1 = mod1[0];
            if (mod2.Count >= 2) opt2 = mod2[0] + mod2[1];
        } else {
            if (mod2.Count >= 1) opt1 = mod2[0];
            if (mod1.Count >= 2) opt2 = mod1[0] + mod1[1];
        }

        int minLoss = Math.Min(opt1, opt2);
        return minLoss == int.MaxValue ? 0 : total - minLoss;
    }
}
```

## 🧮 Core Formula Behind the Code
```
Let S = sum(nums)

If S % 3 == 0 → return S

If S % 3 == r (where r = 1 or 2), remove the smallest subset of elements whose total modulo 3 equals r
```

Compensation Strategy:
```
If S % 3 == 1:

Remove one smallest element with x % 3 == 1, or

Remove two smallest elements with x % 3 == 2

If S % 3 == 2:

Remove one smallest element with x % 3 == 2, or

Remove two smallest elements with x % 3 == 1

This ensures the new sum becomes divisible by 3 with minimal loss.
```

## 🧱 Code Architecture Explained

Step 1: Compute total sum int total = nums.Sum();
Step 2: Classify elements by modulo 3

```csharp
var mod1 = nums.Where(x => x % 3 == 1).OrderBy(x => x).ToList();
var mod2 = nums.Where(x => x % 3 == 2).OrderBy(x => x).ToList();
```

Step 3: If total % 3 == 0, return total
Step 4: Otherwise, compute two options:

- opt1: remove one element
- opt2: remove two elements

Step 5: Subtract minimal loss return total - Math.Min(opt1, opt2);

Step 6: Handle edge case where no valid removal is possible ```return minLoss == int.MaxValue ? 0 : total - minLoss;```

## 📦 Engineering Pattern: Modular Subset Compensation

🔹 Name:
Max Subset Sum Divisible by k (here, k = 3)

🔹 Pattern:
Group elements by mod k

```
If total sum S % k == r, remove the smallest subset of elements whose mod sum equals r

Return S - loss
```

🔹 Use Cases:

- Competitive programming (Leetcode, Codeforces)
- Game theory (modular turn-based strategies)
- DP with modular states (dp[i % k])
- Inventory or trading systems with divisible constraints

🔹 Generalization:
This pattern scales to any k > 1. You can build modular buckets:

```plaintext
modBuckets[k] = List of elements with mod i
```
Then define compensation strategies for each remainder r = 1 to k-1.

🔣 Formula Summary
plaintext
Let S = sum(nums)

If S % k == 0 → return S

Else:
- Identify minimal subset whose mod sum == S % k
- Return S - loss
  
## 📊 Benchmark Insight
This pattern avoids brute-force subset enumeration (O(2^n))

Instead, it uses:

- O(n) classification by mod
- O(n log n) sorting (can be optimized to O(n) with counting buckets)

- Constant-time compensation logic

- ✅ Scales efficiently for large inputs (n ≤ 4 * 10⁴)

## 🧠 Why This Is Deep
This isn’t just a greedy trick — it’s a modular optimization framework. 

You’re not brute-forcing subsets. You’re:

- Using modulo classification to reduce search space
- Applying minimal loss strategy to preserve maximum weight
- Building a reusable template for divisibility-constrained subset selection


---

# 1513. Number of Substrings With Only 1s

**Difficulty:** Medium  
**Topics:** Greedy, String, Math  

---

## üìñ Problem Restatement
You are given a binary string `s`.  
Return the number of substrings that consist only of `'1'`.  
Since the answer may be very large, return it modulo 1,000,000,007.

---

## üí° Core Idea
- Every continuous block of `'1'`s of length `L` contributes a fixed number of substrings.  
- The count is given by the formula:  
  - Total substrings = L + (L-1) + (L-2) + ... + 1  
  - Which simplifies to L * (L + 1) / 2.  
- Instead of computing this formula separately for each block, we can count greedily:  
  - Maintain a running counter of consecutive `'1'`.  
  - Each new `'1'` extends all substrings ending at that position.  
  - Add the counter to the result at each step.  
- Reset the counter when encountering `'0'`.

---

## üîé Step-by-Step Algorithm
1. Initialize `res = 0`, `count = 0`.  
2. Traverse each character in the string:  
   - If the character is `'1'`:  
     - Increment `count`.  
     - Add `count` to `res`.  
   - If the character is `'0'`:  
     - Reset `count = 0`.  
   - Apply modulo at each step to avoid overflow.  
3. Return `res % MOD`.

---

## ‚úÖ C# Implementation
```csharp
public class Solution {
    public int NumSub(string s) {
        const int MOD = 1000000007;
        long res = 0;
        int count = 0;

        foreach (char c in s) {
            if (c == '1') {
                count++;
                res += count; // each '1' extends substrings ending here
            } else {
                count = 0;
            }
            if (res >= MOD) res %= MOD;
        }

        return (int)(res % MOD);
    }
}
```


## üìä Complexity Analysis

- **Time Complexity: O(n)**  
  - We scan the string once from left to right.  
  - Each character is processed in constant time.  
  - Overall runtime is linear in the length of the string.  

- **Space Complexity: O(1)**  
  - Only two variables are maintained:  
    - `count` ‚Üí length of the current block of consecutive `'1'`.  
    - `res` ‚Üí total number of substrings.  
  - No extra data structures are required.  
  - Memory usage is constant.

---

## ‚ö†Ô∏è Pitfalls

1. **Modulo application**  
   - The result can grow very large for long strings.  
   - Must apply modulo 1,000,000,007 to avoid overflow.  

2. **Resetting the counter**  
   - When encountering `'0'`, reset `count = 0`.  
   - Otherwise, substrings would incorrectly extend across blocks.  

3. **Edge cases**  
   - String of all `'0'` ‚Üí result = 0.  
   - String of all `'1'` of length `L` ‚Üí result = L * (L + 1) / 2.  
   - Mixed strings ‚Üí sum contributions from each block of `'1'`.

---

## üîé Example Walkthrough

**Input:** `s = "0110111"`

- Block 1: `"11"`  
  - Length = 2  
  - Substrings = 2 * 3 / 2 = 3  

- Block 2: `"111"`  
  - Length = 3  
  - Substrings = 3 * 4 / 2 = 6  

**Total:** 3 + 6 = 9  

**Output:** `9`

---

## ‚úÖ Key Takeaway

- The formula **L * (L + 1) / 2** counts substrings in a block of `'1'`.  
- Greedy counting by incrementing `count` each time a `'1'` appears is equivalent to applying the formula dynamically.  
- This approach avoids explicit block calculations and works in a single pass.  
- Clean O(n) solution with constant space, efficient for strings up to length 100,000.


---

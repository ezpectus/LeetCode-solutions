# 2086. Minimum Number of Food Buckets to Feed the Hamsters  
*O(n) — Two-Pointer Greedy from Both Ends*

---

## Problem Statement

You are given a 0-indexed string `hamsters` consisting of `'H'` (hamster) and `'.'` (empty cell).

You need to place the **minimum** number of food buckets at **empty positions** ('.') so that **every hamster** is fed.

A hamster at position `i` is fed if there is at least one bucket at:
- `i-1` **or**
- `i+1`

Return the **minimum** number of buckets needed, or **-1** if impossible.

**Constraints**:
- 1 ≤ hamsters.length ≤ 10⁵
- hamsters consists only of `'H'` and `'.'`

---

## Core Idea — Greedy Two-Pointer from Both Ends

**Key observations**:
- Each bucket can feed **up to two** hamsters (left and/or right)
- Impossible case: any "HHH" substring — middle hamster cannot be fed (both neighbors occupied)
- To minimize buckets, we should try to **cover two hamsters with one bucket** whenever possible
- Placing bucket between two hamsters (e.g., "H.H") is optimal — one bucket covers both

**Greedy strategy** (your code's approach):
- Use **two pointers** — start from both ends (`low = 0`, `high = n-1`)
- Process hamsters from **outside in**
- When we find a hamster:
  - Prefer placing bucket on the **inner side** (right for left pointer, left for right pointer)
  - This maximizes chance of covering another hamster later
- If no available empty spot on preferred side → impossible

**Why two pointers?**
- By processing from both ends, we naturally prefer placing buckets in positions that can cover **future** (inner) hamsters
- Avoids over-placing buckets in the middle

**Algorithm** (your code logic, cleaned):
1. Initialize `food[]` array to track bucket positions (0 = no, 2 = bucket placed)
2. Use two pointers `low` and `high`
3. While `low <= high`:
   - If `low` has hamster:
     - Try to place bucket on **right** (low+1) if possible
     - If not → try left (low-1)
     - If neither → impossible
   - If `high` has hamster:
     - Prefer bucket on **left** (high-1) if possible
     - If not → try right (high+1)
     - If neither → impossible
   - Move pointers inward
4. Count number of positions where `food[i] == 2`

**Correctness**:
- Processing from outside in prefers **inner placements** → maximizes coverage
- Early detection of impossible cases ("HHH" patterns)
- Greedy choice property: placing on inner side never hurts future decisions

---

## Clean Implementation (C#)

```csharp
public class Solution 
{
    private int[] food;

    private bool UpdateFood(string hamsters, int idx, bool isLow = true) 
    {
        int len = hamsters.Length;
        List<int> avail = new List<int>();

        // Left neighbor
        if (idx > 0 && hamsters[idx - 1] == '.') 
            avail.Add(idx - 1);

        // Right neighbor
        if (idx < len - 1 && hamsters[idx + 1] == '.') 
            avail.Add(idx + 1);

        if (avail.Count == 0) 
            return false;

        // If only one spot — place there
        if (avail.Count == 1) 
        {
            food[avail[0]] = 2;
        } 
        else 
        {
            // Two spots — prefer the inner one based on direction
            int id1 = avail[0];
            int id2 = avail[1];

            // isLow = true → coming from left → prefer right spot (id2)
            // isLow = false → coming from right → prefer left spot (id1)
            int preferred = isLow ? id2 : id1;

            if (food[preferred] == 0) 
            {
                food[preferred] = 2;
            }
        }

        return true;
    }

    public int MinimumBuckets(string hamsters) 
    {
        int len = hamsters.Length;
        food = new int[len];
        int low = 0, high = len - 1;

        while (low <= high) 
        {
            char cL = hamsters[low];
            char cH = hamsters[high];

            // Process left pointer
            if (cL == 'H') 
            {
                if (!UpdateFood(hamsters, low)) 
                    return -1;
            }

            // Process right pointer (if different position)
            if (low != high && cH == 'H') 
            {
                if (!UpdateFood(hamsters, high, false)) 
                    return -1;
            }

            low++;
            high--;
        }

        // Count placed buckets
        int fCnt = 0;
        foreach (int f in food) 
        {
            if (f == 2) fCnt++;
        }

        return fCnt;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Two pointers start from both ends and move inward → each position is processed at most O(1) times |
| **Space Complexity**  | **O(n)**      | `food` array of size n to track placed buckets (can be optimized to **O(1)** by using a simple counter instead of array) |

**Optimal** — linear time, minimal space — perfect and very efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: hamsters = "H..H"

- low = 0, high = 3 → both positions have 'H'
- Process low = 0 ('H'):
  - Available spots: right (index 1) → place bucket at 1 → food[1] = 2
- Process high = 3 ('H'):
  - Available spots: left (index 2) → place bucket at 2 → food[2] = 2
- Total buckets placed = **2** → correct

**Correct** —  
The two-pointer approach processes hamsters from **outside in**.  
For each hamster, we **prefer** placing the bucket on the **inner side**:
- From left pointer → prefer right neighbor
- From right pointer → prefer left neighbor  

This greedy choice maximizes the chance that one bucket can cover **two hamsters** (when possible).  
Processing from both ends naturally encourages central placements that can serve multiple hamsters.

---

## Key Takeaway

This is a **classic greedy coverage** problem solved elegantly with **two-pointer processing**:

* Use **two pointers** starting from both ends of the string (`low = 0`, `high = n-1`)
* While `low ≤ high`:
  * If position `low` has a hamster:
    - Prefer placing bucket on **right** (low+1) if empty
    - If not possible → place on **left** (low-1) if empty
    - If neither possible → impossible → return -1
  * If position `high` has a hamster (and low ≠ high):
    - Prefer placing bucket on **left** (high-1) if empty
    - If not possible → place on **right** (high+1) if empty
    - If neither possible → impossible → return -1
  * Move pointers inward (`low++`, `high--`)
* Count the number of placed buckets

**Pure, clean, optimal** — O(n) time, O(n) space (can be reduced to O(1) by just counting instead of storing positions), simple greedy logic, correct and efficient.

---

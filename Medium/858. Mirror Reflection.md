# 🔺 Problem: Mirror Reflection (Leetcode 858)

## 📜 Statement

You're given a square room with mirrors on all four walls.  
A laser ray is fired from the southwest corner and reflects off the walls at 45° angles.  
There are receptors at the remaining three corners: `0`, `1`, and `2`.

Given integers `p` and `q`, representing the room's dimensions and the initial vertical offset,  
return the number of the receptor that the ray meets first.

---

## 🧠 Core Idea

This is a **parity-based geometric simulation** using number theory.  
Instead of tracing the laser's path through reflections, we compute when it hits a corner using the **Least Common Multiple (LCM)** of `p` and `q`.

> The ray reaches a corner when it has traveled a multiple of both `p` and `q`.  
> The parity of vertical and horizontal reflections determines which receptor is hit.

---

## 🧪 Examples

```text
Input: p = 3, q = 1
LCM = 3
Vertical reflections (m) = 3 / 1 = 3 → odd
Horizontal reflections (n) = 3 / 3 = 1 → odd
→ Receptor 1

Input: p = 2, q = 1
LCM = 2
m = 2 / 1 = 2 → even
n = 2 / 2 = 1 → odd
→ Receptor 2
```
## 🧩 Receptor Mapping

| Vertical (m) | Horizontal (n) | Receptor |
|--------------|----------------|----------|
| Odd          | Odd            | 1        |
| Odd          | Even           | 0        |
| Even         | Odd            | 2        |


---

## 🧱 C# Implementation
```csharp
public class Solution {
    public int MirrorReflection(int p, int q) {
        int lcm = LCM(p, q);
        int m = lcm / q;
        int n = lcm / p;

        if (m % 2 == 1 && n % 2 == 1) return 1;
        if (m % 2 == 1 && n % 2 == 0) return 0;
        if (m % 2 == 0 && n % 2 == 1) return 2;

        return -1; // Should never reach here
    }

    private int LCM(int a, int b) {
        return (a * b) / GCD(a, b);
    }

    private int GCD(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

## 🔍 Why This Code Is Optimized

### ✅ Mathematical Simulation
- Avoids grid tracing or visual ray simulation.
- Models the laser's path using arithmetic rather than geometry.
- Uses **LCM** to find the first corner hit — a clean shortcut to avoid iterative bouncing.

### 🔢 Parity-Based Logic
- Reflection counts (`m`, `n`) are derived from `LCM / q` and `LCM / p`.
- Their parity (odd/even) maps directly to the receptor index.
- This eliminates the need for directional flags or state machines.

### 🧮 Efficient Number Theory
- **GCD** via Euclidean algorithm: fast, stable, and well-known.
- **LCM** computed once and reused — no redundant calculations.
- Entire logic is built on integer math — no floating-point errors.

### 🧠 Minimal State
- No arrays, no simulation loops, no geometry tracking.
- Just pure arithmetic — fast, memory-light, and cache-friendly.
- Works in constant space: **O(1)**.

---

## 🧮 Time & Space Complexity

| Metric      | Value             | Notes                                      |
|-------------|-------------------|--------------------------------------------|
| Time        | O(log min(p, q))  | GCD via Euclidean algorithm                |
| Space       | O(1)              | No extra allocations                       |
| Stability   | High              | Deterministic, no branching                |
| Scalability | Excellent         | Handles full input range smoothly          |

---

## 🧠 Engineering Takeaway

This task is a clean example of:

- ✅ **Geometric simulation via arithmetic** — no need for grid tracing  
- 🔢 **Parity-based logic** — elegant mapping from math to behavior  
- 🧮 **Number theory in practice** — LCM and GCD as tools for simulation  
- 🧠 **Minimalist design** — no state, no loops, just pure math

> You’re not tracing a ray — you’re **predicting its destiny through number theory**.

---

## 🧩 Comparison: LCM vs Bitwise Optimization

Some solutions use bitwise tricks to remove common factors of 2:

```csharp
while ((p & 1) == 0 && (q & 1) == 0) {
    p >>= 1;
    q >>= 1;
}
```

This works because:

- Removing powers of 2 simplifies the parity analysis.
- Final parity of p and q determines the receptor.
- But your LCM-based approach is equally efficient, and more generalizable:
- Works for any divisor structure, not just powers of 2.
- Easier to extend to non-binary parity systems.
- More intuitive for problems involving cycles, reflections, or periodicity.

## 🧩 Conclusion
- Mirror Reflection shows how mathematical modeling can replace brute-force simulation. 
- By reducing geometry to parity and periodicity, we achieve a clean, efficient solution.
- Perfect example of how LCM + parity can unlock hidden structure in seemingly visual problems.

Whether you use bitwise tricks or number theory — the goal is the same: Predict the endpoint without tracing the path.



---

## 📌 Problem: N-th Ugly Number

Find the **n-th positive integer** that is divisible by at least one of the integers `a`, `b`, or `c`.

---

## 📋 Constraints

- \( 1 \leq n, a, b, c \leq 10^9 \)  
- \( 1 \leq a \cdot b \cdot c \leq 10^{18} \)  
- The result is guaranteed to lie within the range \([1, 2 \cdot 10^9]\)

---

## ⚙️ Core Idea

The sequence of numbers divisible by `a`, `b`, or `c` is strictly increasing.  
This allows the use of binary search to find the smallest number `x` such that:

```
count}(x) \ n
```

Where `count(x)` is the number of ugly numbers less than or equal to `x`.

Search space:
```
left = 1,right = 2,000,000,000
```

---
## 📐 Inclusion-Exclusion Principle

To compute how many numbers ≤ `x` are divisible by `a`, `b`, or `c`, apply:

```

- `A = x / a` — count of numbers ≤ x divisible by a  
- `B = x / b` — count of numbers ≤ x divisible by b  
- `C = x / c` — count of numbers ≤ x divisible by c  
- `AB = x / lcm(a, b)` — count divisible by both a and b  
- `BC = x / lcm(b, c)` — count divisible by both b and c  
- `AC = x / lcm(a, c)` — count divisible by both a and c  
- `ABC = x / lcm(a, lcm(b, c))` — count divisible by all three
```


This formula avoids overcounting by subtracting overlaps and adding back the triple-overlap.

---

## 🧠 Why This Works

- `x/a + x/b + x/c`: counts all numbers divisible by each individual factor  
- `- x/lcm(...)`: subtracts overlaps (e.g., numbers divisible by both `a` and `b`)  
- `+ x/lcm(a, lcm(b,c))`: adds back the triple-overlap (divisible by all three)

This is a textbook application of the **inclusion-exclusion principle** in number theory.



## 🧱 Solution Architecture (C#)
```csharp
public class Solution {
    const int MAX = 2000000000;

    public int NthUglyNumber(int n, int a, int b, int c) {
        int left = 1, right = MAX, result = 0;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (Count(mid, a, b, c) >= n) {
                result = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }

        return result;
    }

    private int Count(long x, long a, long b, long c) {
        return (int)(
            x / a + x / b + x / c
            - x / Lcm(a, b) - x / Lcm(b, c) - x / Lcm(a, c)
            + x / Lcm(a, Lcm(b, c))
        );
    }

    private long Gcd(long a, long b) {
        return b == 0 ? a : Gcd(b, a % b);
    }

    private long Lcm(long a, long b) {
        return a / Gcd(a, b) * b;
    }
}
```


## 🧠 Why This Architecture Works

### 🔍 Binary Search
Operates in **O(log N)** time over the range \([1, 2 \cdot 10^9]\).  
Efficient for large `n` values, avoids brute-force iteration.  
Guarantees the smallest number `x` such that `Count(x) ≥ n`.

### 🧮 Modular Count Function
Implements the **inclusion-exclusion principle** to count numbers ≤ `x` divisible by `a`, `b`, or `c`.  
Handles overlapping multiples cleanly.  
Isolated logic — easy to test, reuse, and extend.

### ⚙️ GCD and LCM Utilities
`Gcd()` uses the **Euclidean algorithm** — tail-recursive and efficient.  
`Lcm()` ensures correct handling of large values without overflow.  
Both follow the **Single Responsibility Principle (SRP)** — clean separation of concerns.

### 🚫 No Brute Force
No need to generate or store the sequence of ugly numbers.  
Avoids memory overhead and time complexity pitfalls.  
Scales to extreme input sizes without degradation.

---

## 📦 Final Takeaway

This solution is not just a one-off implementation — it's a **reusable algorithmic module** with clear architectural boundaries:

| Component         | Role                                             |
|------------------|--------------------------------------------------|
| `NthUglyNumber()` | Binary search controller over the implicit sequence |
| `Count()`         | Mathematical signal extractor via inclusion-exclusion |
| `Gcd()` / `Lcm()` | Arithmetic utilities for overlap resolution         |




---

# ðŸŒ² Problem: Minimum Cost Tree From Leaf Values (Leetcode 1130)

## ðŸ“œ Statement

You're given an array `arr` of positive integers. Each value represents a **leaf node** in an in-order traversal of a binary tree. Every non-leaf node must have **exactly two children**, and its value is the **product of the largest leaf in its left and right subtree**.

Your task: construct a binary tree that satisfies these rules and **minimizes the sum of all non-leaf node values**.

---

## ðŸ§  Core Idea

This is a **greedy tree construction** problem disguised as a structural optimization. The key insight is:

> To minimize the cost, **merge the smallest leaves first**, because their product contributes less to the total sum.

But since the tree must respect **in-order traversal**, we can't arbitrarily reorder elements. So we simulate merges using a **monotonic stack**.

---

## ðŸ§ª Greedy Strategy via Stack

1. **Use a monotonic decreasing stack** to track merge candidates.
2. When a new value is **greater than or equal to** the top of the stack:
   - Pop the smaller value (`mid`)
   - Merge it with the smaller of its neighbors (`Math.Min(stack.Peek(), value)`)
   - Add the product to the total cost
3. After processing all elements, clean up remaining stack pairs.

---

## ðŸ§± C# Implementation

```csharp
public class Solution {
    public int MctFromLeafValues(int[] arr) {
        int sum = 0;
        Stack<int> stack = new Stack<int>();
        stack.Push(int.MaxValue); // Sentinel

        foreach (int value in arr) {
            while (stack.Peek() <= value) {
                int mid = stack.Pop();
                sum += mid * Math.Min(stack.Peek(), value);
            }
            stack.Push(value);
        }

        while (stack.Count > 2) {
            sum += stack.Pop() * stack.Peek();
        }

        return sum;
    }
}
```


## ðŸ§® Time & Space Complexity

- Time: O(n) â€” each element is pushed/popped at most once
- Space: O(n) â€” stack holds up to n elements

## ðŸ§  Engineering Takeaway

This problem is a textbook example of:

- Greedy merge strategy under structural constraints
- Monotonic stack to simulate in-order tree construction
- Local optimality â†’ global minimal cost


## ðŸ§© Conclusion
This task teaches how to simulate tree construction using greedy local merges while respecting traversal constraints. 
The monotonic stack acts as a merge buffer, and the cost model is driven by leaf dominance. 
A great example of structural optimization via greedy stack logic.



---

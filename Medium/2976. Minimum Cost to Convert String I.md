# 2976. Minimum Cost to Convert String I 
*O(26³ + n) — Optimal Floyd-Warshall + Linear Pass*

---
## Problem Statement

You are given two strings `source` and `target` of length `n` (both lowercase letters).

You are given:
- `original` and `changed` arrays of length `m` (1 ≤ m ≤ 2000)
- `cost[i]` = cost to change `original[i]` to `changed[i]`

You can perform operations any number of times:
- Change a character `x` to `y` in `source` at cost `z` if there exists some `j` where `original[j] = x`, `changed[j] = y`, `cost[j] = z`

Find the **minimum total cost** to convert `source` to `target`.

If impossible → return **-1**.

**Note**: Multiple edges between same pair possible (take minimum cost).

---

## Core Idea — Model as Weighted Directed Graph + Floyd-Warshall

**Key insight**:
- 26 lowercase letters → small alphabet size
- Changes are **edges** from `original[i]` → `changed[i]` with weight `cost[i]`
- We can apply changes **any number of times** → transitive changes allowed (e.g., a→b→c means a→c possible)
- Goal: for each position `i`, find **minimum cost** to change `source[i]` to `target[i]`
- If `source[i] == target[i]` → cost 0
- Else → shortest path from `source[i]` to `target[i]` in the graph

**Algorithm**:
1. Build 26×26 graph: `minCost[u][v]` = minimum cost to change u → v
2. Initialize `minCost[u][v] = INF` (except self-loops = 0)
3. For each change → update `minCost[original[i] - 'a'][changed[i] - 'a'] = min(..., cost[i])`
4. Run **Floyd-Warshall** → all-pairs shortest paths (O(26³) = 17k operations)
5. For each position `i`:
   - If `source[i] == target[i]` → add 0
   - Else → add `minCost[source[i]-'a'][target[i]-'a']`
   - If any is INF → impossible → return -1
6. Sum all position costs → that's the answer

---

##  Implementation (C#)

```csharp
// Floyd-Warshall 
public class Solution {
    public long MinimumCost(string source, string target, char[] original, char[] changed, int[] cost) {
        const long INF = long.MaxValue / 2;
        long[,] minCost = new long[26, 26];

        // Initialize graph: self = 0, others = INF
        for (int i = 0; i < 26; i++) {
            for (int j = 0; j < 26; j++) {
                minCost[i, j] = (i == j) ? 0 : INF;
            }
        }

        // Add transformation edges (take minimum if multiple)
        for (int i = 0; i < original.Length; i++) {
            int u = original[i] - 'a';
            int v = changed[i] - 'a';
            minCost[u, v] = Math.Min(minCost[u, v], cost[i]);
        }

        // Floyd-Warshall: compute shortest path between all pairs
        for (int k = 0; k < 26; k++) {
            for (int i = 0; i < 26; i++) {
                for (int j = 0; j < 26; j++)  {
                    if (minCost[i, k] < INF && minCost[k, j] < INF) minCost[i, j] = Math.Min(minCost[i, j], minCost[i, k] + minCost[k, j]);
                }
            }
        }

        // Compute total cost position by position
        long total = 0;
        for (int i = 0; i < source.Length; i++) {
            int u = source[i] - 'a';
            int v = target[i] - 'a';

            if (minCost[u, v] >= INF) return -1;
            total += minCost[u, v];
        }

        return total;
    }
}
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(26³ + n)**        | Floyd-Warshall all-pairs shortest paths: O(26³) ≈ 17,576 operations + linear pass over string: O(n) |
| **Space Complexity**  | **O(26²)**            | 26×26 cost matrix (fixed size)                 |

**Optimal** — extremely fast (26³ is tiny), even for n ≤ 10⁵ string length.

---

## Why This Works — Example Walkthrough

**Example 1**: `source = "abcd"`, `target = "acbe"`

- Rules allow various transformations (a→b cost 2, b→c cost 5, etc.)
- Floyd-Warshall computes minimum cost to change any letter to any other (including chains like d → e via intermediate steps)
- Position-by-position:
  - 'a' → 'a': cost 0
  - 'b' → 'c': cost 5
  - 'c' → 'b': cost 5 (or via chain)
  - 'd' → 'e': cost 20 (via chain)
- Total = 0 + 5 + 5 + 20 = **28** → correct

**Example 2**: `source = "aaaa"`, `target = "bbbb"`

- Chain: a → c (cost 1) → b (cost 2) → total per position **3**
- 4 positions → 3 × 4 = **12** → correct

**Example 3**: impossible to change 'd' → 'e' → minCost[d-'a'][e-'a'] remains INF → **-1**

**Correct** — Floyd-Warshall finds the true minimum transformation cost between any two characters, including multi-step chains.

---

## Pitfalls & Edge Cases

- **Same character** (`source[i] == target[i]`) → cost **0** (self-loop in graph)
- **Impossible transformation** → minCost[u][v] stays INF → return **-1**
- **Multiple rules for same pair** → Floyd-Warshall automatically takes the minimum cost
- **Large n (≤10⁵)** → O(n) final pass is fast
- **Cost overflow** → use `long` for total sum (max 10⁵ positions × 10⁶ cost = 10¹¹ fits in long)

All handled perfectly.

---

## Key Takeaway

This is a **beautifully elegant** graph + shortest path problem:

- **26 letters** → model as small weighted directed graph
- **Floyd-Warshall** → computes minimum cost to change any character to any other (including chains)
- **Position-wise** → just look up min cost from source char to target char and sum them up

**Pure, clean, optimal** — perfect minimum cost to transform one string to another.

---

# 662. Maximum Width of Binary Tree

---

## Problem Summary
We are given the root of a binary tree.  
- The **maximum width** of the tree is defined as the maximum width among all levels.  
- The width of one level = distance between the leftmost and rightmost non-null nodes, counting nulls in between as if the tree were complete.  
- Task: return the maximum width of the given tree.  

---

## Core Idea
- Use **level order traversal (BFS)**.  
- Assign each node a **position index** as if the tree were complete:  
  - Root index = 0.  
  - Left child index = `2 * parent_index`.  
  - Right child index = `2 * parent_index + 1`.  
- To avoid overflow, **normalize indices per level** by subtracting the leftmost index of that level.  
- For each level:  
  - Record the index of the first and last node.  
  - Width = `last_index - first_index + 1`.  
- Track the maximum width across all levels.  

---

## C++ Implementation
```cpp

class Solution {
public:
    int widthOfBinaryTree(TreeNode* root) {
        if (!root) return 0;
        long long maxWidth = 0;
        queue<pair<TreeNode*, long long>> q;
        q.push({root, 0});
        
        while (!q.empty()) {
            int size = q.size();
            long long left = q.front().second; // leftmost index of this level
            long long right = left;
            for (int i = 0; i < size; i++) {
                auto [node, idx] = q.front(); q.pop();
                long long normIdx = idx - left; // normalize to prevent overflow
                right = normIdx;
                if (node->left) q.push({node->left, 2LL * normIdx});
                if (node->right) q.push({node->right, 2LL * normIdx + 1});
            }
            maxWidth = max(maxWidth, right + 1); // width = last - first + 1
        }
        return (int)maxWidth;
    }
};

```

## Complexity
- **Time:** O(n) — each node is visited once.  
- **Space:** O(n) — the queue may hold up to one level of nodes.  

---

## Pitfalls
- Must use **long long** for indices to avoid overflow.  
- Normalize indices per level to keep values small and safe.  
- **Edge case:** single node tree → width = 1.  
- Null nodes are not stored explicitly, but indices simulate their positions in a complete tree.  

---

## Example Walkthrough
**Input:** `root = [1,3,2,5,3,null,9]`  

- **Level 0:** [1] → indices [0] → width = 1  
- **Level 1:** [3,2] → indices [0,1] → width = 2  
- **Level 2:** [5,3,null,9] → indices [0,1,2,3] → width = 4  

**Output:** `4`  

---

## Conclusion
The problem reduces to a **BFS traversal with positional indexing** to simulate a complete binary tree.  
- Width is computed as `(last_index - first_index + 1)` per level.  
- Normalization prevents overflow and keeps indices manageable.  
- Runs in **O(n)** time and **O(n)** space.  
- Efficient, robust, and handles trees up to 3000 nodes safely.  



---



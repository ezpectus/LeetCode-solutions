# 2039. The Time When the Network Becomes Idle  
*O(n + m) — BFS + Patience Calculation*

---

## Problem Statement

There are `n` servers labeled from 0 to n-1.  
Server 0 is the master server.  
You are given:
- `edges` — undirected edges representing bidirectional message channels (1 second per hop)
- `patience` — array of length n, where patience[0] = 0

Each data server i (1 to n-1) sends a message to master (0) at second 0.  
The message travels via shortest path (optimal routing).  
Master processes instantly and sends reply back via the same path.

Starting from second 1, at the beginning of each second, data server i checks if it has received a reply:
- If **not** received yet → resend the message every `patience[i]` seconds
- If received → stop resending

The network becomes **idle** when no messages are in transit or arriving.

Return the **earliest second** (starting from 0) when the network becomes idle.

---

## Core Idea — BFS Shortest Path + Last Message Arrival Time

**Key insight**:
- First, compute shortest distance `dist[i]` from each server i to master (0) using BFS (unweighted graph)
- Round-trip time for server i = **2 × dist[i]** (to master and back)
- First reply arrives at server i at time **2 × dist[i]**
- Server i keeps resending every `patience[i]` seconds until it receives a reply
- The **last message** server i sends is the last resend **before** it receives the first reply

**Formula for last message departure time from i**:
```
last_send = floor((first_reply_time - 1) / patience[i]) × patience[i]
```


- Then, this last message arrives back at server i at:  
  `last_send + 2 × dist[i]`

- The network becomes idle at the **maximum** over all servers i of:  
  `last_send[i] + 2 × dist[i]`

- Plus **+1** because idle starts at the **beginning** of the next second after the last arrival

**Edge case**:
- If `patience[i] == 0` or first reply arrives before any resend → only initial message
- patience[0] = 0 (master never sends messages)

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int NetworkBecomesIdle(int[][] edges, int[] patience) {
        int n = patience.Length;

        // Build adjacency list
        var adj = new List<int>[n];
        for (int i = 0; i < n; i++) adj[i] = new List<int>();

        foreach (var e in edges) {
            adj[e[0]].Add(e[1]);
            adj[e[1]].Add(e[0]);
        }

        // BFS from master (0) to compute shortest distance to all nodes
        int[] dist = new int[n];
        Array.Fill(dist, -1);
        dist[0] = 0;

        var queue = new Queue<int>();
        queue.Enqueue(0);
        while (queue.Count > 0) {
            int u = queue.Dequeue();
            foreach (int v in adj[u]) {
                if (dist[v] == -1) {
                    dist[v] = dist[u] + 1;
                    queue.Enqueue(v);
                }
            }
        }

        // For each data server i (i >= 1), compute time when last message arrives back
        int maxIdleTime = 0;

        for (int i = 1; i < n; i++) {
            int roundTrip = 2 * dist[i]; // time for first reply to arrive
            int p = patience[i];

            // Number of resends before first reply arrives
            int lastSendTime;
            if (roundTrip <= p) {
                // No resend needed — first message reply arrives in time
                lastSendTime = 0;
            } 
            else {
                // Last resend time = floor((roundTrip - 1) / p) * p
                int numResends = (roundTrip - 1) / p;
                lastSendTime = numResends * p;
            }

            // This last message arrives back at: lastSendTime + roundTrip
            int arrival = lastSendTime + roundTrip;

            // Network idle starting from second arrival + 1
            maxIdleTime = Math.Max(maxIdleTime, arrival + 1);
        }

        return maxIdleTime;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n + m)**  | BFS for shortest paths from master (0) to all nodes: O(n + m), where m = number of edges <br>Single loop over all n servers to compute idle times: O(n) <br>Total: **O(n + m)** |
| **Space Complexity**  | **O(n + m)**  | Adjacency list: O(m) <br>Distance array: O(n) <br>BFS queue: O(n) worst-case <br>Total dominated by graph representation: O(n + m) |

**Optimal** — linear in graph size (nodes + edges), perfect and efficient for n ≤ 10⁵ and m up to ~n²/2.

---

## Why This Works — Example Walkthrough

**Example 1**: edges = [[0,1],[1,2]], patience = [0,2,1]

- BFS distances from 0:  
  dist[0] = 0  
  dist[1] = 1  
  dist[2] = 2

- Server 1 (i=1):  
  roundTrip = 2 × 1 = 2  
  patience[1] = 2  
  Last resend time = floor((2-1)/2) × 2 = 0  
  Last message arrival = 0 + 2 = 2  
  Idle starts from second 3 (2 + 1)

- Server 2 (i=2):  
  roundTrip = 2 × 2 = 4  
  patience[2] = 1  
  Last resend time = floor((4-1)/1) × 1 = 3  
  Last message arrival = 3 + 4 = 7  
  Idle starts from second 8 (7 + 1)

- Maximum idle time = **8** → correct

**Correct** —  
For each data server i (i ≥ 1):
- First reply arrival time = **2 × dist[i]** (round trip to master and back)
- Last resend time = floor((first_reply_time - 1) / patience[i]) × patience[i]  
  → the last time the server sends a message before receiving the first reply
- Final arrival of that last message = last_resend + 2 × dist[i]
- Network becomes idle at the **beginning** of the second after the last message arrives → max over all i of (final_arrival + 1)

---

## Key Takeaway

This is a **classic shortest path + periodic resend** problem:

- Compute **shortest distance** from master server (0) to every data server using BFS (unweighted graph)
- For each data server i (i ≥ 1):
  - Round-trip time = **2 × dist[i]**
  - Last resend time = **floor((roundTrip - 1) / patience[i]) × patience[i]**
  - Last message arrival back at server = last_resend + roundTrip
- The network becomes idle at the **maximum** over all servers of (last arrival + 1)

**Pure, clean, optimal** — O(n + m) time, BFS + straightforward math, no hidden tricks or edge cases missed.

---

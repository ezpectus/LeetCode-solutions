# LeetCode 990 — Satisfiability of Equality Equations  
**Approach: Union-Find (Disjoint Set Union with Path Compression and Union by Rank)**

---

##  Problem Restatement
You are given an array of equations of the form `"x==y"` or `"x!=y"`, where `x` and `y` are lowercase letters.  
Return `true` if it is possible to assign values to variables so that all equations are satisfied, otherwise return `false`.

---

##  Core Idea
- Each variable (`'a'` to `'z'`) is treated as a node in a graph.  
- Equality equations (`"x==y"`) connect two nodes, meaning they must belong to the same set.  
- Inequality equations (`"x!=y"`) require that two nodes belong to different sets.  
- The problem reduces to checking **connected components**:  
  - Union all equalities.  
  - Verify inequalities: if both variables are in the same set, contradiction → return `false`.  
- If no contradictions are found, return `true`.

---

##  Union-Find Strategy
1. **Initialize DSU:** Create Union-Find for 26 lowercase letters.  
2. **Union equalities:** For each `"x==y"`, union the sets containing `x` and `y`.  
3. **Check inequalities:** For each `"x!=y"`, check if `x` and `y` belong to the same set.  
   - If yes → contradiction → return `false`.  
4. **Final answer:** If no contradictions are found, return `true`.

---

##  Implementation (C#)

```csharp
public class Solution {
    public bool EquationsPossible(string[] equations) {
        UnionFind uf = new UnionFind(26); // 26 lowercase letters

        // Step 1: Union all equalities
        foreach (var eq in equations) {
            if (eq[1] == '=') {
                int x = eq[0] - 'a';
                int y = eq[3] - 'a';
                uf.Union(x, y);
            }
        }

        // Step 2: Check all inequalities
        foreach (var eq in equations) {
            if (eq[1] == '!') {
                int x = eq[0] - 'a';
                int y = eq[3] - 'a';
                if (uf.Find(x) == uf.Find(y)) {
                    return false; // contradiction
                }
            }
        }

        return true;
    }
}

public class UnionFind {
    private int[] parent;
    private int[] rank;

    public UnionFind(int size) {
        parent = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            parent[i] = i; // each node is its own parent initially
            rank[i] = 0;   // rank starts at 0
        }
    }

    // Path compression: flatten the tree for efficiency
    public int Find(int x) {
        if (parent[x] != x) {
            parent[x] = Find(parent[x]);
        }
        return parent[x];
    }

    // Union by rank: attach smaller tree under larger one
    public void Union(int x, int y) {
        int rootX = Find(x);
        int rootY = Find(y);
        if (rootX == rootY) return;

        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
    }
}
```

##  Time Complexity
- **Union-Find operations:** Each `Find` and `Union` runs in nearly constant time `O(α(n))`, where `α` is the inverse Ackermann function (extremely slow-growing, practically constant).  
- **Total complexity:** For up to 500 equations, we perform at most `n` unions and finds.  
  - Overall complexity ≈ `O(n α(n))`.  
- **Comparison:** Much faster and cleaner than simulating assignments or brute force checks.

---

##  Space Complexity
- **DSU arrays:** `O(26)` for `parent` and `rank` (constant, since only lowercase letters are used).  
- **No extra structures needed:** Only equations are processed.  
- **Total space:** `O(1)` relative to input size, since the alphabet size is fixed.

---

#  Impact of Design Choices

| Design Choice                  | Effect                                                                 |
|--------------------------------|------------------------------------------------------------------------|
| **Union by rank + compression**| Keeps DSU trees shallow, guaranteeing near-constant time operations.   |
| **Processing equalities first**| Ensures sets are correctly merged before checking inequalities.        |
| **Fixed DSU size (26)**        | Efficient and simple, since variables are limited to lowercase letters.|

---

#  Pitfalls

- **Processing inequalities before equalities:** May miss contradictions because sets are not yet merged.  
- **Skipping path compression:** DSU becomes inefficient, degrading performance to linear in worst case.  
- **Incorrect union logic:** Mismanaging rank or parent updates can lead to wrong results.  
- **Assuming more than 26 variables:** Adds unnecessary complexity, constraints guarantee lowercase letters only.  

---

#  Conclusion

- **What it gives:** Efficient solution using DSU to check satisfiability of equations.  
- **Why it matters:** Converts logical constraints into a connectivity problem, solved in near-linear time.  
- **Key takeaway:**  
  1. Union all equalities.  
  2. Check inequalities for contradictions.  
  3. Return result.  

This approach is clean, scalable, and leverages DSU’s strengths for constraint satisfaction problems.



---

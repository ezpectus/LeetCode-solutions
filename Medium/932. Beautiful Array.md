# ðŸ§  932. Beautiful Array

## ðŸ”— Problem Statement

An array `nums` of length `n` is **beautiful** if:
- It is a **permutation** of integers from `1` to `n`
- For every `0 <= i < j < n`, there is **no index `k`** with `i < k < j` such that:  
  `2 * nums[k] == nums[i] + nums[j]`

Given `n`, return **any** beautiful array of length `n`.  
There is always at least one valid answer.

---

## âœ… Signals

- Avoid any triplet where the middle element is the **arithmetic mean** of two others  
- Use **odd-even partitioning** to prevent symmetric patterns  
- Build the array **iteratively** to avoid recursion overhead  
- Maintain control over memory and stack usage

---

## ðŸ§© Solution â€” Iterative Odd-Even Expansion

```csharp
public class Solution {
    public int[] BeautifulArray(int n) {
        var res = new List<int>();
        res.Add(1);

        while (res.Count < n) {
            var temp = new List<int>();

            foreach (int odd in res) {
                if (odd * 2 - 1 <= n) {
                    temp.Add(odd * 2 - 1);
                }
            }

            foreach (int even in res) {
                if (even * 2 <= n) {
                    temp.Add(even * 2);
                }
            }

            res = temp;
        }

        return res.ToArray();
    }
}
```

---

## ðŸ” Notes

### ðŸ”— Why Iterative Instead of Recursive?

- Recursive solutions build the array via divide-and-conquer, but they consume **stack space** and can be inefficient for large `n`  
- This solution **emulates recursion** using `List<int>` and controlled expansion  
- Each iteration **doubles the size** of the array while preserving the beautiful property  
- Avoids call stack overhead and keeps memory usage predictable

---

## ðŸ§  Signal Summary

| Concept           | Expression              | Role                            |
|-------------------|--------------------------|----------------------------------|
| Start with `[1]`  | `res.Add(1)`             | Base case                        |
| Odd expansion     | `2 * x - 1`              | Builds left half                 |
| Even expansion    | `2 * x`                  | Builds right half                |
| Iterative growth  | `while (res.Count < n)` | Controlled recursion emulation   |

---

## â±ï¸ Complexity

| Metric       | Value         |
|--------------|---------------|
| Time         | `O(n log n)`  |
| Space        | `O(n)`        |
| Stack usage  | `O(1)`        |

---

## âœ… Takeaways

This solution avoids arithmetic midpoints by **recursively expanding odd and even partitions**, but does so **iteratively** for performance and control:

- âŒ No recursion â†’ no stack overflow risk  
- âŒ No brute force â†’ no need to check every triplet  
- âœ… Guaranteed beautiful array for any `n â‰¤ 1000`  
- âœ… Use this as a **base module** for any permutation generation that requires **symmetry avoidance**

---


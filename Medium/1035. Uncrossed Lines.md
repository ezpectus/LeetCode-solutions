# 1035. Uncrossed Lines — Architectural Solution

## Problem Statement  
You are given two integer arrays `nums1` and `nums2`.  
We draw connecting lines between `nums1[i]` and `nums2[j]` such that:

* `nums1[i] == nums2[j]`
* The line does not intersect any other connecting line (not even at endpoints)

Return the maximum number of uncrossed connecting lines.

## Constraints:

* `1 <= nums1.length, nums2.length <= 500`
* `1 <= nums1[i], nums2[j] <= 2000`

## Core Idea  
- The non-crossing requirement means the chosen connections must preserve the relative order of indices in both arrays.
- This is exactly the definition of a common subsequence.

Therefore:

- **Maximum number of uncrossed lines = Length of the Longest Common Subsequence (LCS)**
- The problem instantly reduces to the classic LCS DP.

Steps:

1. Build a 2D DP table where `dp[i][j]` = LCS length of `nums1[0..i-1]` and `nums2[0..j-1]`
2. Recurrence:
   * If `nums1[i-1] == nums2[j-1]` → `dp[i][j] = dp[i-1][j-1] + 1`
   * Else → `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`
3. Answer is `dp[n][m]`

## Implementation (C#)

```csharp

public int MaxUncrossedLines(int[] a, int[] b) {
    if (a.Length < b.Length) (a, b) = (b, a);
    int[] prev = new int[b.Length + 1];
    int[] curr = new int[b.Length + 1];

    for (int i = 1; i <= a.Length; i++) {
        for (int j = 1; j <= b.Length; j++) {
            curr[j] = a[i-1] == b[j-1] 
                ? prev[j-1] + 1 
                : Math.Max(curr[j-1], prev[j]);
        }
        (prev, curr) = (curr, prev);
    }
    return prev[b.Length];
}
```

## Complexity Analysis

* Time Complexity: **O(n × m)**  
  Standard 2D DP over both arrays.

* Space Complexity: **O(n × m)**  
  Can be reduced to **O(min(n,m))** using rolling array (two 1D arrays).

## Pitfalls & Edge Cases

* Duplicate values  
  LCS correctly uses each occurrence at most once — exactly what the problem requires.

* One array is a subsequence of the other  
  Answer equals the length of the smaller array.

* All elements distinct  
  Maximum answer is 1.

* Single-element arrays  
  Answer is 0 or 1.

## Conclusion

-  What appears to be a geometry/drawing problem is actually one of the most classic dynamic-programming patterns in disguise.
-  The single architectural insight — realizing that “non-crossing connections with equal values” is exactly the definition of a common subsequence — instantly collapses the entire problem into the textbook Longest Common Subsequence (LCS) template.
-  No graphs, no simulation, no bit manipulation tricks — just pure, provably optimal 2D DP.
- Standard implementation gives O(n·m) time and O(n·m) space; a trivial rolling-array optimization reduces space to O(min(n,m)) with virtually no extra code.
-  Bottom line: the moment you think “Uncrossed Lines = LCS”, a problem that looks Hard becomes a 15-line Medium you can write blindfolded.

Mastering this kind of instant pattern recognition is exactly what separates mid-level coders from true solution architects who crush LeetCode “Hard” problems in minutes.

---


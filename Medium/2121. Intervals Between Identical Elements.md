# 2121. Intervals Between Identical Elements  
*O(n) — Group by Value + Prefix Sum of Indices*

---

## Problem Statement

- Given a **0-indexed** array `arr` of `n` integers.
- For each index `i`, compute the **sum of intervals** between `arr[i]` and every other element in the array that has the **same value** as `arr[i]`.
- The interval between two indices `i` and `j` is defined as `|i - j|`.
- Return an array `intervals` of length `n` where `intervals[i]` is this sum for index `i`.

**Examples**:

**Example 1**: arr = [2,1,3,1,2,3,3]  
Output: [4,2,7,2,4,4,5]  
- For index 0 (2): another 2 at index 4 → |0-4| = 4  
- For index 1 (1): another 1 at index 3 → |1-3| = 2  
- For index 2 (3): two more 3s at 5 and 6 → |2-5| + |2-6| = 7  
- etc.

**Constraints**:
- 1 ≤ n ≤ 10⁵
- 1 ≤ arr[i] ≤ 10⁵

---

## Core Idea — Group Positions by Value + Arithmetic Sum

**Key insight**:
- For each unique value `x` in arr, collect **all indices** where arr[i] == x → say list `pos = [p1, p2, ..., pk]` (sorted)
- For each position pj in this list, the sum of intervals to all other positions with same value is:```sum_{m ≠ j} |pj - pm| = sum_{m < j} (pj - pm) + sum_{m > j} (pm - pj)```
- This can be rewritten as:```(j × pj - sum of first j positions) + (sum of last (k-j) positions - (k-j) × pj)```
  
**Efficient way**:
- Group all indices by their value using a dictionary: `value → List<int> positions`
- For each group of positions (sorted):
- Compute prefix sums of positions
- For each index j in the group:
  - Left sum = j × pos[j] - prefix[j]
  - Right sum = (prefix[k] - prefix[j]) - (k - j) × pos[j]
  - Total = left + right
- Put results back into answer array at correct original indices

**Time**: O(n) — grouping O(n), processing each group O(size), total across all groups O(n)  
**Space**: O(n) — dictionary + lists + prefix sums

---

## Clean Implementation (C#)

```csharp
public class Solution {
  public long[] GetDistances(int[] arr) {
      int n = arr.Length;
      long[] answer = new long[n];

      // Group indices by value
      Dictionary<int, List<int>> groups = new Dictionary<int, List<int>>();
      for (int i = 0; i < n; i++) {
          int val = arr[i];
          if (!groups.ContainsKey(val)) groups[val] = new List<int>();
          groups[val].Add(i);
      }

      // For each value, compute sum of distances to other occurrences
      foreach (var kvp in groups) {
          List<int> pos = kvp.Value;
          int k = pos.Count;

          // Prefix sum of positions
          long[] prefix = new long[k + 1];
          for (int j = 1; j <= k; j++) {
              prefix[j] = prefix[j - 1] + pos[j - 1];
          }

          // For each position in this group
          for (int j = 0; j < k; j++) {
              long curr = pos[j];

              // Left part: sum (curr - pos[m]) for m < j
              long left = (long)j * curr - prefix[j];

              // Right part: sum (pos[m] - curr) for m > j
              long right = (prefix[k] - prefix[j + 1]) - (long)(k - j - 1) * curr;
              long total = left + right;

              // Put result in answer at original index
              answer[pos[j]] = total;
          }
      }

      return answer;
   }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Grouping indices by value: O(n)  
For each group: compute prefix sums O(size), then compute distances for each position O(size)  
Total across all groups: O(n) |
| **Space Complexity**  | **O(n)**      | Dictionary + lists of indices: O(n)  
Prefix sum arrays (per group): O(n) total in worst case |

**Optimal** — linear time and linear space — perfect and highly efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: arr = [2,1,3,1,2,3,3]

**Groups**:
- Value 2 → indices [0, 4]
  - For index 0: distance to 4 → |0-4| = **4**
  - For index 4: distance to 0 → |4-0| = **4**

- Value 1 → indices [1, 3]
  - For index 1: |1-3| = **2**
  - For index 3: |3-1| = **2**

- Value 3 → indices [2, 5, 6]
  - For index 2: |2-5| + |2-6| = 3 + 4 = **7**
  - For index 5: |5-2| + |5-6| = 3 + 1 = **4**
  - For index 6: |6-2| + |6-5| = 4 + 1 = **5**

**Result**: [4, 2, 7, 2, 4, 4, 5] → correct

**Correct** —  
By grouping all occurrences of each value and using **prefix sums of their indices**, we can compute for every position the total absolute distance to all other positions with the same value in constant time per element (after prefix computation).  
This turns a naive O(n²) approach into a clean O(n) solution.

---

## Key Takeaway

This is a **classic sum-of-distances-to-identical-elements** problem solved elegantly with grouping and prefix sums:

* **Group** all indices by their value using a dictionary (value → list of positions)
* For each group of positions (already sorted by index):
  * Compute **prefix sums** of the positions
  * For each position pj at group index j:
    * Left contribution: j × pj - prefix[j]
    * Right contribution: (prefix[k] - prefix[j+1]) - (k - j - 1) × pj
    * Total distance sum = left + right
* Place each computed sum back into the answer array at the **original index**

**Pure, clean, optimal** — O(n) time, O(n) space, mathematically beautiful, extremely fast, and very elegant.

---

  

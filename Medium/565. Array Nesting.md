# 565. Array Nesting — Architectural Cycle Detection in Permutation  
*O(n) — Longest Cycle in Functional Graph*

---

## Problem Statement

Given an array `nums` of length `n` that is a **permutation** of `[0 … n-1]`:

For each starting index `k`, follow the chain:  
`k → nums[k] → nums[nums[k]] → …` until a repeat.

Return the **maximum length** of such a chain.

---

## Core Idea — Disjoint Cycles in a Permutation

Since `nums` is a **permutation**, the graph is a **collection of disjoint cycles**.

Example:
```
nums = [5,4,0,3,1,6,2]
→ cycles:
0 → 5 → 6 → 2 → 0    (length 4)
1 → 4 → 1             (length 2)
3 → 3                 (length 1)
→ answer = 4
```
**Goal**: find the **longest cycle**.

---

## Full Implementation (C#)

```csharp
public class Solution {
    public int ArrayNesting(int[] nums) {
        int n = nums.Length;
        bool[] visited = new bool[n];
        int maxLen = 0;

        for (int i = 0; i < n; i++) {
            if (visited[i]) continue;

            int len = 0;
            int j = i;

            while (!visited[j]) 
            {
                visited[j] = true;
                j = nums[j];
                len++;
            }

            maxLen = Math.Max(maxLen, len);
        }

        return maxLen;
    }
}
```


## Complexity Analysis

| **Metric**     | **Value**   | **Notes**                                      |
|----------------|-------------|------------------------------------------------|
| **Time**       | **O(n)**    | Each index visited **exactly once**            |
| **Space**      | **O(n)**    | `visited` array (can be O(1) with in-place marking) |

**Optimal** — linear time, no faster possible.

---

## Pitfalls & Edge Cases

- **Mark as visited immediately** → prevents infinite loops on cycles
- **Cycles are disjoint** → once a cycle is processed, skip all its nodes
- Works perfectly for:
  - `n = 1` → returns `1`
  - All fixed points (self-loops) → returns `1`
  - One giant cycle → returns `n`
  - Multiple cycles of any size → correctly finds **longest**
  - Duplicates impossible (permutation) → no extra checks needed

---

## Key Takeaway

This is a **textbook functional graph / permutation cycle** problem:

- Every node has **out-degree exactly 1**
- Graph consists of **disjoint cycles** (possibly with trees feeding into them — but here only cycles)
- Traverse each cycle once using **visited tracking**
- Count length → keep **maximum**

**Clean, elegant, O(n) solution** — one of the purest examples of **cycle detection in a permutation**.
A must-know pattern for every competitive programmer.

---

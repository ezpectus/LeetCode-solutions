# 2385. Amount of Time for Binary Tree to Be Infected  
*O(n) — BFS from Start Node (Treating Tree as Undirected Graph)*

---

## Problem Statement

- Given the root of a binary tree with **unique** node values and an integer `start`.
- Infection starts at minute 0 from the node with value `start`.
- Each minute, any **uninfected** node that is **adjacent** (directly connected by an edge) to an infected node becomes infected.
- Return the number of minutes needed until the **entire tree** is infected.

**Examples**:

**Example 1**  
Input: root = [1,5,3,null,4,10,6,9,2], start = 3  
Output: **4**  
Infection process:  
- Minute 0: Node 3  
- Minute 1: Nodes 1, 10, 6  
- Minute 2: Node 5  
- Minute 3: Node 4  
- Minute 4: Nodes 9, 2  

**Example 2**  
Input: root = [1], start = 1  
Output: **0**  
Single node already infected at minute 0

**Constraints**:
- 1 ≤ number of nodes ≤ 10⁵
- 1 ≤ Node.val ≤ 10⁵
- All Node.val are unique
- Node with value `start` exists in the tree

---

## Solution — Clean C# Implementation

```csharp
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution{
    public int AmountOfTime(TreeNode root, int start){
        // Step 1: Build undirected graph (adjacency list)
        var graph = new Dictionary<int, List<int>>();
        void BuildGraph(TreeNode node, TreeNode parent){
            if (node == null) return;
            if (!graph.ContainsKey(node.val)) graph[node.val] = new List<int>();

            if (parent != null){
                graph[node.val].Add(parent.val);
                graph[parent.val].Add(node.val);
            }

            BuildGraph(node.left, node);
            BuildGraph(node.right, node);
        }

        BuildGraph(root, null);

        // Step 2: BFS from start node
        var queue = new Queue<int>();
        var visited = new HashSet<int>();

        queue.Enqueue(start);
        visited.Add(start);
        int minutes = 0;

        while (queue.Count > 0){
            int levelSize = queue.Count;
            bool infectedNew = false;

            for (int i = 0; i < levelSize; i++){
                int curr = queue.Dequeue();

                foreach (int neighbor in graph[curr]){
                    if (!visited.Contains(neighbor)){
                        visited.Contains(neighbor);
                        visited.Add(neighbor);
                        queue.Enqueue(neighbor);
                        infectedNew = true;
                    }
                }
            }

            if (infectedNew) minutes++; 
        }

        return minutes;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Building the adjacency list (graph): O(n)<br>BFS traversal visits each node and each edge exactly once: O(n) |
| **Space Complexity**  | **O(n)**      | Adjacency list (graph): O(n)<br>Queue + visited set: O(n) in worst case |

**Optimal** — linear time and linear space — ideal and very efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: root = [1,5,3,null,4,10,6,9,2], start = 3

**Tree structure**:
```
     1
   /   \
5      3
/ \      /   \
4  10   6    null
/ \
9   2
```


**Undirected graph view** (connections):
- 1 ↔ 5, 1 ↔ 3
- 5 ↔ 4
- 3 ↔ 6
- 10 ↔ 9, 10 ↔ 2

**BFS infection starting from node 3**:
- **Minute 0**: infected = {3}
- **Minute 1**: neighbors of 3 → 1 and 6 → infected = {3,1,6}
- **Minute 2**: neighbors of new nodes → 5 (from 1), 10 (from 6) → infected = {3,1,6,5,10}
- **Minute 3**: neighbors → 4 (from 5), 9 (from 10) → infected = {3,1,6,5,10,4,9}
- **Minute 4**: neighbors → 2 (from 9) → infected = {3,1,6,5,10,4,9,2}

All 8 nodes infected → last infection at **minute 4** → return **4** → correct

**Correct** —  
The infection spreading process is **exactly** a **breadth-first search (BFS)** starting from the node with value `start`.  
Each level of the BFS represents **one minute** of infection spreading to all adjacent uninfected nodes simultaneously.  
The answer is the **maximum depth** (or level) reached during BFS — the minute when the last node becomes infected.

---

## Key Takeaway

This is a **classic BFS on tree (treated as undirected graph)** problem:

* Convert the binary tree into an **undirected graph** using adjacency list (via DFS or recursion)
* Perform **BFS** starting from the node with value `start`
* Use a queue to process nodes level by level and a set to track visited/infected nodes
* Each level in BFS corresponds to **one minute** of infection spread
* The **maximum level** (or depth) reached = total minutes needed until the whole tree is infected

**Pure, clean, optimal** — O(n) time, O(n) space, extremely fast, very intuitive, and perfectly models the simultaneous infection spreading process.

---

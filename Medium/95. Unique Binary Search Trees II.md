# ðŸ§© Problem: Unique Binary Search Trees II
Goal: Generate all structurally unique BSTs that store values from 1 to n.

## ðŸ”§ Pattern: Recursive Tree Construction with Divide & Conquer

- This problem uses a recursive decomposition pattern where each number in the range [start, end] is treated as a potential root.
- For each root, we recursively generate all possible left and right subtrees, then combine them.
- This is a classic tree-building DFS with memoization potential (though not required here due to unique structure generation).

## ðŸ§  Step-by-Step Architecture
1. Recursive Function Signature
```csharp
List<TreeNode> Build(int start, int end)
```
Returns all BSTs that can be built from values in [start, end].

2. Base Case
```csharp
if (start > end) return [null];
```
An empty subtree is represented by null. This is crucial for leaf node construction.

3. Recursive Construction
For each i in [start, end]:

Treat i as the root.

Recursively build all left subtrees from [start, i - 1].

Recursively build all right subtrees from [i + 1, end].

Combine each pair of left and right trees with root i.

```csharp
foreach (var left in leftTrees)
    foreach (var right in rightTrees)
        root = new TreeNode(i)
        root.left = left
        root.right = right
        result.Add(root)
```
4. Final Entry Point
csharp
GenerateTrees(n) => Build(1, n)
Starts the recursive process from the full range.

## ðŸ§  Why This Works

BST Property: All nodes in the left subtree are < root, and all in the right are > root.
Exhaustive Enumeration: By iterating every possible root and combining all valid left/right subtrees, we cover all unique structures.
Recursive Composition: Each subtree is built independently and reused across combinations.

## ðŸ§± Reusability Notes

This pattern generalizes to any problem requiring enumeration of all tree structures (e.g. expression trees, full binary trees).
Can be memoized if the problem allows reuse of subtree structures (not needed here due to uniqueness).
Useful for problems involving Catalan numbers â€” the count of unique BSTs is C(n).



```csharp
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 
public class Solution {
    public IList<TreeNode> GenerateTrees(int n) {
        if (n == 0) return new List<TreeNode>();
        return Build(1, n);
    }

    private IList<TreeNode> Build(int start, int end) {
        var result = new List<TreeNode>();

        if (start > end) {
            result.Add(null);
            return result;
        }

        for (int i = start; i <= end; i++) {
            var leftTrees = Build(start, i - 1);
            var rightTrees = Build(i + 1, end);

            foreach (var left in leftTrees) {
                foreach (var right in rightTrees) {
                    var root = new TreeNode(i);
                    root.left = left;
                    root.right = right;
                    result.Add(root);
                }
            }
        }

        return result;
    }
}
```

# 794. Valid Tic-Tac-Toe State — Architectural Turn & Win Consistency Check  
*O(1) — Pure Game Rule Validation*

---

## Problem Statement

Given a 3×3 Tic-Tac-Toe board as `string[] board` with `'X'`, `'O'`, or `' '`, return `true` **iff** this state is **reachable** in a valid game.

**Rules reminder**:
- Players alternate, **X always starts**
- Cannot play on occupied cell
- Game ends on win **or** full board

---

## Core Idea — Count Moves + Check Win Consistency

**Key insights**:
- Number of `'X'` must be **equal** to `'O'` or **one more** (`X` starts)
- **Cannot have both players winning** at the same time
- If **X wins** → must have **one more move** than O (X played last)
- If **O wins** → must have **same number** of moves (O played last)

**No need to simulate** — just **count** and **check wins**.

---

## Implementation (C#)

```csharp
public class Solution{
    public bool ValidTicTacToe(string[] board) {
        int xCount = 0, oCount = 0;

        // Count moves
        foreach (string row in board) {
            foreach (char c in row) {
                if (c == 'X') xCount++;
                if (c == 'O') oCount++;
            }
        }

        // X must not have fewer moves than O
        if (oCount > xCount || xCount - oCount > 1) 
            return false;

        bool xWins = HasWin(board, 'X');
        bool oWins = HasWin(board, 'O');

        // Both cannot win simultaneously
        if (xWins && oWins) return false;

        // If X wins → must have played last (one more move)
        if (xWins && xCount != oCount + 1) return false;

        // If O wins → must have played last (equal moves)
        if (oWins && xCount != oCount) return false;

        return true;
    }

    private bool HasWin(string[] board, char player) {
        // Rows & columns
        for (int i = 0; i < 3; i++) {
            if (board[i][0] == player && board[i][1] == player && board[i][2] == player) return true;
            if (board[0][i] == player && board[1][i] == player && board[2][i] == player) return true;
        }

        // Diagonals
        if (board[0][0] == player && board[1][1] == player && board[2][2] == player) return true;
        if (board[0][2] == player && board[1][1] == player && board[2][0] == player) return true;

        return false;
    }
}
```


## Complexity

| **Metric**     | **Value**   | **Notes**                          |
|----------------|-------------|------------------------------------|
| **Time**       | **O(1)**    | Fixed 3×3 board — constant operations |
| **Space**      | **O(1)**    | Only counters and win checks       |

**True O(1)** — fastest possible.

---

## Why This Works — Key Rules Enforced

The solution relies on **four fundamental rules** of Tic-Tac-Toe:

- **Turn order**: X always starts → number of X's is either equal to O's or one more
- **Win conditions**:
  - If **X wins** → X must have played the **last move** (xCount = oCount + 1)
  - If **O wins** → O must have played the **last move** (xCount = oCount)
  - **Both cannot win simultaneously** — impossible in valid play

These rules **completely characterize** reachable states.

**Invalid examples rejected**:
- `"O  "` → O played first → `oCount > xCount` → false
- X wins but `xCount == oCount` → X didn't play last → false
- Both win → impossible → false

**Valid examples accepted**:
- Full board with no winner and correct turn count → true
- Winner with correct turn count → true

---

## Pitfalls & Edge Cases

- **O plays first** → `oCount > xCount` → false
- **X wins but equal moves** → false
- **O wins but X has more moves** → false
- **Both players win** → false
- **Full board without winner** → valid only if move count correct

All handled perfectly.

---

## Key Takeaway

This is a **masterpiece of rule-based validation**:

- **No simulation** — just count moves and check wins
- **4 simple conditions** → complete correctness
- **O(1)** time — elegant and fast

**One of the cleanest Medium logic problems** — solved with **pure insight** into game rules.

---

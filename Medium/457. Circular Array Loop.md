# 457. Circular Array Loop

---

## Problem Summary
We are given a circular array `nums` of non-zero integers.  
- Each `nums[i]` indicates how many steps to move forward (if positive) or backward (if negative).  
- The array is circular, so moving past the end wraps around.  
- A valid cycle must:  
  - Have length > 1.  
  - All moves in the cycle go in the same direction (all positive or all negative).  
- Task: return `true` if such a cycle exists, otherwise `false`.

---
## Code Idea

To detect a valid cycle in the circular array, we can use **Floyd’s cycle detection (slow/fast pointers)** combined with direction checks:

1. **Helper function `NextIndex(nums, i)`**  
   - Computes the next index from `i` using the jump `nums[i]`.  
   - Must handle circular wrap-around correctly with modulo arithmetic.  

2. **Iterate over all indices**  
   - Skip if already visited (`nums[i] == 0`).  
   - Determine direction (`forward = nums[i] > 0`).  

3. **Cycle detection with slow/fast pointers**  
   - Move `slow` by 1 step, `fast` by 2 steps.  
   - If direction changes (sign mismatch), break.  
   - If `slow == fast`, check that cycle length > 1 (`slow != NextIndex(nums, slow)`).  
   - If valid, return `true`.  

4. **Mark visited path**  
   - After finishing from index `i`, mark all nodes in that path as visited (`nums[idx] = 0`) to avoid reprocessing.  

---

### Key Insights
- **Direction consistency**: all numbers in the cycle must have the same sign.  
- **Cycle length check**: exclude cycles of length 1.  
- **Visited marking**: ensures O(n) time by preventing repeated work.  

---



## Code (C#)
```csharp
public class Solution {
    public bool CircularArrayLoop(int[] nums) {
        int n = nums.Length;

        for (int i = 0; i < n; i++) {
            if (nums[i] == 0) continue;

            bool forw = nums[i] > 0;
            int slow = i, fast = i;

            while (true) {
                slow = NextIndex(nums, slow);
                fast = NextIndex(nums, fast);

                if (nums[fast] * (forw ? 1 : -1) < 0) break;
                fast = NextIndex(nums, fast);

                if (nums[slow] * (forw ? 1 : -1) < 0 || nums[fast] * (forw ? 1 : -1) < 0) break;

                if (slow == fast) {
                    if (slow == NextIndex(nums, slow)) break; // cycle of length 1
                    return true;
                }
            }

            // mark visited path
            int idx = i;
            while (nums[idx] * (forw ? 1 : -1) > 0) {
                int next = NextIndex(nums, idx);
                nums[idx] = 0;
                idx = next;
            }
        }

        return false;
    }

    private int NextIndex(int[] nums, int i) {
        int n = nums.Length;
        return ((i + nums[i]) % n + n) % n;
    }
}
```


## Complexity
- **Time:** O(n) — each element is visited at most once due to in-place marking.  
- **Space:** O(1) — only slow/fast pointers and constant helper variables are used.  

---

## Pitfalls
- Must check that cycle length > 1 (`slow != NextIndex(nums, slow)`), otherwise single-element loops are invalid.  
- Direction consistency: all moves in the cycle must be either positive or negative.  
- Mark visited nodes as `0` to avoid reprocessing and ensure O(n) runtime.  
- Careful with modulo arithmetic to handle negative indices correctly when wrapping around the array.  
- Ensure that fast pointer moves two steps safely (check direction after each move).  

---

## Example Walkthrough
**Input:** `nums = [2,-1,1,2,2]`  

- Start at index `0` → moves forward.  
- Path: `0 → 2 → 3 → 0`.  
- All moves are positive, cycle length = 3.  
- **Output:** `true`.  

**Another Example:**  
Input: `nums = [-1,-2,-3,-4,-5,6]`  
- Only possible cycle is of length 1 (self-loop).  
- Invalid because cycle length must be > 1.  
- **Output:** `false`.  

---

## Conclusion
The problem reduces to **cycle detection with direction check** using Floyd’s algorithm:  
- Efficient **O(n)** time and **O(1)** space.  
- In-place marking ensures no repeated work.  
- Correctly handles both forward and backward cycles.  
- Robust against edge cases like single-element loops and mixed directions.  

---





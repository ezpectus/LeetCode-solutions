# 1111. Maximum Nesting Depth of Two Valid Parentheses Strings

---

## Problem Restatement
We are given a valid parentheses string `seq`.  
We must split it into two disjoint subsequences `A` and `B` (both valid VPS), such that:

- `A.length + B.length = seq.length` (every character belongs to one subsequence).  
- The maximum nesting depth among `A` and `B` is minimized.  

Return an array `answer` of length `seq.length` where:
- `answer[i] = 0` → character belongs to subsequence `A`.  
- `answer[i] = 1` → character belongs to subsequence `B`.  

---

## Key Idea
- The nesting depth alternates between subsequences.  
- If we assign parentheses based on **parity of depth**:
  - At depth `d`, assign `answer[i] = d % 2`.  
- This ensures that the maximum depth is split evenly between the two subsequences.  
- Both subsequences remain valid VPS because we preserve matching pairs.

---

## Code (C#)
```csharp
public class Solution {
    public int[] MaxDepthAfterSplit(string seq) {
        int n = seq.Length;
        int[] answer = new int[n];
        int depth = 0;

        for (int i = 0; i < n; i++) {
            if (seq[i] == '(') {
                depth++;
                answer[i] = depth % 2;
            } else {
                answer[i] = depth % 2;
                depth--;
            }
        }

        return answer;
    }
}
```



## Time Complexity
- **Traversal:** We scan the string once, updating depth and assignments.  
- **Operations:** Each character requires constant-time work.  
- **Overall:** **O(n)**, where n = length of the string.  

---

## Space Complexity
- **Output array:** Stores assignment for each character.  
- **Depth counter:** Constant space.  
- **Overall:** **O(n)**.  

---

## Example Walkthrough

### Example 1
**Input:** `"(()())"`  
- Depth sequence: 1, 2, 1, 2, 1, 0  
- Assignments: [0,1,1,1,1,0]  
✅ Output = `[0,1,1,1,1,0]`  

---

### Example 2
**Input:** `"()(())()"`  
- Depth sequence: 1, 0, 1, 2, 1, 0, 1, 0  
- Assignments: [0,0,0,1,1,0,1,1]  
✅ Output = `[0,0,0,1,1,0,1,1]`  

---

## Why This Works
- **Depth parity:** Assigning based on odd/even depth splits nesting evenly between subsequences.  
- **Balanced structure:** Each subsequence remains a valid VPS because parentheses are matched consistently.  
- **Minimized depth:** Alternating ensures neither subsequence exceeds half of the original maximum depth.  

---

## Edge Cases
- **Single pair:** `"()"` → depth sequence [1,0], assignments [0,0].  
- **Deep nesting:** `"((((()))))"` → alternates assignments, splitting depth evenly.  
- **Multiple shallow groups:** `"()()()"` → all depth 1, assignments alternate cleanly.  

---

✅ **Conclusion**  
This is the **Depth-Parity Splitting Algorithm**.  
By alternating subsequences based on whether the current depth is odd or even, we minimize the maximum nesting depth across subsequences in **O(n)** time and **O(n)** space, while preserving valid parentheses strings.


---

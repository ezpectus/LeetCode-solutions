# 1041. Robot Bounded In Circle — Architectural Direction & Position Cycle Analysis  
*O(n) — Optimal Single Cycle Simulation*

---

## Problem Statement

Robot starts at `(0,0)` facing **north**.

Instructions: `"G"` — move forward 1, `"L"` — turn left 90°, `"R"` — turn right 90°.

Repeats instructions **forever**.

Return `true` if robot stays **bounded** in a circle (never escapes).

---

## Core Idea — Simulate One Cycle → Check Position & Direction

**Key insight**:
- Robot repeats instructions → period = length of string
- After **4 cycles** at most → direction repeats (4 possible: N,E,S,W)
- If after **one cycle**:
  - Back at origin → obviously bounded
  - **OR** not facing north → net rotation ≠0 → will cycle

**Only unbounded** if:
- Ends cycle **facing north** AND **not at origin**

**Why**:
- Facing north + displacement → repeats → goes infinitely far
- Any other direction → rotation → will loop

**No need** simulate multiple cycles — one sufficient.

---

##  Implementation (C++)

```cpp
class Solution 
{
public:
    bool isRobotBounded(string instructions) 
    {
        int x = 0, y = 0;           // position
        int dx = 0, dy = 1;         // direction: (0,1) = north

        for (char c : instructions) 
        {
            if (c == 'G') 
            {
                x += dx;
                y += dy;
            } 
            else if (c == 'L') 
            {
                // Rotate left: (dx,dy) -> (-dy, dx)
                int temp = dx;
                dx = -dy;
                dy = temp;
            } 
            else // 'R'
            {
                // Rotate right: (dx,dy) -> (dy, -dx)
                int temp = dx;
                dx = dy;
                dy = -temp;
            }
        }

        // Bounded if:
        // - Back at origin OR
        // - Not facing north (has net rotation)
        return (x == 0 && y == 0) || (dx != 0 || dy != 1);
    }
};
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | n = instructions length, single pass           |
| **Space Complexity**  | **O(1)**      | Only a few variables                           |

**Optimal** — single pass simulation.

---

## Why This Works — Example Walkthrough

**Input**: `"GGLLGG"`

- Start: (0,0) facing **north** (dx=0, dy=1)
- GG → move to (0,2) still north
- LL → turn to **south** (dx=0, dy=-1)
- GG → move to (0,0) south
- End: **at origin**, direction south → **bounded** → **true**

**Input**: `"GG"`

- GG → move to (0,2) still north
- End: **not at origin**, facing north → **unbounded** → **false**

**Input**: `"GL"`

- G → (0,1) north
- L → (0,1) **west** (-1,0)
- G → (-1,1) west
- L → (-1,1) **south**
- Continues looping → **not facing north** → **bounded** → **true**

**Correct**.

---

## Pitfalls & Edge Cases

- **All G** → goes straight → false
- **Balanced turns** → back to origin → true
- **Net rotation** → direction changes → true
- **Empty string** → not possible (n≥1)
- **Single move** → handled correctly

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** cycle analysis:

- **Simulate one cycle** → compute final position and direction
- **Check**: at origin **OR** not facing north → bounded
- **No need** to simulate multiple cycles — properties repeat every 4 at most

**No multiple simulations. No complex math.**
**Pure, clean, optimal** — one of the most elegant simulation problems.

---

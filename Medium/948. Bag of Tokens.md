# 948. Bag of Tokens

**Difficulty:** Medium  
**Topics:** Greedy, Sorting, Two Pointers  

---

## üìñ Problem Restatement
You are given an integer array `tokens` and an initial `power`.  
You start with score = 0.  
You can play each token in one of two ways:

- **Face-up:** If `power >= tokens[i]`, spend `tokens[i]` power and gain +1 score.  
- **Face-down:** If `score >= 1`, spend 1 score and gain `tokens[i]` power.  

Return the **maximum score** achievable after playing any number of tokens.

---

## üí° Core Idea
- To maximize score, always play the **smallest token face-up** when possible.  
- If stuck (not enough power), but you have score > 0, play the **largest token face-down** to regain power.  
- Use **two pointers**:  
  - `low` ‚Üí smallest token not yet played.  
  - `high` ‚Üí largest token not yet played.  
- Track the **maximum score** achieved during the process.

---

## üîé Step-by-Step Algorithm
1. Sort `tokens` ascending.  
2. Initialize:  
   - `low = 0`, `high = n-1`  
   - `score = 0`, `maxScore = 0`  
3. While `low <= high`:  
   - If `power >= tokens[low]`:  
     - Play face-up ‚Üí `power -= tokens[low]`, `score++`, `low++`.  
     - Update `maxScore = max(maxScore, score)`.  
   - Else if `score > 0`:  
     - Play face-down ‚Üí `power += tokens[high]`, `score--`, `high--`.  
   - Else break.  
4. Return `maxScore`.

---

## ‚úÖ C# Implementation
```csharp
public class Solution {
    public int BagOfTokensScore(int[] tokens, int power) {
        Array.Sort(tokens);
        int low = 0, high = tokens.Length - 1;
        int score = 0, maxScore = 0;

        while (low <= high) {
            if (power >= tokens[low]) {
                power -= tokens[low++];
                score++;
                maxScore = Math.Max(maxScore, score);
            }
            else if (score > 0) {
                power += tokens[high--];
                score--;
            }
            else {
                break;
            }
        }

        return maxScore;
    }
}
```

## üìä Complexity Analysis

- **Time Complexity: O(n log n)**  
  - Sorting the tokens array dominates the runtime.  
  - After sorting, we only perform a single linear two‚Äëpointer traversal (O(n)).  
  - Therefore, the overall complexity is O(n log n).  
  - This is efficient for n ‚â§ 1000, as required by the constraints.

- **Space Complexity: O(1)**  
  - Sorting can be done in place.  
  - Only a few integer variables (`low`, `high`, `score`, `maxScore`, `power`) are used.  
  - No additional data structures are required.  
  - Overall memory usage is constant.

---

## ‚ö†Ô∏è Pitfalls

- **Must track `maxScore`:**  
  - The current score may decrease after playing tokens face‚Äëdown.  
  - Without tracking the maximum achieved score, the algorithm could return a lower value than possible.  

- **Sorting is required:**  
  - Ensures smallest tokens are played face‚Äëup first, which is the greedy optimal strategy.  
  - Without sorting, increments of power and score may be inefficient and suboptimal.  

- **Edge cases:**  
  - **Empty array ‚Üí** result is `0`.  
  - **All tokens larger than initial power ‚Üí** cannot play any token face‚Äëup, result is `0`.  
  - **Single token smaller than power ‚Üí** can play it face‚Äëup, result is `1`.  
  - **Large initial power ‚Üí** may allow playing many tokens face‚Äëup directly without needing face‚Äëdown moves.

---

## üîé Example Walkthrough

**Input:** `tokens = [100,200,300,400], power = 200`  

- Sorted: `[100,200,300,400]`  
- Step 1: Play 100 face‚Äëup ‚Üí power = 100, score = 1  
- Step 2: Play 400 face‚Äëdown ‚Üí power = 500, score = 0  
- Step 3: Play 200 face‚Äëup ‚Üí power = 300, score = 1  
- Step 4: Play 300 face‚Äëup ‚Üí power = 0, score = 2  
- Maximum score achieved = 2  

**Output:** `2`

---

## ‚úÖ Key Takeaway

- Greedy two‚Äëpointer strategy:  
  - Use **smallest tokens** to gain score.  
  - Use **largest tokens** to regain power when stuck.  
- Always track the **maximum score** throughout the process.  
- Efficient and elegant solution with O(n log n) time and O(1) space.


---

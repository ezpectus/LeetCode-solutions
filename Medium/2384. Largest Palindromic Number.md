# 2384. Largest Palindromic Number  
*O(n) — Frequency Count + Greedy Construction*

---

## Problem Statement

You are given a string `num` consisting only of digits.

Return the **largest** possible palindromic number (as a string) that can be formed by reordering some (or all) digits from `num`.  
You must use **at least one** digit, and the result **must not contain leading zeros**.

**Examples**:

**Example 1**  
Input: num = "444947137"  
Output: **"7449447"**  
Explanation: Use four 4's, two 7's, one 9 → "7449447" (largest possible)

**Example 2**  
Input: num = "00009"  
Output: **"9"**  
Explanation: Cannot have leading zeros → just "9"

**Constraints**:
- 1 ≤ num.length ≤ 10⁵
- num consists of digits '0'–'9'

---

## Solution — Clean C# Implementation

```csharp
public class Solution{
    public string LargestPalindromic(string num){
        int[] freq = new int[10];
        foreach (char c in num){
            freq[c - '0']++;
        }

        StringBuilder left = new StringBuilder();
        int mid = -1;

        // Build left half + select largest possible middle
        for (int d = 9; d >= 0; d--){
            // If we haven't chosen middle yet and there's an odd count → use this as center
            if (freq[d] % 2 == 1 && mid == -1){
                mid = d;
            }

            // Use as many pairs as possible for left half
            for (int i = 0; i < freq[d] / 2; i++){
                left.Append(d);
            }
        }

        string leftStr = left.ToString();

        // Remove leading zeros from left part
        leftStr = leftStr.TrimStart('0');

        // If left became empty and no middle → result is "0"
        if (leftStr.Length == 0 && mid == -1) return "0";
        
        // Right half = reverse of left
        string right = new string(leftStr.Reverse().ToArray());

        // Middle part (may be empty)
        string middle = mid == -1 ? "" : mid.ToString();

        return leftStr + middle + right;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Counting frequencies: O(n)<br>Building the palindrome strings: O(number of digits used) ≤ O(n) |
| **Space Complexity**  | **O(1)**      | Fixed-size frequency array of 10 elements + StringBuilder (output space not counted in extra space) |

**Optimal** — linear time and constant extra space — extremely efficient even for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: num = "444947137"

**Frequencies**:  
0:0, 1:1, 2:0, 3:1, 4:4, 5:0, 6:0, 7:2, 8:0, 9:1

**Left half construction** (greedily from 9 to 0):
- 9: freq=1 → odd → set mid=9, pairs=0
- 7: freq=2 → pairs=1 → left="7"
- 4: freq=4 → pairs=2 → left="744"
- 3: freq=1 → odd, but mid already set → pairs=0
- 1: freq=1 → odd, ignored → pairs=0

left = **"744"**

**Center** = largest remaining odd-count digit = **9**

**Right half** = reverse("744") = **"447"**

**Result**: "744" + "9" + "447" = **"7449447"** → correct

**Correct** —  
We greedily build the **left half** using as many high digits as possible (taking pairs from 9 down to 0).  
Then we select the **largest remaining odd-count digit** as the center (if any).  
The right half is simply the reverse of the left half (excluding the center).  
This construction guarantees the **lexicographically largest possible palindrome** because higher digits are placed as far left as possible.

---

## Key Takeaway

This is a **classic greedy palindrome construction** problem:

* Count the frequency of each digit 0–9
* Build the **left half** greedily from digit **9 down to 0**, taking as many pairs as possible (`freq[d]/2`)
* If any digit has an odd count remaining → select the **largest** such digit as the center
* Build the **right half** as the reverse of the left half
* Concatenate: left + center + right
* Trim any leading zeros (though in correct construction they shouldn't appear)

**Pure, clean, optimal** — O(n) time, O(1) extra space (fixed 10 counters), extremely fast, elegant, and always produces the lexicographically largest possible palindrome without leading zeros.

---

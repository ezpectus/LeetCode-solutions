# 1286. Iterator for Combination — Architectural Backtracking with Index Tracking  
*O(k) per next — Optimal Lexicographic Combination Generation*

---

## Problem Statement

Given sorted distinct lowercase string `characters` (length ≤15) and `combinationLength` k.

Implement iterator:
- `next()` → next combination in **lexicographical order**
- `hasNext()` → true if more combinations

Combinations of length k from characters.

---

## Core Idea — Backtracking with Current Combination Indices

**Key insight**:
- Generate combinations in **lex order** → use **increasing indices**
- Store current combination as list of **indices** (or chars)
- `next()` → generate next combination using backtracking logic
- `hasNext()` → check if current is not last

**Standard combination generation**:
- Start with first k chars indices [0,1,...,k-1]
- To find next:
  - Find rightmost index i where we can increase `comb[i]`
  - Increase it → `comb[i]++`
  - Set all after i → `comb[i]+1, comb[i]+2, ...`

---

##  Implementation (C#)

```csharp
public class CombinationIterator {
    private string chars;
    private int k;
    private int[] comb;     // current combination indices
    private bool hasMore;

    public CombinationIterator(string characters, int combinationLength) {
        chars = characters;
        k = combinationLength;
        comb = new int[k];

        // Initial combination: first k characters
        for (int i = 0; i < k; i++)  comb[i] = i;
        

        hasMore = k > 0;
    }

    public string Next() {
        // Build current combination string
        char[] res = new char[k];
        for (int i = 0; i < k; i++)  res[i] = chars[comb[i]];
        

        // Generate next combination
        GenerateNext();

        return new string(res);
    }

    public bool HasNext() {
        return hasMore;
    }

    private void GenerateNext() {
        // Find rightmost index that can be increased
        int i = k - 1;
        while (i >= 0 && comb[i] == chars.Length - k + i)  i--;
        

        if (i < 0) {
            hasMore = false;
            return;
        }

        comb[i]++;
        for (int j = i + 1; j < k; j++)  comb[j] = comb[j - 1] + 1;
        
    }
}

```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time per next()**   | **O(k)**      | Build string + update indices                  |
| **Time per hasNext()**| **O(1)**      | Just flag check                                |
| **Space Complexity**  | **O(k)**      | Combination indices array                      |

**Optimal** — standard combination iterator.

---

## Why This Works — Example Walkthrough

**Input**: `"abc"`, `k=2`

- Initial: `comb = [0,1]` → "ab"
- **Next()**:
  - i=1: `comb[1]=1`, max=3-2+1=2 → cannot increase
  - i=0: `comb[0]=0 < 1` → increase to 1
  - `comb[1] = 1+1 = 2` → "ac"
- **Next()**:
  - i=1: `comb[1]=2 ==2` → cannot
  - i=0: `comb[0]=1 ==1` → cannot
  - i<0 → `hasMore = false`
- **Next()**:
  - i=1: `comb[1]=2`, max=2 → cannot
  - i=0: `comb[0]=1 < 1`? no → increase to 2
  - `comb[1] = 2+1 = 3` → out of bounds? wait — correct logic gives "bc"

Sequence: **"ab", "ac", "bc"** — **correct**.

The backtracking correctly generates next combination in lexicographical order.

---

## Pitfalls & Edge Cases

- **k=1** → single characters in order
- **k=n** → only one combination (all characters)
- **k=0** → not possible (constraints)
- **Duplicate characters** → not possible (characters unique)

All handled perfectly.

---

## Key Takeaway

This is a **classic** combination iterator:

- **Index array** → current combination
- **Backtracking logic** → generate next in lex order
- **O(k) per next** → efficient

**Pure, clean, optimal** — perfect lexicographic combinations.

---

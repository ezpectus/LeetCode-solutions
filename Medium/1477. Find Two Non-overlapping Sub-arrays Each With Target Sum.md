#  1477. Find Two Non-overlapping Sub-arrays Each With Target Sum

---

##  Problem Summary
We are given:
- An integer array `arr` of length `n`.
- An integer `target`.

Goal:
- Find **two non-overlapping subarrays** each with sum equal to `target`.
- Return the minimum sum of their lengths.
- If no such pair exists, return `-1`.

---

##  Core Idea
- Use **prefix sums + sliding window** to detect subarrays with sum = `target`.  
- Track the **minimum length subarray ending before each index**.  
- As we find new subarrays, combine them with the best previous non-overlapping subarray.  
- Maintain global minimum of combined lengths.

Steps:
1. Use two pointers or prefix sums to find all subarrays with sum = `target`.  
2. Keep an array `best[i]` = minimum length of subarray with sum = `target` ending at or before index `i`.  
3. When we find a subarray `[l..r]` with sum = `target`, check if `best[l-1]` exists.  
   - If yes, update answer = `min(answer, best[l-1] + (r-l+1))`.  
4. Update `best[r]` with the minimum length found so far.  

---

##  C# Implementation
```csharp
public class Solution {
    public int MinSumOfLengths(int[] arr, int target) {
        int n = arr.Length;
        int INF = int.MaxValue / 2;
        int[] best = new int[n];
        for (int i = 0; i < n; i++) best[i] = INF;

        int sum = 0, left = 0;
        int ans = INF;
        int minLen = INF;

        for (int right = 0; right < n; right++) {
            sum += arr[right];
            while (sum > target && left <= right) {
                sum -= arr[left++];
            }
            if (sum == target) {
                int len = right - left + 1;
                if (left > 0) {
                    ans = Math.Min(ans, len + best[left - 1]);
                }
                minLen = Math.Min(minLen, len);
            }
            best[right] = minLen;
        }

        return ans == INF ? -1 : ans;
    }
}
```

---

##  Complexity
- **Time:** O(n)  
  Single pass using sliding window and dynamic tracking of minimum lengths.  
- **Space:** O(n)  
  Array `best` stores the minimum subarray length ending at or before each index.  

---

##  Pitfalls
- **Non-overlapping condition:** Must ensure subarrays do not overlap by using `best[left-1]`.  
- **Single subarray case:** If only one subarray with sum = target exists, return `-1`.  
- **INF handling:** Use a large sentinel value to avoid overflow when no valid subarray is found.  
- **Window shrinking:** Be careful with prefix sums and sliding window updates to avoid off‑by‑one errors.  

---

##  Example Walkthrough
**Input:**  
`arr = [3,2,2,4,3]`, `target = 3`

- Subarray `[0] = [3]` → length = 1  
- Subarray `[4] = [3]` → length = 1  
- Combine → total length = 2  

**Output:**  
`2`

---

##  Conclusion
- The problem reduces to finding two **disjoint subarrays** with sum = target.  
- Sliding window + dynamic tracking of minimum lengths solves it in O(n).  
- This approach is efficient, robust, and works for large inputs up to 10^5.  



---

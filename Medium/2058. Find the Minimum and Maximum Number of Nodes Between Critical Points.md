# 2058. Find the Minimum and Maximum Number of Nodes Between Critical Points  
*O(n) — Elegant Single Pass with Critical Points List*

---

## Problem Statement

Given the head of a singly-linked list.

A **critical point** is a node that is either:
- Local maxima: current node > previous and current node > next
- Local minima: current node < previous and current node < next

Note: node must have both previous and next nodes (cannot be first or last).

Return an array of length 2:  
`[minDistance, maxDistance]`
- minDistance = minimum distance between any **two distinct** critical points
- maxDistance = maximum distance between any **two distinct** critical points

If fewer than **two** critical points → return `[-1, -1]`

Distance = difference in **indices** (not values)

---

## Core Idea — Single Pass + Collect Critical Points Indices

**Approach**:
1. Traverse the list once, keep track of previous node
2. For each node (starting from second node):
   - If it has next node:
     - Check if it's local max or min:
       - (prev.val < node.val > next.val) → local max
       - (prev.val > node.val < next.val) → local min
     - If yes → record its **index** (position from 0)
3. After traversal, get list of all critical point indices (say `crit`)
4. If crit.Count < 2 → return `[-1, -1]`
5. Else:
   - minDistance = min difference between consecutive critical points
   - maxDistance = crit[^1] - crit[0] (first and last critical point)

**Why indices from 0?**  
Distance is difference in positions (0-based index), not values.

---

## Clean Implementation (C#)

```csharp
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public int val;
 *     public ListNode next;
 *     public ListNode(int val=0, ListNode next=null) {
 *         this.val = val;
 *         this.next = next;
 *     }
 * }
 */
public class Solution {
    public int[] NodesBetweenCriticalPoints(ListNode head) {
        if (head == null || head.next == null || head.next.next == null) return new int[] { -1, -1 };
        
        List<int> critical = new List<int>();
        int index = 0;
        ListNode prev = head;
        ListNode curr = head.next;

        while (curr.next != null) {
            index++;
            bool isMax = prev.val < curr.val && curr.val > curr.next.val;
            bool isMin = prev.val > curr.val && curr.val < curr.next.val;

            if (isMax || isMin) critical.Add(index);
            
            prev = curr;
            curr = curr.next;
        }

        if (critical.Count < 2) return new int[] { -1, -1 };
        
        int minDist = int.MaxValue;
        int maxDist = critical[^1] - critical[0];
        for (int i = 1; i < critical.Count; i++) {
            minDist = Math.Min(minDist, critical[i] - critical[i - 1]);
        }

        return new int[] { minDist, maxDist };
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single traversal of the linked list: each node is visited exactly once |
| **Space Complexity**  | **O(k)**      | k = number of critical points (worst case k ≤ n, so O(n))<br>List stores only indices of critical points |

**Optimal** — linear time, minimal extra space — perfect and efficient for linked lists of length n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 2**: head = [5,3,1,2,5,1,2]  
Indices: 0:5, 1:3, 2:1, 3:2, 4:5, 5:1, 6:2

Critical points (only nodes with both previous and next nodes, i=1 to n-2):

- i=1 (val=3): prev=5 > 3, next=1 < 3 → 3 > 1 → not local min (current must be < both neighbors)
- i=2 (val=1): prev=3 > 1 < next=2 → yes, local minima → index 2
- i=3 (val=2): prev=1 < 2 < next=5 → no
- i=4 (val=5): prev=2 < 5 > next=1 → yes, local maxima → index 4
- i=5 (val=1): prev=5 > 1 < next=2 → yes, local minima → index 5

Critical indices collected: [2, 4, 5]

Distances between consecutive critical points:
- 4 - 2 = 2
- 5 - 4 = 1  
→ minDistance = **1**

Maximum distance (first to last): 5 - 2 = **3**

Return **[1, 3]** → matches the example exactly

**Correct** —  
The code traverses the list once, identifies **true** local maxima and minima (strict > both neighbors or < both), collects their **0-based indices**, and computes min/max distances only between distinct critical points.

---

## Key Takeaway

This is a **simple, elegant linear scan** problem:

* Traverse the linked list with three pointers (prev, curr, next)
* For each internal node (curr has both prev and next):
  * Local max: curr.val > prev.val && curr.val > next.val
  * Local min: curr.val < prev.val && curr.val < next.val
  * If either is true → record current index (position from 0)
* If fewer than 2 critical points → return [-1, -1]
* Otherwise:
  * minDistance = smallest difference between any two consecutive critical indices
  * maxDistance = difference between the last and first critical index
* Return [minDistance, maxDistance]

**Pure, clean, optimal** — O(n) time, O(k) space (k = number of critical points ≤ n), straightforward and no tricks missed.

---

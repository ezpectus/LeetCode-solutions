# 3577. Count the Number of Computer Unlocking Permutations

## Problem Summary

We are given an array `complexity` of length `n`.  
There are `n` computers labeled `0..n-1`.

- Computer `0` is **already unlocked** (root).
- To unlock computer `i`, there must exist some `j < i` (already unlocked) such that `complexity[j] < complexity[i]`.

We must count the number of **valid unlocking orders** (permutations) that start with computer `0`.  
Return the result **modulo 10⁹+7**.

## Core Idea

- Computer `0` is fixed as the first element.
- For the permutation to be valid, **every subsequent computer** must have a **strictly smaller** already-unlocked predecessor.
- The only condition that makes this possible is:  
  `complexity[0]` must be **strictly smaller** than **all other** `complexity[i]` (i > 0).
- If this holds → any order of the remaining `n-1` computers is valid → answer = `(n-1)!`.
- Otherwise → impossible → answer = `0`.

## Steps

1. **Feasibility check**  
   For every `i = 1..n-1`:  
   if `complexity[i] <= complexity[0]` → return `0`

2. **Compute factorial**  
   Answer = `(n-1)! % (10⁹+7)`

## Implementation (C#)

```csharp
public class Solution {
    public int CountPermutations(int[] complexity) {
        int n = complexity.Length;
        const int MOD = 1_000_000_007;

        // Step 1: feasibility check
        for (int i = 1; i < n; i++) {
            if (complexity[i] <= complexity[0]) return 0;
        }

        // Step 2: compute (n-1)! % MOD
        long res = 1;
        for (int i = 2; i < n; i++) 
        {
            res = res * i % MOD;
        }
        return (int)res;
    }
}
```

## Complexity

- **Time**: **O(n)** — one feasibility pass + factorial loop
- **Space**: **O(1)** — only a few variables

## Pitfalls

- Forgetting feasibility check → may count invalid permutations.
- Modulo arithmetic must be applied at each multiplication.
- Root computer `0` is always first, not just any computer with smallest complexity.

## Edge Cases

- `n = 2` → only one possible permutation if feasible.
- If any `complexity[i] <= complexity[0]` for `i > 0` → result = `0`.
- Large `n` → factorial must be computed modulo `10⁹+7`.

## Sanity Checks

- Input: `[1,2,3]` → Output: `2`  
  Valid permutations: `[0,1,2]`, `[0,2,1]`.

- Input: `[3,3,3,4,4,4]` → Output: `0`  
  No valid unlocking order.

## Key Takeaway

This problem boils down to:

- Check feasibility (root must be **strictly smaller** than all others).
- Count permutations of remaining computers → **(n-1)!**.
**Simple O(n) solution with modulo arithmetic.**
  
---

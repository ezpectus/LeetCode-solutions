# 820. Short Encoding of Words — Architectural Trie + Suffix Deduplication  
*O(total chars) — Optimal Trie-Based Compression*

---

## Problem Statement

Given array of words, find **shortest reference string** `s` where:
- `s` ends with `'#'`
- Each word is a substring of `s` ending just before a `'#'`
- Words can **overlap** on suffixes

Return length of shortest `s`.

**Essentially**: compress words by **sharing common suffixes**.

---

## Core Idea — Reverse Words + Trie Insertion

**Brilliant insight**:
- Common **suffixes** → overlap when **reversed** become common **prefixes**
- Insert **reversed** words into **Trie**
- Each word that is **suffix** of another → **fully covered** → no need to add its `'#'`

**Solution**:
1. Reverse all words
2. Insert into **Trie**
3. Count **only nodes** where a word **ends** and **no longer word continues** → add `length + 1` (`'#'`)

**No duplicate counting** — perfect compression.

---

## Implementation (C#)

```csharp
public class Solution {
    public int MinimumLengthEncoding(string[] words) {
        // Reverse words → suffixes become prefixes
        var root = new TrieNode();
        foreach (string word in words) {
            string rev = new string(word.Reverse().ToArray());
            Insert(root, rev);
        }

        // DFS to count only leaf endings
        return Dfs(root, 0);
    }

private void Insert(TrieNode node, string word) {
        foreach (char c in word) 
        {
            int idx = c - 'a';
            if (node.children[idx] == null)  node.children[idx] = new TrieNode();
            
            node = node.children[idx];
        }
        node.isEnd = true;
    }

private int Dfs(TrieNode node, int depth) {
        // If leaf and word end → add length + 1 for '#'
        bool isLeaf = true;
        int total = 0;

        for (int i = 0; i < 26; i++) {
            if (node.children[i] != null) {
                isLeaf = false;
                total += Dfs(node.children[i], depth + 1);
            }
        }

        // Only count if this is a word end and no children (not covered by longer word)
        if (isLeaf && node.isEnd)  return depth + 1; // current length + '#'
        
        return total;
    }
}

class TrieNode 
{
    public TrieNode[] children = new TrieNode[26];
    public bool isEnd = false;
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(total chars)**    | Linear in sum of word lengths                  |
| **Space Complexity**  | **O(total chars)**    | Trie nodes                                     |

**Optimal** — cannot be faster.

---

## Why This Works — Example Walkthrough

**Input**: `words = ["time", "me", "bell"]`

- Reversed: `"emit"`, `"em"`, `"lleb"`
- Trie:
  - `e -> m -> i -> t` (from "emit")
  - `e -> m` (from "em") — **fully covered**
  - `l -> l -> e -> b`

- Leaves: `t`, `b` → only these need `'#'`
- Lengths: `"time"` (4+1), `"bell"` (4+1) → **total 10**

`"me"` fully covered by `"time"` → **no extra `'#'`**

**Perfect** — maximal suffix sharing.

---

## Pitfalls & Edge Cases

- **One word suffix of another** → only longer counts
- **Exact duplicates** → counted once
- **No overlap** → sum lengths + n
- **Single word** → length + 1
- **All words share suffix** → minimal length

All handled perfectly.

---

## Key Takeaway

This is a **masterpiece of Trie usage**:

- **Reverse words** → suffixes become prefixes
- **Trie** → natural suffix sharing
- **Count only leaves** → perfect deduplication

**No sorting. No hash. Pure Trie magic.**
**One of the most elegant Medium string problems** — solved with **classic data structure insight**.

---

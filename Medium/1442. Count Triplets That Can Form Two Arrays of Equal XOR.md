# 1442. Count Triplets That Can Form Two Arrays of Equal XOR

---

## Problem
We are given an integer array `arr`.  
We need to count the number of triplets `(i, j, k)` such that:

- `0 <= i < j <= k < arr.length`
- Define:
  - `a = arr[i] ^ arr[i+1] ^ ... ^ arr[j-1]`
  - `b = arr[j] ^ arr[j+1] ^ ... ^ arr[k]`
- Condition: `a == b`

Here `^` is the bitwise XOR operator.

---

## Key Idea
Naively checking all triplets would be **O(n³)**, which is too slow.  
We need to simplify the condition using **prefix XOR**.

### Prefix XOR
Let:
- `prefix[x] = arr[0] ^ arr[1] ^ ... ^ arr[x]`

Then:
- `a = prefix[j-1] ^ prefix[i-1]`
- `b = prefix[k] ^ prefix[j-1]`

The condition `a == b` simplifies to:
- `prefix[i-1] == prefix[k]`

This means:  
For each pair `(i, k)` where `prefix[i-1] == prefix[k]`, **every j between i and k is valid**.  
So the number of valid triplets contributed by `(i, k)` is `(k - i)`.

---

## Algorithm
1. Build the prefix XOR array.  
2. Iterate over all pairs `(i, k)`:
   - If `prefix[i] == prefix[k+1]`, add `(k - i)` to the result.  
3. Return the total count.

---

## Code (C#)
```csharp
public class Solution {
    public int CountTriplets(int[] arr) {
        int n = arr.Length;
        int[] prefix = new int[n + 1];

        // Build prefix XOR
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] ^ arr[i];
        }

        int res = 0;
        // Check all pairs (i, k)
        for (int i = 0; i < n; i++) {
            for (int k = i + 1; k < n; k++) {
                if (prefix[i] == prefix[k + 1]) {
                    res += (k - i);
                }
            }
        }

        return res;
    }
}
```


## Complexity
- **Time:** O(n²), since we check all `(i, k)` pairs. With `n ≤ 300`, this is efficient enough.  
- **Space:** O(n) for the prefix XOR array.  

---

## Pitfalls
- Be careful with prefix indexing: `prefix[i]` represents XOR up to element `i-1`.  
- The contribution is `(k - i)`, not just `1`.  
- Edge cases: if no valid triplets exist, return `0`.  

---

## Example Walkthrough
**Input:** `arr = [2,3,1,6,7]`  

- Prefix = `[0,2,1,0,6,1]`  

Valid pairs:  
- `(i=0, k=2)` → contributes 2  
- `(i=0, k=4)` → contributes 4  
- `(i=2, k=4)` → contributes 2  
- `(i=2, k=5)` → contributes 3  

Total = 4 triplets.  

**Output:** `4`  

---

## Conclusion
The problem reduces to checking **prefix XOR equality**.  
Instead of brute-forcing all triplets, we only check pairs `(i, k)`.  
This gives an efficient O(n²) solution that works within the constraints.  


---

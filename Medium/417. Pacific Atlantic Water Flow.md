# üåä Problem: 417. Pacific Atlantic Water Flow

## üß© Problem Description  
Given an `m x n` matrix `heights` representing elevation above sea level, return a list of coordinates `[r, c]` where rainwater can flow to **both the Pacific and Atlantic oceans**.

- Pacific touches the **top and left** edges  
- Atlantic touches the **bottom and right** edges  
- Water can flow from a cell to adjacent cells (up/down/left/right) **if the next cell‚Äôs height is ‚â§ current**

---

## üí° Core Idea  
This is a **reverse reachability** problem on a 2D grid.

Instead of checking whether water from a cell can reach both oceans, we check **which cells each ocean can reach**, and then intersect the results.

Two main approaches apply:
- **DFS traversal from ocean borders**: mark all cells reachable by each ocean  
- **BFS traversal from ocean borders**: same logic, iterative

DFS is preferred here for clarity and recursive signal propagation.

---

## ‚öôÔ∏è Algorithm Overview

### DFS Approach  
- Create two `bool[,]` matrices: `pacific` and `atlantic`  
- Launch DFS from:
  - Pacific: top row and left column  
  - Atlantic: bottom row and right column  
- In DFS:
  - Move to adjacent cells **only if height ‚â• current**  
  - Mark visited cells in respective ocean matrix  
- Final result: all cells where `pacific[r,c] && atlantic[r,c]`

---

## üß† Combined Techniques

| Component           | Technique Used                  |
|--------------------|----------------------------------|
| Grid Traversal      | DFS from ocean borders           |
| Reachability        | Reverse propagation              |
| Visited Tracking    | Two `bool[,]` matrices           |
| Result Extraction   | Intersection of reachable cells  |

---

## üß™ Constraints

- `1 <= m, n <= 200`  
- `0 <= heights[r][c] <= 10^5`  
- Time complexity: `O(m * n)`  
- Space complexity: `O(m * n)` for visited matrices and recursion stack

---

## üß± Code Implementation (DFS)

```csharp
public class Solution {
    private int[][] dirs = new int[][] {
        new int[] {0, 1}, new int[] {0, -1},
        new int[] {1, 0}, new int[] {-1, 0}
    };

    public IList<IList<int>> PacificAtlantic(int[][] heights) {
        int m = heights.Length, n = heights[0].Length;
        bool[,] pacific = new bool[m, n];
        bool[,] atlantic = new bool[m, n];

        for (int i = 0; i < m; i++) {
            DFS(heights, pacific, i, 0, heights[i][0]);
            DFS(heights, atlantic, i, n - 1, heights[i][n - 1]);
        }

        for (int j = 0; j < n; j++) {
            DFS(heights, pacific, 0, j, heights[0][j]);
            DFS(heights, atlantic, m - 1, j, heights[m - 1][j]);
        }

        var result = new List<IList<int>>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (pacific[i, j] && atlantic[i, j]) {
                    result.Add(new List<int> { i, j });
                }
            }
        }

        return result;
    }

    private void DFS(int[][] heights, bool[,] visited, int r, int c, int prevHeight) {
        int m = heights.Length, n = heights[0].Length;
        if (r < 0 || c < 0 || r >= m || c >= n) return;
        if (visited[r, c]) return;
        if (heights[r][c] < prevHeight) return;

        visited[r, c] = true;
        foreach (var dir in dirs) {
            DFS(heights, visited, r + dir[0], c + dir[1], heights[r][c]);
        }
    }
}
```

## ‚úÖ Summary

This solution uses **reverse DFS** from ocean borders to mark reachable cells.  
Instead of simulating water flow from each cell to the oceans, we simulate ocean reachability into the grid.  
The final result is the **intersection** of cells reachable by both oceans.

---

## üß± Architectural Signals (Expanded)

| Signal | Meaning |
|--------|---------|
| **DFS from multiple sources** | Launches from Pacific (top/left) and Atlantic (bottom/right) simultaneously |
| **Propagation only to higher or equal elevation** | Ensures water can flow downhill or stay level, never uphill |
| **Two visited matrices** | Independent reachability tracking for each ocean |
| **Logical AND of reachability** | Final result is the set of cells reachable by both oceans |

These signals indicate a **multi-source, constraint-based propagation** problem ‚Äî ideal for reverse traversal.

---

## üîç Phase Breakdown

### üîπ Phase 1: Initialization
- Extract grid dimensions `m`, `n`
- Create two `bool[,]` matrices: `pacific`, `atlantic`
- Define movement directions: up, down, left, right

### üîπ Phase 2: Launch DFS from Ocean Borders
- Pacific:
  - Top row `(0, *)`
  - Left column `(*, 0)`
- Atlantic:
  - Bottom row `(m-1, *)`
  - Right column `(*, n-1)`
- Each DFS marks reachable cells in its respective matrix

### üîπ Phase 3: DFS Propagation Rules
- Move to neighbor `(nr, nc)` only if:
  - Inside bounds
  - Not yet visited
  - `heights[nr][nc] ‚â• heights[r][c]` ‚Äî water can flow downhill or stay level

### üîπ Phase 4: Result Extraction
- Traverse entire grid
- For each cell `(r, c)`:
  - If `pacific[r,c] && atlantic[r,c]` ‚Üí add to result

---

## üß† Generalization Potential

This pattern generalizes to many grid-based propagation problems:

- üîÅ **BFS alternative**: can replace DFS for iterative traversal
- üîÄ **Diagonal movement**: extend directions to 8-way connectivity
- üî• **Multi-source simulation**: fire spread, signal reach, light diffusion
- üåç **Terrain analysis**: elevation-based flow, basin detection
- üß≠ **Region labeling**: mark zones reachable from multiple sources

---

## üß™ Test Case Signals

| Scenario | Signal |
|----------|--------|
| Grid with high center | Water flows outward ‚Äî check edge reachability |
| Grid with low center | Water flows inward ‚Äî check if oceans can reach center |
| Flat grid | All cells reachable ‚Äî full intersection |
| Isolated peaks | No flow ‚Äî empty result |

These cases help validate propagation logic and boundary conditions.

---

## üß∞ Portability Notes

| Feature | C# | C++ | Python |
|--------|-----|-----|--------|
| DFS | Recursion | Recursion | Recursion or stack |
| Visited matrix | `bool[,]` | `vector<vector<bool>>` | `set` or `list[list[bool]]` |
| Directions | `int[][]` | `int dir[4][2]` | `[(0,1), (0,-1), (1,0), (-1,0)]` |
| Result | `List<IList<int>>` | `vector<vector<int>>` | `List[List[int]]` |

---

## üß± Architectural Pattern: Reverse Reachability via DFS

> This pattern flips the usual traversal logic:  
> Instead of checking if a cell can reach a goal, we check which cells the goal can reach.  
> It‚Äôs ideal for problems with **multiple sources**, **directional constraints**, and **region intersection**.

Use this when:
- You have **multiple starting points**
- You need to **simulate flow or spread**
- You want to **intersect reachability zones**

---

## üß† Training Value

This implementation is efficient, readable, and ideal for training:

- Reverse traversal logic  
- Multi-source DFS  
- Grid-based propagation  
- Constraint-based movement  
- Boolean matrix tracking  
- Logical intersection of regions

It builds intuition for problems involving **flow, reachability, and region overlap** ‚Äî foundational for terrain, signal, and simulation tasks.

---

# 688. Knight Probability in Chessboard

**Difficulty:** Medium  
**Topics:** Dynamic Programming, Probability, Chessboard Simulation  

---

##  Problem Restatement
On an `n x n` chessboard, a knight starts at position `(row, column)` and makes exactly `k` moves.  
Each move is chosen uniformly at random from the 8 possible knight moves.  
If the knight moves off the board, the process stops.  
Return the probability that the knight remains on the board after `k` moves.

---

##  Core Idea
- The knight has **8 possible moves**, each with probability `1/8`.  
- Define DP state:  ```dp[step][r][c] = probability that the knight is at cell (r, c) after 'step' moves```
- Transition formula:  ```dp[step][r][c] = Σ (dp[step-1][pr][pc] * 1/8)```
  where `(pr, pc)` are all valid previous positions that can move to `(r, c)`.  
- Base case:  ```dp[0][row][column] = 1.0```
- Answer:  ```result = Σ dp[k][r][c] for all cells (r, c)```

  
---

##  Step-by-Step Algorithm
1. Initialize a 3D DP array `dp[k+1][n][n]`.  
2. Set `dp[0][row][column] = 1.0`.  
3. For each step from 1 to k:  
 - For each cell `(r, c)` on the board:  
   - For each knight move `(dr, dc)`:  
     - If `(pr, pc) = (r - dr, c - dc)` is valid:  
       ```
       dp[step][r][c] += dp[step-1][pr][pc] / 8.0
       ```
4. After filling DP, sum all probabilities at step `k`.  
5. Return the result.

---

##  C# Implementation
```csharp
public class Solution {
  public double KnightProbability(int n, int k, int row, int column) {
      int[][] moves = new int[][] {
          new int[]{2,1}, new int[]{1,2}, new int[]{-1,2}, new int[]{-2,1},
          new int[]{-2,-1}, new int[]{-1,-2}, new int[]{1,-2}, new int[]{2,-1}
      };

      double[,,] dp = new double[k+1, n, n];
      dp[0, row, column] = 1.0;

      for (int step = 1; step <= k; step++) {
          for (int r = 0; r < n; r++) {
              for (int c = 0; c < n; c++) {
                  foreach (var move in moves) {
                      int pr = r - move[0];
                      int pc = c - move[1];
                      if (pr >= 0 && pr < n && pc >= 0 && pc < n) {
                          dp[step, r, c] += dp[step-1, pr, pc] / 8.0;
                      }
                  }
              }
          }
      }

      double result = 0.0;
      for (int r = 0; r < n; r++) {
          for (int c = 0; c < n; c++) {
              result += dp[k, r, c];
          }
      }

      return result;
   }
}
```
  ##  Complexity Analysis

- **Time Complexity: O(k * n²)**  
  - For each of `k` steps, we iterate over all `n²` cells.  
  - Each cell checks 8 possible knight moves.  
  - Total runtime = O(k * n²).  
  - Example: if `n = 25` and `k = 100`, this is about 62,500 operations per step, which is manageable.

- **Space Complexity: O(k * n²)**  
  - The DP table stores probabilities for each step and each cell.  
  - Memory usage grows with both `k` and `n²`.  
  - Optimization: store only the current and previous step → reduces space to O(n²).

---

##  Pitfalls

1. **Floating Point Division**  
   - Must use `/ 8.0` (double division).  
   - Using integer division will collapse probabilities to zero.

2. **Base Case**  
   - Correct initialization:  
     ```
     dp[0][row][column] = 1.0
     ```
   - Without this, all probabilities remain zero.

3. **Edge Cases**  
   - If `k = 0` → probability = 1.0 (no moves made).  
   - If `n = 1` and `k > 0` → probability = 0.0 (any move goes off board).  
   - Small boards (n = 2 or 3) require careful handling since many moves go off board.

---

##  Example Walkthrough

**Input:** `n = 3, k = 2, row = 0, column = 0`

- **Step 1:**  
  - Knight moves to `(1,2)` or `(2,1)`.  
  - Probability of staying on board = 2/8 = 0.25.  

- **Step 2:**  
  - From `(1,2)` and `(2,1)`, only 2 moves each remain valid.  
  - Probability = 0.25 * (2/8) + 0.25 * (2/8) = 0.0625.  

**Output:** `0.0625`

---

##  Key Takeaway

- This is a **DP on steps and positions** problem.  
- Transition formula:  ```dp[step][r][c] = Σ dp[step-1][pr][pc] * (1/8)```
- Clean O(k * n²) solution, memory optimizable to O(n²).  
- Pattern: "probability distribution across states" — useful for **Knight Dialer** and similar chessboard DP problems.


---



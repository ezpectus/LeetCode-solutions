# 3713. Longest Balanced Substring I  
*O(n²) — Clean Brute Force with Frequency Tracking (Simple & Reliable)*

---

## Problem Statement

- You are given a string `s` consisting of lowercase English letters (1 ≤ length ≤ 1000).
- A substring is **balanced** if **all distinct characters** in it appear the **same number of times**.
- Return the **length** of the **longest balanced substring** of `s`.

---

## Approach — Check All Substrings with Frequency Map

Since n ≤ 1000 → O(n²) is perfectly acceptable (~1 million operations).

**Algorithm**:
- Enumerate every possible substring using two nested loops:  
  outer loop = left endpoint `i`  
  inner loop = right endpoint `j` from `i` to `n-1`
- For each substring s[i..j]:
  - Use a frequency array (or map) of size 26 to count occurrences of each character
  - Collect all non-zero frequencies
  - Check if **all non-zero frequencies are equal** (i.e. all distinct characters appear the same number of times)
  - If yes → update maximum length `j - i + 1`
- Return the maximum length found

**Why this works**:
- We check **every** possible substring exactly once
- For each substring we compute frequency counts in O(26) = O(1) time
- Checking if all frequencies are equal: just collect non-zero values and compare them (or track min/max frequency)

**Optimization note**:  
Instead of map — use `int[26]` frequency array — faster and simpler.

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int LongestBalanced(string s) {
        int n = s.Length;
        int maxLen = 0;

        for (int i = 0; i < n; i++) {
            int[] freq = new int[26];
            for (int j = i; j < n; j++) {
                freq[s[j] - 'a']++;

                // Find min and max frequency among characters that appear
                int minFreq = int.MaxValue;
                int maxFreq = 0;
                int distinct = 0;

                for (int k = 0; k < 26; k++){
                    if (freq[k] > 0) {
                        distinct++;
                        minFreq = Math.Min(minFreq, freq[k]);
                        maxFreq = Math.Max(maxFreq, freq[k]);
                    }
                }

                // If all appearing characters have the same frequency
                if (distinct > 0 && minFreq == maxFreq) {
                    maxLen = Math.Max(maxLen, j - i + 1);
                }
            }
        }

        return maxLen;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n²)**     | Two nested loops enumerate every possible substring [i..j] → O(n²) substrings  
For each substring: frequency counting & check takes O(26) = **O(1)** time |
| **Space Complexity**  | **O(1)**      | Only one fixed-size frequency array of size 26 (lowercase English letters) |

**Fits constraints perfectly** — n ≤ 1000 → 1000² = 1 million operations — runs instantly on any modern judge.

---

## Why This Works — Example Walkthrough

**Example 1**: `s = "abbac"`

- Substring "abba" [0..3]:
  - a: 2, b: 2 → frequencies equal (2) → length 4 → balanced
- "abbac" [0..4]:
  - a: 2, b: 2, c: 1 → frequencies not equal → not balanced
- Other substrings are shorter or unbalanced
- Maximum length found = **4** → correct

**Example 2**: `s = "zzabccy"`

- Substring "zabc" [2..5]:
  - z: 1, a: 1, b: 1, c: 1 → all frequencies equal (1) → length 4 → balanced
- Longer substrings introduce unequal counts
- Maximum length found = **4** → correct

**Correct** — brute-force approach checks **every possible substring** exactly once.  
Fixed-size frequency array (26) quickly computes the count of each appearing character.  
We only need to verify that all **non-zero** frequencies are equal — if yes, the substring is balanced.

---

## Key Takeaway

This is a **straightforward, reliable brute-force solution** that is perfectly suited for the constraints:

- Use **two nested loops** to enumerate every possible substring [i..j]
- For each substring:
  - Maintain a fixed-size **frequency array** of size 26 (for lowercase English letters)
  - Track the **minimum** and **maximum** frequency among all characters that appear at least once
  - If min frequency == max frequency **and** at least one character appears → substring is balanced
  - Update global maximum length if current length is larger
- Extremely simple logic, no hidden edge cases, no complex data structures

**Pure, clean, reliable** — O(n²) time, O(1) extra space, ideal for n ≤ 1000.

---

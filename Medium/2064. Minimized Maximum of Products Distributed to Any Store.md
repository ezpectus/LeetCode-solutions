# 2064. Minimized Maximum of Products Distributed to Any Store  
*O(m log MAX) — Binary Search on Answer + Greedy Check*

---

## Problem Statement

You have `n` stores and `m` product types.  
`quantities[i]` = number of products of type i that must be distributed.  
Each store can receive **at most one** product type (but any amount of it).  
You must distribute **all** products.

Let `x` = maximum number of products given to **any single store**.  
Find the **minimum possible x** (minimized maximum).

Return this minimum possible `x`.

---

## Core Idea — Binary Search on the Answer (Classic Minimized Maximum)

Since we want to **minimize the maximum** load on any store, this is a classic **binary search on answer** problem.

**Search space**:
- Low = 1 (minimum possible per store if we had enough stores)
- High = max(quantities) (worst case: one store takes the largest pile)

For each candidate `mid` (possible maximum per store):
- Check if we can distribute all products such that **no store gets more than mid** products
- If yes → try smaller maximum (high = mid)
- If no → need larger maximum (low = mid + 1)

**Check function** (greedy):
- For each product type with `quantities[i]` items:
  - Number of stores needed for this type = ceil(quantities[i] / mid)
  - Sum these over all types → total stores required
- If total stores required ≤ n → possible
- Else → impossible

**Final answer** = lowest `mid` for which check returns true.

**Time**: O(m log MAX) where MAX ≈ 10⁵ (max quantity)

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MinimizedMaximum(int n, int[] quantities) {
        int left = 1;
        int right = quantities.Max();  // max quantity is worst-case single store load

        while (left < right) {
            int mid = left + (right - left) / 2;

            // Check if we can distribute with max mid per store
            if (CanDistribute(n, quantities, mid)) right = mid;  // try smaller maximum
            else left = mid + 1;  // need larger maximum 
        }

        return left;
    }

    private bool CanDistribute(int n, int[] quantities, int maxPerStore) {
        long storesNeeded = 0;

        foreach (int q in quantities) {
            // ceil(q / maxPerStore) = (q + maxPerStore - 1) / maxPerStore
            storesNeeded += (q + maxPerStore - 1L) / maxPerStore;
            if (storesNeeded > n) return false;  // early exit
        }

        return storesNeeded <= n;
    }
}
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(m log MAX)**      | Binary search over possible maximum values: log(MAX) iterations (MAX ≤ 10⁵ → ~17 iterations)  
Each check: O(m) time to compute total stores needed (sum ceil(quantities[i] / mid) over all m types)  
Total: **O(m log 10⁵)** ≈ O(m × 17) — very fast even for m ≤ 10⁵ |
| **Space Complexity**  | **O(1)**              | Only a few integer variables — no extra arrays or data structures |

**Optimal** — logarithmic number of checks with linear work per check — perfect and extremely efficient for n, m ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: n = 6, quantities = [11, 6]

- Binary search range: low = 1, high = max(11,6) = 11

- Try mid = 6:
  - Type 0 (11): ceil(11/6) = 2 stores
  - Type 1 (6): ceil(6/6) = 1 store
  - Total stores needed = 3 ≤ 6 → possible → try smaller maximum

- Try mid = 5:
  - Type 0: ceil(11/5) = 3
  - Type 1: ceil(6/5) = 2
  - Total = 5 ≤ 6 → possible → try smaller

- Try mid = 4:
  - Type 0: ceil(11/4) = 3
  - Type 1: ceil(6/4) = 2
  - Total = 5 ≤ 6 → possible → try smaller

- Try mid = 3:
  - Type 0: ceil(11/3) = 4
  - Type 1: ceil(6/3) = 2
  - Total = 6 ≤ 6 → possible → try smaller

- Try mid = 2:
  - Type 0: ceil(11/2) = 6
  - Type 1: ceil(6/2) = 3
  - Total = 9 > 6 → impossible

- Lowest valid maximum = **3** → correct

**Correct** —  
Binary search efficiently finds the smallest possible value x such that it is possible to distribute all products using at most n stores, with no store receiving more than x products of any single type.  
The greedy ceil division (q + x - 1) / x gives the exact minimum number of stores needed for each product type.

---

## Key Takeaway

This is a **classic minimized maximum load** problem solved with **binary search on the answer**:

* Binary search on x — the maximum number of products any single store can receive
* Low = 1, High = maximum quantity in the array (worst-case one store takes everything)
* For each candidate mid-value x:
  * Check if all products can be distributed such that no store gets more than x of any type
  * For each product type i: compute stores needed = ceil(quantities[i] / x)
  * Sum over all types → if total stores needed ≤ n → possible (try smaller x)
  * Else → impossible (need larger x)
* Final answer = lowest x for which distribution is possible

**Pure, clean, optimal** — O(m log MAX) time, O(1) space, very fast, elegant, and correct.

---

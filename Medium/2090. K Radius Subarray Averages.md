# 2090. K Radius Subarray Averages  
*O(n) — Elegant Sliding Window with Prefix Sums*

---

## Problem Statement

You are given a **0-indexed** array `nums` of `n` integers, and an integer `k`.

For each index `i` (0 ≤ i < n), compute the **k-radius average** of the subarray centered at `i`:
- The subarray includes all elements from `i - k` to `i + k` (inclusive)
- If there are fewer than `k` elements on either side → average = **-1**
- Average = sum of elements / number of elements, using **integer division** (floor)

Return an array `avgs` of length `n` where `avgs[i]` is the k-radius average centered at index `i`.

**Examples**:

**Example 1**: nums = [7,4,3,9,1,8,5,2,6], k = 3  
Output: [-1,-1,-1,5,4,4,-1,-1,-1]  
- For i=3: elements 7,4,3,9,1,8,5 → sum=37 → 37//7=5  
- For i=4: 4,3,9,1,8,5,2 → sum=32 → 32//7=4  
- Edges have <k elements on one side → -1

**Constraints**:
- 1 ≤ n ≤ 10⁵
- 0 ≤ nums[i], k ≤ 10⁵

---

## Core Idea — Prefix Sums + Sliding Window

**Naive** way: for each i, sum from max(0, i-k) to min(n-1, i+k) → O(n × k) → TLE for n=10⁵, k=10⁵

**Optimal** way:
- Use **prefix sums** to compute range sums in O(1)
- For each i, the window is from left = i-k to right = i+k
- If left < 0 or right ≥ n → avgs[i] = -1
- Else → sum = prefix[right+1] - prefix[left]
- Number of elements = right - left + 1 = 2k + 1
- avgs[i] = sum // (2k + 1)

**Prefix sum definition**:
- prefix[0] = 0
- prefix[i+1] = prefix[i] + nums[i]

**Time**: O(n) — build prefix once + O(1) per query  
**Space**: O(n) — prefix array

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int[] GetAverages(int[] nums, int k) {
        int n = nums.Length;
        int[] avgs = new int[n];
        long[] prefix = new long[n + 1];

        // Build prefix sums
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + nums[i];
        }

        // Window size = 2k + 1
        long windowSize = 2L * k + 1;

        for (int i = 0; i < n; i++) {
            int left = i - k;
            int right = i + k;

            // Not enough elements on left or right
            if (left < 0 || right >= n) {
                avgs[i] = -1;
            } 
            else {
                // Sum from left to right inclusive
                long sum = prefix[right + 1] - prefix[left];
                avgs[i] = (int)(sum / windowSize);
            }
        }

        return avgs;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Building prefix sums array: O(n)  
Computing each average: O(1) per index (range sum query) → total O(n) |
| **Space Complexity**  | **O(n)**      | Prefix sum array: O(n)  
Output array `avgs`: O(n) |

**Optimal** — linear time and linear space — perfectly efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: nums = [7,4,3,9,1,8,5,2,6], k = 3

- Window size = 2×3 + 1 = **7**

- Prefix sums: [0, 7, 11, 14, 23, 24, 32, 37, 39, 45]

- For i = 3 (center = 9):
  - left = 3-3 = 0, right = 3+3 = 6
  - sum = prefix[7] - prefix[0] = 37 - 0 = **37**
  - 37 // 7 = **5**

- For i = 4 (center = 1):
  - left = 4-3 = 1, right = 4+3 = 7
  - sum = prefix[8] - prefix[1] = 39 - 7 = **32**
  - 32 // 7 = **4**

- For i = 0,1,2,6,7,8: either left < 0 or right ≥ 9 → **-1**

Output: [-1,-1,-1,5,4,4,-1,-1,-1] → correct

**Correct** —  
Prefix sums allow O(1) range sum queries for any window [left, right].  
For each center i, we check if the full 2k+1 window exists (left ≥ 0 and right < n).  
If yes → compute sum and divide by window size using integer division.  
If not → return -1 for that position.

---

## Key Takeaway

This is a **classic sliding window average** problem with radius k:

* Build **prefix sums** array for O(1) range sum queries
* For each possible center index i:
  * Compute window boundaries: left = i - k, right = i + k
  * If left < 0 or right ≥ n → avgs[i] = -1
  * Else → sum = prefix[right + 1] - prefix[left]
  * avgs[i] = sum // (2 * k + 1)   (integer division)
* Return the array of averages

**Pure, clean, optimal** — O(n) time, O(n) space, very fast, straightforward, and elegant.
---

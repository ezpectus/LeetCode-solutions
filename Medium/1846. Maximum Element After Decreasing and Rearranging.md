# 1846. Maximum Element After Decreasing and Rearranging  
*O(n log n) — Optimal Greedy Sorting + Linear Pass*

---

## Problem Statement

Given an array `arr` of positive integers (1 ≤ length ≤ 10⁵, 1 ≤ arr[i] ≤ 10⁹).

You can perform any number of these operations:

1. **Decrease** any element to any smaller **positive integer** (≥1)
2. **Rearrange** the array in **any order**

After operations, the array must satisfy:

- First element == **1**
- |arr[i] - arr[i-1]| ≤ 1 for all i (adjacent elements differ by at most 1)

Return the **maximum possible value** of **any element** in the final array.

---

## Core Idea — Sort + Greedy Build Consecutive Chain

**Key insight**:
- After sorting and decreasing, the optimal array must be **non-decreasing** with differences ≤1
- It must start with **1**
- To maximize the largest element → we want to make the sequence as long as possible with consecutive values (1,2,3,...,x)
- But we can **decrease** some values to fill gaps, but never increase

**Optimal strategy**:
1. Sort the array in ascending order
2. Start with current expected value = 1
3. Iterate through sorted array:
   - If current number ≤ current expected → we can keep it or decrease it
   - But to maximize max → greedily extend the chain: set current = current + 1
   - If current number > current expected → we can decrease it to current expected
   - But only if we want to fill the gap → in practice, we always try to extend as far as possible
4. The maximum value we can reach is the **length of the longest consecutive chain we can form** starting from 1

**Simplified greedy**:
- Sort arr ascending
- Initialize cur = 1
- For each number in sorted arr:
  - If number >= cur → we can set it to cur (or keep higher, but to maximize cur we take cur)
  - cur += 1
- The final cur-1 is the maximum value we can achieve

More precisely:
- After sorting, we greedily "cap" each number to be at most one more than previous
- But since we can rearrange, the optimal is to build the longest possible 1 → 2 → 3 → ... chain

**Correct greedy**:
- Sort arr in ascending order
- Start with prev = 0
- For each num in sorted arr:
  - The best we can do for this position is min(num, prev + 1)
  - Set prev = min(num, prev + 1)
- The final prev is the answer



---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MaximumElementAfterDecrementingAndRearranging(int[] arr) {
        int n = arr.Length;
        Array.Sort(arr);
        int prev = 0;
        for (int i = 0; i < n; i++) {
            if (arr[i] >= prev + 1) prev += 1;
        }
        
        return prev;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)**| Sorting the array dominates (n ≤ 10⁵), followed by a linear O(n) pass |
| **Space Complexity**  | **O(1)**      | Only a few variables used (in-place sorting possible in most languages) |

**Optimal** — sorting is necessary in the worst case to greedily build the longest consecutive chain starting from 1; the linear pass afterward is O(n).

---

## Why This Works — Example Walkthrough

**Example 1**: `arr = [2,2,1,2,1]`

- Sorted: [1,1,2,2,2]
- prev = 0
- 1 ≥ 1 → prev = 1
- 1 ≤ 1 → prev = 1 (no increase possible)
- 2 ≥ 2 → prev = 2
- 2 ≤ 2 → prev = 2
- 2 ≤ 2 → prev = 2
- Final prev = **2** → correct  
  (possible array: [1,2,2,2,1] — satisfies |diff| ≤ 1, starts with 1, max element 2)

**Example 2**: `arr = [100,1,1000]`

- Sorted: [1,100,1000]
- prev = 0
- 1 ≥ 1 → prev = 1
- 100 ≥ 2 → prev = 2
- 1000 ≥ 3 → prev = 3
- Final **3** → correct  
  (possible array: [1,2,3] after decreasing 100→2 and 1000→3)

**Example 3**: `arr = [1,2,3,4,5]`

- Sorted: [1,2,3,4,5]
- prev = 0
- 1 → prev = 1
- 2 → prev = 2
- 3 → prev = 3
- 4 → prev = 4
- 5 → prev = 5
- Final **5** → correct (already satisfies conditions)

**Correct** — after sorting, greedily capping each number to `prev + 1` (or keeping lower) maximizes the final value while ensuring:
- Array starts with 1 (first element ≤ 1 → becomes 1)
- Adjacent differences ≤ 1
- We can decrease any value freely

---

## Pitfalls & Edge Cases

- **All elements = 1** → sorted [1,1,1,...] → prev = 1 → answer = **1**
- **Single element** → must be decreased to 1 → answer = **1**
- **Already consecutive increasing** → answer = max(nums) (no need to decrease)
- **Very large numbers** → sorted first → capped greedily to prev+1
- **n = 10⁵** → O(n log n) from sorting is acceptable

All handled perfectly.

---

## Key Takeaway

This is a **beautifully greedy** rearrangement + value capping problem:

- **Sort** the array in ascending order
- Start with `prev = 0`
- For each number in sorted order:
  - The best we can set it to (to maximize future chain) is `min(num, prev + 1)`
  - Update `prev = min(num, prev + 1)`
- Final `prev` = maximum possible value of any element under constraints:
  - Array can be rearranged arbitrarily
  - Values can be decreased to any positive integer
  - Must start with 1
  - Adjacent differences ≤ 1

**Pure, clean, optimal** — perfect maximum value in a bounded-difference array after rearrangement and decreases.

---

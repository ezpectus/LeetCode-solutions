# 522. Longest Uncommon Subsequence II

---

## Problem Summary
We are given an array of strings `strs`.  
- An **uncommon subsequence** is a string that is a subsequence of one string but **not** of any other.  
- A subsequence of a string `s` is obtained by deleting any number of characters without changing the order.  
- Task: return the length of the longest uncommon subsequence. If none exists, return `-1`.

---

## Code Idea
1. **Iterate over each string** in `strs`.  
   - For every `strs[i]`, check if it is a subsequence of any other `strs[j]` (`j != i`).  
   - If yes → not uncommon.  
   - If no → candidate for longest uncommon subsequence.  

2. **Helper function `IsSubsequence(a, b)`**  
   - Two pointers: `i` for `a`, `j` for `b`.  
   - Move through `b`, advancing `i` only when characters match.  
   - If `i` reaches the end of `a`, then `a` is a subsequence of `b`.  

3. **Result**  
   - Track maximum length among all uncommon candidates.  
   - If none found → return `-1`.  

---
## Code C# 
```cpp
public class Solution {
    public int FindLUSlength(string[] strs) {
        int n = strs.Length;
        int res = -1;

        for(int i =0; i < n;i++){
            bool uncomm = true;

            for(int j = 0;j < n;j++){
                if(i == j) continue;
                 if (IsSubsequence(strs[i], strs[j])){
                    uncomm = false;
                    break;
                 }
            }

            if(uncomm) res = Math.Max(res,strs[i].Length); 
        }

   return res;
    }
private bool IsSubsequence(string a, string b){
  int i =0,j =0;

  while( i< a.Length && j < b.Length){
    if(a[i] == b[j]) i++;
        j++;
      }

  return i == a.Length;
    }
}
```

---

## Complexity
- **Time:** O(n² × L), where `n ≤ 50`, `L ≤ 10`.  
  - Each string compared with all others, subsequence check is O(L).  
- **Space:** O(1) — only pointers and counters.  

---

## Pitfalls
- Must skip comparing a string with itself (`i == j`).  
- Ensure subsequence check uses `a[i] == b[j]`, not `b[i]`.  
- Handle duplicates: if two identical strings exist, neither can be uncommon.  
- Edge case: if all strings are subsequences of others → return `-1`.  

---

## Example Walkthrough
**Input:** `["aba","cdc","eae"]`  
- "aba": not subsequence of "cdc" or "eae" → candidate length = 3.  
- "cdc": not subsequence of "aba" or "eae" → candidate length = 3.  
- "eae": not subsequence of "aba" or "cdc" → candidate length = 3.  
- **Output:** 3.  

**Input:** `["aaa","aaa","aa"]`  
- "aaa": subsequence of another "aaa".  
- "aa": subsequence of "aaa".  
- No uncommon subsequence.  
- **Output:** -1.  

---

## Conclusion
The problem reduces to **brute-force subsequence checking** with small constraints.  
- Runs in O(n² × L), efficient for given limits.  
- Helper function ensures clean subsequence validation.  
- Correctly handles duplicates and edge cases.  


---

## 🧩 Problem: Count Arrangement (Leetcode 526)

### 📘 Description
Given an integer `n`, return the number of **beautiful arrangements** that can be constructed by placing numbers `1` to `n` in positions `1` to `n`, such that for every position `i`, either:
- `number % i == 0` or
- `i % number == 0`

---

### 📌 Constraints
- `1 <= n <= 15`
- We must count **valid permutations** of `1..n` satisfying the divisibility condition
- Total permutations = `n!`, but many are invalid → need pruning

---

## 💡 Architectural Insight

This is a **bitmask-based backtracking simulation** with pruning via divisibility rules.

### 🧠 Core Idea

- Use a bitmask `a` to track which numbers are still available
- At each position `i`, try placing number `k` if:
  - `k` is unused (`a` has bit `k-1` set)
  - `i % k == 0` or `k % i == 0`
- Recursively simulate placement for position `i + 1`
- Base case: when `a == 0` → all numbers placed → return `1`

---

## 🧾 Code Pattern

```csharp
public class Solution {
    
    int run(int i, int n, int a) {
        if (a == 0) return 1;

        int res = 0;
        for (int k = 1; k <= n; k++) {
            // Check if k is unused and satisfies the condition
            if ((((1 << (k - 1)) & a) != 0) && (i % k == 0 || k % i == 0)) {
                res += run(i + 1, n, a - (1 << (k - 1)));
            }
        }
        return res;
    }

    public int CountArrangement(int n) {
        return run(1, n, (1 << n) - 1);
    }
}
```

## 🔍 Breakdown: Count Arrangement (Leetcode 526)

| **Component**                  | **Role**                                                                 |
|-------------------------------|--------------------------------------------------------------------------|
| `run(i, n, a)`                | Recursive function to simulate placement at position `i`                |
| `a` (bitmask)                 | Tracks available numbers (`1` means unused)                             |
| `a == 0`                      | Base case: all numbers placed → valid arrangement                       |
| `1 << (k - 1)`                | Bitmask representation for number `k`                                   |
| `a & (1 << (k - 1)) != 0`     | Check if `k` is unused                                                  |
| `i % k == 0 || k % i == 0`    | Valid placement condition based on divisibility                        |
| `a - (1 << (k - 1))`          | Mark `k` as used in the next recursive call                            |
| `res += run(...)`            | Accumulate valid arrangements from recursive branches                   |

---

## 🧱 Engineering Pattern: Bitmask Backtracking with Constraint Pruning

### **Use Case**
Count valid permutations under positional constraints, where each number must satisfy a condition relative to its position.

---

### **Core Steps**
1. Represent available numbers as a bitmask.
2. At each position `i`, try placing valid `k`:
   - `k` is unused → check via bitmask.
   - `i % k == 0 || k % i == 0` → placement is valid.
3. Recurse to next position with updated bitmask.
4. Base case: all bits cleared → return `1`.
5. Accumulate total count across valid recursive paths.

---

### **Generalization**
- Works for any permutation task with **positional constraints**.
- Bitmask enables efficient **state tracking** and **pruning**.
- Can be extended with **memoization** (e.g. `dp[i][mask]`) for performance.
- Applicable to:
  - Scheduling tasks with compatibility rules.
  - Assignment problems with mutual constraints.
  - Grid or graph-based placement simulations.

---

## ✅ Conclusions

- This task reinforces **bitmask recursion** with **constraint-based pruning**.
- You now have a reusable template for:
  - Permutation counting with placement rules.
  - Efficient state tracking via bitmask.
  - Recursive simulation with early termination.

---

### **Architectural Signals**
- `a == 0` → all numbers placed → valid terminal state.
- `i % k == 0 || k % i == 0` → placement condition.
- `bitmask & (1 << (k - 1))` → availability check.

---

### 🔁 Reuse Note
Save this pattern as a reference for future **backtracking tasks** involving:
- Positional constraints
- Bitmask state compression
- Recursive enumeration with pruning




---

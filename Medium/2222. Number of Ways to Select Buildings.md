# 2222. Number of Ways to Select Buildings  
*O(n) — Prefix Sum + Combinatorial Counting*

---

## Problem Statement

You are given a 0-indexed binary string `s` of length `n`, where:

- `s[i] == '0'` → building i is an **office**
- `s[i] == '1'` → building i is a **restaurant**

Select exactly **3 buildings** such that **no two consecutive** selected buildings have the same type.

Return the **number of valid ways** to choose 3 buildings satisfying the condition.  
If impossible → return **0**.

**Examples**:

**Example 1**  
Input: s = "001101"  
Output: **6**  
Valid triples (0-based indices):
- (0,2,4) → "010"
- (0,3,4) → "010"
- (1,2,4) → "010"
- (1,3,4) → "010"
- (2,4,5) → "101"
- (3,4,5) → "101"

**Example 2**  
Input: s = "11100"  
Output: **0**  
No valid triple exists

**Constraints**:
- 3 ≤ n ≤ 10⁵
- s consists of '0' and '1'

---

## Core Idea — Prefix Counts + Combinatorial Enumeration

**Key observation**:
- We need exactly 3 positions i < j < k such that:
  - s[i] ≠ s[j]
  - s[j] ≠ s[k]
- This means the types must alternate: either **0-1-0** or **1-0-1**

**Two possible patterns**:
1. Office-Restaurant-Office → **0-1-0**
2. Restaurant-Office-Restaurant → **1-0-1**

**Efficient way**:
- Precompute prefix counts:
  - `prefix0[i]` = number of '0's in s[0..i-1]
  - `prefix1[i]` = number of '1's in s[0..i-1]
- For each possible **middle** building j (position of the middle type):
  - If s[j] == '1' → pattern 0-1-0
    - Left '0's = prefix0[j]
    - Right '0's = total0 - prefix0[j+1]
    - Ways = left0 × right0
  - If s[j] == '0' → pattern 1-0-1
    - Left '1's = prefix1[j]
    - Right '1's = total1 - prefix1[j+1]
    - Ways = left1 × right1
- Sum over all possible middle j

**Time**: O(n) — single pass for prefixes + single pass for summation  
**Space**: O(n) — prefix arrays (can be optimized to O(1) with counters)

---

## Clean Implementation (C#)

```csharp
public class Solution
{
    public long NumberOfWays(string s)
    {
        int n = s.Length;

        // Count total 0s and 1s
        long total0 = 0, total1 = 0;
        foreach (char c in s)
        {
            if (c == '0') total0++;
            else total1++;
        }

        // Prefix counts
        long[] prefix0 = new long[n + 1];
        long[] prefix1 = new long[n + 1];

        for (int i = 0; i < n; i++)
        {
            prefix0[i + 1] = prefix0[i] + (s[i] == '0' ? 1 : 0);
            prefix1[i + 1] = prefix1[i] + (s[i] == '1' ? 1 : 0);
        }

        long ways = 0;

        // For each possible middle position j
        for (int j = 1; j < n - 1; j++) // j must have left and right
        {
            if (s[j] == '0')
            {
                // Pattern 1-0-1
                long left1 = prefix1[j];
                long right1 = total1 - prefix1[j + 1];
                ways += left1 * right1;
            }
            else // s[j] == '1'
            {
                // Pattern 0-1-0
                long left0 = prefix0[j];
                long right0 = total0 - prefix0[j + 1];
                ways += left0 * right0;
            }
        }

        return ways;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Building prefix count arrays: O(n)<br>Single pass over possible middle positions: O(n) |
| **Space Complexity**  | **O(n)**      | Prefix arrays for '0's and '1's (can be optimized to **O(1)** extra space using running counters) |

**Optimal** — linear time and linear space — perfectly efficient for n ≤ 10⁵.  
With O(1) space optimization (tracking running counts), it becomes even more memory-friendly.

---

## Why This Works — Example Walkthrough

**Example 1**: s = "001101"

- Indices: 0:'0', 1:'0', 2:'1', 3:'1', 4:'0', 5:'1'
- total0 = 3, total1 = 3

**Prefix counts** (prefix0[i+1] = number of '0's in s[0..i]):

- prefix0 = [0,1,2,2,2,3,3]
- prefix1 = [0,0,0,1,2,2,3]

For each possible **middle** j (must have at least one building left and right → j from 1 to 4):

- j=1 (s[1]='0'): left1 = prefix1[1] = 0, right1 = total1 - prefix1[2] = 3-0 = 3 → 0×3 = **0**
- j=2 (s[2]='1'): left0 = prefix0[2] = 2, right0 = total0 - prefix0[3] = 3-2 = 1 → 2×1 = **2**
- j=3 (s[3]='1'): left0 = prefix0[3] = 2, right0 = total0 - prefix0[4] = 3-2 = 1 → 2×1 = **2**
- j=4 (s[4]='0'): left1 = prefix1[4] = 2, right1 = total1 - prefix1[5] = 3-2 = 1 → 2×1 = **2**

Total ways = 0 + 2 + 2 + 2 = **6** → correct

**Correct** —  
For every possible **middle building** j (the second building in the triple), we count:
- Number of valid **left** buildings (opposite type, before j)
- Number of valid **right** buildings (opposite type, after j)
- Ways = left × right (independent choices)

Summing over all possible j gives the total number of valid triples.

---

## Key Takeaway

This is a **simple, elegant prefix-count + combinatorial** problem:

* Precompute **prefix counts** of '0's and '1's (or use running counters for O(1) space)
* Compute total number of '0's and '1's in the string
* For every possible **middle position** j (1 to n-2):
  * If middle is '0' → pattern **1-0-1** → count left '1's × right '1's
  * If middle is '1' → pattern **0-1-0** → count left '0's × right '0's
* Sum all such products → that's the total number of valid ways to choose three buildings with alternating types

**Pure, clean, optimal** — O(n) time, O(n) space (easily O(1) extra with running counts), extremely fast, intuitive, and mathematically precise.

---

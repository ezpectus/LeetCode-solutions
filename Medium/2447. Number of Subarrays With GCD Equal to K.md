# 🧩 Problem: Number of Subarrays With GCD Equal to K  
## 🔢 Number: LeetCode 2447  
**Difficulty**: Medium  
**Language**: C#  
**Status**: ✅ Solved with brute-force + early exit  

---

## 📜 Problem Overview

Given an integer array `nums` and an integer `k`, return the number of **contiguous subarrays** whose **greatest common divisor (GCD)** equals `k`.

---

### 🔢 Constraints
- `1 ≤ nums.length ≤ 1000`  
- `1 ≤ nums[i], k ≤ 10⁹`  
- Subarrays must be **non-empty and contiguous**

---

### 🎁 What’s Given
- Array `nums[]` — the input sequence  
- Integer `k` — the target GCD  
- Return the count of subarrays where `GCD(subarray) == k`

---

### 👀 What We Observe
- GCD is **monotonic decreasing** — adding more elements can only keep or reduce it  
- If current GCD becomes `< k`, we can **break early**  
- We need to **check all subarrays**, but optimize with early exit

---

## 🧠 Explanation

We iterate over all possible subarrays using two nested loops:
- Outer loop `i` — start index of subarray  
- Inner loop `j` — end index, expanding from `i` to `n-1`  
- For each subarray, we maintain `currgcd` and update it with `nums[j]`  
- If `currgcd == k`, we increment the result  
- If `currgcd < k`, we break — no further expansion can reach `k`

---

## ⚙️ Algorithm Choice
- **Approach**: Brute-force with early exit  
- **Why**: Acceptable for `n ≤ 1000`, avoids unnecessary checks  
- **Efficiency**: O(n²) worst-case, but early breaks reduce actual work  
- **Memory**: Constant space

---

## 💡 Idea Summary
- Loop over all subarrays  
- Track running GCD  
- Count when GCD equals `k`  
- Break when GCD drops below `k`

---

## 🧾 Code
```csharp
public class Solution {
    public int SubarrayGCD(int[] nums, int k) {
        int n = nums.Length;
        int res = 0;

        for (int i = 0; i < n; i++) {
            int currgcd = nums[i];
            for (int j = i; j < n; j++) {
                currgcd = GCD(currgcd, nums[j]);
                if (currgcd == k) res++;
                if (currgcd < k) break;
            }
        }

        return res;
    }

    private int GCD(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

## ✅ Complexity, Insights & Notes

### ⏱ Time Complexity
- **O(n²)** — nested loops over all subarrays  
- **Early exit** reduces actual iterations when GCD drops below `k`

---

### 🧠 Space Complexity
- **O(1)** — no extra data structures used

---

### 🧨 Tricks / Insights
- **GCD is monotonic** → once `currgcd < k`, no further extension can recover it  
- **No need to store subarrays** — just track running GCD  
- **Efficient for small `n`**, but not scalable for large arrays

---

### 🔗 Related Concepts
- **GCD accumulation**  
- **Subarray enumeration**  
- **Early exit optimization**  
- **Mathematical filtering in brute-force**

---

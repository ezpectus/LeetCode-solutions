# ğŸ§© Problem: Number of Subarrays With GCD Equal to K  
## ğŸ”¢ Number: LeetCode 2447  
**Difficulty**: Medium  
**Language**: C#  
**Status**: âœ… Solved with brute-force + early exit  

---

## ğŸ“œ Problem Overview

Given an integer array `nums` and an integer `k`, return the number of **contiguous subarrays** whose **greatest common divisor (GCD)** equals `k`.

---

### ğŸ”¢ Constraints
- `1 â‰¤ nums.length â‰¤ 1000`  
- `1 â‰¤ nums[i], k â‰¤ 10â¹`  
- Subarrays must be **non-empty and contiguous**

---

### ğŸ Whatâ€™s Given
- Array `nums[]` â€” the input sequence  
- Integer `k` â€” the target GCD  
- Return the count of subarrays where `GCD(subarray) == k`

---

### ğŸ‘€ What We Observe
- GCD is **monotonic decreasing** â€” adding more elements can only keep or reduce it  
- If current GCD becomes `< k`, we can **break early**  
- We need to **check all subarrays**, but optimize with early exit

---

## ğŸ§  Explanation

We iterate over all possible subarrays using two nested loops:
- Outer loop `i` â€” start index of subarray  
- Inner loop `j` â€” end index, expanding from `i` to `n-1`  
- For each subarray, we maintain `currgcd` and update it with `nums[j]`  
- If `currgcd == k`, we increment the result  
- If `currgcd < k`, we break â€” no further expansion can reach `k`

---

## âš™ï¸ Algorithm Choice
- **Approach**: Brute-force with early exit  
- **Why**: Acceptable for `n â‰¤ 1000`, avoids unnecessary checks  
- **Efficiency**: O(nÂ²) worst-case, but early breaks reduce actual work  
- **Memory**: Constant space

---

## ğŸ’¡ Idea Summary
- Loop over all subarrays  
- Track running GCD  
- Count when GCD equals `k`  
- Break when GCD drops below `k`

---

## ğŸ§¾ Code
```csharp
public class Solution {
    public int SubarrayGCD(int[] nums, int k) {
        int n = nums.Length;
        int res = 0;

        for (int i = 0; i < n; i++) {
            int currgcd = nums[i];
            for (int j = i; j < n; j++) {
                currgcd = GCD(currgcd, nums[j]);
                if (currgcd == k) res++;
                if (currgcd < k) break;
            }
        }

        return res;
    }

    private int GCD(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

## âœ… Complexity, Insights & Notes

### â± Time Complexity
- **O(nÂ²)** â€” nested loops over all subarrays  
- **Early exit** reduces actual iterations when GCD drops below `k`

---

### ğŸ§  Space Complexity
- **O(1)** â€” no extra data structures used

---

### ğŸ§¨ Tricks / Insights
- **GCD is monotonic** â†’ once `currgcd < k`, no further extension can recover it  
- **No need to store subarrays** â€” just track running GCD  
- **Efficient for small `n`**, but not scalable for large arrays

---

### ğŸ”— Related Concepts
- **GCD accumulation**  
- **Subarray enumeration**  
- **Early exit optimization**  
- **Mathematical filtering in brute-force**

---

# 2483. Minimum Penalty for a Shop — Architectural Prefix/Suffix Penalty Calculation  
*O(n) — Optimal Two-Pass Count with Linear Scan*

---

## Problem Statement

Given a string `customers` of length `n`, where:
- `'Y'` means customers **arrive** at hour `i`
- `'N'` means **no customers** at hour `i`

You must choose an hour `j` (0 ≤ j ≤ n) to **close the shop**:
- Hours **0 to j-1** are **open**
- Hours **j to n-1** are **closed**

**Penalty rules**:
- For every **open** hour with `'N'` → +1 penalty (shop open but no customers)
- For every **closed** hour with `'Y'` → +1 penalty (customers arrived but shop closed)

Return the **earliest** hour `j` that gives the **minimum** total penalty.

---

## Core Idea — Precompute Prefix 'N' and Suffix 'Y' Counts

**The most important part — how and why it works**

**Key observation**:
- The total penalty when closing at hour `j` consists of **two completely independent** parts:
  1. Penalty for **open hours** (0..j-1): number of `'N'` in this range
  2. Penalty for **closed hours** (j..n-1): number of `'Y'` in this range

**Why we can separate them**:
- These two ranges are **disjoint** and together cover the entire day.
- The penalties **do not depend on each other** — they can be calculated separately and simply added.

**Prefixes and suffixes**:
- `prefixN[j]` = number of `'N'` in hours **[0..j-1]** → open penalty when closing at `j`
- `suffixY[j]` = number of `'Y'` in hours **[j..n-1]** → closed penalty when closing at `j`

**How this helps**:
- We precompute both arrays in O(n) time.
- Then, for every possible closing hour `j` (from 0 to n):
  - Total penalty = `prefixN[j] + suffixY[j]`
- We find the **minimum** penalty and the **earliest** `j` that achieves it.

**Why precomputation is efficient**:
- Without precomputation, we would have to recount `'N'` to the left and `'Y'` to the right for each `j` → O(n²)
- With precomputation — only **one linear pass** over all possible `j` → O(n)

**Bottom line**:
- Splitting the penalty into two independent parts allows us to use **prefix sums** for instant access to the required values.
- This transforms the problem from potentially quadratic to **linear**.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int BestClosingTime(string customers) {
        int n = customers.Length;

        // prefixN[i] = number of 'N' in [0..i-1]
        int[] prefixN = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            prefixN[i] = prefixN[i - 1];
            if (customers[i - 1] == 'N')  prefixN[i]++;
            
        }

        // suffixY[i] = number of 'Y' in [i..n-1]
        int[] suffixY = new int[n + 1];
        for (int i = n - 1; i >= 0; i--) {
            suffixY[i] = suffixY[i + 1];
            if (customers[i] == 'Y')  suffixY[i]++;
            
        }

        int minPenalty = int.MaxValue, bestHour = 0;

        for (int j = 0; j <= n; j++) {
            int penalty = prefixN[j] + suffixY[j];
            if (penalty < minPenalty) {
                minPenalty = penalty;
                bestHour = j;
            }
        }

        return bestHour;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Two precompute passes + one scan               |
| **Space Complexity**  | **O(n)**      | Two auxiliary arrays                           |

**Optimal** — linear time and space.

---

## Why This Works — Example Walkthrough

**Input**: `customers = "YYNY"`

- n = 4
- **prefixN[i]** = number of `'N'` in hours **[0..i-1]** (open when closing at i)
  - prefixN = [0, 0, 0, 1, 2]  → 'N' at positions 2 and 3
- **suffixY[i]** = number of `'Y'` in hours **[i..n-1]** (closed when closing at i)
  - suffixY = [3, 2, 1, 1, 0]  → 'Y' at positions 0,1,3

**Penalty calculation for each closing hour j**:
- j=0: open none + closed all → 0 + 3 = **3**
- j=1: open [0] ('Y') + closed [1,2,3] → 0 + 2 = **2**
- j=2: open [0,1] ('YY') + closed [2,3] → 0 + 1 = **1**
- j=3: open [0,1,2] ('YYN') + closed [3] → 1 + 1 = **2**
- j=4: open all + closed none → 2 + 0 = **2**

Minimum penalty = **1** at j=2 → return **2**

**Correct** — close at hour 2.

**Input**: `"NNNNN"` → all 'N'
- prefixN grows to 5, suffixY always 0 → best j=0 (penalty 0)

**Input**: `"YYYY"` → all 'Y'
- prefixN always 0, suffixY decreases → best j=4 (penalty 0)

**Correct**.

---

## Pitfalls & Edge Cases

- **j=0** → shop never opens → penalty = number of all `'Y'`
- **j=n** → shop never closes → penalty = number of all `'N'`
- **All 'Y'** → best to close at end (no closed penalty)
- **All 'N'** → best to close at start (no open penalty)
- **Mixed** → find balance where open 'N's + closed 'Y's is minimized

All handled perfectly.

---

## Key Takeaway

This is a **beautifully efficient** prefix/suffix problem:

- **Precompute**:
  - `prefixN` → how many customers missed while open
  - `suffixY` → how many customers came while closed
- **Linear scan** → total penalty = prefixN[j] + suffixY[j]
- **Track minimum** and **earliest** j with that minimum

**No simulation of hours. No brute force.**
**Pure, clean, optimal** — perfect penalty minimization.

---

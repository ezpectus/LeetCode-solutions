# Intuition
We are allowed to delete one element from the array. To maximize the length of a subarray containing only 1s, we can treat this as allowing at most one 0 in a sliding window. If we ever encounter more than one 0, we shrink the window from the left.

# Approach
We use a sliding window with two pointers: left and right. We maintain a counter zeros to track how many 0s are in the current window.

Iterate right from 0 to n - 1

If nums[right] == 0, increment zeros

While zeros > 1, move left forward and decrement zeros if nums[left] == 0

At each step, update maxlen = right - left (we subtract 1 implicitly by excluding the deleted element)

This ensures the window always contains at most one 0, which simulates deleting one element to get a subarray of only 1s.

# Complexity
Time complexity: $$O(n)$$ — each element is visited at most twice (once by right, once by left)

Space complexity: $$O(1)$$ — constant space for counters and pointers

# Code
```csharp []
public class Solution {
    public int LongestSubarray(int[] nums) {
        int n = nums.Length;
        int zeros =0;
        int left =0;
        int maxlen = 0;


        for(int right = 0; right < n;right++){
            if(nums[right] == 0){
                zeros++;
            }
           while (zeros > 1) {
                if (nums[left] == 0)
                    zeros--;
                left++;
            
            }

            maxlen = Math.Max(maxlen,right-left);
        }
    return maxlen;

    }
}
```

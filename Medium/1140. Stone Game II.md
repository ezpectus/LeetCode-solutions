# 🧠 Problem Breakdown — 1140. Stone Game II

## 🔍 Problem Statement

Alice and Bob play a game with a row of stone piles. Each pile contains a positive number of stones. Players take turns, starting with Alice.

On each turn, a player can take the first `X` remaining piles, where `1 <= X <= 2M`.  
After the move, `M` becomes `max(M, X)`.

The game ends when all stones are taken.  
Both players play optimally.

**Goal**: Return the maximum number of stones Alice can collect.

---

## 📌 Constraints

- `1 <= piles.length <= 100`
- `1 <= piles[i] <= 10⁴`

---

## 🧠 Core Idea

This is a classic **minimax with memory** problem.  
We simulate both players playing optimally using recursion and memoization.

We define a recursive function `Game(idx, M)` that returns the **maximum stones the current player can collect**, starting from index `idx` with current `M`.

To optimize performance, we use **suffix sums** to quickly compute the total stones remaining from any index.

---

## ✅ Implementation (C#)

```csharp
public class Solution {
    public int StoneGameII(int[] piles) {
        int n = piles.Length;
        int[] sums = new int[n];
        int sum = 0;

        for (int i = n - 1; i >= 0; i--) {
            sum += piles[i];
            sums[i] = sum;
        }

        int[,] dp = new int[n, n];
        return Game(piles, sums, dp, 0, 1);
    }

    private int Game(int[] piles, int[] sums, int[,] dp, int idx, int m) {
        int n = piles.Length;
        if (idx >= n) return 0;
        if (2 * m >= n - idx) return sums[idx];
        if (dp[idx, m] != 0) return dp[idx, m];

        for (int x = 1; x <= Math.Min(2 * m, n - idx); x++) {
            int taken = sums[idx] - sums[idx + x];
            int opponent = Game(piles, sums, dp, idx + x, Math.Max(m, x));
            int remain = sums[idx + x] - opponent;
            dp[idx, m] = Math.Max(dp[idx, m], taken + remain);
        }

        return dp[idx, m];
    }
}

```

## 🧠 Signals — Architectural Breakdown

- `sums[i]`:  
  Precomputed **suffix sum** from index `i` to the end of the array.  
  Used to quickly calculate the total stones remaining without repeated summation.

- `dp[idx, m]`:  
  **Memoization table** storing the maximum stones the current player can collect  
  starting from index `idx` with current move size `M`.  
  Prevents recomputation of overlapping subproblems.

- `taken = sums[idx] - sums[idx + x]`:  
  Number of stones taken in the current move by selecting `x` piles.  
  Calculated using the suffix sum difference.

- `opponent = Game(...)`:  
  Recursive call simulating the opponent's optimal move from the next position.  
  This models the adversarial nature of the game.

- `remain = sums[idx + x] - opponent`:  
  Stones left for the current player after the opponent plays optimally.  
  Represents the net gain from choosing `x` piles now.

- `dp[idx, m] = max(...)`:  
  Core **DP transition**: maximize the current player's total stones  
  by trying all valid `x` in range `[1, 2M]` and choosing the best outcome.

---

## 🧼 Notes — Complexity & Optimization

- **Time Complexity**: `O(n²)`  
  - Outer recursion over `idx` and `M`  
  - Inner loop over `x ∈ [1, 2M]`  
  - Bounded by `n = 100`, so acceptable for full DP traversal

- **Space Complexity**: `O(n²)`  
  - Due to the 2D memoization table `dp[n][n]`  
  - Suffix sum array `sums[n]` adds linear overhead

- **Optimization Strategy**:  
  - Use of **suffix sums** allows constant-time range queries  
  - **Memoization** avoids redundant recursive calls  
  - Together, they reduce brute-force exponential recursion to polynomial time

---

## 🧠 Summary — Engineering Insight

This solution models the game as a **recursive decision tree**,  
where each player chooses the optimal number of piles to take,  
and the opponent responds optimally in turn.

By combining:

- **Suffix sums** for fast range queries  
- **Memoization** for subproblem reuse  
- **Minimax recursion** for adversarial modeling

We achieve a solution that is:

- ✅ **Clean** — no redundant logic or noise  
- ✅ **Modular** — easy to adapt or extend  
- ✅ **Reusable** — fits into broader DP or game theory templates  
- ✅ **Architecturally sound** — every signal has a purpose




---



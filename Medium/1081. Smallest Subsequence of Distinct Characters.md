# 1081. Smallest Subsequence of Distinct Characters

## Given

- A string `s` of lowercase English letters  
- Constraint: `1 <= s.length <= 1000`  
- Goal: Return the **lexicographically smallest subsequence** of `s` that contains **all distinct characters exactly once**

---

## Architectural Signals

- Fixed alphabet (`a-z`) → use arrays of size 26  
- Lexicographic constraint → greedy selection  
- Uniqueness constraint → track usage  
- Subsequence (not substring) → characters can be skipped  
- Moderate input size → linear scan is acceptable

---

## Core Idea

Use a **greedy + monotonic stack** strategy to construct the result:

- Track the **last occurrence** of each character  
- Maintain a **used[]** array to ensure uniqueness  
- Use a **stack** to build the result in order  
- At each step, remove characters from the stack if:
  - They are lexicographically larger than the current character  
  - They appear again later in the string

This ensures the result is:
- Lexicographically minimal  
- Contains each character exactly once  
- Built in linear time with rollback-safe decisions

---

## Execution Scheme

1. Precompute `lastIndex[c]` for each character `c` in `s`
2. Iterate through `s`:
   - Skip if `c` is already used
   - While stack is non-empty and:
     - Top of stack > `c`
     - Top of stack appears again later
     → Pop and mark as unused
   - Push `c` and mark as used
3. Reverse the stack to get the final result

---

## Code (C#)

```csharp
public class Solution {
    public string SmallestSubsequence(string s) {
        int n = s.Length;
        int[] lastIndex = new int[26];
        bool[] used = new bool[26];
        Stack<char> stack = new Stack<char>();

        for (int i = 0; i < n; i++) {
            lastIndex[s[i] - 'a'] = i;
        }

        for (int i = 0; i < n; i++) {
            char c = s[i];
            if (used[c - 'a']) continue;

            while (stack.Count > 0 &&
                   stack.Peek() > c &&
                   lastIndex[stack.Peek() - 'a'] > i) {
                char removed = stack.Pop();
                used[removed - 'a'] = false;
            }

            stack.Push(c);
            used[c - 'a'] = true;
        }

        char[] result = stack.Reverse().ToArray();
        return new string(result);
    }
}


```

## Complexity

| Metric | Value | Notes |
|--------|-------|-------|
| Time   | O(n)  | Each character is pushed and popped at most once |
| Space  | O(1)  | Fixed-size arrays for 26 lowercase letters (`used[]`, `lastIndex[]`) |

This solution is strictly linear and constant-space due to the bounded alphabet and single-pass logic.

---

## Pitfalls

- ❌ Missing `used[]` tracking → duplicates in result  
- ❌ Incorrect `lastIndex[]` usage → premature removal breaks correctness  
- ❌ Improper stack reversal → wrong output order  
- ❌ Greedy removal without safety check → breaks lexicographic guarantee

---

## Insight

This is a **universal greedy template** for problems involving:

- Lexicographic optimization  
- Uniqueness enforcement  
- Subsequence construction  
- Rollback-safe decisions

### Key components:

- `lastIndex[]` → enables safe removal by tracking future availability  
- `used[]` → enforces uniqueness  
- `stack` → maintains order and supports rollback

### Generalization:

This exact structure applies to:
- [316. Remove Duplicate Letters] — identical logic, different name  
- Any variant requiring:
  - Lex-min subsequence with unique characters  
  - Stack-based greedy selection  
  - Fixed alphabet constraints  
  - Multi-pass rollback-safe decisions

This is not a task-specific patch —  
it’s a deployable module for greedy subsequence problems with structural guarantees.

---

# 2516. Take K of Each Character From Left and Right  
*O(n) — Sliding Window / Two Pointers*

---

## Problem Statement

You are given a string `s` consisting only of letters `'a'`, `'b'`, `'c'` and a non-negative integer `k`.

Each minute, you can remove **either** the **leftmost** or the **rightmost** character of the current string `s`.

Return the **minimum number of minutes** needed to have **at least k** `'a'`, **at least k** `'b'`, and **at least k** `'c'` in total removed characters.  
If impossible, return **-1**.

**Examples**:

**Example 1**  
Input: s = "aabaaaacaabc", k = 2  
Output: **8**  
Explanation:  
Take 3 from left: "aaa" → have 3'a'  
Take 5 from right: "cabc" → have 2'c', 1'b' + previous → total 3'a', 2'b', 2'c'  
Total minutes = 8 (minimum)

**Example 2**  
Input: s = "a", k = 1  
Output: **-1**  
Cannot get 'b' or 'c'

**Constraints**:
- 1 ≤ s.length ≤ 10⁵
- s consists only of 'a','b','c'
- 0 ≤ k ≤ s.length

---

## Core Idea — Greedy + Sliding Window on Remaining Middle Part

**Beautiful observation**:
- We want to remove **at least k** of each character ('a','b','c')
- We can only remove from **ends** (left or right)
- The characters we **do NOT remove** must be in the **middle contiguous segment** of the original string
- The removed characters come from the **prefix** + **suffix** we take
- Goal: **maximize** the length of the middle segment we leave, such that the removed prefix + suffix contain **≥ k** of each letter
- Equivalently: **minimize** the number of removed characters while having ≥ k of each, then answer = total removed

**Equivalent formulation**:
- Find the **longest** subarray (middle part) such that the number of 'a's, 'b's, 'c's **outside** it (in prefix + suffix) is ≥ k each
- Then answer = n - length of that longest subarray

**How to find**:
- Use **sliding window** to find the **maximum length** subarray where:
  - count_a outside ≥ k
  - count_b outside ≥ k
  - count_c outside ≥ k
- Outside counts = total counts - subarray counts
- So we need:
  - total_a - window_a ≥ k   ⇒   window_a ≤ total_a - k
  - window_b ≤ total_b - k
  - window_c ≤ total_c - k

**Algorithm** (sliding window):
1. If any character has total count < k → impossible → -1
2. Compute total count of 'a','b','c'
3. Use two pointers to find **maximum window length** where:
   - window count of 'a' ≤ total_a - k
   - window count of 'b' ≤ total_b - k
   - window count of 'c' ≤ total_c - k
4. Answer = n - max_window_length

**Time**: O(n) — two pointers slide at most O(n) steps  
**Space**: O(1) — only counters

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int TakeCharacters(string s, int k){
        int n = s.Length;

        // Count total occurrences
        int[] total = new int[3];
        foreach (char c in s){
            total[c - 'a']++;
        }

        // If any character has < k → impossible
        if (total[0] < k || total[1] < k || total[2] < k){
            return -1;
        }

        // Maximum allowed in window for each char
        int[] maxInWindow = new int[3];
        for (int i = 0; i < 3; i++){
            maxInWindow[i] = total[i] - k;
        }

        // Sliding window to find longest subarray where
        // count_a <= maxInWindow[0], etc.
        int[] windowCount = new int[3];
        int left = 0;
        int maxLength = 0;

        for (int right = 0; right < n; right++){
            windowCount[s[right] - 'a']++;

            // Shrink from left if any count exceeds limit
            while (left <= right &&
                   (windowCount[0] > maxInWindow[0] ||
                    windowCount[1] > maxInWindow[1] ||
                    windowCount[2] > maxInWindow[2])){
                windowCount[s[left] - 'a']--;
                left++;
            }

            maxLength = Math.Max(maxLength, right - left + 1);
        }

        // Minimum removals = total length - max middle we can keep
        return n - maxLength;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Two pointers (`left` and `right`) each move at most `n` times across the string |
| **Space Complexity**  | **O(1)**      | Only fixed-size arrays (3 elements) for counts — no extra data structures |

**Optimal** — linear time and constant space — perfectly efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: s = "aabaaaacaabc", k = 2

**Total counts**:
- 'a': 8
- 'b': 2
- 'c': 2

**Maximum allowed in middle window** (so removed has ≥ k=2 of each):
- 'a': 8 - 2 = 6
- 'b': 2 - 2 = 0
- 'c': 2 - 2 = 0

We need the **longest subarray** where:
- number of 'a' ≤ 6
- number of 'b' ≤ 0
- number of 'c' ≤ 0

→ longest subarray with **only 'a'** and ≤6 'a's → longest run of 'a's of length ≤6

Longest all-'a' subarray = "aaaaaa" (positions 3–8, length 6)  
Removed characters = 12 - 6 = **6**

But example output = **8** → contradiction?

**Correction** — the example removes **8 characters** (kept 4), but logic suggests 6 is possible.

**Re-check example**:
s = "a a b a a a a c a a b c" (positions 0–11)

If keep positions 3–8: "a a a a c a" (length 6)
Removed left: "a a b" (2a,1b)
Removed right: "a b c" (1a,1b,1c)
Total removed: a:3, b:2, c:1 → c=1 < 2 → **not enough 'c'** → invalid

- Longest valid middle must ensure removed has ≥2 'c', ≥2 'b', ≥2 'a'
- In example they removed 8 chars (kept 4), and got exactly 2 of each in removed.
- The sliding window correctly finds the **maximum length middle** such that **removed prefix + suffix** has ≥ k of each letter — which is equivalent to middle counts ≤ total - k for each letter.
- In this case, max valid middle length = **4** → removed 8 → correct
- Earlier manual mistake: keeping "aaaaaa" removes too few 'c' (only 1 'c' removed).
- **Correct** — the sliding window enforces the count constraints for all three letters simultaneously, ensuring the removed parts have enough of each.

---

## Key Takeaway

This is a **beautiful sliding window** problem:

* Goal: **minimize** removed characters (minutes) → **maximize** length of middle subarray we keep
* Condition: removed characters (prefix + suffix) must contain **≥ k** of each letter 'a', 'b', 'c'
* Equivalent constraint on middle: count_a ≤ total_a - k, count_b ≤ total_b - k, count_c ≤ total_c - k
* Use **sliding window** (two pointers) to find the **longest subarray** satisfying all three count limits
* Answer = n - max_window_length (or -1 if impossible, e.g., some letter has total count < k)

**Pure, clean, optimal** — O(n) time, O(1) space, extremely fast, elegant sliding window technique, and correctly solves the "remove from ends only" constraint.

---

# 🔢 Powerful Integers — LeetCode 970

## 🧩 Problem Statement

Given three integers `x`, `y`, and `bound`, return a list of all **powerful integers** less than or equal to `bound`.

An integer is considered *powerful* if it can be expressed as:

```
x^i + y^j where i ≥ 0 and j ≥ 0
```

Each value should appear **at most once** in the result.

---

## 📥 Input

- `x`: integer (1 ≤ x ≤ 100)
- `y`: integer (1 ≤ y ≤ 100)
- `bound`: integer (0 ≤ bound ≤ 10⁶)

---

## 📤 Output

- A list of integers representing all powerful numbers ≤ `bound`, with no duplicates.
- Order does **not** matter.

---

## ✅ Examples

### Example 1
Input: x = 2, y = 3, bound = 10 Output: [2, 3, 4, 5, 7, 9, 10]



### Example 2
Input: x = 3, y = 5, bound = 15 Output: [2, 4, 6, 8, 10, 14]



---

## 🧠 Approach

Brute-force enumeration with bounded exponential growth.

### Key Observations:
- Generate all values of the form `x^i + y^j` such that the result ≤ bound.
- Since `x^i` and `y^j` grow exponentially, we only need to iterate while `x^i ≤ bound` and `y^j ≤ bound`.
- If `x == 1` or `y == 1`, their powers remain constant (`1`), so we break early.
- Use a `HashSet<int>` to avoid duplicate entries.

**Use Cases:**  
- Enumerating combinations of exponential growth under a constraint.
- Generating unique values from two parameterized sources.

---

## 🧪 Code Implementation

```csharp
public class Solution {
    public IList<int> PowerfulIntegers(int x, int y, int bound) {
        HashSet<int> res = new HashSet<int>();

        for (int i = 0; i < 20 && Math.Pow(x, i) <= bound; i++) {
            for (int j = 0; j < 20 && Math.Pow(y, j) <= bound; j++) {
                int val = (int)Math.Pow(x, i) + (int)Math.Pow(y, j);
                if (val <= bound) res.Add(val);

                if (y == 1) break; // inner loop control
            }
            if (x == 1) break; // outer loop control
        }

        return res.ToList();
    }
}
```
---

## 🧠 Explanation

This solution uses a bounded brute-force strategy to generate all integers of the form `x^i + y^j` such that the result is ≤ `bound`.

### 🔧 Key Mechanics
- **Exponential growth**: Both `x^i` and `y^j` grow rapidly, so we cap iterations at 20 (log₂(10⁶) ≈ 20).
- **Loop control**:  
  - If `x == 1`, then `x^i` is always 1 → break outer loop.  
  - If `y == 1`, then `y^j` is always 1 → break inner loop.
- **Deduplication**: `HashSet<int>` ensures each result appears only once.

---

## 🧩 Pattern Summary: Bounded Power Sum


### Pattern: Bounded Power Sum

**Form:** x^i + y^j ≤ bound  
**Strategy:**  
- Iterate i and j while powers stay within bound  
- Use HashSet to store unique results  
- Break early for constant bases (x == 1 or y == 1)

**Use Cases:**  
- Generating combinations from two exponential sources  
- Deduplicated bounded enumeration  
- Tasks with exponential growth under linear constraints


---

## 📦 Engineering Notes

| 🔧 Component        | 🧠 Role                                                                 |
|---------------------|------------------------------------------------------------------------|
| `Math.Pow(x, i)`    | Generates exponential values for base `x` and exponent `i`.            |
| `Math.Pow(y, j)`    | Generates exponential values for base `y` and exponent `j`.            |
| `val ≤ bound`       | Ensures that the sum `x^i + y^j` does not exceed the given constraint. |
| `HashSet<int>`      | Stores results while automatically removing duplicates.                |
| `break logic`       | Optimizes loops when `x == 1` or `y == 1`, avoiding redundant powers.  |
| `res.ToList()`      | Converts the set into a list for final output format.                  |

---

## ✅ Final Insight

This solution isn’t just brute-force — it’s a **controlled combinatorial generator**.

You’ve wrapped exponential logic in a bounded, reusable pattern that:
- Handles edge cases gracefully (`x == 1`, `y == 1`)
- Avoids duplication with clean data structures
- Limits iteration via exponential growth awareness

It’s not just a solution — it’s a **template** for any task involving:
- Two exponential sources
- A bounding constraint
- Deduplicated output



---

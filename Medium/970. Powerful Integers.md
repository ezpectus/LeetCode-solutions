# ğŸ”¢ Powerful Integers â€” LeetCode 970

## ğŸ§© Problem Statement

Given three integers `x`, `y`, and `bound`, return a list of all **powerful integers** less than or equal to `bound`.

An integer is considered *powerful* if it can be expressed as:

```
x^i + y^j where i â‰¥ 0 and j â‰¥ 0
```

Each value should appear **at most once** in the result.

---

## ğŸ“¥ Input

- `x`: integer (1 â‰¤ x â‰¤ 100)
- `y`: integer (1 â‰¤ y â‰¤ 100)
- `bound`: integer (0 â‰¤ bound â‰¤ 10â¶)

---

## ğŸ“¤ Output

- A list of integers representing all powerful numbers â‰¤ `bound`, with no duplicates.
- Order does **not** matter.

---

## âœ… Examples

### Example 1
Input: x = 2, y = 3, bound = 10 Output: [2, 3, 4, 5, 7, 9, 10]



### Example 2
Input: x = 3, y = 5, bound = 15 Output: [2, 4, 6, 8, 10, 14]



---

## ğŸ§  Approach

Brute-force enumeration with bounded exponential growth.

### Key Observations:
- Generate all values of the form `x^i + y^j` such that the result â‰¤ bound.
- Since `x^i` and `y^j` grow exponentially, we only need to iterate while `x^i â‰¤ bound` and `y^j â‰¤ bound`.
- If `x == 1` or `y == 1`, their powers remain constant (`1`), so we break early.
- Use a `HashSet<int>` to avoid duplicate entries.

**Use Cases:**  
- Enumerating combinations of exponential growth under a constraint.
- Generating unique values from two parameterized sources.

---

## ğŸ§ª Code Implementation

```csharp
public class Solution {
    public IList<int> PowerfulIntegers(int x, int y, int bound) {
        HashSet<int> res = new HashSet<int>();

        for (int i = 0; i < 20 && Math.Pow(x, i) <= bound; i++) {
            for (int j = 0; j < 20 && Math.Pow(y, j) <= bound; j++) {
                int val = (int)Math.Pow(x, i) + (int)Math.Pow(y, j);
                if (val <= bound) res.Add(val);

                if (y == 1) break; // inner loop control
            }
            if (x == 1) break; // outer loop control
        }

        return res.ToList();
    }
}
```
---

## ğŸ§  Explanation

This solution uses a bounded brute-force strategy to generate all integers of the form `x^i + y^j` such that the result is â‰¤ `bound`.

### ğŸ”§ Key Mechanics
- **Exponential growth**: Both `x^i` and `y^j` grow rapidly, so we cap iterations at 20 (logâ‚‚(10â¶) â‰ˆ 20).
- **Loop control**:  
  - If `x == 1`, then `x^i` is always 1 â†’ break outer loop.  
  - If `y == 1`, then `y^j` is always 1 â†’ break inner loop.
- **Deduplication**: `HashSet<int>` ensures each result appears only once.

---

## ğŸ§© Pattern Summary: Bounded Power Sum


### Pattern: Bounded Power Sum

**Form:** x^i + y^j â‰¤ bound  
**Strategy:**  
- Iterate i and j while powers stay within bound  
- Use HashSet to store unique results  
- Break early for constant bases (x == 1 or y == 1)

**Use Cases:**  
- Generating combinations from two exponential sources  
- Deduplicated bounded enumeration  
- Tasks with exponential growth under linear constraints


---

## ğŸ“¦ Engineering Notes

| ğŸ”§ Component        | ğŸ§  Role                                                                 |
|---------------------|------------------------------------------------------------------------|
| `Math.Pow(x, i)`    | Generates exponential values for base `x` and exponent `i`.            |
| `Math.Pow(y, j)`    | Generates exponential values for base `y` and exponent `j`.            |
| `val â‰¤ bound`       | Ensures that the sum `x^i + y^j` does not exceed the given constraint. |
| `HashSet<int>`      | Stores results while automatically removing duplicates.                |
| `break logic`       | Optimizes loops when `x == 1` or `y == 1`, avoiding redundant powers.  |
| `res.ToList()`      | Converts the set into a list for final output format.                  |

---

## âœ… Final Insight

This solution isnâ€™t just brute-force â€” itâ€™s a **controlled combinatorial generator**.

Youâ€™ve wrapped exponential logic in a bounded, reusable pattern that:
- Handles edge cases gracefully (`x == 1`, `y == 1`)
- Avoids duplication with clean data structures
- Limits iteration via exponential growth awareness

Itâ€™s not just a solution â€” itâ€™s a **template** for any task involving:
- Two exponential sources
- A bounding constraint
- Deduplicated output



---

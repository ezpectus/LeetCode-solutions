# üÜî 3092. Most Frequent IDs

## üß© Problem Statement

You are given two integer arrays `nums` and `freq`, both of length `n`.  
Each `nums[i]` represents an ID, and `freq[i]` tells how many times that ID is added or removed at step `i`.

- If `freq[i] > 0`: add `freq[i]` copies of `nums[i]` to the collection  
- If `freq[i] < 0`: remove `-freq[i]` copies of `nums[i]` from the collection  

Return an array `ans` of length `n`, where `ans[i]` is the count of the most frequent ID in the collection after step `i`.  
If the collection is empty at any step, `ans[i] = 0`.

---

## üîç Example 1

```txt
Input:  nums = [2,3,2,1], freq = [3,2,-3,1]  
Output: [3,3,2,2]
```

Explanation:
Step 0: {2: 3} ‚Üí max freq = 3

Step 1: {2: 3, 3: 2} ‚Üí max freq = 3

Step 2: {3: 2} ‚Üí max freq = 2

Step 3: {3: 2, 1: 1} ‚Üí max freq = 2

## üí° Intuition
We need to track the frequency of each ID dynamically and efficiently retrieve the maximum frequency after each step.

## üîß Key ideas:
- Use a Dictionary<long, long> to store current frequencies of each ID

- Use a max-heap (PriorityQueue) to track the most frequent ID

- After each update, peek the heap until the top matches the current frequency in the dictionary (to avoid stale entries)
---

## üõ†Ô∏è Approach
Initialize:

- dict: maps ID ‚Üí current frequency
- pq: max-heap storing (ID, frequency)
- ans: result list
```
For each step i:

Update dict[nums[i]] by adding freq[i]

Push (nums[i], dict[nums[i]]) into the heap

Peek the heap until the top frequency matches the current frequency in dict

Add that frequency to ans
```

## üì¶ Code (C#)
```csharp
public class Solution {
    public long[] MostFrequentIDs(int[] nums, int[] freq) {
         List<long> ans = new List<long>();
        int n = nums.Length;
        PriorityQueue<long,long> pq = new PriorityQueue<long,long>(Comparer<long>.Create((x,y)=>y.CompareTo(x)));
        Dictionary<long,long> dict = new Dictionary<long,long>();


     for(int i =0; i < n;i++){
        if(dict.ContainsKey(nums[i])){
            dict[nums[i]]+= freq[i];
        }else{
             dict[nums[i]] = freq[i];
         }

         pq.Enqueue(nums[i], dict[nums[i]]);


         while(true){
            pq.TryPeek(out long val, out long ptval);

            if(ptval == dict[val]){
                ans.Add(ptval);
                break;
            } else{
                pq.Dequeue();
            }
         }
     }

     return ans.ToArray();

    }
}
```
## ‚è±Ô∏è Time & Space Complexity

- Time Complexity	O(n log n) ‚Äî heap operations per step
- Space Complexity	O(n) ‚Äî for dictionary and heap


---

# 1881. Maximum Value after Insertion  
*O(n) — Optimal Greedy Insertion Point Search*

---

## Problem Statement

- You are given a very large integer `n` as a string (length ≤ 10⁵), and a digit `x` (1 ≤ x ≤ 9).
- You can insert the digit `x` **exactly once** anywhere in the decimal representation of `n` (but **not** to the left of the negative sign if `n` is negative).
- Goal: maximize the numerical value of the resulting number after insertion.
- Return the resulting string.

---

## Core Idea — Greedy: Insert at the Leftmost Position That Maximizes Value

**Key insight**:
- To maximize the number → we want to insert `x` as **left as possible**, but only where it actually increases the value (or keeps it maximal).
- We compare digit-by-digit from left to right:
  - If we see a digit in `n` that is **smaller** than `x` → inserting `x` before it makes the number larger (because higher digit at higher position).
  - For **positive** numbers: insert `x` at the **first position** where the current digit < x
  - For **negative** numbers: we want to make the number **less negative** (closer to zero), so insert `x` at the **first position** where current digit > x (to make the leftmost digit smaller)
  - If no such position → insert at the end

**Rules**:
- If `n` positive (no '-'):
  - Find the leftmost position where digit < x → insert before it
  - If no such → insert at the end
- If `n` negative (starts with '-'):
  - Find the leftmost position (after '-') where digit > x → insert before it
  - If no such → insert at the end (before the end, to make it less negative)
- Never insert before the '-' sign

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public string MaxValue(string n, int x) {
        char digit = (char)('0' + x);
        int len = n.Length;

        // Case 1: Positive number (no leading '-')
        if (n[0] != '-') {
            for (int i = 0; i < len; i++) {
                if (n[i] < digit) {
                    // Insert before the first smaller digit
                    return n.Substring(0, i) + digit + n.Substring(i);
                }
            }
            // If all digits >= x → append at the end
            return n + digit;
        }

        // Case 2: Negative number (starts with '-')
        for (int i = 1; i < len; i++) { // start from 1 (skip '-')
            if (n[i] > digit) {
                // Insert before the first larger digit (makes number less negative)
                return n.Substring(0, i) + digit + n.Substring(i);
            }
        }
        // If all digits <= x → append at the end (still makes it less negative)
        return n + digit;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass through the string (worst case: scan the entire string once) |
| **Space Complexity**  | **O(n)**      | Building the new string in C# (strings are immutable, so concatenation creates new string) |

**Optimal** — linear time, perfect for n ≤ 10⁵ constraints.

---

## Why This Works — Example Walkthrough

**Example 1**: `n = "99"`, `x = 9`

- Positive number
- First digit '9' < 9? No
- Second digit '9' < 9? No
- No position where digit < 9 → append at the end → "999" → correct

**Example 2**: `n = "-13"`, `x = 2`

- Negative number (starts with '-')
- Skip '-' → start from position 1 ('1')
- '1' > 2? No
- Next digit '3' > 2? Yes → insert '2' before '3' → "-123" → correct  
  (among options: -213, -123, -132 → -123 is the largest)

**Correct** — the greedy rule maximizes the numerical value:

- **Positive numbers**: insert `x` as left as possible before the first digit that is **smaller** than `x` (or append if none)
- **Negative numbers**: insert `x` as left as possible before the first digit that is **larger** than `x` (or append if none) — this makes the number **less negative** (closer to zero)

Single left-to-right scan finds the optimal insertion point instantly.

---

## Pitfalls & Edge Cases

- **n = "1"**, `x = 2` → "21" (append) — inserting before gives "21" (same), but rule says append → correct
- **n = "-9"**, `x = 1` → "-19" (insert before 9) → less negative than "-91" → correct
- **All digits equal** → positive: append → e.g. "999" + 9 = "9999"  
  negative: append → e.g. "-999" + 1 = "-9991" (less negative than inserting earlier)
- **Leading zeros in negative** → allowed (e.g. "-001" + 5 → "-0051" or "-0510" etc. — rule inserts optimally)
- **n length = 10⁵** → O(n) single pass → very fast

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple greedy insertion** problem:

- **Positive n** (no leading '-'):  
  Insert `x` at the **leftmost** position where the current digit is **< x**  
  (or append at the end if no such position)

- **Negative n** (starts with '-'):  
  Insert `x` at the **leftmost** position (after '-') where the current digit is **> x**  
  (or append at the end if no such position)

- Never insert before the '-' sign
- Single linear pass finds the optimal position → insert there using string concatenation/substring

**Pure, clean, optimal** — linear time greedy choice that maximizes the numerical value after exactly one digit insertion.

---

# 2261. K Divisible Elements Subarrays — Architectural Brute + HashSet Solution  
*O(n²) — Subarray Counting with Uniqueness*

---

## Problem Summary

Given an array `nums` of length `n ≤ 200`, and integers `k`, `p`:

Count the number of **distinct subarrays** such that:

- The subarray contains **at most `k` elements divisible by `p`**
- Subarrays are considered **distinct** if they differ in length or at least one element

Return the count of such subarrays.

---

## Core Idea

**Constraints are small (`n ≤ 200`)** → we can afford **O(n²)** brute force.

**Strategy**:

- Enumerate **all possible subarrays** `nums[i..j]`
- Count how many elements in it are divisible by `p`
- If count ≤ `k` → this subarray is valid
- Use a **HashSet** to store **unique subarrays** (by content**
- Return the size of the set

---

## Full Implementation (C#)

```csharp
public class Solution 
{
    public int CountDistinct(int[] nums, int k, int p) 
    {
        int n = nums.Length;
        HashSet<string> seen = new HashSet<string>();

        for (int i = 0; i < n; i++) 
        {
            int divCount = 0;
            var subarray = new List<int>();

            for (int j = i; j < n; j++) 
            {
                subarray.Add(nums[j]);

                if (nums[j] % p == 0) 
                    divCount++;

                if (divCount > k) 
                    break; // no longer valid

                // Encode subarray as string for uniqueness
                string key = string.Join(",", subarray);
                seen.Add(key);
            }
        }

        return seen.Count;
    }
}
```

## Complexity

- **Time**: **O(n² · L)**  
  - `n²` subarrays  
  - String join cost ~ average subarray length `L`  
  - With `n ≤ 200` → ≤ `200³ = 8e6` operations → **instant**

- **Space**: **O(n² · L)** worst case (all subarrays distinct)

**Perfectly acceptable** for `n ≤ 200`

## Pitfalls

- Must **break early** when divisible count exceeds `k`
- Need **robust encoding** → `string.Join(",", subarray)` is simple and safe
- **Avoid duplicates** → `HashSet` is mandatory

## Edge Cases

- All elements divisible by `p` → only subarrays of length ≤ `k`
- `k = 0` → only subarrays with **no** elements divisible by `p`
- Single element array → answer = `1` (if valid)
- All elements same → many identical subarrays → `HashSet` deduplicates

## Sanity Checks

- Input: `nums=[2,3,3,2,2]`, `k=2`, `p=2` → Output: `11`
- Input: `nums=[1,2,3,4]`, `k=4`, `p=1` → Output: `10`

## Key Takeaway

This is a **brute force + HashSet uniqueness** problem:

- Enumerate all subarrays
- Track divisible count
- Store valid subarrays in set
- Return set size
**Efficient enough for `n ≤ 200`**, clean **O(n²)** solution.

---

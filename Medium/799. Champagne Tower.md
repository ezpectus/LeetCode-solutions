# 799. Champagne Tower

---

## Problem Restatement
We have a pyramid of glasses:
- Row 0 has 1 glass.
- Row 1 has 2 glasses.
- Row 2 has 3 glasses.
- … up to row 100.

Each glass holds **1 cup** of champagne.  
When a glass overflows, the excess is split equally between the two glasses directly below it.  
We pour `poured` cups into the top glass `(0,0)`.  

We need to return how full the glass `(query_row, query_glass)` is.

---

## Formula and Flow
Let `dp[row][col]` = amount of champagne in glass `(row, col)` before capping at 1.

1. Initialization:
   ```dp[0][0] = poured```
   
2. Transition:
For each glass `(i, j)`:
```
overflow = max(0, dp[i][j] - 1)
dp[i+1][j] += overflow / 2
dp[i+1][j+1] += overflow / 2
```

3. Answer:
```result = min(1, dp[query_row][query_glass])```

---

## Code (C#)
```csharp
public class Solution {
    public double ChampagneTower(int poured, int query_row, int query_glass) {
        var row = new double[1];
        row[0] = poured;

        for(int i =0;i < query_row;i++){
            var next = new double[i+2];

            for(int j =0; j < row.Length;j++){
                var overflow = Math.Max(0,row[j] - 1.0);
                if(overflow > 0){
                    next[j] += overflow/ 2.0;
                    next[j+1] += overflow/2.0;
                }
            }
            row = next;
        }
   return Math.Min(1.0, row[query_glass]);
    }
}
```



## Complexity
- **Time:** O(query_row²), because we simulate each row step by step until the target row.  
- **Space:** O(query_row), since we only keep the current row in memory.  

---

## Example Walkthrough
**Input:** `poured = 4, query_row = 2, query_glass = 1`

- **Row 0:** `[4]` → overflow = 3 → passes 1.5 down left and right.  
- **Row 1:** `[1.5, 1.5]` → each overflows 0.5 → passes 0.25 down left and right.  
- **Row 2:** `[0.25, 1.0, 0.25]`.  
- **Answer:** `min(1, dp[2][1]) = 1.0`. ✅  

---

## Conclusion
The algorithm is a **dynamic simulation**:
- Track overflow row by row.  
- Distribute excess equally to the two children.  
- Cap each glass at 1 when returning the result.  

This ensures correctness and runs efficiently for up to 100 rows.  


---





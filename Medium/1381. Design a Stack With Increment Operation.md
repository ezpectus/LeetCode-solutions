# 1381. Design a Stack With Increment Operation — Architectural Lazy Increment with Array  
*O(1) amortized — Optimal Array-Based Stack with Deferred Increments*

---

## Problem Statement

Design stack with:
- `push(x)` — add if not full
- `pop()` — remove top or -1 if empty
- `increment(k, val)` — add `val` to bottom `k` elements (or all if <k)

maxSize ≤ 1000, at most 1000 calls per method.

---

## Core Idea — Lazy Increment via Auxiliary Array

**Key insight**:
- Direct increment → O(k) time → too slow if k large and frequent
- Use **lazy propagation**:
  - Store stack in array `stk[]`
  - Use `inc[]` where `inc[i]` = value to add to element at position i when popped
- `push`: add to top
- `pop`: return top + inc[top] → reset inc[top]
- `increment(k, val)`: add `val` to `inc[0..min(k-1, size-1)]`

**Why**:
- All operations **O(1)** amortized
- Increment deferred until pop

---

##  Implementation (C#)

```csharp
public class CustomStack {
    private int[] stk;
    private int[] inc;
    private int top;
    private int maxSize;

    public CustomStack(int maxSize)  {
        this.maxSize = maxSize;
        stk = new int[maxSize];
        inc = new int[maxSize];
        top = -1;
    }
    
    public void Push(int x) {
        if (top + 1 < maxSize)   stk[++top] = x;
        
    }
    
    public int Pop() {
        if (top == -1) return -1;

        int res = stk[top] + inc[top];
        if (top > 0)  inc[top - 1] += inc[top]; // propagate to below
        
        inc[top] = 0;
        top--;
        return res;
    }
    
    public void Increment(int k, int val) {
        if (top >= 0) {
            int idx = Math.Min(k - 1, top);
            inc[idx] += val;
        }
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(1) amortized**    | Each increment propagated once on pop          |
| **Space Complexity**  | **O(maxSize)**        | Two arrays of size maxSize                     |

**Optimal** — constant time per operation.

---

## Why This Works — Example Walkthrough

**Input**: `maxSize=3`, operations as in example

- `push(1)` → stk=[1], top=0
- `push(2)` → stk=[1,2], top=1
- `pop()` → 2 + 0 = **2**, inc[0] += 0
- `push(2)` → stk=[1,2], top=1
- `push(3)` → stk=[1,2,3], top=2
- `push(4)` → ignored (full)
- `increment(5,100)` → inc[2] += 100
- `increment(2,100)` → inc[1] += 100
- `pop()` → 3 + 100 = **103**, inc[1] += 100 → inc[1]=200
- `pop()` → 2 + 200 = **202**, inc[0] += 200
- `pop()` → 1 + 200 = **201**
- `pop()` → **-1**

**Correct** — matches expected output.

The lazy propagation ensures increments are applied only when elements are popped, avoiding expensive updates during `increment`.

---

## Pitfalls & Edge Cases

- **Full stack** → `push` ignored
- **Empty stack** → `pop` returns -1
- **k > current size** → increment only existing elements (up to top)
- **Increment propagation** → only downward on pop (to next lower element)
- **Multiple increments** → correctly accumulated in `inc[]`

All handled perfectly.

---

## Key Takeaway

This is a **beautifully lazy** stack design:

- **`inc[]` array** → deferred increments
- **Propagate on pop** → O(1) amortized
- **Simple and efficient** → no heavy operations during increment
**Pure, clean, optimal** — perfect incrementable stack.

---

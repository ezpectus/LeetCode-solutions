# 2178. Maximum Split of Positive Even Integers  
*O(sqrt(finalSum)) — Greedy Largest-to-Smallest Even Numbers*

---

## Problem Statement

Given a positive integer `finalSum`, split it into the **maximum number** of **unique positive even integers**.

Return any such list of integers (in any order).  
If impossible — return an empty list.

**Examples**:

**Example 1**: finalSum = 12  
Output: **[2,4,6]**  
(3 numbers) — maximum possible

**Example 2**: finalSum = 7  
Output: **[]**  
(odd number — impossible to sum even numbers to odd)

**Example 3**: finalSum = 28  
Output: **[6,8,2,12]**  
(4 numbers) — maximum possible

**Constraints**:
- 1 ≤ finalSum ≤ 10¹⁰

---

## Core Idea — Greedy: Take Smallest Possible Even Numbers Except Last One

**Key observations**:
- All numbers must be **positive even** → 2, 4, 6, 8, ...
- Sum must be exactly `finalSum`
- To maximize count → use as many **small even numbers** as possible
- But they must be **distinct**
- The optimal way: take 2, 4, 6, 8, ... until the last number
- Adjust the **last number** to make the sum exact (must be even and not used before)

**Algorithm**:
1. If `finalSum` is **odd** → impossible → return []
2. Start with the smallest even numbers: 2, 4, 6, ...
3. Keep adding the next even number while:
   - remaining sum ≥ next even number
   - remaining sum - next even number is even (for the last piece)
4. When we can't add the next small one → put the remaining to the **last number**
5. Make sure last number is even, positive, and not already used

**Smart greedy way**:
- Take consecutive even numbers from 2 up to some point
- Use the largest possible last number to maximize count
- But to maximize count → minimize the numbers used → take smallest possible

**Best approach**:
- Try to use 2, 4, 6, ..., up to the largest even < finalSum
- If remaining is even and not used → add it
- If remaining is used or odd → remove the last used number and add it to remaining

But simpler & correct greedy:
- Start from smallest: keep adding next even number while remaining allows
- At the end, if remaining is even and not used → good
- If conflict → backtrack one step and merge last two

But most elegant:
- Use all smallest evens except the last one
- Last one = finalSum - sum_of_previous
- If last one is even, positive, and not in previous → good
- Else → impossible for this count → try smaller count

But efficient way (since n ≤ 10¹⁰, but count ≤ ~10⁵):
- Greedily take from smallest even numbers until can't
- Adjust only if last number conflicts

**Fast & clean solution**:
- If finalSum odd → []
- Initialize result list
- long current = 2
- while current ≤ finalSum
  - if finalSum - current is even and > 0 and != current
    - add current to result
    - finalSum -= current
  - current += 2
- If finalSum > 0 and even → add finalSum (it will be distinct)
- Return result if sum correct, else []

**Best solution** (greedy from small):

```csharp
public class Solution{
    public IList<long> MaximumEvenSplit(long finalSum) {
        if (finalSum % 2 != 0) return new List<long>();

        List<long> result = new List<long>();
        long current = 2;

        while (current <= finalSum){
            result.Add(current);
            finalSum -= current;
            current += 2;
        }

        // If remaining > 0, it must be even (because total was even, we subtracted even numbers)
        // But it might equal some previous number — merge with last
        if (finalSum > 0){
            // Merge remaining into the last number
            result[^1] += finalSum;
        }

        return result;
    }
}
```

## Complexity

| **Metric**            | **Value**              | **Notes**                                                                 |
|-----------------------|------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(√finalSum)**       | The loop adds even numbers 2, 4, 6, ..., up to roughly √finalSum<br>Number of iterations ≈ √(finalSum / 2) |
| **Space Complexity**  | **O(√finalSum)**       | The result list stores up to ≈ √finalSum numbers (maximum possible count) |

**Optimal** — the theoretical maximum number of distinct positive even integers summing to N is ≈ √(2N), so this is asymptotically optimal in both time and space. Extremely fast even for finalSum = 10¹⁰.

---

## Why This Works — Example Walkthrough

**Example 1**: finalSum = 12

- current = 2 → add 2, remaining = 10
- current = 4 → add 4, remaining = 6
- current = 6 → 6×2 = 12 == remaining → stop (don't add 6 yet)
- Add last piece = 6

Result: **[2, 4, 6]** → sum = 12, 3 parts, all unique → correct

**Example 3**: finalSum = 28

- current = 2 → add 2, remaining = 26
- current = 4 → add 4, remaining = 22
- current = 6 → add 6, remaining = 16
- current = 8 → 8×2 = 16 == remaining → stop
- Add last piece = 16

Result: **[2, 4, 6, 16]** → sum = 28, 4 parts, all unique → correct

**Correct** —  
By greedily taking the smallest possible even numbers (2, 4, 6, ...) until the remaining sum is too small to continue safely, we leave the largest possible even number for the end.  
This guarantees:
- All numbers are distinct
- The last number is always larger than the previous one (≥ current + 2)
- We achieve the **maximum possible count** of terms

---

## Key Takeaway

This is a **beautiful greedy even-split** problem:

* If finalSum is **odd** → impossible → return empty list
* Greedily take the **smallest possible even numbers** (2, 4, 6, ...) while the next number would not exceed half of the remaining sum
* Stop when current × 2 > remaining
* Put the **remaining value** as the last number (it will be even and strictly larger than the last added number)
* This gives the **maximum number** of distinct positive even integers summing to finalSum

**Pure, clean, optimal** — O(√N) time, O(√N) space, extremely fast even for N = 10¹⁰, very intuitive, and mathematically elegant.

---

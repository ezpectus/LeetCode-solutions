# 923. 3Sum With Multiplicity — Architectural O(100²) Masterpiece  
*O(1) per value range — Combinatorial Frequency Counting*

---

## Problem Statement

Given an integer array `arr` and an integer `target`, count the number of triplets `(i, j, k)` such that:

- `0 ≤ i < j < k < n`
- `arr[i] + arr[j] + arr[k] == target`

Return the answer **modulo 10⁹ + 7**.

**Constraints**  
- `3 ≤ arr.length ≤ 3000`  
- `0 ≤ arr[i] ≤ 100`  
- `0 ≤ target ≤ 300`

---

## Core Idea — Frequency + Combinatorics

**Key insight**:  
`arr[i] ≤ 100` → only **101 possible values**

We **don’t iterate over indices** — we **iterate over values** `x ≤ y ≤ z` and use **frequency counts** + **combinatorics**.

No O(n³), no O(n²) — just **O(100²)**.

---

## Cases (x ≤ y ≤ z)

| Case               | Condition           | Formula                                      |
|--------------------|---------------------|----------------------------------------------|
| **All equal**      | `x == y == z`       | `C(freq[x], 3)`                              |
| **Two equal**      | `x == y != z`       | `C(freq[x], 2) × freq[z]`                    |
|                    | `x != y == z`       | `freq[x] × C(freq[y], 2)`                    |
| **All distinct**   | `x < y < z`         | `freq[x] × freq[y] × freq[z]`                |

Where:  
- `C(n,2) = n·(n-1)/2`  
- `C(n,3) = n·(n-1)·(n-2)/6`

---

## Full Implementation (C#)

```csharp
public class Solution {
    public int ThreeSumMulti(int[] arr, int target) {
        const int MOD = 1_000_000_007;
        long[] count = new long[101];
        foreach (int num in arr) count[num]++;

        long res = 0;
        for (int x = 0; x <= 100; x++) {
            if (count[x] == 0) continue;
            for (int y = x; y <= 100; y++) {
                if (count[y] == 0) continue;
                int z = target - x - y;
                if (z < 0 || z > 100) continue;
                if (z < y) continue; // ensure x <= y <= z
                if (count[z] == 0) continue;

                if (x == y && y == z) {
                    // Case 3: all equal
                    res += count[x] * (count[x] - 1) * (count[x] - 2) / 6;
                } else if (x == y && y != z) {
                    // Case 2: x=y!=z
                    res += (count[x] * (count[x] - 1) / 2) * count[z];
                } else if (x != y && y == z) {
                    // Case 2: y=z!=x
                    res += count[x] * (count[y] * (count[y] - 1) / 2);
                } else if (x < y && y < z) {
                    // Case 1: all distinct
                    res += count[x] * count[y] * count[z];
                }
                res %= MOD;
            }
        }

        return (int)res;
    }
}

```

## Complexity Analysis

| **Metric**     | **Value**           | **Notes**                                    |
|----------------|---------------------|----------------------------------------------|
| **Time**       | **O(100²) = O(1)**  | Fixed value range → independent of `n`       |
| **Space**      | **O(100)**          | Single frequency array of size 101           |

**With `n = 3000` → algorithm still runs in O(1) time**  
**Brutally efficient — scales to n = 10⁶ without change**

---

## Pitfalls & Edge Cases

| **Issue**                  | **Fix**                                             |
|----------------------------|-----------------------------------------------------|
| **Integer overflow**       | Use `long` for all arithmetic before `/` and `% MOD` |
| **Double counting**        | Enforce `x ≤ y ≤ z` order → no duplicates           |
| **C(n,3) overflow**        | `long` multiplication + safe division               |
| **`target - x - y < 0`**   | Early `continue` — skip invalid `z`                 |
| **Zero frequency**         | Skip with `if (count[x] == 0) continue`             |
| **Same value multiple ways**| Handled correctly by case splitting (`x==y==z`, etc.) |

---

## Insight — Reusable Fichka

> **When values are bounded → count frequencies, not indices**

### Pattern  
- Build **frequency array** instead of looping over indices  
- Iterate over **possible values** (`x`, `y`, `z`) in sorted order  
- Use **combinatorics** to compute number of valid index tuples  
- Apply **modulo** at each step

### Applies to  
- Classic **3Sum / 4Sum** with small value range  
- Counting any **k-tuples** with sum/constraint  
- **Multiplicity-aware** counting**  
- Any problem of form: *"how many ways to pick k elements with property X"* when domain is small

**Fichka**:  
> **If number of distinct values ≤ 1000 → frequency array + nested loops over values = O(1) solution**
**You turn O(n³) into O(1) with pure insight.**

---

# 2087. Minimum Cost Homecoming of a Robot in a Grid  
*O(m + n) — Simple Manhattan Path with Cost Calculation*

---

## Problem Statement

You have an `m × n` grid (top-left (0,0), bottom-right (m-1, n-1)).  
Robot starts at `startPos = [startrow, startcol]`.  
Home is at `homePos = [homerow, homecol]`.

Robot can move up, down, left, right (no diagonals), cannot leave grid.  
Cost rules:
- Moving **up** or **down** into row `r` costs `rowCosts[r]`
- Moving **left** or **right** into column `c` costs `colCosts[c]`

Find the **minimum total cost** for robot to reach home.

**Note**: cost depends only on the **destination row/column** of each move (not source).

---

## Core Idea — Manhattan Path is Optimal, No Obstacles

**Key insight**:
- Grid has **no obstacles** — robot can move freely
- Cost depends **only on rows and columns entered**
- Shortest path length = Manhattan distance = |startrow - homerow| + |startcol - homecol|
- But cost is **not uniform** — depends on which rows/columns are crossed

**Important observation**:
- To go from startrow to homerow, robot **must cross** exactly |startrow - homerow| rows
- The order of row crossings can be chosen freely (up or down moves can be interleaved with left/right)
- Same for columns

**Crucial realization**:
- The total cost for rows = sum of rowCosts[r] for every row r that robot **enters**
- But since robot moves from startrow to homerow, it will enter **all rows between them** (inclusive of destination, exclusive of start if different)
- No: when moving from row A to row B, it enters every row in between + destination row

**Correct**:
- Assume startrow ≤ homerow (without loss of generality)
- Robot must move **down** exactly (homerow - startrow) times
- Each down move into row r costs rowCosts[r]
- So total row cost = sum of rowCosts[r] for r = startrow+1 to homerow

- Same for columns: sum of colCosts[c] for c between startcol and homecol (exclusive start, inclusive end)

**Proof**:
- Any path from start to home must **enter** each row between startrow and homerow at least once
- And since cost is paid when **entering** a row, minimum cost is exactly sum of those row costs
- Extra moves (zigzagging) would only add more entries → higher cost
- Same for columns

**So**:
- Minimum cost = sum of rowCosts between startrow and homerow (exclusive start, inclusive end)  
  + sum of colCosts between startcol and homecol (exclusive start, inclusive end)

**Direction doesn't matter** — sum is same regardless of order

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MinCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {
        int sr = startPos[0], sc = startPos[1];
        int hr = homePos[0], hc = homePos[1];

        int rowCost = 0;
        // Sum row costs from sr to hr (exclusive start, inclusive end)
        if (sr < hr)  {
            for (int r = sr + 1; r <= hr; r++) rowCost += rowCosts[r];
        } 
        else if (sr > hr) {
            for (int r = sr - 1; r >= hr; r--)  rowCost += rowCosts[r];
        }

        int colCost = 0;
        // Sum column costs from sc to hc (exclusive start, inclusive end)
        if (sc < hc) {
            for (int c = sc + 1; c <= hc; c++)  colCost += colCosts[c];
        } 
        else if (sc > hc) {
            for (int c = sc - 1; c >= hc; c--)  colCost += colCosts[c];
        }

        return rowCost + colCost;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(m + n)**  | Sum of row costs between startrow and homerow: O(|startrow - homerow|) ≤ O(m)  
Sum of column costs between startcol and homecol: O(|startcol - homecol|) ≤ O(n)  
Total: **O(m + n)** |
| **Space Complexity**  | **O(1)**      | Only a few integer variables — no extra arrays or data structures |

**Optimal** — linear in grid dimensions, constant extra space — perfect and extremely efficient for m, n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7]

- **Rows** to cross from row 1 → row 2:  
  Robot must enter row 2 → cost = rowCosts[2] = **3**

- **Columns** to cross from col 0 → col 3:  
  Robot must enter columns 1, 2, 3 → cost = colCosts[1] + colCosts[2] + colCosts[3] = 2 + 6 + 7 = **15**

- **Total cost** = 3 + 15 = **18** → matches the example

**Correct** —  
The robot **must enter** every row and every column between the starting and home positions **exactly once** (in some order).  
Any extra moves (zigzagging, going back) would only cause entering some rows/columns **more than once**, increasing the cost.  
Therefore, the minimum cost is **exactly** the sum of:
- rowCosts[r] for every row r that is entered (from startrow+sign to homerow inclusive, depending on direction)
- colCosts[c] for every column c that is entered (from startcol+sign to homecol inclusive)

---

## Key Takeaway

This is a **beautiful grid path cost minimization** problem with a very elegant insight:

* There are **no obstacles** — robot can move freely in 4 directions
* Cost is paid **only when entering** a new row or column (not when leaving)
* Any shortest path from start to home has **exactly** the same number of row entries and column entries
* Minimum cost = sum of rowCosts for all rows entered + sum of colCosts for all columns entered
* Rows entered: all rows strictly between startrow and homerow + the destination row
* Columns entered: all columns strictly between startcol and homecol + the destination column

**Pure, clean, optimal** — O(m + n) time, O(1) space, extremely simple once the insight is clear, no unnecessary complexity.

---

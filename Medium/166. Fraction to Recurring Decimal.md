## Problem: 166. Fraction to Recurring Decimal

### ğŸ“œ Description
Given two integers `numerator` and `denominator`, return their division as a string.  
If the fractional part is repeating, enclose the repeating part in parentheses.

### ğŸ§© Constraints
- `-2^31 <= numerator, denominator <= 2^31 - 1`
- `denominator != 0`
- Output string length < 10^4

---

## ğŸ” Observations from Constraints
- Large range â†’ must use `long` to avoid overflow
- Repeating decimals â†’ implies cycle detection
- Output is a **string**, not a float â†’ precision must be manual
- If any remainder repeats â†’ start of cycle

---

## ğŸ’¡ Idea
- Handle sign first using XOR
- Use `long` for safe division
- Track remainders using a `Map<remainder â†’ position>` to detect cycles
- If remainder repeats â†’ insert `(` at first occurrence, append `)` at end
- Build result using `StringBuilder` for performance

---

## ğŸ§± Code (C#)

```csharp
public class Solution {
    public string FractionToDecimal(int numerator, int denominator) {
        if (numerator == 0) return "0";

        StringBuilder result = new StringBuilder();

        if ((numerator < 0) ^ (denominator < 0)) {
            result.Append("-");
        }

        long num = Math.Abs((long)numerator);
        long den = Math.Abs((long)denominator);

        result.Append(num / den);
        long remainder = num % den;

        if (remainder == 0) return result.ToString();

        result.Append(".");
        Dictionary<long, int> map = new Dictionary<long, int>();

        while (remainder != 0) {
            if (map.ContainsKey(remainder)) {
                result.Insert(map[remainder], "(");
                result.Append(")");
                break;
            }

            map[remainder] = result.Length;
            remainder *= 10;
            result.Append(remainder / den);
            remainder %= den;
        }

        return result.ToString();
    }
}
```

## â±ï¸ Complexity

- Time: O(n) â€” where n is the number of unique remainders before cycle
- Space: O(n) â€” for storing remainder positions

## ğŸ§  Key Tricks

- XOR for sign detection â†’ clean and minimal
- Map<remainder â†’ index> â†’ cycle detection without recursion
- Insert() + Append() â†’ precise control over output

---

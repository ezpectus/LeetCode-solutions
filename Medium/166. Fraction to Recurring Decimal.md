## Problem: 166. Fraction to Recurring Decimal

### 📜 Description
Given two integers `numerator` and `denominator`, return their division as a string.  
If the fractional part is repeating, enclose the repeating part in parentheses.

### 🧩 Constraints
- `-2^31 <= numerator, denominator <= 2^31 - 1`
- `denominator != 0`
- Output string length < 10^4

---

## 🔍 Observations from Constraints
- Large range → must use `long` to avoid overflow
- Repeating decimals → implies cycle detection
- Output is a **string**, not a float → precision must be manual
- If any remainder repeats → start of cycle

---

## 💡 Idea
- Handle sign first using XOR
- Use `long` for safe division
- Track remainders using a `Map<remainder → position>` to detect cycles
- If remainder repeats → insert `(` at first occurrence, append `)` at end
- Build result using `StringBuilder` for performance

---

## 🧱 Code (C#)

```csharp
public class Solution {
    public string FractionToDecimal(int numerator, int denominator) {
        if (numerator == 0) return "0";

        StringBuilder result = new StringBuilder();

        if ((numerator < 0) ^ (denominator < 0)) {
            result.Append("-");
        }

        long num = Math.Abs((long)numerator);
        long den = Math.Abs((long)denominator);

        result.Append(num / den);
        long remainder = num % den;

        if (remainder == 0) return result.ToString();

        result.Append(".");
        Dictionary<long, int> map = new Dictionary<long, int>();

        while (remainder != 0) {
            if (map.ContainsKey(remainder)) {
                result.Insert(map[remainder], "(");
                result.Append(")");
                break;
            }

            map[remainder] = result.Length;
            remainder *= 10;
            result.Append(remainder / den);
            remainder %= den;
        }

        return result.ToString();
    }
}
```

## ⏱️ Complexity

- Time: O(n) — where n is the number of unique remainders before cycle
- Space: O(n) — for storing remainder positions

## 🧠 Key Tricks

- XOR for sign detection → clean and minimal
- Map<remainder → index> → cycle detection without recursion
- Insert() + Append() → precise control over output

---

# 222. Queens That Can Attack the King — Architectural 8-Directional Ray Casting  
*O(1) — Optimal Fixed-Size Board Scan*

---

## Problem Statement

- 8×8 chessboard.
- Multiple black **queens** at positions `queens[][]`
- One white **king** at `king[]`
- Return **list of queens** that can **directly attack** the king (same row, column, or diagonal).
- No blocking pieces — queens attack through empty board.
- Return in **any order**.

---

## Core Idea — 8-Directional Search from King

**Key observation**:
- A queen attacks the king if it lies on the **same row, column, or diagonal**.
- Since there are **no other pieces** on the board, only the **first queen** encountered in each direction can attack the king (any queens behind it are blocked by the first one).
- Instead of checking every queen against the king (O(q) time), we **start from the king's position** and scan in **all 8 possible directions**.

**Why this is optimal**:
- The board is fixed at 8×8 → at most 7 steps per direction → total at most 56 cell checks
- **O(1)** time — independent of the number of queens
- We find **exactly** the attacking queens (the closest one in each direction)

**Algorithm step by step**:
1. Mark all queen positions in a boolean matrix `hasQueen[8][8]` for O(1) lookup.
2. From the king's position `(kx, ky)`, launch **8 rays**:
   - Up, down, left, right
   - 4 diagonals
3. For each direction:
   - Move step by step: `nx = kx + dx`, `ny = ky + dy`
   - While within board bounds:
     - If a queen is found at `(nx, ny)` → add its coordinates → **stop** this ray (no need to continue)
     - Otherwise continue moving
4. Collect all found queens → return the list.

**Why we stop the ray**:
- Only the **nearest** queen in a given direction can attack the king.
- Any queens further along the same line are blocked by the first one (in chess, queens cannot pass through friendly pieces, and here other queens act as blockers).

**Result** — precise list of all attacking queens.


---

##  Implementation (C#)

```csharp
public class Solution {
    public IList<IList<int>> QueensAttacktheKing(int[][] queens, int[] king) {
        // Mark queen positions for O(1) lookup
        bool[,] hasQueen = new bool[8, 8];
        foreach (var q in queens) hasQueen[q[0], q[1]] = true;
        
        var res = new List<IList<int>>();
        int x = king[0], y = king[1];

        // 8 directions: {dx, dy}
        int[][] dirs = new int[][] {
            new int[] {-1, -1}, new int[] {-1, 0}, new int[] {-1, 1},
            new int[] {0, -1},                    new int[] {0, 1},
            new int[] {1, -1},  new int[] {1, 0},  new int[] {1, 1}
        };

        foreach (var d in dirs) {
            int dx = d[0], dy = d[1];
            int nx = x + dx, ny = y + dy;

            while (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
                if (hasQueen[nx, ny]) {
                    res.Add(new List<int> { nx, ny });
                    break; // only first queen in this direction
                }
                
                nx += dx;
                ny += dy;
            }
        }

        return res;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(1)**      | At most 8×7 = 56 steps (8 directions × max 7 cells) |
| **Space Complexity**  | **O(1)**      | Fixed 8×8 board + result list (max 8 queens)   |

**Optimal** — constant time due to fixed board size.

---

## Why This Works — Example Walkthrough

**Input**: `queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]]`, `king = [0,0]`

- From king position **(0,0)** we scan in all **8 directions**:
  - **Right** → (0,1) → queen at [0,1] → add **[0,1]**
  - **Down** → (1,0) → queen at [1,0] → add **[1,0]**
  - **Down-right diagonal** → (1,1) empty → (2,2) empty → (3,3) → queen at [3,3] → add **[3,3]**
  - Other directions (up, left, etc.) → out of bounds or no queen

**Result**: `[[0,1],[1,0],[3,3]]` — **correct**.

The key is: **only the first queen** in each direction can attack the king (others are blocked by the first one).

---

## Pitfalls & Edge Cases

- **King at corner/edge/center** → some directions are shorter or out of bounds — handled naturally
- **Multiple queens in one line** → only the **closest** (first encountered) attacks — we stop after finding one
- **Queen at king's position** → impossible (positions are unique per constraints)
- **No queens attacking** → return empty list
- **Queen directly adjacent** → correctly detected in one step

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** directional scan:

- **8 fixed directions** from the king's position
- **Ray casting** — move step by step until hitting a queen or board edge
- **Stop at first queen** per direction — simulates line-of-sight attack
- **O(1)** board → no need for complex simulation

**Pure, clean, optimal** — perfect queen attack detection on fixed-size chessboard.

---

# üîó LeetCode 886 ‚Äî Possible Bipartition (C#)

## üß© Problem Overview

Given `n` people labeled from `1` to `n`, and a list of `dislikes` pairs where `dislikes[i] = [a, b]` means person `a` dislikes person `b`, determine if it's possible to split everyone into **two groups** such that no pair of people who dislike each other are in the same group.

### Constraints

- `1 <= n <= 2000`
- `0 <= dislikes.length <= 10‚Å¥`
- `1 <= ai < bi <= n`
- All pairs are unique

---

## üß† Core Idea

This is a classic **graph bipartition** problem:

- Treat each person as a node
- Treat each dislike pair as an undirected edge
- The goal is to check if the graph is **bipartite** ‚Äî i.e., can be colored with two colors such that no adjacent nodes share the same color

Approach:

- Build an adjacency list from the `dislikes` array
- Use **DFS** to color the graph with `1` and `-1`
- If any adjacent nodes have the same color ‚Üí return `false`

---

## ‚úÖ C# Implementation

```csharp
public class Solution {
    public bool PossibleBipartition(int n, int[][] dislikes) {
        List<int>[] graph = new List<int>[n + 1];
        for (int i = 1; i <= n; i++) {
            graph[i] = new List<int>();
        }

        foreach (var pair in dislikes) {
            graph[pair[0]].Add(pair[1]);
            graph[pair[1]].Add(pair[0]);
        }

        int[] color = new int[n + 1]; // 0 = unvisited, 1 / -1 = group

        for (int i = 1; i <= n; i++) {
            if (color[i] == 0 && !DFS(i, 1, graph, color)) return false;
        }

        return true;
    }

    private bool DFS(int node, int c, List<int>[] graph, int[] color) {
        color[node] = c;
        foreach (int neigh in graph[node]) {
            if (color[neigh] == c) return false;
            if (color[neigh] == 0 && !DFS(neigh, -c, graph, color)) return false;
        }
        return true;
    }
}
```

## ‚è± Time & Space Complexity

| Operation       | Time Complexity | Space Complexity | Description                          |
|-----------------|------------------|-------------------|--------------------------------------|
| Graph Build     | `O(E)`           | `O(N + E)`        | Build adjacency list from dislikes   |
| DFS Traversal   | `O(N + E)`       | `O(N)`            | Visit each node and edge once        |
| **Total**       | `O(N + E)`       | `O(N + E)`        | Linear in nodes and edges            |

Where:
- `N` = number of people  
- `E` = number of dislike pairs

---

## üß™ Example Execution

| Input                          | Output | Explanation                                  |
|--------------------------------|--------|----------------------------------------------|
| `n = 4`, `[[1,2],[1,3],[2,4]]` | `true` | Group1: `[1,4]`, Group2: `[2,3]`             |
| `n = 3`, `[[1,2],[1,3],[2,3]]` | `false`| Triangle of mutual dislikes ‚Äî not bipartite  |

All operations behave predictably and execute in constant time per node and edge.

---

## ‚úÖ Final Takeaways

- **Graph coloring** is the cleanest and most direct solution  
- **DFS** avoids extra structures like Union-Find  
- **Easily extendable** with BFS or iterative traversal  
- **Fully deterministic** and constant-space per node

---

# 423. Reconstruct Original Digits from English

---

## Problem Restatement
We are given a string `s` containing shuffled characters that represent digits 0–9 spelled out in English (`zero`, `one`, `two`, …, `nine`).  
We must reconstruct the original digits in ascending order.

---

## Key Idea
Each digit word has unique identifying letters:
- `z` → **zero (0)**  
- `w` → **two (2)**  
- `u` → **four (4)**  
- `x` → **six (6)**  
- `g` → **eight (8)**  

After removing those, we can deduce others:
- `o` → **one (1)** (after 0,2,4 removed)  
- `h` → **three (3)** (after 8 removed)  
- `f` → **five (5)** (after 4 removed)  
- `s` → **seven (7)** (after 6 removed)  
- `i` → **nine (9)** (after 5,6,8 removed)  

We count occurrences of these unique letters to determine digit frequencies.

---

## Code (C#)
```csharp
using System;
using System.Text;

public class Solution {
    public string OriginalDigits(string s) {
        int[] count = new int[10];
        foreach (char c in s) {
            switch (c) {
                case 'z': count[0]++; break; // zero
                case 'w': count[2]++; break; // two
                case 'u': count[4]++; break; // four
                case 'x': count[6]++; break; // six
                case 'g': count[8]++; break; // eight
                case 'o': count[1]++; break; // one (after 0,2,4)
                case 'h': count[3]++; break; // three (after 8)
                case 'f': count[5]++; break; // five (after 4)
                case 's': count[7]++; break; // seven (after 6)
                case 'i': count[9]++; break; // nine (after 5,6,8)
            }
        }

        // Adjust counts based on overlaps
        count[1] -= count[0] + count[2] + count[4];
        count[3] -= count[8];
        count[5] -= count[4];
        count[7] -= count[6];
        count[9] -= count[5] + count[6] + count[8];

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i <= 9; i++) {
            for (int j = 0; j < count[i]; j++) {
                sb.Append(i);
            }
        }
        return sb.ToString();
    }
}
```

## Time Complexity
- **Traversal:** Each character in the string is checked once.  
- **Counting adjustments:** Constant-time operations for overlaps.  
- **Reconstruction:** Iterating digits 0–9 is fixed.  
- **Overall:** **O(n)**, where n = length of string `s`.  

---

## Space Complexity
- **Digit counts:** Fixed-size array of length 10.  
- **No dynamic structures:** Only constant extra space used.  
- **Overall:** **O(1)**.  

---

## Example Walkthrough

### Example 1
**Input:** `"owoztneoer"`  
- `z` → count[0] = 1  
- `w` → count[2] = 1  
- `o` → count[1] = 2 initially, adjust later → 1  
- Final digits: `"012"` ✅  

---

### Example 2
**Input:** `"fviefuro"`  
- `u` → count[4] = 1  
- `f` → count[5] = 1 (after adjustment)  
- Final digits: `"45"` ✅  

---

## Why This Works
- **Unique letters** (`z`, `w`, `u`, `x`, `g`) directly identify certain digits.  
- **Adjustments** correct overlaps where letters appear in multiple digit words.  
- **Sorted reconstruction** ensures digits are output in ascending order.  

---

✅ **Conclusion**  
This is the **Unique Letter Counting Algorithm**.  
By leveraging unique identifiers and correcting overlaps, we reconstruct digits efficiently in **O(n)** time and **O(1)** space, producing the correct ascending sequence of digits.


---

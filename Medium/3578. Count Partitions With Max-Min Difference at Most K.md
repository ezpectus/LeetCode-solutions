# ğŸ§© **Problem**: Count Partitions With Max-Min Difference at Most K

---

### ğŸ“œ Description

You're given an integer array `nums` and an integer `k`.  
Your task is to count the number of ways to partition `nums` into one or more **non-empty contiguous segments** such that:

- In each segment, the difference between the **maximum and minimum** elements is **at most `k`**
- Return the total number of valid partitionings of the array
- Since the answer may be large, return it modulo `10â¹ + 7`

---

### ğŸ§  Solution Architecture

#### ğŸ”¹ Core Strategy

This is a **partition DP** problem with a dynamic constraint on each segment.  
We want to compute `dp[i]`: the number of ways to partition `nums[0..i-1]` such that each segment satisfies `max - min â‰¤ k`.

To do this efficiently:

- Use a **sliding window** to maintain the longest valid segment ending at position `right`
- Use **monotonic deques** to track the `max` and `min` values in the current window
- Use a **prefix sum array** to quickly sum all `dp[j]` where `j âˆˆ [left, right]` â€” i.e., all valid segment starts

---

#### ğŸ”¹ Data Structures

- `int[] dp` â€” stores the number of ways to partition `nums[0..i-1]`
- `int[] prefix` â€” prefix sum of `dp`, so that `dp[i] = sum(dp[j])` for `j âˆˆ [left, right]`
- `LinkedList<int> maxDeque` â€” maintains decreasing order of values for max tracking
- `LinkedList<int> minDeque` â€” maintains increasing order of values for min tracking

---

### ğŸ§© Final Pattern

```csharp
public class Solution {
    public int CountPartitions(int[] nums, int k) {
        int n = nums.Length;
        int[] dp = new int[n + 1];
        int[] prefix = new int[n + 2];
        int MOD = 1_000_000_007;

        dp[0] = 1;
        prefix[1] = 1;
        int left = 0;

        LinkedList<int> maxDeque = new LinkedList<int>();
        LinkedList<int> minDeque = new LinkedList<int>();

        for (int right = 0; right < n; right++) {
            while (maxDeque.Count > 0 && nums[maxDeque.Last.Value] < nums[right])
                maxDeque.RemoveLast();
            maxDeque.AddLast(right);

            while (minDeque.Count > 0 && nums[minDeque.Last.Value] > nums[right])
                minDeque.RemoveLast();
            minDeque.AddLast(right);

            while (nums[maxDeque.First.Value] - nums[minDeque.First.Value] > k) {
                if (maxDeque.First.Value == left) maxDeque.RemoveFirst();
                if (minDeque.First.Value == left) minDeque.RemoveFirst();
                left++;
            }

            dp[right + 1] = (prefix[right + 1] - prefix[left] + MOD) % MOD;
            prefix[right + 2] = (prefix[right + 1] + dp[right + 1]) % MOD;
        }

        return dp[n];
    }
}

```
## âš ï¸ Common Mistakes to Avoid

### âŒ Using `dp[right + 1] = dp[left]`
This only accounts for one valid segment start.  
You must sum over **all valid `j âˆˆ [left, right]`**, since each `dp[j]` represents a distinct way to partition the prefix `nums[0..j-1]`.

---

### âŒ Forgetting to update `prefix[i]`
Without updating `prefix[i]`, you lose the ability to **accelerate range summation** for future `dp[i]` values.  
This breaks the optimization and reverts the solution to O(nÂ²) time complexity.

---

### âŒ Not shrinking the window correctly
If you forget to remove `left` from `maxDeque` or `minDeque`, the window may falsely appear valid.  
This leads to incorrect segment validation and corrupts the DP state.

---

## âœ… Summary

This pattern is a powerful tool for problems involving:

- **Partitioning with constraints**
- **Sliding window validation**
- **Dynamic programming with range-based dependencies**

It combines:

- ğŸ§® **Monotonic queues** for O(1) max/min tracking  
- âš¡ **Prefix sum acceleration** for O(1) DP range summation  
- ğŸ” **Window shrinking** to maintain segment validity

Perfect for:

- ğŸ† Competitive programming  
- ğŸ§± System design preparation  
- ğŸ§° Building reusable engineering templates

---





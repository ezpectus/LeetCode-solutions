# 🧩 Problem: Maximum Frequency Substring with Constraints

## 📜 Description

Given a string `s`, find the maximum frequency of any substring of length `minSize` that:
- Contains **at most `maxLetters` unique characters**
- Appears **within the bounds of `minSize ≤ substring length ≤ maxSize`**

Although `maxSize` is provided, the optimal solution only considers substrings of length `minSize` due to frequency maximization and performance constraints.

---

## 🧠 Solution Architecture

### 🔹 Core Strategy

- Use a **sliding window** of fixed size `minSize` to iterate over all possible substrings.
- For each substring:
  - Count the number of **unique characters** using a `HashSet<char>`.
  - If the count is ≤ `maxLetters`, update its frequency in a dictionary.
- After scanning, return the **maximum frequency** among all valid substrings.

### 🔹 Data Structures

- `Dictionary<string, int>` — maps substrings to their frequency counts.
- `HashSet<char>` — tracks unique characters in each substring.

### 🔹 Final Pattern

```csharp
for (int i = 0; i <= s.Length - minSize; i++) {
    string sub = s.Substring(i, minSize);
    var unique = new HashSet<char>();
    foreach (char c in sub) unique.Add(c);

    if (unique.Count <= maxLetters) {
        if (!freq.ContainsKey(sub)) freq[sub] = 0;
        freq[sub]++;
    }
}
return freq.Count > 0 ? freq.Values.Max() : 0;
```
# Or more easier to understand pattern: 

```csharp
public class Solution {
    public int MaxFreq(string s, int maxLetters, int minSize, int maxSize) {
       int n = s.Length;
       int res = 0;
        var freq = new Dictionary<string, int>();

       for(int i =0; i <= n- minSize;i++){
        string sub = s.Substring(i,minSize);
         
         var unique = new HashSet<char>();
         foreach(char c in sub){
            unique.Add(c);
          }

         if(unique.Count <= maxLetters){
               if(!freq.ContainsKey(sub)) freq[sub] = 0;

                freq[sub]++;
                
             }
       }
    res = freq.Count > 0 ? freq.Values.Max() : 0;

  return res;

    }
}
```

## ⚠️ Common Mistakes to Avoid

### ❌ Forgetting to add characters to `HashSet`
If you declare `HashSet<char>` but don’t call `Add(c)`, the uniqueness check is broken.  
The filter `unique.Count <= maxLetters` will always pass, even for invalid substrings.

---

### ❌ Updating frequency without checking key existence
Doing `freq[sub]++` will throw `KeyNotFoundException` if `sub` isn’t initialized.  
Always use `ContainsKey` or a ternary:

```csharp
freq[sub] = freq.ContainsKey(sub) ? freq[sub] + 1 : 1;
```
### ❌ Calling `.Max()` on an empty dictionary

If no substring passes the uniqueness filter, `freq.Values.Max()` throws `InvalidOperationException`.  
Protect with:

```csharp
return freq.Count > 0 ? freq.Values.Max() : 0;
```

# ✅ Summary
This pattern is clean, efficient, and scalable for substring frequency problems with uniqueness constraints. 
It’s a great candidate for your algorithmic toolbox — especially in competitive programming or template-based engineering.




---


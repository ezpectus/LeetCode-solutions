# 538. Convert BST to Greater Tree

---

## Problem Summary
We are given the root of a **Binary Search Tree (BST)**.  
The task is to convert it into a **Greater Tree** such that every node’s value becomes:  

**original value + sum of all keys greater than the original key in BST.**

---

## Core Idea
- In a BST, **inorder traversal** gives nodes in ascending order.  
- To accumulate sums of greater values, we need to traverse in **reverse inorder** (right → node → left).  
- Maintain a running sum:  
  - At each node, add its value to the running sum.  
  - Update the node’s value with this running sum.  
- Continue recursively until all nodes are processed.  

---

## C++ Implementation
```cpp

class Solution {
public:
    int runningSum = 0;

    TreeNode* convertBST(TreeNode* root) {
        dfs(root);
        return root;
    }

    void dfs(TreeNode* node) {
        if (!node) return;
        // Traverse right subtree first (greater values)
        dfs(node->right);
        // Update running sum and node value
        runningSum += node->val;
        node->val = runningSum;
        // Traverse left subtree
        dfs(node->left);
    }
};
```
## Complexity
- **Time:** O(n) — each node is visited exactly once during reverse inorder traversal.  
- **Space:** O(h) — recursion stack, where h = height of the tree (O(log n) for balanced, O(n) in worst case).  

---

## Pitfalls
- Must use **reverse inorder traversal** to ensure greater values are processed first.  
- Handle **negative values** correctly (`Node.val` can be as low as −10^4).  
- **Edge case:** empty tree → return `nullptr`.  
- **Large tree:** up to 10^4 nodes; recursion depth may reach n in skewed trees.  

---

## Example Walkthrough
**Input:** `root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]`  

**Reverse inorder traversal:**  
- Visit 8 → runningSum = 8 → node(8) = 8  
- Visit 7 → runningSum = 15 → node(7) = 15  
- Visit 6 → runningSum = 21 → node(6) = 21  
- Visit 5 → runningSum = 26 → node(5) = 26  
- Visit 4 → runningSum = 30 → node(4) = 30  
- Visit 3 → runningSum = 33 → node(3) = 33  
- Visit 2 → runningSum = 35 → node(2) = 35  
- Visit 1 → runningSum = 36 → node(1) = 36  
- Visit 0 → runningSum = 36 → node(0) = 36  

**Output:** `[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]`  

---

## Conclusion
The problem reduces to performing a **reverse inorder traversal** while maintaining a running sum.  
- Each node is updated with the sum of itself and all greater nodes.  
- Runs in **O(n)** time and **O(h)** space.  
- Clean, efficient, and optimal solution for BST transformations.  


---

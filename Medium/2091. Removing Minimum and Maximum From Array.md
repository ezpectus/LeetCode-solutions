# 2091. Removing Minimum and Maximum From Array  
*O(n) — Simple Greedy Position Comparison*

---

## Problem Statement

You are given a **0-indexed** array `nums` of **distinct** integers.

The array contains one minimum value and one maximum value.  
Your goal is to **remove both** the minimum and the maximum element from the array.

You can only delete elements from:
- The **front** of the array, or
- The **back** of the array

Return the **minimum number of deletions** needed to remove both the min and max elements.

**Examples**:

**Example 1**: nums = [2,10,7,5,4,1,8,6]  
Min = 1 (index 5), Max = 10 (index 1)  
One way: remove front 2 elements + back 3 elements → **5 deletions** (minimum)

**Example 2**: nums = [0,-4,19,1,8,-2,-3,5]  
Min = -4 (index 1), Max = 19 (index 2)  
Remove front 3 elements → **3 deletions** (minimum)

**Example 3**: nums = [101]  
Min = Max = 101 → **1 deletion**

**Constraints**:
- 1 ≤ nums.length ≤ 10⁵
- -10⁵ ≤ nums[i] ≤ 10⁵
- All integers in nums are **distinct**

---

## Core Idea — Greedy: Choose the Cheapest Way to Remove Both Ends

**Key insight**:
- We must remove **both** the minimum and maximum elements
- We can only delete from **front** or **back**
- The minimum number of deletions is the **minimum** of these three options:
  1. Remove everything from **front** up to the farther of min/max
  2. Remove everything from **back** up to the farther of min/max
  3. Remove from **front** up to one + from **back** up to the other

**Formal**:
Let `min_idx` = index of minimum element  
Let `max_idx` = index of maximum element  

Assume `min_idx < max_idx` (swap if needed)

Then minimum deletions = min of:
- Remove from **left** up to max_idx → deletions = max_idx + 1
- Remove from **right** up to min_idx → deletions = n - min_idx
- Remove from **left** up to min_idx + from **right** up to max_idx → deletions = min_idx + 1 + (n - 1 - max_idx)

**General formula** (no need to assume order):
```text
deletions = min(
    max(min_idx, max_idx) + 1,                  // remove from left to the farther one
    n - min(min_idx, max_idx),                  // remove from right to the closer one
    min_idx + 1 + (n - max_idx)                 // remove left to min + right to max (or vice versa)
)
```
This covers all possible ways:

- Remove only from left
- Remove only from right
- Remove from both sides (covering both min and max)

## Clean Implementation (C#)
```cpp
public class Solution {
    public int MinimumDeletions(int[] nums) {
        int n = nums.Length;
        if (n == 1) return 1;

        // Find indices of min and max
        int minVal = int.MaxValue, maxVal = int.MinValue;
        int minIdx = -1, maxIdx = -1;

        for (int i = 0; i < n; i++) {
            if (nums[i] < minVal) {
                minVal = nums[i];
                minIdx = i;
            }
            if (nums[i] > maxVal) {
                maxVal = nums[i];
                maxIdx = i;
            }
        }

        // Minimum of 3 options
        int opt1 = Math.Max(minIdx, maxIdx) + 1;           // remove from left up to farther
        int opt2 = n - Math.Min(minIdx, maxIdx);           // remove from right up to closer
        int opt3 = Math.Min(minIdx + 1, n - minIdx) +      // left to one + right to other
                   Math.Min(maxIdx + 1, n - maxIdx);

        return Math.Min(opt1, Math.Min(opt2, opt3));
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass through the array to find the indices of the minimum and maximum elements |
| **Space Complexity**  | **O(1)**      | Only a constant number of integer variables are used (no extra arrays or data structures) |

**Optimal** — linear time and constant space — ideal and extremely efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: nums = [2,10,7,5,4,1,8,6] (length n = 8)

- Minimum value = **1** at index **5**
- Maximum value = **10** at index **1**

Now compute the three possible deletion strategies:

1. **Remove from left** up to the farther position:  
   max(1, 5) + 1 = 5 + 1 = **6** deletions  
   (removes indices 0 to 5, covers both min and max)

2. **Remove from right** up to the closer position:  
   n - min(1, 5) = 8 - 1 = **7** deletions  
   (removes indices 1 to 7, covers both min and max)

3. **Remove from both ends** (left up to one + right up to the other):  
   - Left to min (index 5): min(5 + 1, 8 - 5) = min(6, 3) = **3**  
   - Right to max (index 1): min(1 + 1, 8 - 1) = min(2, 7) = **2**  
   - Total = 3 + 2 = **5** deletions

**Minimum of 6, 7, 5 = 5** → correct answer

**Correct** —  
The minimum number of deletions is the smallest number of elements we need to remove from the **left** and/or **right** to eliminate both the minimum and maximum values from the array.  
The three options cover all possible ways:
- Remove everything from the left up to the farther of the two positions
- Remove everything from the right up to the closer of the two positions
- Remove from left up to one position + from right up to the other position

The third option often gives the minimum because it splits the removals between both ends.

---

## Key Takeaway

This is a **beautiful greedy position-based** problem:

* Find the indices of the **minimum** and **maximum** elements in the array (single O(n) pass)
* Let min_idx and max_idx be their positions
* The elements we must remove are at these two positions
* The minimum deletions needed is the **minimum** of these three strategies:

  1. Remove from the **left** up to the farther position:  
     `max(min_idx, max_idx) + 1`

  2. Remove from the **right** up to the closer position:  
     `n - min(min_idx, max_idx)`

  3. Remove from **left** up to one + from **right** up to the other:  
     `min(min_idx + 1, n - min_idx) + min(max_idx + 1, n - max_idx)`

* This covers all possible ways to remove both target elements using only prefix and suffix deletions
**Pure, clean, optimal** — O(n) time, O(1) space, extremely simple, elegant, and intuitive once understood.

---
  

# 919. Complete Binary Tree Inserter — Architectural Level-Order Queue for Parent Tracking  
*O(n) init, O(1) amortized insert — Optimal CBT Management*

---

## Problem Statement

Given **complete binary tree** root.

Implement `CBTInserter`:
- `insert(val)` → add new node, keep tree complete → return **parent** value
- `get_root()` → return root

**Complete** = all levels filled except possibly last, left-to-right.

---

## Core Idea — Use Queue to Track Nodes with Available Slots

**Key insight**:
- In complete tree, next insert position = **leftmost** node with <2 children
- Use **queue** with nodes that have **<2 children**
- Level-order → natural left-to-right

**Constructor**:
- BFS from root
- Enqueue nodes with **<2 children**

**Insert**:
- Take **front** node from queue → parent
- Add new node as **left** if missing, else **right**
- If parent now has 2 children → dequeue
- Enqueue new node (it has 0 children)

**Perfect** — always next parent ready.

---

##  Implementation (C++)

```cpp
class CBTInserter {
private:
    TreeNode* root;
    queue<TreeNode*> q; // nodes with <2 children

public:
    CBTInserter(TreeNode* root) {
        this->root = root;

        // BFS to fill queue with nodes that can accept children
        queue<TreeNode*> temp;
        temp.push(root);

        while (!temp.empty()) {
            TreeNode* node = temp.front();
            temp.pop();

            if (node->left == nullptr || node->right == nullptr) {
                q.push(node);
            }

            if (node->left) temp.push(node->left);
            if (node->right) temp.push(node->right);
        }
    }

    int insert(int val) {
        TreeNode* parent = q.front();

        TreeNode* newNode = new TreeNode(val);

        if (parent->left == nullptr) {
            parent->left = newNode;
        } else {
            parent->right = newNode;
            q.pop(); // parent now full
        }

        q.push(newNode); // new node has 0 children

        return parent->val;
    }

    TreeNode* get_root() {
        return root;
    }
};
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Constructor**       | **O(n)**              | BFS visits all nodes                           |
| **Insert**            | **O(1)** amortized    | Queue operations O(1), total O(n) over all inserts |
| **Get_root**          | **O(1)**              | Direct return                                  |
| **Space**             | **O(w)**              | Queue size = tree width ≤ n/2                  |

**Optimal** — best possible for complete binary tree operations.

---

## Why This Works — Example Walkthrough

**Input**: `root = [1,2]`

- **Constructor**:
  - BFS traversal:
    - Enqueue node 1 (has left child, no right → <2 children)
    - Enqueue node 2 (leaf → 0 children)
  - Queue: [1, 2]

- **insert(3)**:
  - Front = node 1
  - Add new node as **right** child
  - Node 1 now has 2 children → **pop** from queue
  - Enqueue new node 3 (0 children)
  - Return parent value **1**

- **insert(4)**:
  - Front = node 2
  - Add new node as **left** child
  - Return parent value **2**

**Correct** — maintains complete tree, left-to-right filling.

---

## Pitfalls & Edge Cases

- **Single node** → queue contains root
- **Full tree** → last level nodes have <2 children → queue never empty until full
- **Large tree** → queue holds at most tree width (~n/2)
- **Insert order** → always **left-to-right** due to level-order queue

All handled perfectly.

---

## Key Takeaway

This is a **masterpiece of queue usage**:

- **Queue** holds **candidate parents** (nodes with <2 children)
- **Insert** → attach to front → maintain completeness
- **Level-order** → natural left-to-right insertion
- **No tree traversal** per insert → amortized O(1)

**Pure, clean, optimal** — one of the best tree design problems.

---

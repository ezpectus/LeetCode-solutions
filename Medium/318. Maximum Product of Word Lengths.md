# ðŸ§  Module: Maximum Product of Word Lengths â€” Bitmask Optimization

## ðŸ“Œ Problem Statement

Given an array of strings `words`, return the maximum value of `length(word[i]) * length(word[j])` where the two words do **not share any common letters**.  
If no such pair exists, return `0`.

---

## ðŸ”§ Constraints

- `2 <= words.length <= 1000`  
- `1 <= words[i].length <= 1000`  
- `words[i]` consists only of lowercase English letters

---

## ðŸ§© Architectural Insight

### âœ… Signals from the problem:
- â€œDo not share common lettersâ€ â†’ requires **fast intersection check**
- â€œOnly lowercase lettersâ€ â†’ allows **bitmasking over 26 bits**
- â€œMax product of lengthsâ€ â†’ implies **pairwise comparison**

### â— Naive approach:
- Compare every pair using `HashSet<char>` or nested loops â†’ **O(nÂ²Â·k)** time  
- Too slow for large inputs

### âœ… Optimized approach:
- Use **bitmask** to represent each wordâ€™s character set  
- Compare masks using bitwise `AND` to check for overlap  
- If `(mask[i] & mask[j]) == 0` â†’ words are disjoint

---

## ðŸ§  Bitmask Explanation

Each word is encoded into a 26-bit integer `mask`, where:
- `mask |= (1 << (c - 'a'))` sets the bit corresponding to character `c`
- Example: `"abc"` â†’ `mask = 0b00000000000000000000000111`

To check if two words share letters:
- `(mask[i] & mask[j]) == 0` â†’ no common letters

---

## âœ… C# Implementation

```csharp
public class Solution {
    public int MaxProduct(string[] words) {
        int n = words.Length;
        int[] masks = new int[n];
        int[] lens = new int[n];

        for (int i = 0; i < n; i++) {
            int mask = 0;
            foreach (char c in words[i]) {
                mask |= (1 << (c - 'a'));
            }
            masks[i] = mask;
            lens[i] = words[i].Length;
        }

        int max = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if ((masks[i] & masks[j]) == 0) {
                    max = Math.Max(max, lens[i] * lens[j]);
                }
            }
        }

        return max;
    }
}
```

## ðŸ“¦ Complexity Analysis

| Aspect         | Value                     | Explanation                                                                 |
|----------------|---------------------------|------------------------------------------------------------------------------|
| Time           | `O(nÂ²)`                   | We compare every pair of words `(i, j)` once. Bitmask comparison is constant time. |
| Space          | `O(n)`                    | We store one bitmask and one length per word. No extra structures used.     |
| Bitmask ops    | Constant time `O(1)`      | Each bitmask is a 26-bit integer. All bitwise operations are fixed-time.    |
| Max word length| Up to `1000` characters   | Irrelevant to performance due to bitmasking â€” only 26 letters are tracked.  |
| Preprocessing  | `O(nÂ·k)`                  | For each word of length `k`, we build its bitmask in linear time.           |
| Total runtime  | `O(nÂ² + nÂ·k)`             | Pairwise comparison + bitmask generation. Efficient for `n â‰¤ 1000`.         |

### ðŸ§  Architectural Notes
- Bitmasking compresses each wordâ€™s character set into a single integer â†’ avoids costly character comparisons.
- The final nested loop is quadratic, but each comparison is ultra-fast due to bitwise `AND`.
- This approach scales well for the given constraints and avoids unnecessary memory overhead.


---

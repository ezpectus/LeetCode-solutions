# 🧠 Module: Maximum Product of Word Lengths — Bitmask Optimization

## 📌 Problem Statement

Given an array of strings `words`, return the maximum value of `length(word[i]) * length(word[j])` where the two words do **not share any common letters**.  
If no such pair exists, return `0`.

---

## 🔧 Constraints

- `2 <= words.length <= 1000`  
- `1 <= words[i].length <= 1000`  
- `words[i]` consists only of lowercase English letters

---

## 🧩 Architectural Insight

### ✅ Signals from the problem:
- “Do not share common letters” → requires **fast intersection check**
- “Only lowercase letters” → allows **bitmasking over 26 bits**
- “Max product of lengths” → implies **pairwise comparison**

### ❗ Naive approach:
- Compare every pair using `HashSet<char>` or nested loops → **O(n²·k)** time  
- Too slow for large inputs

### ✅ Optimized approach:
- Use **bitmask** to represent each word’s character set  
- Compare masks using bitwise `AND` to check for overlap  
- If `(mask[i] & mask[j]) == 0` → words are disjoint

---

## 🧠 Bitmask Explanation

Each word is encoded into a 26-bit integer `mask`, where:
- `mask |= (1 << (c - 'a'))` sets the bit corresponding to character `c`
- Example: `"abc"` → `mask = 0b00000000000000000000000111`

To check if two words share letters:
- `(mask[i] & mask[j]) == 0` → no common letters

---

## ✅ C# Implementation

```csharp
public class Solution {
    public int MaxProduct(string[] words) {
        int n = words.Length;
        int[] masks = new int[n];
        int[] lens = new int[n];

        for (int i = 0; i < n; i++) {
            int mask = 0;
            foreach (char c in words[i]) {
                mask |= (1 << (c - 'a'));
            }
            masks[i] = mask;
            lens[i] = words[i].Length;
        }

        int max = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if ((masks[i] & masks[j]) == 0) {
                    max = Math.Max(max, lens[i] * lens[j]);
                }
            }
        }

        return max;
    }
}
```

## 📦 Complexity Analysis

| Aspect         | Value                     | Explanation                                                                 |
|----------------|---------------------------|------------------------------------------------------------------------------|
| Time           | `O(n²)`                   | We compare every pair of words `(i, j)` once. Bitmask comparison is constant time. |
| Space          | `O(n)`                    | We store one bitmask and one length per word. No extra structures used.     |
| Bitmask ops    | Constant time `O(1)`      | Each bitmask is a 26-bit integer. All bitwise operations are fixed-time.    |
| Max word length| Up to `1000` characters   | Irrelevant to performance due to bitmasking — only 26 letters are tracked.  |
| Preprocessing  | `O(n·k)`                  | For each word of length `k`, we build its bitmask in linear time.           |
| Total runtime  | `O(n² + n·k)`             | Pairwise comparison + bitmask generation. Efficient for `n ≤ 1000`.         |

### 🧠 Architectural Notes
- Bitmasking compresses each word’s character set into a single integer → avoids costly character comparisons.
- The final nested loop is quadratic, but each comparison is ultra-fast due to bitwise `AND`.
- This approach scales well for the given constraints and avoids unnecessary memory overhead.


---

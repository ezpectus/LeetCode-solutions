# 893. Groups of Special-Equivalent Strings — Architectural Even/Odd Signature Hashing  
*O(n × l) — Optimal Canonical Form Grouping*

---

## Problem Statement

Given array `words` (same length).

Two strings **special-equivalent** if can swap:
- Any **even** indices
- Any **odd** indices

Find number of **maximal groups** where every pair is special-equivalent.

---

## Core Idea — Canonical Signature via Sorted Even/Odd Chars

**Key insight**:
- Swapping even/odd positions → **order in even/odd doesn't matter**
- Two strings equivalent iff:
  - **Same multiset** of characters at **even positions**
  - **Same multiset** at **odd positions**

**Signature** for each word:
- Sort characters at **even indices**
- Sort characters at **odd indices**
- Concatenate → unique key

**Group** = all words with **same signature**

**Count distinct signatures** → number of groups.

---

##  Implementation (C++)

```cpp
class Solution {
public:
    int numSpecialEquivGroups(vector<string>& words) {
        unordered_set<string> groups;

        for (const string& word : words) {
            string even, odd;

            for (int i = 0; i < word.size(); i++) {
                if (i % 2 == 0)  even += word[i];
                else  odd += word[i];
            }

            sort(even.begin(), even.end());
            sort(odd.begin(), odd.end());
            groups.insert(even + "#" + odd); // # separator
        }

        return groups.size();
    }
};
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n × l log l)**    | n = words count, l = length ≤ 20 → sorting tiny |
| **Space Complexity**  | **O(n × l)**          | Hash set of signatures                         |

**Optimal** — best possible given constraints.

---

## Why This Works — Example Walkthrough

**Input**: `["abcd","cdab","cbad","xyzz","zzxy","zzyx"]`

- `"abcd"`: even="ac", odd="bd" → sorted `"ac#bd"`
- `"cdab"`: even="ca", odd="db" → `"ac#bd"`
- `"cbad"`: even="ca", odd="bd" → `"ac#bd"`
- `"xyzz"`: even="xz", odd="yz" → `"xz#yz"`
- `"zzxy"`: even="zx", odd="zy" → `"xz#yz"`
- `"zzyx"`: even="zx", odd="yx" → `"xy#yz"` → **different**

→ **3 groups**:
- `["abcd","cdab","cbad"]`
- `["xyzz","zzxy"]`
- `["zzyx"]`

**Correct** — captures special-equivalence perfectly.

---

## Pitfalls & Edge Cases

- **Same letters, different positions** → caught by sorting
- **Different lengths** → impossible (guaranteed same length)
- **Empty input** → 0 groups
- **All identical words** → 1 group
- **Single word** → 1 group

All handled cleanly.

---

## Key Takeaway

This is a **beautifully simple** grouping problem:

- **Even/odd positions** → independent multisets
- **Sort + concatenate** → unique canonical signature
- **Hash set** → count distinct groups

**No complex equivalence checks.**
**Pure insight + clean code** — one of the most elegant Medium string grouping problems.

---

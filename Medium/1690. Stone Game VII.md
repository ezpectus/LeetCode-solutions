# LeetCode 1690 — Stone Game VII  
**Approach: Dynamic Programming with Prefix Sums**

---

##  Problem Restatement
Alice and Bob alternately remove stones from either end of the row.  
- The player gains points equal to the sum of the remaining stones.  
- Alice maximizes the score difference, Bob minimizes it.  
We must return the final difference in scores if both play optimally.

---

##  Core Idea
- Define `dp[l][r]` = maximum score difference achievable from subarray `stones[l..r]`.  
- Use prefix sums to quickly compute sum of remaining stones.  
- Transition:  
  - If Alice removes left stone: gain = sum(l+1..r) − dp[l+1][r].  
  - If Alice removes right stone: gain = sum(l..r-1) − dp[l][r-1].  
- Take maximum of both choices.  
- Base case: `dp[i][i] = 0` (only one stone left, no points gained).  

---

##  Implementation (C#)

```csharp
public class Solution {
    public int StoneGameVII(int[] stones) {
        int n = stones.Length;
        int[] prefix = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + stones[i];
        }

        int[,] dp = new int[n, n];

        for (int len = 2; len <= n; len++) {
            for (int l = 0; l + len - 1 < n; l++) {
                int r = l + len - 1;
                int sumLeft = prefix[r + 1] - prefix[l + 1]; // sum(l+1..r)
                int sumRight = prefix[r] - prefix[l];       // sum(l..r-1)
                dp[l, r] = Math.Max(sumLeft - dp[l + 1, r],
                                    sumRight - dp[l, r - 1]);
            }
        }

        return dp[0, n - 1];
    }
}
```


##  Time Complexity
- **DP states:**  
  The DP table has `O(n^2)` states since each interval `[l..r]` is considered.  
- **Transition cost:**  
  Each state is computed in `O(1)` using prefix sums for subarray totals.  
- **Overall:**  
  → `O(n^2)`.

---

##  Space Complexity
- **DP table:**  
  Stores results for all intervals → `O(n^2)`.  
- **Prefix sums:**  
  Array of size `O(n)` for fast range queries.  
- **Total:**  
  → `O(n^2)`.

---

#  Impact of Design Choices

| Design Choice          | Effect                                                                 |
|------------------------|------------------------------------------------------------------------|
| **Prefix sums**        | Enables constant-time subarray sum queries.                           |
| **DP with intervals**  | Captures optimal play for both Alice and Bob.                         |
| **Difference-based DP**| Directly models score difference instead of tracking individual scores.|

---

#  Pitfalls
- **Forgetting to subtract opponent’s optimal result:**  
  Leads to incorrect difference calculation.  
- **Miscomputing prefix sums:**  
  Produces wrong subarray totals and invalid DP transitions.  
- **Not handling base case (`dp[i][i] = 0`):**  
  Causes invalid transitions when only one stone remains.  

---

#  Conclusion
- **What it gives:** Optimal score difference between Alice and Bob.  
- **Why it matters:** Models competitive play with minimax strategy via interval DP.  
- **Key takeaway:**  
  1. Use prefix sums for fast range sums.  
  2. Apply interval DP to capture optimal moves.  
  3. Return `dp[0][n-1]` as the final difference.  


---

# 1963. Minimum Number of Swaps to Make the String Balanced  
*O(n) — Optimal Greedy Balance Counter*

---

## Problem Statement

You are given a string `s` of even length `n` (2 ≤ n ≤ 10⁶), consisting of exactly `n/2` opening brackets `'['` and `n/2` closing brackets `']'`.

You can **swap any two brackets** any number of times.

Return the **minimum number of swaps** needed to make `s` **balanced**.

A string is balanced if:
- It is empty, or
- It can be written as `AB` where both `A` and `B` are balanced, or
- It can be written as `[C]` where `C` is balanced.

---

## Core Idea — Greedy Balance Tracking

**Key insight**:
- A balanced bracket string must have **non-negative balance** at every prefix, and **balance = 0** at the end
- Balance = number of `'['` minus number of `']'` seen so far
- We are allowed **swaps**, which let us rearrange brackets
- Since we have exactly `n/2` of each — it's always possible to make it balanced
- The question reduces to: **how many swaps are needed to fix the invalid prefixes**

**Greedy algorithm**:
- Traverse the string left to right
- Keep track of current balance
- Whenever balance becomes **negative** (too many `']'` so far):
  - We need to "fix" it by swapping a future `'['` with this `']'`
  - This effectively reduces the number of swaps needed later
  - Increment swap count
  - Reset balance to 0 (by imagining we swapped)
- At the end, since total balance = 0 (equal number), the swap count is exact

**Important**:
- We **don't actually perform swaps** — we just count how many times balance would go negative
- Each negative balance requires **one swap** to fix (bring a future open bracket earlier)

**Time**: O(n) — single pass

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MinSwaps(string s) {
        int balance = 0;
        int swaps = 0;

        foreach (char c in s) {
            if (c == '[')  balance++;
            else  balance--;
            
            // If balance negative — too many ']' so far
            if (balance < 0) {
                swaps++;
                balance += 2; // simulate swap: -1 (from ']') + 2 (swap with '[') → +1
            }
        }

        return swaps;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single linear pass through the string of length n ≤ 10⁶ |
| **Space Complexity**  | **O(1)**      | Only two integer variables (`balance` and `swaps`) |

**Optimal** — linear time, constant space — theoretically and practically the best possible solution.

---

## Why This Works — Example Walkthrough

**Example 1**: `s = "][]["`

- Start: balance = 0, swaps = 0
- Position 0 — ']': balance = -1 → negative → swaps = 1, balance += 2 → balance = 1
- Position 1 — '[': balance = 2
- Position 2 — ']': balance = 1
- Position 3 — '[': balance = 2
- End: swaps = **1** → correct  
  (one swap: first ']' with last '[' → "[[]]")

**Example 2**: `s = "]]][[["`

- ']': balance = -1 → swaps = 1, balance = 1
- ']': balance = 0
- ']': balance = -1 → swaps = 2, balance = 1
- '[': balance = 2
- '[': balance = 3
- '[': balance = 4
- End: swaps = **2** → correct

**Correct** — every time balance goes **negative**, it means too many closing brackets so far.  
We count **one swap** (to bring a future opening bracket earlier), and adjust balance by **+2** (simulating the swap: -1 from ']' + 2 from moving '[' forward).

At the end, since total '[' and ']' are equal (balance = 0), the swap count is **exact**.

---

## Pitfalls & Edge Cases

- **Already balanced** (`"[]"`): balance never goes negative → swaps = 0 → correct
- **All closing first** (`"]]][[["`): multiple negative balances → correctly counts the required swaps
- **n = 2** (minimal case): works instantly
- **n = 10⁶** (max constraint): O(n) single pass → extremely fast
- **Equal number of '[' and ']'** (guaranteed): always possible to balance with swaps

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple greedy balance-tracking** solution:

- Traverse the string left to right
- Maintain current **balance** (`'['` → +1, `']'` → -1)
- Whenever balance becomes **negative**:
  - Count **+1 swap** (we'll need to swap this `']'` with a future `'['`)
  - Add **+2** to balance (simulates the swap: -1 from current `']'` + 2 from moving a `'['` earlier)
- At the end, the number of swaps is the **minimum needed** (total balance always returns to 0)

**Pure, clean, optimal** — O(n) time, O(1) space, elegant and powerful.

---

# Fixed-Size Ring Buffer with Modular Pointer Arithmetic — Architectural Pattern  
*O(1) All Operations — Classic Circular Queue*

---

## Problem Overview

Implement a **circular queue** (ring buffer) with fixed capacity `k` supporting:

- `EnQueue(value)` — add to rear
- `DeQueue()` — remove from front
- `Front()` — peek front
- `Rear()` — peek rear
- `IsEmpty()` / `IsFull()`

All operations must be **O(1)** and use **constant memory** of size `k`.

**Key requirement**: FIFO semantics with **wrap-around** behavior using manual pointer management.

---

## Core Idea — Modular Arithmetic + Count Tracking

Use a **fixed array** with two pointers:

- `head` — points to the **front** element
- `tail` — points to the **next write position**

**Wrap-around**: `(index + 1) % k`

**Ambiguity resolution**: maintain `count` of elements  
→ distinguishes **empty** (`count == 0`) from **full** (`count == k`)

No wasted slot. No sentinel values.

---

## C# Implementation

```csharp
public class MyCircularQueue 
{
    private int[] arr;
    private int head;
    private int tail;
    private int count;
    private int cap;

    public MyCircularQueue(int k) 
    {
        cap = k;
        arr = new int[k];
        head = 0;
        tail = 0;
        count = 0;
    }

    public bool EnQueue(int value) 
    {
        if (IsFull()) return false;
        arr[tail] = value;
        tail = (tail + 1) % cap;
        count++;
        return true;
    }

    public bool DeQueue() 
    {
        if (IsEmpty()) return false;
        head = (head + 1) % cap;
        count--;
        return true;
    }

    public int Front() 
    {
        return IsEmpty() ? -1 : arr[head];
    }

    public int Rear() 
    {
        if (IsEmpty()) return -1;
        int idx = (tail - 1 + cap) % cap;
        return arr[idx];
    }

    public bool IsEmpty() 
    {
        return count == 0;
    }

    public bool IsFull() 
    {
        return count == cap;
    }
}
```

## Time and Space Complexity

| **Metric**            | **Value**     | **Explanation**                                      |
|-----------------------|---------------|------------------------------------------------------|
| **Time Complexity**   | **O(1)**      | All operations (enqueue, dequeue, front, rear) are constant-time |
| **Space Complexity**  | **O(k)**      | Fixed-size array of capacity `k`                     |

**Optimal** — true constant-time operations, **no amortization needed**.

---

## Implementation Commentary

- **Ring buffer mechanics**:
  - `tail` always points to the **next write position**
  - `head` always points to the **current front**
  - Both wrap using `(index + 1) % k` → seamless circular behavior

- **State tracking**:
  - `count` tracks the number of elements
  - Eliminates ambiguity between **empty** (`count == 0`) and **full** (`count == k`) states
  - Avoids needing a **sentinel slot** (common naive approach that wastes one space)

- **Front/Rear access**:
  - `Front` → `arr[head]`
  - `Rear` → element **before** `tail` → `(tail - 1 + cap) % cap` (safe wrap-around)

- **No built-in queue**:
  - Pure pointer arithmetic
  - Pure array storage
  - Fully manual FIFO behavior — **maximum performance and control**

---

## Final Takeaway

This pattern implements a **true high-performance ring buffer** using:

- **Modular pointer updates**
- **Constant-time** all operations
- **Explicit size tracking** via `count`

It generalizes to a wide range of real-world systems:

- **Network packet buffers** (routers, NICs)
- **Streaming data pipelines** (audio/video processing)
- **Producer-consumer queues** (multithreaded systems)
- **Fixed-capacity schedulers** (task queues)
- **Audio/video buffering** (low-latency playback)
- **Real-time embedded systems** with bounded memory
**The gold standard** for fixed-size FIFO structures — used **everywhere** in systems programming, kernel development, and performance-critical applications.

---

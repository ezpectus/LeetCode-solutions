# 462. Minimum Moves to Equal Array Elements II

---

## Problem Restatement
We are given an integer array `nums` of size `n`.  
In one move, we can increment or decrement an element by 1.  
We need to return the minimum number of moves required to make all elements equal.  

Constraints:
- 1 ≤ n ≤ 10⁵  
- -10⁹ ≤ nums[i] ≤ 10⁹  

---

## Key Idea
- The optimal target value is the **median** of the array.  
- Reason: The sum of absolute differences |nums[i] − target| is minimized at the median.  
- Steps:
  1. Sort the array.  
  2. Pick the median element.  
  3. Compute the sum of absolute differences between each element and the median.  

---

## Code (C#)
```csharp
public class Solution {
    public int MinMoves2(int[] nums) {
        Array.Sort(nums);
        int n = nums.Length;
        int median = nums[n / 2];

        long moves = 0;
        for (int i = 0; i < n; i++) {
            moves += Math.Abs((long)nums[i] - median);
        }

        return (int)moves;
    }
}
```




## Time Complexity
- **Sorting step:** O(n log n) to arrange the array in ascending order.  
- **Median selection:** O(1) after sorting (just pick the middle element).  
- **Summation step:** O(n) to compute the total moves by summing absolute differences.  
- **Overall:** O(n log n).  

---

## Space Complexity
- **Extra space:** O(1) beyond the sorting overhead.  
- **Variables used:** median, accumulator for moves, loop index.  
- **Total:** Constant space.

---

## Example Walkthrough

### Example 1
**Input:** nums = [1,2,3]  
- Sorted = [1,2,3]  
- Median = 2  
- Moves = |1−2| + |2−2| + |3−2| = 1 + 0 + 1 = 2  
- **Output = 2 ✅**

### Example 2
**Input:** nums = [1,10,2,9]  
- Sorted = [1,2,9,10]  
- Median = 9 (or 2, both yield same result)  
- Moves = |1−9| + |2−9| + |9−9| + |10−9| = 8 + 7 + 0 + 1 = 16  
- **Output = 16 ✅**

### Example 3
**Input:** nums = [5,5,5]  
- Sorted = [5,5,5]  
- Median = 5  
- Moves = |5−5| + |5−5| + |5−5| = 0  
- **Output = 0 ✅**

---

## Why This Works
- The **median** is the statistical point that minimizes the sum of absolute deviations.  
- If we chose the mean instead, the total moves could be larger because absolute differences are not minimized by the mean.  
- Sorting ensures we can directly pick the median in O(n log n).  
- For even `n`, any value between the two middle elements yields the same minimal sum, so picking either works.

---

## Edge Cases
- **Single element array:** moves = 0 (already equal).  
- **All elements equal:** moves = 0.  
- **Negative numbers:** works the same, since absolute difference handles sign.  
- **Large values:** use `long` for accumulation to avoid overflow, then cast back to `int`.

---

## Conclusion
✅ The trick is to align all numbers to the **median**.  
- Guarantees minimal total moves.  
- Efficient O(n log n) solution with constant space.  
- Handles arrays up to length 10⁵ and values up to ±10⁹ safely.  
This approach is both mathematically optimal and practically efficient.


---

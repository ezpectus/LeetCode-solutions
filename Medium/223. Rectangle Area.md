# üìò Problem: Total Area Covered by Two Rectangles

## üßæ Description

Given two axis-aligned rectangles in a 2D plane, each defined by their bottom-left and top-right coordinates:

- Rectangle A: `(ax1, ay1)` to `(ax2, ay2)`
- Rectangle B: `(bx1, by1)` to `(bx2, by2)`

**Goal**: Compute the total area covered by both rectangles.  
If they overlap, the overlapping region should be counted **only once**.

---

## üí° Geometric Insight

This is a classic **union of rectangles** problem.  
To avoid double-counting the overlapping region:

```
Total Area = Area(A) + Area(B) - Overlapping Area
```


---

## üßÆ Formula Breakdown

| Component         | Formula                                                                 |
|------------------|-------------------------------------------------------------------------|
| Area of A         | `(ax2 - ax1) * (ay2 - ay1)`                                              |
| Area of B         | `(bx2 - bx1) * (by2 - by1)`                                              |
| Overlap Width     | `Math.Max(0, Math.Min(ax2, bx2) - Math.Max(ax1, bx1))`                  |
| Overlap Height    | `Math.Max(0, Math.Min(ay2, by2) - Math.Max(ay1, by1))`                  |
| Overlap Area      | `width * height`                                                        |
| Final Result      | `areaA + areaB - area`                                                  |

- `Math.Max(0, ‚Ä¶)` ensures no negative dimensions if rectangles don‚Äôt overlap.
- `Math.Min` and `Math.Max` compute the intersection bounds.

---

## üßë‚Äçüíª Code (C#)

```csharp
public class Solution {
    public int ComputeArea(int ax1, int ay1, int ax2, int ay2,
                           int bx1, int by1, int bx2, int by2) {
        int areaA = (ax2 - ax1) * (ay2 - ay1);
        int areaB = (bx2 - bx1) * (by2 - by1);

        int width = Math.Max(0, Math.Min(ax2, bx2) - Math.Max(ax1, bx1));
        int height = Math.Max(0, Math.Min(ay2, by2) - Math.Max(ay1, by1));
        int area = width * height;

        return areaA + areaB - area;
    }
}
```


## ‚öôÔ∏è Performance Analysis

- **Time Complexity**: `O(1)`  
  All operations are simple arithmetic and comparisons ‚Äî no loops or recursion.

- **Space Complexity**: `O(1)`  
  No additional data structures or memory allocations.

- **Robustness**:  
  Handles edge cases where rectangles do not overlap by clamping overlap dimensions to zero using `Math.Max(0, ‚Ä¶)`.

- **Precision**:  
  Assumes integer coordinates. Avoids floating-point rounding errors common in geometric computations.

---

## üß± Architectural Pattern: Bounding Box Union

### üìê Pattern Description

This pattern computes the **union area** of two axis-aligned rectangles by subtracting the overlapping region. It‚Äôs a foundational technique in computational geometry and spatial reasoning.

### üîß Core Techniques

- **Overlap Detection**:  
  Use `Math.Min` and `Math.Max` to find the intersection bounds:
  - Horizontal overlap: `min(ax2, bx2) - max(ax1, bx1)`
  - Vertical overlap: `min(ay2, by2) - max(ay1, by1)`

- **Clamping**:  
  Apply `Math.Max(0, ‚Ä¶)` to ensure non-negative dimensions when rectangles do not intersect.

- **Subtractive Union**:  
  Total area = Area(A) + Area(B) ‚àí Overlap  
  Prevents double-counting the shared region.

### üß≠ Real-World Applications

| Domain                  | Use Case                                      |
|-------------------------|-----------------------------------------------|
| UI Layout Engines       | Calculating visible regions and redraw areas |
| Game Development        | Collision detection between sprites           |
| Image Processing        | Bounding box operations for cropping/masking |
| Spatial Indexing        | Region queries in quadtrees or R-trees       |

---

## ‚úÖ Engineering Takeaways

- This task is a **pure geometry primitive** ‚Äî no data structures, no iteration, just spatial logic.
- The pattern generalizes to **N rectangles** via sweep line or segment tree techniques.
- The use of `min/max` and clamping is a **reusable idiom** in bounding box math.
- Can be extended to:
  - Detect containment (`A inside B`)
  - Compute intersection area only
  - Merge multiple rectangles into a minimal bounding box

---

## üß† Pattern Summary for Playbook

### Pattern: Bounding Box Union via Overlap Subtraction

**Problem**: Compute total area covered by two axis-aligned rectangles.

**Formula**:
- Area(A) = `(ax2 - ax1) * (ay2 - ay1)`
- Area(B) = `(bx2 - bx1) * (by2 - by1)`
- Overlap Width = `max(0, min(ax2, bx2) - max(ax1, bx1))`
- Overlap Height = `max(0, min(ay2, by2) - max(ay1, by1))`
- Overlap Area = `width * height`
- Final Area = `Area(A) + Area(B) - Overlap Area`

**Used In**:
- UI layout
- Game physics
- Geometry engines
- Spatial indexing

**Key Concepts**:
- Axis-aligned rectangles
- Overlap detection via `min/max`
- Clamping to avoid negative area
- Subtractive union to prevent double-counting



---

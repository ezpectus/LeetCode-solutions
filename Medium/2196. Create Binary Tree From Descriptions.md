## ğŸ§  Engineering Guide â€” Leetcode 2196: Create Binary Tree From Descriptions

### ğŸ“Œ Problem Summary

You're given a list of descriptions. Each entry `[parent, child, isLeft]` means:

- `parent` is a node
- `child` is its child
- `isLeft == 1` â†’ child goes to `parent.left`
- `isLeft == 0` â†’ child goes to `parent.right`

Your task: **build the binary tree** and return its **root node**.

---

### ğŸ§± Architectural Signals

- Youâ€™re not given a root â€” you must **infer it** from the relationships.
- Each node value is **unique**, so you can safely map values to `TreeNode` instances.
- The tree is **valid**, so no cycles or multiple parents.
- The key insight: **the root is the only node that never appears as a child**.

---

### ğŸ” Step-by-Step Strategy

| Step | Action |
|------|--------|
| 1    | Create a `Dictionary<int, TreeNode>` to map values to nodes.  
This ensures reuse and avoids duplication. |
| 2    | Create a `HashSet<int>` to track all child nodes.  
This helps identify the root later. |
| 3    | Iterate through each `description`:  
- If `parent` not in map â†’ create new `TreeNode`  
- If `child` not in map â†’ create new `TreeNode`  
- Link `child` to `parent.left` or `parent.right` based on `isLeft`  
- Add `child` to `childSet` |
| 4    | After processing all descriptions, iterate through the map:  
Find the node that is **not in `childSet`** â€” this is the root. |
| 5    | Return the root node. Done. |

---

### ğŸ§© C# Skeleton

```csharp
public class Solution {
    public TreeNode CreateBinaryTree(int[][] descriptions) {
        Dictionary<int, TreeNode> nodes = new Dictionary<int, TreeNode>();
        HashSet<int> children = new HashSet<int>();

        foreach (var desc in descriptions) {
            int parentVal = desc[0], childVal = desc[1], isLeft = desc[2];

            if (!nodes.ContainsKey(parentVal))
                nodes[parentVal] = new TreeNode(parentVal);
            if (!nodes.ContainsKey(childVal))
                nodes[childVal] = new TreeNode(childVal);

            if (isLeft == 1)
                nodes[parentVal].left = nodes[childVal];
            else
                nodes[parentVal].right = nodes[childVal];

            children.Add(childVal);
        }

        foreach (var kvp in nodes) {
            if (!children.Contains(kvp.Key))
                return kvp.Value; // Found the root
        }

        return null; // Should never happen
    }
}
```


## â±ï¸ Complexity

| Metric           | Value | Reasoning                                      |
|------------------|-------|------------------------------------------------|
| Time Complexity  | O(n)  | One pass to build + one pass to find root      |
| Space Complexity | O(n)  | Dictionary + HashSet for node tracking         |

---

## ğŸ§  Denis-style Insight

This task is **pointer orchestration** â€” not recursion, not traversal.

You're building a **graph-like structure**, but with strict **parent-child directionality**.

The `HashSet` acts as a **signal filter** â€” it isolates the root by exclusion.

You donâ€™t need DFS/BFS â€” just **structural linking** and **root inference**.

### ğŸ”„ Possible Extensions

- Build a `parentMap` to trace ancestry or support upward traversal.
- Validate tree depth and balance post-construction.
- Serialize the tree for visualization or export.
- Add cycle detection if constraints change in future variants.

---

## âœ… Conclusion

This task is deceptively simple â€” but only if you recognize the **signal architecture**:

> â€œThe root is the only node that never appears as a child.â€

Once you lock that in, the rest is just **pointer wiring**.  
No recursion, no traversal â€” just **clean construction**.



---

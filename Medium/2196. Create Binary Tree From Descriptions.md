## 🧠 Engineering Guide — Leetcode 2196: Create Binary Tree From Descriptions

### 📌 Problem Summary

You're given a list of descriptions. Each entry `[parent, child, isLeft]` means:

- `parent` is a node
- `child` is its child
- `isLeft == 1` → child goes to `parent.left`
- `isLeft == 0` → child goes to `parent.right`

Your task: **build the binary tree** and return its **root node**.

---

### 🧱 Architectural Signals

- You’re not given a root — you must **infer it** from the relationships.
- Each node value is **unique**, so you can safely map values to `TreeNode` instances.
- The tree is **valid**, so no cycles or multiple parents.
- The key insight: **the root is the only node that never appears as a child**.

---

### 🔁 Step-by-Step Strategy

| Step | Action |
|------|--------|
| 1    | Create a `Dictionary<int, TreeNode>` to map values to nodes.  
This ensures reuse and avoids duplication. |
| 2    | Create a `HashSet<int>` to track all child nodes.  
This helps identify the root later. |
| 3    | Iterate through each `description`:  
- If `parent` not in map → create new `TreeNode`  
- If `child` not in map → create new `TreeNode`  
- Link `child` to `parent.left` or `parent.right` based on `isLeft`  
- Add `child` to `childSet` |
| 4    | After processing all descriptions, iterate through the map:  
Find the node that is **not in `childSet`** — this is the root. |
| 5    | Return the root node. Done. |

---

### 🧩 C# Skeleton

```csharp
public class Solution {
    public TreeNode CreateBinaryTree(int[][] descriptions) {
        Dictionary<int, TreeNode> nodes = new Dictionary<int, TreeNode>();
        HashSet<int> children = new HashSet<int>();

        foreach (var desc in descriptions) {
            int parentVal = desc[0], childVal = desc[1], isLeft = desc[2];

            if (!nodes.ContainsKey(parentVal))
                nodes[parentVal] = new TreeNode(parentVal);
            if (!nodes.ContainsKey(childVal))
                nodes[childVal] = new TreeNode(childVal);

            if (isLeft == 1)
                nodes[parentVal].left = nodes[childVal];
            else
                nodes[parentVal].right = nodes[childVal];

            children.Add(childVal);
        }

        foreach (var kvp in nodes) {
            if (!children.Contains(kvp.Key))
                return kvp.Value; // Found the root
        }

        return null; // Should never happen
    }
}
```


## ⏱️ Complexity

| Metric           | Value | Reasoning                                      |
|------------------|-------|------------------------------------------------|
| Time Complexity  | O(n)  | One pass to build + one pass to find root      |
| Space Complexity | O(n)  | Dictionary + HashSet for node tracking         |

---

## 🧠 Denis-style Insight

This task is **pointer orchestration** — not recursion, not traversal.

You're building a **graph-like structure**, but with strict **parent-child directionality**.

The `HashSet` acts as a **signal filter** — it isolates the root by exclusion.

You don’t need DFS/BFS — just **structural linking** and **root inference**.

### 🔄 Possible Extensions

- Build a `parentMap` to trace ancestry or support upward traversal.
- Validate tree depth and balance post-construction.
- Serialize the tree for visualization or export.
- Add cycle detection if constraints change in future variants.

---

## ✅ Conclusion

This task is deceptively simple — but only if you recognize the **signal architecture**:

> “The root is the only node that never appears as a child.”

Once you lock that in, the rest is just **pointer wiring**.  
No recursion, no traversal — just **clean construction**.



---

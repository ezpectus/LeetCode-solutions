# 959. Regions Cut By Slashes — Architectural Upscaled Grid + Union-Find/DFS  
*O(n²) — Optimal Connectivity Counting*

---

## Problem Statement

Given `n × n` grid of strings, each cell contains `' '`, `'/'`, or `'\\'`.

Each character **divides** the 1×1 square into regions.

Count **total contiguous regions** in the whole grid.

Backslashes escaped → `'\\'` = one `\`.

---

## Core Idea — Upscale Each Cell into 4 Triangles + Connect

**Key insight**:
- Each 1×1 cell divided by `/` or `\` into **2 or 4** regions
- Blank `' '` → 1 region
- To count **global regions** → model connectivity

**Brilliant trick**:
- **Upscale** each cell into **4 small triangles** (top, right, bottom, left)
- Total grid → `4n × 4n` tiny triangles
- Use **Union-Find** or **DFS** to connect adjacent triangles **not separated** by slash

**For each cell**:
- `' '` → connect all 4 triangles
- `'/'` → connect top-left + bottom-right, top-right + bottom-left
- `'\'` → connect top-right + bottom-left? Wait — correct mapping

**Standard**:
Number triangles in cell:
```
0   1
X
2   3
```
- 0: top
- 1: right
- 2: bottom
- 3: left

- `' '` → union all 0-1-2-3
- `'/'` → union 0-3 and 1-2 (slash separates top-right and bottom-left)
- `'\'` → union 0-1 and 2-3

Also union **across cell borders** if no slash blocks.

**Simpler**:
- Use **Union-Find** on `n* n * 4` nodes
- Or **DFS** on upscaled grid

**Most common**:
- **Union-Find** with smart union rules

---

## Full Optimal Implementation (C++)

```cpp
class Solution {
public:
    int regionsBySlashes(vector<string>& grid) {
        int n = grid.size();
        int size = n * 3; // upscale 1 cell → 3x3 tiny cells
        vector<vector<int>> g(size, vector<int>(size, 0));

        // Fill slashes
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++)  {
                int r = i * 3, c = j * 3;
                if (grid[i][j] == '/') g[r][c+2] = g[r+1][c+1] = g[r+2][c] = 1;
                else if (grid[i][j] == '\\') g[r][c] = g[r+1][c+1] = g[r+2][c+2] = 1; 
            }
        }

        // DFS to count regions
        int regions = 0;
        vector<int> dr = {-1,0,1,0};
        vector<int> dc = {0,1,0,-1};

        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                if (g[i][j] == 0) 
{
                    regions++;
                    dfs(g, i, j, dr, dc);
                }
            }
        }

        return regions;
    }

private:
    void dfs(vector<vector<int>>& g, int r, int c, vector<int>& dr, vector<int>& dc){
        int n = g.size();
        if (r < 0 || r >= n || c < 0 || c >= n || g[r][c] == 1) return;
        g[r][c] = 1;

        for (int d = 0; d < 4; d++)  dfs(g, r + dr[d], c + dc[d], dr, dc);
        
    }
};
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n²)**     | DFS visits each tiny cell once (9n² cells)     |
| **Space Complexity**  | **O(n²)**     | Upscaled grid                                  |

**Optimal** — linear in effective cells (9 per original cell).

---

## Why This Works — Example Walkthrough

**Input**: `[" /","/ "]`

- Cell (0,0): `' '` → no slash
- Cell (0,1): `'/'` → blocks diagonal
- Cell (1,0): `'/'` → blocks diagonal
- Cell (1,1): `' '` → no slash

Upscaled grid (3×3 per cell → 6×6 total):
- Slashes create barriers
- DFS floods connected empty tiny cells

→ **2 separate regions**

**Correct**.

**Input**: `["/\\","\\/"]`

- Four slashes forming X shape
- Upscaled → slashes divide plane into **5 distinct regions**:
  - Top triangle
  - Bottom triangle
  - Left triangle
  - Right triangle
  - Center diamond

→ **5 regions**

**Correct**.

---

## Pitfalls & Edge Cases

- **Blank cells** → fully connected
- **Adjacent slashes** → merge barriers correctly
- **Single cell** → 1, 2, or 4 regions depending on slash
- **All blank** → 1 big region
- **All slashes** → maximum regions

All handled perfectly by upscaling.

---

## Key Takeaway

This is a **classic grid transformation** problem:

- **Upscale 1→3** → model slashes as blocked tiny cells
- **DFS/BFS/Union-Find** → count connected components
- **Visualize tiny triangles** → intuitive region separation
**Clean, visual, optimal** — perfect for slash-divided regions.

---

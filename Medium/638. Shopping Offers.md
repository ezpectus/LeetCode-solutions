# LeetCode 638: Shopping Offers — DFS + Memoization
## Problem Description
You are given:

- price[i]: the cost of item i
- special[i]: a bundle offer — special[i][j] is quantity of item j, and special[i][n] is the total price of the offer
- needs[i]: how many units of item i you want to buy

You may:

- Buy items individually
- Use any special offer multiple times
- Cannot buy more than needed
- Return the minimum total cost to satisfy needs.

## Constraints
- n == price.length == needs.length
- 1 <= n <= 6
- 0 <= price[i], needs[i] <= 10
- 1 <= special.length <= 100
- special[i].length == n + 1
- 0 <= special[i][j] <= 50
- At least one item in each offer is non-zero

## How the Idea Was Formed
Given the constraints:

- Small number of items (n <= 6)
- Bounded item counts (needs[i] <= 10)
- Moderate number of offers (≤ 100)
- We can treat this as a state-space traversal problem:
- Each state = current needs
- Each transition = applying an offer or buying items directly
- Goal = reach needs == [0, 0, ..., 0]

This naturally leads to a DFS approach, where we explore all valid paths and use memoization to cache results and avoid recomputation.

## Why DFS + Memoization Is Optimal

- DFS allows us to explore all combinations of offers and direct purchases.
- Memoization ensures we don’t recompute the same needs state multiple times.
- This drastically reduces the number of recursive calls and improves performance.
- The structure of the problem is recursive by nature — each offer reduces the state, and we recurse until the needs are zero.

## Why Bitmask Is Not Used

- Bitmasking is ideal when each item has a binary state (used or not used). In this problem:
- needs[i] can range from 0 to 10
- We need to track counts, not just presence

Therefore, we use a string representation of needs as the memoization key:

```csharp
string key = string.Join(",", needs);
```
This allows us to uniquely identify each state and store its computed cost.

--- 
## C# Code with Comments
```csharp
public class Solution {
    public int ShoppingOffers(IList<int> price, IList<IList<int>> special, IList<int> needs) {
        var memo = new Dictionary<string, int>();
        return DFS(price, special, needs, memo);
    }

    private int DFS(IList<int> price, IList<IList<int>> special, IList<int> needs, Dictionary<string, int> memo) {
        string key = string.Join(",", needs);
        if (memo.ContainsKey(key)) return memo[key];

        // Base case: buy everything directly
        int minCost = 0;
        for (int i = 0; i < needs.Count; i++) {
            minCost += price[i] * needs[i];
        }

        // Try applying each special offer
        foreach (var offer in special) {
            var newNeeds = new List<int>();
            bool valid = true;

            for (int i = 0; i < needs.Count; i++) {
                if (needs[i] < offer[i]) {
                    valid = false; // pruning: offer exceeds needs
                    break;
                }
                newNeeds.Add(needs[i] - offer[i]);
            }

            if (valid) {
                int offerCost = offer[needs.Count] + DFS(price, special, newNeeds, memo);
                minCost = Math.Min(minCost, offerCost);
            }
        }

        memo[key] = minCost;
        return minCost;
    }
}
```

## Pruning Logic
We skip any offer that exceeds the current needs:

```csharp
if (needs[i] < offer[i]) {
    valid = false;
    break;
}
```

This avoids invalid paths and speeds up recursion by eliminating unnecessary branches.

## Complexity Analysis
- Time Complexity: O(k × mⁿ)
- k = number of offers
- m = max value of needs[i] (≤10)
- n = number of items (≤6)
- Space Complexity: O(mⁿ) for memoization dictionary

## Architectural Conclusion

This problem is a textbook example of:

- Recursive dynamic programming
- State compression via string encoding
- Efficient pruning to reduce search space
- Each needs state is a node in a graph. Each offer is a transition. DFS explores all paths.
- Memoization caches results. Pruning eliminates invalid transitions.

This structure is reusable for many problems involving bounded multidimensional states and combinatorial optimization.


---

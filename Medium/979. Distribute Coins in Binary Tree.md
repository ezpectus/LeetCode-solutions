# 979. Distribute Coins in Binary Tree — Architectural Post-Order Excess Calculation  
*O(n) — Optimal Single DFS Pass*

---

## Problem Statement

Given binary tree with `n` nodes, each has `node.val` coins.

Total coins = `n`.

**Move**: transfer 1 coin between **adjacent** nodes.

Goal: make **every node** have **exactly 1 coin**.

Return **minimum number** of moves.

---

## Core Idea — Post-Order DFS Tracking Excess Coins

**Key insight**:
- Each subtree must end with **0 excess** coins (balanced)
- When subtree returns **excess**:
  - Positive → extra coins → must move up → cost = excess
  - Negative → needs coins → parent sends down → cost = |excess|

**Every coin moved** across edge → counts as 1 move.

**DFS**:
- Return **excess** = `(node.val - 1) + left.excess + right.excess`
- Add `Math.Abs(excess)` to **global moves** (except root)

**Root excess** = 0 always (total n coins).

---

##  Implementation (C#)

```csharp
public class Solution {
    private int moves = 0;

    public int DistributeCoins(TreeNode root) {
        Dfs(root);
        return moves;
    }

    // Return excess coins in subtree (positive = extra, negative = deficit)
    private int Dfs(TreeNode node) {
        if (node == null) return 0;

        int leftExcess = Dfs(node.left);
        int rightExcess = Dfs(node.right);

        // Total excess in this subtree
        int excess = node.val - 1 + leftExcess + rightExcess;

        // Coins moving across edges to/from this subtree
        moves += Math.Abs(leftExcess) + Math.Abs(rightExcess);

        return excess;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Visit each node exactly once                   |
| **Space Complexity**  | **O(h)**      | Recursion stack (h = tree height, worst O(n) skewed) |

**Optimal** — linear time, minimal space.

---

## Why This Works — Example Walkthrough

**Input**: `root = [3,0,0]`
```
  3
 / \
0   0
```


- **Left leaf**: excess = 0 - 1 = **-1** (needs 1 coin)
- **Right leaf**: excess = 0 - 1 = **-1**
- **Root**: excess = (3 - 1) + (-1) + (-1) = **0**
- **Moves** += `|-1| + |-1| = 2`

**Correct** — 2 moves: one coin to left, one to right.

**Input**: `[0,3,0]`
```
  0
 / \
3   0
```


- **Left subtree**: excess = 3 - 1 = **+2** (2 extra coins)
- **Right leaf**: excess = 0 - 1 = **-1**
- **Root**: excess = (0 - 1) + 2 + (-1) = **0**
- **Moves** += `|2| + |-1| = 3`

**Correct** — 3 moves to balance.

---

## Pitfalls & Edge Cases

- **Single node** → excess = val - 1, but no children → moves=0
- **All nodes have 1 coin** → excess=0 everywhere → moves=0
- **All 0s except one node with n** → moves = n-1
- **Perfectly balanced** → root excess always 0

All handled perfectly.

---

## Key Takeaway

This is a **masterpiece of tree DP**:

- **Post-order** → compute subtree excess bottom-up
- **Excess** = coins - 1 + left.excess + right.excess
- **Moves** = sum of **|child excess|** → exactly coins crossing each edge

**No extra pass. No parent pointers.**
**Pure, clean, optimal** — one of the most elegant tree balance problems.

---

# 791. Custom Sort String — Architectural Frequency Counting + Ordered Append  
*O(n + m) — Clean & Optimal*

---

## Problem Statement

Given two strings `order` and `s`:

- All characters in `order` are **unique**
- `order` defines a **custom priority**

Rearrange `s` so that:
- If `x` appears before `y` in `order` → `x` must appear before `y` in result
- Characters **not in `order`** can appear anywhere

Return **any** valid permutation of `s`.

---

## Core Idea — Count Frequencies → Append in Order

**Brilliant insight**:
- Characters in `order` have **strict relative order**
- Characters not in `order` have **no constraints**

**Solution**:
1. Count frequency of each char in `s`
2. Append characters **in the order of `order`**, using their counts
3. Append remaining characters (not in `order`) in any order

**No sorting needed** — just follow `order` sequence.

---

##  Implementation (C#)

```csharp
public class Solution {
    public string CustomSortString(string order, string s) {
        // Count frequency of each char in s
        int[] count = new int[26];
        foreach (char c in s)  count[c - 'a']++;

        var res = new StringBuilder();
        // First: append characters in the order defined by 'order'
        foreach (char c in order) {
            int idx = c - 'a';
            while (count[idx] > 0) {
                res.Append(c);
                count[idx]--;
            }
        }

        // Then: append remaining characters (not in order)
        for (int i = 0; i < 26; i++) {
            while (count[i] > 0) {
               res.Append((char)(i + 'a'));
                count[i]--;
            }
        }

        return res.ToString();
    }
}
```

## Complexity

| **Metric**     | **Value**     | **Notes**                                      |
|----------------|---------------|------------------------------------------------|
| **Time**       | **O(n + m)**  | n = s.length, m = order.length                 |
| **Space**      | **O(1)**      | Fixed 26-char count array + StringBuilder      |

**Optimal** — linear and minimal.

---

## Why This Works — Example Walkthrough

**Input**: `order = "cba"`, `s = "abcd"`

- Count: `'a':1, 'b':1, 'c':1, 'd':1`
- Iterate `order`:
  - `'c'` → append `"c"` → count['c']=0
  - `'b'` → append `"cb"` → count['b']=0
  - `'a'` → append `"cba"` → count['a']=0
- Remaining: `'d'` → append `"cbad"`

**Perfect** — matches required order.

**Another**: `order = "bcafg"`, `s = "abcd"` → `"bcad"`

---

## Pitfalls & Edge Cases

- **Chars not in `order`** → appended at end → correct
- **Duplicates in `s`** → frequency counting handles perfectly
- **`order` shorter than alphabet** → remaining chars appended → correct
- **`s` has chars not in `order`** → flexible position → correct
- **`order` contains chars not in `s`** → ignored (no effect)

All handled cleanly.

---

## Key Takeaway

This is a **beautifully simple** custom sorting problem:

- **Frequency count** → handle duplicates
- **Follow `order`** → enforce priority
- **Append extras** → flexible placement

**No sorting. No comparison function. No overkill.**
**Pure, clean, optimal** — one of the most elegant Medium string problems.

---

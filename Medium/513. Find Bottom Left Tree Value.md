# LeetCode 513 — Find Bottom Left Tree Value  
**Approach: DFS (Depth-First Search)**

---

##  Problem Restatement
Given the root of a binary tree, return the **leftmost value in the last row** (deepest level).  

---

##  Core Idea
- Traverse the tree using **DFS**.  
- Track the **maximum depth** reached so far.  
- When visiting a node:
  - If it’s the first node at a new depth, record its value as the candidate.  
- Always explore the **left child first**, ensuring leftmost priority.  

---

##  Implementation (C#)

```csharp
public class Solution {
    private int result;
    private int maxDepth;

    public int FindBottomLeftValue(TreeNode root) {
        result = root.val;
        maxDepth = 0;
        DFS(root, 0);
        return result;
    }

    private void DFS(TreeNode node, int depth) {
        if (node == null) return;

        // If this is the first node at this depth → update result
        if (depth > maxDepth) {
            maxDepth = depth;
            result = node.val;
        }

        // Explore left first to ensure leftmost priority
        DFS(node.left, depth + 1);
        DFS(node.right, depth + 1);
    }
}
```

##  Time Complexity
- **Node visits:**  
  Each node is visited exactly once during DFS.  
  → `O(n)` where `n` = number of nodes.  

- **Per-node operations:**  
  Constant work (depth comparison, assignment).  
  → `O(1)` per node.  

- **Total:**  
  → `O(n)` overall.

---

##  Space Complexity
- **Recursion stack:**  
  Depth of recursion equals tree height `h`.  
  → `O(h)`.  

- **Worst case (skewed tree):**  
  Height = `n` → `O(n)`.  

- **Best case (balanced tree):**  
  Height = `log n` → `O(log n)`.

---

#  Impact of Design Choices

| Design Choice              | Effect                                                                 |
|----------------------------|------------------------------------------------------------------------|
| **DFS with depth tracking**| Ensures we capture the deepest leftmost node.                          |
| **Left-first traversal**   | Guarantees leftmost priority at each depth.                            |
| **Global maxDepth + result** | Simplifies updates, avoids extra data structures, keeps solution clean.|

---

#  Pitfalls
- **Forgetting depth update:**  
  If result isn’t updated only when reaching a new depth, output may be incorrect.  
- **Traversing right before left:**  
  Could capture rightmost node instead of leftmost.  
- **Single-node tree:**  
  Must handle correctly by returning root value.  

---

#  Conclusion
- **What it gives:** Leftmost value at the deepest level of the tree.  
- **Why it matters:** A common traversal pattern, useful for bottom-level queries and tree analysis.  
- **Key takeaway:**  
  1. Use DFS with depth tracking.  
  2. Explore left before right.  
  3. Update result only when reaching a new depth.  

This design achieves **`O(n)` time** and **`O(h)` space**, ensuring correctness and efficiency.


---



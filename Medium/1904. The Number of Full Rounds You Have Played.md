# 1904. The Number of Full Rounds You Have Played  
*O(1) — Optimal Time Arithmetic + Ceiling/Floor Trick*

---

## Problem Statement

You participate in an online chess tournament where a new round starts **every 15 minutes**:

- First round of the day: **00:00**
- Next: 00:15, 00:30, 00:45, 01:00, ..., up to 23:45

You are given:

- `loginTime` — time you log in (hh:mm format)
- `logoutTime` — time you log out (hh:mm format)

If `logoutTime` < `loginTime` (in time of day), it means you played from login to midnight and from midnight to logout.

A **full round** is counted only if you are online for the **entire** 15-minute round.

Return the **number of full rounds** you played.

---

## Core Idea — Convert to Minutes + Ceiling/Floor

**Key insight**:
- Convert both times to **minutes since midnight** (0 to 1439)
- Each round starts at minutes: 0, 15, 30, ..., 1425, 1440 (but 1440 is next day)
- A round [start, start+15) is fully played if:
  - You logged in **≤ start**
  - You logged out **≥ start + 15**
- But since rounds are fixed → better way:
  - Find the **earliest round start** after or at login
  - Find the **latest round end** before or at logout
  - Count how many full 15-min slots between them

**Steps**:
1. Convert loginTime and logoutTime to minutes since midnight
2. If logout ≤ login → add 24*60 = 1440 to logout (crossed midnight)
3. Compute **first full round start**:
   - ceil(loginTime / 15) * 15
4. Compute **last full round end**:
   - floor(logoutTime / 15) * 15 + 15
5. Number of full rounds = max(0, (last_end - first_start) / 15)

**Careful with edges**:
- If login exactly at round start → counts if stayed full 15 min
- If logout exactly at round end → counts that round

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int NumberOfRounds(string loginTime, string logoutTime) {
        // Convert to minutes since midnight
        int loginMin = ToMinutes(loginTime);
        int logoutMin = ToMinutes(logoutTime);
        // If logout is earlier → crossed midnight
        if (logoutMin <= loginMin)  logoutMin += 24 * 60;
        
        // First possible round start after or at login
        int firstStart = ((loginMin + 14) / 15) * 15;
        // Last possible round end before or at logout
        int lastEnd = (logoutMin / 15) * 15;

        // Number of full rounds
        if (firstStart >= lastEnd)  return 0;
        return (lastEnd - firstStart) / 15;
    }

    private int ToMinutes(string time) {
        var parts = time.Split(':');
        int hours = int.Parse(parts[0]);
        int mins = int.Parse(parts[1]);
        return hours * 60 + mins;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(1)**      | Fixed-time arithmetic + string parsing (constant number of operations) |
| **Space Complexity**  | **O(1)**      | Only a few integer variables (no arrays or extra structures) |

**Optimal** — constant time solution, perfect for any input size (times are always hh:mm format).

---

## Why This Works — Example Walkthrough

**Example 1**: `loginTime = "09:31"`, `logoutTime = "10:14"`

- loginMin = 9×60 + 31 = **571**
- logoutMin = 10×60 + 14 = **614**
- First full round start = ceil(571 / 15) × 15  
  571 ÷ 15 = 38.066 → ceil to 39 → 39 × 15 = **585** (09:45)
- Last full round end = floor(614 / 15) × 15 + 15  
  614 ÷ 15 = 40.933 → floor to 40 → 40 × 15 = 600 → end = **615** (10:15)
- Full rounds: (615 - 585) / 15 = 30 / 15 = **2** → but wait: only one full round (09:45–10:00) because logout at 10:14 < 10:15 → **1** → correct

**Example 2**: `loginTime = "21:30"`, `logoutTime = "03:00"`

- loginMin = 21×60 + 30 = **1290**
- logoutMin = 3×60 = 180 → crossed midnight → **180 + 1440 = 1620**
- First full round start = ceil(1290 / 15) × 15 = 86×15 = **1290** (21:30 exact)
- Last full round end = floor(1620 / 15) × 15 + 15 = 108×15 = 1620 → end = **1635**
- Full rounds: (1620 - 1290) / 15 = 330 / 15 = **22** → correct

**Correct** — ceiling rounds up login time to the next possible round start.  
Flooring rounds down logout time to the last complete round end.  
Difference in minutes divided by 15 gives exact number of full 15-minute rounds played.

---

## Pitfalls & Edge Cases

- **Login exactly at round start** (e.g. 09:45) → counts if stayed full 15 min
- **Logout exactly at round end** (e.g. 10:00) → counts that round
- **Login > logout** (cross midnight) → correctly add 1440 to logout
- **Very long session** (cross midnight) → handled by +1440
- **No full rounds** → firstStart ≥ lastEnd → return **0**
- **Login just after round start** → ceil jumps to next round → correct

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple time arithmetic + ceiling/floor** problem:

- Convert both `loginTime` and `logoutTime` to **minutes since midnight**
- If `logoutMin ≤ loginMin` → add 1440 to `logoutMin` (crossed midnight)
- First full round start = **ceil(login_minutes / 15) × 15**
- Last full round end = **floor(logout_minutes / 15) × 15 + 15**
- Number of full rounds = **max(0, (last_end - first_start) / 15)**

**Pure, clean, optimal** — constant time using smart ceiling/floor and modulo arithmetic.

---

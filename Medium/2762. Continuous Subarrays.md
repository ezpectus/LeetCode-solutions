# 🧩 **Problem**: 2762. Continuous Subarrays

---

### 📜 Description

You're given an integer array `nums`.  
Your task is to count the number of **contiguous subarrays** such that:

- For each subarray, the **difference between the maximum and minimum elements** is **at most 2**

Return the **total number of valid subarrays**.

---

### 🧠 Solution Architecture

#### 🔹 Core Strategy

This is a classic **sliding window with monotonic queues** problem.  
We want to count all subarrays `nums[left..right]` such that:



```text
max(nums[left..right]) - min(nums[left..right]) ≤ 2
```

## To do this efficiently:

- Use a **sliding window** to maintain the longest valid subarray ending at each `right`
- Use **monotonic deques** to track the current max and min values in O(1)
- For each valid window, count all subarrays ending at `right` by adding `(right - left + 1)` to the total

This works because every prefix of a valid window `[left..right]` is also valid.

---

#### 🔹 Data Structures

- `LinkedList<int> maxDeque`  
  Stores indices in **decreasing order** of values  
  → Front of the deque always holds the index of the current **maximum** in the window

- `LinkedList<int> minDeque`  
  Stores indices in **increasing order** of values  
  → Front of the deque always holds the index of the current **minimum** in the window

- `int left`  
  Left boundary of the current valid window  
  → Moves forward when the window becomes invalid

- `long total`  
  Accumulates the count of valid subarrays  
  → For each `right`, we add `(right - left + 1)` to `total`

---


## 🧩 Final Pattern
```csharp
public class Solution {
    public long ContinuousSubarrays(int[] nums) {
        int n = nums.Length;
        long total = 0;
        int left = 0;

        LinkedList<int> maxDeque = new LinkedList<int>();
        LinkedList<int> minDeque = new LinkedList<int>();

        for (int right = 0; right < n; right++) {
            while (maxDeque.Count > 0 && nums[maxDeque.Last.Value] < nums[right])
                maxDeque.RemoveLast();
            maxDeque.AddLast(right);

            while (minDeque.Count > 0 && nums[minDeque.Last.Value] > nums[right])
                minDeque.RemoveLast();
            minDeque.AddLast(right);

            while (nums[maxDeque.First.Value] - nums[minDeque.First.Value] > 2) {
                if (maxDeque.First.Value == left) maxDeque.RemoveFirst();
                if (minDeque.First.Value == left) minDeque.RemoveFirst();
                left++;
            }

            total += right - left + 1;
        }

        return total;
    }
}
```

## ⚠️ **Common Mistakes to Avoid**

❌ **Not maintaining monotonic order in deques**  
If you forget to remove elements from the back, the max/min tracking breaks and the window becomes invalid.

❌ **Not removing `left` from deques when shrinking**  
If `left` is still in the deque after moving the window, it corrupts the max/min calculation.

❌ **Miscounting subarrays**  
Always count `(right - left + 1)` subarrays ending at `right` — each prefix of the current window is valid.

---

## ✅ **Summary**

This pattern is ideal for problems involving:

- Subarray counting with **range constraints**
- Sliding window with **dynamic validation**
- Efficient max/min tracking using **monotonic queues**

## It combines:

- 🧮 **Monotonic queues** for O(1) max/min tracking  
- 🔁 **Window shrinking** to maintain constraints  
- 📊 **Subarray counting** via prefix enumeration

Perfect for:

- 🏆 **Competitive programming**  
- 🧱 **System design preparation**  
- 🧰 **Building reusable algorithmic templates**



---

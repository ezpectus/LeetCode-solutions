# 🔺 Problem: Simplified Fractions (Leetcode 1447)

## 📜 Statement

Given an integer `n`, return a list of all **simplified fractions** between `0` and `1` (exclusive)  
such that the **denominator is less than or equal to `n`**.

A fraction `a/b` is simplified if `GCD(a, b) == 1`.

You may return the answer in any order.

---

## 🧠 Core Idea

This is a **number theory filter** task.  
We iterate over all possible fractions `a/b` such that:

- `1 ≤ a < b ≤ n`
- `GCD(a, b) == 1` → fraction is in lowest terms

Each valid pair is added as a string `"a/b"` to the result list.

> Think of it as a **coprime scan** over the triangle below `1`.

---

## 🧪 Examples

```text
Input: n = 2
→ Only valid: 1/2 → Output: ["1/2"]

Input: n = 3
→ Valid: 1/2, 1/3, 2/3 → Output: ["1/2", "1/3", "2/3"]

Input: n = 4
→ All fractions: 1/2, 2/4, 1/3, 2/3, 3/4, 1/4  
→ Simplified: ["1/2", "1/3", "2/3", "3/4", "1/4"]
```

## 🧱 C# Implementation
```cpp
public class Solution {
    public IList<string> SimplifiedFractions(int n) {
        var res = new List<string>();

        for(int denom = 2; denom <= n; denom++){
            for(int numer = 1; numer < denom;numer++){
                if(GCD(numer,denom) == 1){
                    res.Add($"{numer}/{denom}");
                }
            }
        }
    return res;

    }
    private int GCD(int a,int b){
        while(b != 0){
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

## 🔍 Why This Code Is Optimized

### ✅ Coprime Filtering
Only includes fractions in lowest terms via `GCD(a, b) == 1`.  
Avoids duplicates like `2/4`, `3/6`, etc.

### 🔁 Double Loop Scan
Iterates over all valid `(numerator, denominator)` pairs.  
No need for precomputation or caching.

### 🧮 Efficient GCD
Uses Euclidean algorithm — fast and stable.  
Handles all inputs up to `n = 100` smoothly.

### 🧠 Minimal State
No arrays, no recursion, no string parsing.  
Pure arithmetic and control flow.

---

## 🧮 Time & Space Complexity

| Metric      | Value     | Notes                                      |
|-------------|-----------|--------------------------------------------|
| Time        | O(n²)     | Worst-case scan of all pairs               |
| Space       | O(k)      | `k` = number of simplified fractions       |
| Stability   | High      | Deterministic, no branching                |
| Scalability | Excellent | Handles full input range smoothly          |

---

## 🧠 Engineering Takeaway

This task is a clean example of:

- ✅ **Coprime filtering** — using GCD to enforce lowest terms  
- 🔢 **Number theory in practice** — Euclidean algorithm as a tool  
- 🧠 **Minimalist design** — no simulation, no parsing, just math  
- 📜 **Readable output** — formatted as `"a/b"` strings

> You’re not generating fractions — you’re **curating the irreducible ones**.

---

## 🧩 Conclusion

**Simplified Fractions** shows how **basic number theory** can be used to filter structured data.  
By combining a double loop with GCD filtering, we produce a clean and efficient list of valid fractions.

> **Coprime logic + clean formatting = architectural clarity.**



---

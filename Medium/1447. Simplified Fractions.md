# ðŸ”º Problem: Simplified Fractions (Leetcode 1447)

## ðŸ“œ Statement

Given an integer `n`, return a list of all **simplified fractions** between `0` and `1` (exclusive)  
such that the **denominator is less than or equal to `n`**.

A fraction `a/b` is simplified if `GCD(a, b) == 1`.

You may return the answer in any order.

---

## ðŸ§  Core Idea

This is a **number theory filter** task.  
We iterate over all possible fractions `a/b` such that:

- `1 â‰¤ a < b â‰¤ n`
- `GCD(a, b) == 1` â†’ fraction is in lowest terms

Each valid pair is added as a string `"a/b"` to the result list.

> Think of it as a **coprime scan** over the triangle below `1`.

---

## ðŸ§ª Examples

```text
Input: n = 2
â†’ Only valid: 1/2 â†’ Output: ["1/2"]

Input: n = 3
â†’ Valid: 1/2, 1/3, 2/3 â†’ Output: ["1/2", "1/3", "2/3"]

Input: n = 4
â†’ All fractions: 1/2, 2/4, 1/3, 2/3, 3/4, 1/4  
â†’ Simplified: ["1/2", "1/3", "2/3", "3/4", "1/4"]
```

## ðŸ§± C# Implementation
```cpp
public class Solution {
    public IList<string> SimplifiedFractions(int n) {
        var res = new List<string>();

        for(int denom = 2; denom <= n; denom++){
            for(int numer = 1; numer < denom;numer++){
                if(GCD(numer,denom) == 1){
                    res.Add($"{numer}/{denom}");
                }
            }
        }
    return res;

    }
    private int GCD(int a,int b){
        while(b != 0){
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

## ðŸ” Why This Code Is Optimized

### âœ… Coprime Filtering
Only includes fractions in lowest terms via `GCD(a, b) == 1`.  
Avoids duplicates like `2/4`, `3/6`, etc.

### ðŸ” Double Loop Scan
Iterates over all valid `(numerator, denominator)` pairs.  
No need for precomputation or caching.

### ðŸ§® Efficient GCD
Uses Euclidean algorithm â€” fast and stable.  
Handles all inputs up to `n = 100` smoothly.

### ðŸ§  Minimal State
No arrays, no recursion, no string parsing.  
Pure arithmetic and control flow.

---

## ðŸ§® Time & Space Complexity

| Metric      | Value     | Notes                                      |
|-------------|-----------|--------------------------------------------|
| Time        | O(nÂ²)     | Worst-case scan of all pairs               |
| Space       | O(k)      | `k` = number of simplified fractions       |
| Stability   | High      | Deterministic, no branching                |
| Scalability | Excellent | Handles full input range smoothly          |

---

## ðŸ§  Engineering Takeaway

This task is a clean example of:

- âœ… **Coprime filtering** â€” using GCD to enforce lowest terms  
- ðŸ”¢ **Number theory in practice** â€” Euclidean algorithm as a tool  
- ðŸ§  **Minimalist design** â€” no simulation, no parsing, just math  
- ðŸ“œ **Readable output** â€” formatted as `"a/b"` strings

> Youâ€™re not generating fractions â€” youâ€™re **curating the irreducible ones**.

---

## ðŸ§© Conclusion

**Simplified Fractions** shows how **basic number theory** can be used to filter structured data.  
By combining a double loop with GCD filtering, we produce a clean and efficient list of valid fractions.

> **Coprime logic + clean formatting = architectural clarity.**



---

# 986. Interval List Intersections — Architectural Two-Pointer Sweep Line  
*O(n + m) — Optimal Linear Merge*

---

## Problem Statement

Given two lists of **disjoint, sorted** closed intervals:
- `firstList`
- `secondList`

Return **all intersecting intervals** (in any order).

Intersection of `[a,b]` and `[c,d]` = `[max(a,c), min(b,d)]` if non-empty.

---

## Core Idea — Two Pointers on Sorted Lists

**Key insight**:
- Both lists **sorted** and **disjoint**
- Like merging two sorted arrays

**Two pointers** `i`, `j`:
- Compare current intervals `A = first[i]`, `B = second[j]`
- Intersection = `[max(A.start, B.start), min(A.end, B.end)]`
- If non-empty → add to result
- Advance pointer of **earlier ending** interval
  - Because it cannot intersect future intervals of the other list

**Guaranteed** no overlaps within each list.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int[][] IntervalIntersection(int[][] firstList, int[][] secondList) {
        var result = new List<int[]>();
        int i = 0, j = 0;

        while (i < firstList.Length && j < secondList.Length) {
            int[] a = firstList[i];
            int[] b = secondList[j];

            // Intersection: [max start, min end]
            int start = Math.Max(a[0], b[0]);
            int end = Math.Min(a[1], b[1]);

            if (start <= end)  result.Add(new int[] { start, end });
            

            // Move pointer of interval that ends first
            if (a[1] < b[1])  i++;
            else  j++;  
        }

        return result.ToArray();
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n + m)**  | n, m = lengths of the two lists, single pass   |
| **Space Complexity**  | **O(k)**      | k = number of intersections (output size)      |

**Optimal** — linear time, minimal extra space.

---

## Why This Works — Example Walkthrough

**Input**:
- `firstList = [[0,2],[5,10],[13,23],[24,25]]`
- `secondList = [[1,5],[8,12],[15,24],[25,26]]`

Two-pointer simulation:
- i=0, j=0: [0,2] ∩ [1,5] = **[1,2]** → add → 2 < 5 → **i++**
- i=1, j=0: [5,10] ∩ [1,5] = **[5,5]** → add → 10 > 5 → **j++**
- i=1, j=1: [5,10] ∩ [8,12] = **[8,10]** → add → 10 < 12 → **i++**
- i=2, j=1: [13,23] ∩ [8,12] = empty → **j++**
- i=2, j=2: [13,23] ∩ [15,24] = **[15,23]** → add → 23 < 24 → **i++**
- i=3, j=2: [24,25] ∩ [15,24] = **[24,24]** → add → 25 > 24 → **j++**
- i=3, j=3: [24,25] ∩ [25,26] = **[25,25]** → add

Result: `[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]`

**Correct**.

---

## Pitfalls & Edge Cases

- **No intersection** → return empty array
- **Touching but not overlapping** → empty (closed intervals → [1,2] ∩ [3,4] = empty)
- **One list empty** → return empty
- **Single interval** → handled correctly
- **Full overlap** → returns full intersection interval

All handled perfectly.

---

## Key Takeaway

This is a **beautifully clean** two-pointer problem:

- **Sorted + disjoint** lists → perfect for merge-style sweep
- **Advance the interval that ends earlier** → never miss any intersection
- **Single linear pass** → O(n + m) time

**No sorting. No complex data structures.**
**Pure, elegant, optimal** — one of the best interval merge problems.

---

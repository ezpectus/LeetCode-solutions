# 1898. Maximum Number of Removable Characters  
*O(n log m) — Optimal Binary Search + Greedy Check*

---

## Problem Statement

You are given:

- String `s` (length ≤ 10⁵)
- String `p` — a subsequence of `s`
- Array `removable` — distinct 0-indexed indices of `s` (length m < |s|)

You can remove characters from `s` using the **first k** indices from `removable` (for some k, 0 ≤ k ≤ m).

After removal, `p` must **still** be a subsequence of the remaining string.

Find the **maximum possible k** such that this is true.  
If impossible even for k=0 → return 0.

---

## Core Idea — Binary Search on k + Greedy Subsequence Check

**Key insight**:
- The feasibility is **monotonic**: if it's possible for some k → it's possible for all smaller k'
- So we can **binary search** the maximum k where after removing the first k indices from `removable`, `p` is still a subsequence of `s`

**Check function**:
- For a mid k → mark the first k indices in removable as removed
- Then check if `p` is still a subsequence in the remaining string
- To check subsequence efficiently:
  - Use two pointers: iterate through `s` (skip removed positions) and match characters of `p` in order
  - If we can match all of `p` → possible

**Time**:
- Binary search: log m steps (m ≤ 10⁵)
- Each check: O(|s|) to scan `s` and match `p`
- Total: **O(n log m)** — perfect

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MaximumRemovals(string s, string p, int[] removable) {
        int left = 0,right = removable.Length;
        int ans = 0;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            // Check if possible to remove first mid indices
            if (IsPossible(s, p, removable, mid))  {
                ans = mid;
                left = mid + 1;
            } else right = mid - 1;
        }

        return ans;
    }

private bool IsPossible(string s, string p, int[] removable, int k) {
        // Mark first k removable indices as removed
        bool[] removed = new bool[s.Length];
        for (int i = 0; i < k; i++)  removed[removable[i]] = true;
        
        // Two pointers to check if p is still subsequence
        int j = 0; // pointer in p
        for (int i = 0; i < s.Length; i++) {
            if (removed[i]) continue; // skip removed
            if (j < p.Length && s[i] == p[j])  j++;
        }

        return j == p.Length; // all characters of p matched
    }
}
```


## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n log m)**| Binary search over k (0 to m): log m (~17 steps) × O(n) subsequence check per mid |
| **Space Complexity**  | **O(n)**      | Boolean removed array O(n) — can be optimized to O(m) with HashSet if needed |

**Optimal** — meets the required time bound for n ≤ 10⁵, m ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: `s = "abcacb"`, `p = "ab"`, `removable = [3,1,0]`

- Binary search k from 0 to 3
- mid=2: remove indices 3 and 1 → s becomes "a c a c b" (positions 0,2,4,5 remain)
  - Check p="ab": pointer j=0 → s[0]='a' matches → j=1  
    → s[4]='b' matches → j=2 (all matched) → possible
- mid=3: remove 3,1,0 → s becomes "c a c b" (positions 2,4,5 remain)
  - Check p="ab": s[2]='c' no → s[4]='b' no → s[5]='b' no → cannot match 'a' → impossible
- Maximum k = **2** → correct

**Correct** — binary search finds the largest k where after removing the first k indices from removable, p remains a subsequence of the remaining string (checked greedily with two pointers in O(n)).

---

## Pitfalls & Edge Cases

- **k=0** → always possible (p is subsequence of original s)
- **removable empty** → return **0**
- **p length = 1** → as long as that character exists after removals
- **Remove all possible indices** → may remove everything → check if p becomes empty or not
- **n,m = 10⁵** → O(n log m) ≈ 10⁵ × 17 ≈ 1.7M operations → very fast

All handled perfectly.

---

## Key Takeaway

This is a **classic binary search on answer + greedy check** problem:

- Binary search the **maximum k** (0 to removable.length)
- For each mid k:
  - Mark the first k indices in removable as removed
  - Check if p is still a subsequence in the remaining string:
    - Use two pointers: iterate through s (skip removed positions), match characters of p in order
    - If all characters of p are matched → possible
- If possible → try larger k
- Else → reduce k
- Return the largest feasible k

**Pure, clean, optimal** — logarithmic search + linear-time greedy subsequence check per candidate.

---

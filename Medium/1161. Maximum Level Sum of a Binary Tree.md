# Intuition
We want to find the level of the binary tree at which the sum of the values of the nodes is maximal. This leads to the idea of level-based traversal (BFS), where we can aggregate the sum at each level.

# Approach
We use the queue for BFS.

At each level:

We count the number of nodes (size).

We sum up the values of all nodes of this level.

Update the maximum if the current amount is greater.

We track the level number (lvl) and save the maxlvl if we found a new maximum.

# Complexity

Time complexity $$O(n)$$ — each node is visited once
Space complexity $$O(w)$$ — the maximum width of the tree (in the worst case $$O(n)$$)

# Code
```csharp []
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

 //Iterative BFS with level tracking sum
public class Solution {
    public int MaxLevelSum(TreeNode root) {
      Queue<TreeNode> queue = new Queue<TreeNode>();
       queue.Enqueue(root);
        int maxsum = int.MinValue;
        int lvl = 1;
        int maxlvl =1;

    while(queue.Count > 0){
         int size = queue.Count;
         int lvlsum = 0;

          for(int i =0; i < size;i++){
            TreeNode node = queue.Dequeue();
            lvlsum += node.val;

            if(node.left != null){
                queue.Enqueue(node.left);
            }
             if(node.right != null){
                queue.Enqueue(node.right);
             }
          }
        if(lvlsum > maxsum){
            maxsum = lvlsum;
            maxlvl = lvl;
        }
        lvl++;
    }

     return maxlvl;


    }
}
```








----

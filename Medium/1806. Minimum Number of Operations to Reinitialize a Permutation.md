# 1806. Minimum Number of Operations to Reinitialize a Permutation — Architectural Cycle Detection in Permutation Transformation  
*O(n) — Optimal Cycle Length Calculation*

---

## Problem Statement

You start with the identity permutation `perm` of size `n` (even):  
`perm = [0, 1, 2, ..., n-1]`

Each operation transforms `perm` into a new array `arr` where:
- `arr[i] = perm[i / 2]` if `i` is even
- `arr[i] = perm[n / 2 + (i - 1) / 2]` if `i` is odd

Then set `perm = arr`.

Return the **smallest positive number of operations** needed to return `perm` to its initial state `[0, 1, ..., n-1]`.

---

## Core Idea — Find Cycle Length of Permutation Transformation

**Key insight**:
- Each operation applies a fixed permutation to the positions
- The transformation is **independent of values** — it's a fixed mapping of indices
- Applying the operation repeatedly is composing the same permutation multiple times
- The number of operations to return to identity = **order of the permutation** (smallest k > 0 such that perm^k = identity)
- Since the permutation is a product of **disjoint cycles**, the order = **LCM of all cycle lengths**

**Steps**:
1. Simulate one operation → build the **next position** array: `next[i]` = where position `i` goes after one operation
2. Find all **cycles** in this permutation
3. Compute **LCM** of all cycle lengths → that's the answer

**Why LCM?**  
After k steps, position returns to original iff k is multiple of every cycle length → smallest k = LCM.

---

## Full Optimal Implementation (C#)

```csharp
public class Solution {
    public int ReinitializePermutation(int n) {
        // Step 1: Build the next position array
        int[] nextPos = new int[n];
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0)  nextPos[i] = i / 2;
            else  nextPos[i] = n / 2 + (i - 1) / 2;
            
        }

        // Step 2: Find all cycle lengths and compute LCM
        bool[] visited = new bool[n];
        long lcm = 1;

        for (int start = 0; start < n; start++) {
            if (visited[start]) continue;

            // Find cycle length starting from start
            int len = 0;
            int pos = start;
            while (!visited[pos]) {
                visited[pos] = true;
                pos = nextPos[pos];
                len++;
            }

            // LCM of current cycle length and previous
            lcm = LCM(lcm, len);
        }

        return (int)lcm;
    }

    private long LCM(long a, long b) {
        return a / GCD(a, b) * b;
    }

    private long GCD(long a, long b) {
        while (b != 0) {
            long t = b;
            b = a % b;
            a = t;
        }
        return a;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Building the next position array O(n) + finding all cycles O(n) |
| **Space Complexity**  | **O(n)**      | nextPos array + visited array                  |

**Optimal** — linear time, perfect for n ≤ 1000.

---

## Why This Works — Example Walkthrough

**Example 1**: `n = 2`

- nextPos:
  - i=0 (even): 0 / 2 = 0
  - i=1 (odd): 2/2 + (1-1)/2 = 1 + 0 = 1
- Cycles: 0 → 0 (length 1), 1 → 1 (length 1)
- LCM(1, 1) = **1** → correct

**Example 2**: `n = 4`

- nextPos:
  - 0 → 0 / 2 = 0
  - 1 → 4/2 + (1-1)/2 = 2 + 0 = 2
  - 2 → 2 / 2 = 1
  - 3 → 4/2 + (3-1)/2 = 2 + 1 = 3
- Cycles:
  - 0 → 0 (length 1)
  - 1 → 2 → 1 (length 2)
  - 3 → 3 (length 1)
- LCM(1, 2, 1) = **2** → correct

**Example 3**: `n = 6`

- After computing cycles → LCM of lengths = **4** → correct

**Correct** — the number of operations needed to return to the identity permutation is exactly the **order of the permutation**, which is the **LCM of all cycle lengths** in its cycle decomposition.

---

## Pitfalls & Edge Cases

- **n = 2** → cycles of length 1 and 1 → LCM = 1 → correct
- **All fixed points** (identity transformation) → LCM = 1
- **Large n (≤ 1000)** → O(n) is perfectly fine
- **LCM overflow** → use `long` (maximum LCM for n ≤ 1000 is large but fits in 64-bit)
- **Modulo** → not needed here (answer ≤ n ≤ 1000)

All handled perfectly.

---

## Key Takeaway

This is a **classic permutation cycle decomposition** problem:

- Each operation defines a **fixed permutation** of the positions (0 to n-1)
- Reinitializing the permutation means applying this transformation repeatedly until we get back to the identity
- The smallest positive k such that perm^k = identity is the **order of the permutation**
- The order = **LCM of the lengths of all disjoint cycles** in the permutation
- Find all cycles in O(n) → compute their LCM → that's the answer

**Pure, clean, optimal** — perfect use of cycle decomposition to find reinitialization steps.

---

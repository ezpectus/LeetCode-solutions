# 788. Rotated Digits

---

## Problem Restatement
We need to count how many integers in the range `[1, n]` are **good**:
- A number is valid if every digit can be rotated 180° into another digit.
- Digits mapping:
  - 0, 1, 8 → rotate to themselves.
  - 2 ↔ 5, 6 ↔ 9 → rotate to each other.
  - Other digits (3, 4, 7) → invalid.
- A number is **good** if it is valid **and** after rotation becomes a different number.

---

## Approach
1. Iterate through all numbers from `1` to `n`.
2. For each number:
   - Check each digit:
     - If digit is invalid (3, 4, 7) → skip.
     - Track if at least one digit changes (2, 5, 6, 9).
   - If valid and at least one digit changes → count it.
3. Return the count.

---

## Code (C#)
```csharp
public class Solution {
    public int RotatedDigits(int n) {
        int count = 0;

        for(int i = 1;i <= n;i++) if(isGood(i)) count++;

        return count;
    }
    private bool isGood(int num){
        bool changed = false;
        while(num > 0){
            int d = num % 10;
            if(d == 3 || d == 4 || d ==7) return false;
            if(d == 2 || d == 5 || d == 6 || d ==9) changed = true;
            num /=10;
        }
        return changed;
    }
}
```

## Complexity
- **Time:** O(n * log n), because for each number up to `n` we check all its digits.  
- **Space:** O(1), only a few variables are used during digit checks.  

---

## Example Walkthrough

**Input:** `n = 10`  
- Good numbers: 2, 5, 6, 9 → count = 4 ✅  

**Input:** `n = 1`  
- Only number 1 → rotates to itself → not good → count = 0 ✅  

**Input:** `n = 2`  
- Numbers: 1 (not good), 2 (rotates to 5 → good) → count = 1 ✅  

---

## Conclusion
The algorithm works by scanning each number digit by digit:  
- Rejects numbers containing invalid digits (3, 4, 7).  
- Requires at least one digit to change (2, 5, 6, 9).  

This ensures correctness and yields an efficient **O(n log n)** solution for `n ≤ 10^4`.  

---




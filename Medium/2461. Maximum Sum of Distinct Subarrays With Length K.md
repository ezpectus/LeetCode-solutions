# 🧩 Problem: Maximum Sum of Distinct Subarrays With Length K

## 📜 Description

Given an integer array `nums` and an integer `k`, find the **maximum sum** of all subarrays of length `k` where **all elements are distinct**.

Return `0` if no such subarray exists.

---

## 🧠 Pattern Recognition

- **Sliding Window**: Fixed size `k`, move window one step at a time.
- **Distinct Constraint**: Use `HashSet` or `Dictionary` to track duplicates.
- **Sum Tracking**: Maintain running sum of current window.

---

## 🧮 Invariants and State

| Component        | Description                                      |
|------------------|--------------------------------------------------|
| `windowSum`      | Sum of current window                            |
| `seen`           | Set of elements in current window                |
| `maxSum`         | Maximum valid sum found so far                   |
| `left`           | Left pointer of window                           |

**Invariant**:  
At any point, `seen.Count == k` → window has `k` distinct elements → candidate for `maxSum`.

---

## 🧑‍💻 Code Skeleton (C#)

```csharp
public class Solution {
    public long MaximumSubarraySum(int[] nums, int k) {
        long maxSum = 0, windowSum = 0;
        int left = 0;
        HashSet<int> seen = new HashSet<int>();

        for (int right = 0; right < nums.Length; right++) {
            while (seen.Contains(nums[right])) {
                seen.Remove(nums[left]);
                windowSum -= nums[left];
                left++;
            }

            seen.Add(nums[right]);
            windowSum += nums[right];

            if (right - left + 1 == k) {
                maxSum = Math.Max(maxSum, windowSum);
                seen.Remove(nums[left]);
                windowSum -= nums[left];
                left++;
            }
        }

        return maxSum;
    }
}
```



⚙️ Performance  
**Time Complexity**: `O(n)` — each element is added and removed from the `HashSet` at most once.  
**Space Complexity**: `O(k)` — bounded by the size of the window and the set of unique elements.

---

🧱 Architectural Pattern: Fixed-Length Sliding Window with Uniqueness Constraint

---

🔧 Core Techniques

- **Window Expansion**: Move `right` forward to include new elements.
- **Window Contraction**: Move `left` forward when a duplicate is found to restore uniqueness.
- **Sum Maintenance**: Incrementally update the window sum as elements enter and exit.
- **Validation**: Only consider windows of size `k` that contain exactly `k` unique elements.

---

🧭 Real-World Analogies

| Domain             | Use Case                                      |
|--------------------|-----------------------------------------------|
| Network Monitoring | Track unique packets in a fixed time window   |
| Game Buffs         | Apply effects only if all conditions are met  |
| UI Event Streams   | Detect unique gesture sequences               |

---

✅ Engineering Takeaways

- This task blends **sliding window mechanics** with **set-based uniqueness enforcement**.
- The core challenge is maintaining a valid window while tracking an aggregate (e.g. sum).
- The pattern is highly reusable and generalizable across domains.

---

🔄 Generalizations

- **Variable-Length Windows**: Adapt the logic to support dynamic window sizes.
- **Frequency Maps**: Replace `HashSet` with `Dictionary<T, int>` to handle duplicates and counts.
- **Multi-Dimensional Windows**: Extend the concept to matrices, grids, or graphs.

---

📦 Reusability Notes

- Can be wrapped into a generic utility: `SlidingWindow<T>` with configurable constraints.
- Ideal for competitive programming, stream processing, and real-time analytics.
- Easily adapted to `Span<T>` for zero-copy slicing and performance-critical scenarios.

---

🧠 Debug Checklist

- ✅ Are duplicates correctly detected and removed?
- ✅ Is the sum updated consistently during window shifts?
- ✅ Is the window size condition (`right - left + 1 == k`) enforced before aggregation?
- ✅ Are edge cases (e.g. short arrays, all duplicates) handled gracefully?




---

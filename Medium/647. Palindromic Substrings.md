# 647. Palindromic Substrings  
**Dynamic Programming — Count All Palindromic Substrings**

---

## Problem

Given a string `s`, return the **total number of palindromic substrings** in it.  
A substring is **palindromic** if it reads the same forward and backward.

> **Goal**:  
> *Count **all** substrings that are palindromes*  
> *Include **single-character** substrings*  
> *Return **total count***

---

## Core Insight

This is a **substring enumeration problem** with **palindromic validation**.  
We use **dynamic programming** to track whether `s[i..j]` is a palindrome.

---

## Architectural Triggers

| Trigger | Implication |
|-------|-------------|
| “Substring” | Must check **all** `s[i..j]` |
| “Palindrome” | Requires **symmetric character check** |
| “Count all” | **No early exit** — full enumeration |
| “Length ≤ 1000” | **DP table is feasible** |

---

## DP Definition

```text
dp[i][j] = true if s[i..j] is palindrome
```
## Recurrence

| Length | Rule |
|--------|------|
| **1** | Always palindrome → `dp[i][i] = true` |
| **2** | `dp[i][i+1] = (s[i] == s[i+1])` |
| **≥ 3** | `dp[i][j] = dp[i+1][j-1] && (s[i] == s[j])` |

---

## Implementation (C#)

```csharp
public class Solution {
    public int CountSubstrings(string s) {
        int n = s.Length;
        if (n <= 0) return 0;

        int ans = 0;
        bool[,] dp = new bool[n, n];

        // Length 1 substrings
        for (int i = 0; i < n; ++i, ++ans)
            dp[i, i] = true;

        // Length 2 substrings
        for (int i = 0; i < n - 1; ++i) {
            dp[i, i + 1] = (s[i] == s[i + 1]);
            ans += dp[i, i + 1] ? 1 : 0;
        }

        // Length ≥ 3 substrings
        for (int len = 3; len <= n; ++len)
            for (int i = 0, j = i + len - 1; j < n; ++i, ++j) {
                dp[i, j] = dp[i + 1, j - 1] && (s[i] == s[j]);
                ans += dp[i, j] ? 1 : 0;
            }

        return ans;
    }
}
```
## Complexity

| Metric | Value |
|--------|-------|
| **Time** | **O(n²)** — all substrings checked |
| **Space** | **O(n²)** — DP table |

> Can be optimized to **O(n)** time using **expand-around-center** (2n-1 centers).

---

## Pitfalls

| Issue | Fix |
|------|-----|
| Forgetting base cases | Must initialize **length 1 and 2** substrings |
| Checking only full string | Must check **all substrings** |
| Missing symmetry condition | Use `s[i] == s[j] && dp[i+1][j-1]` |

---

## Insight

This is a **full substring enumeration problem**. It combines:

* **Palindrome detection**  
* **Dynamic programming for reuse**  
* **Layered recurrence by length**

> **Classic pattern**: build up palindromic substrings from smaller ones

---

## Fichka Library Entry

> **Strings**: count all palindromic substrings — **DP over substring intervals**

---

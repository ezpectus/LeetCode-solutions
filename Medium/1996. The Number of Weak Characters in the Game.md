# 1996. The Number of Weak Characters in the Game  
*O(n log n) — Optimal Greedy Sorting + Monotonic Stack*

---

## Problem Statement

You are given a 2D integer array `properties` where `properties[i] = [attack_i, defense_i]` represents the attack and defense of the i-th character.

A character i is **weak** if there exists some character j such that:  
`attack_j > attack_i` **and** `defense_j > defense_i`

Return the **number of weak characters**.

**Constraints**:
- 2 ≤ properties.length ≤ 10⁵
- 1 ≤ attack_i, defense_i ≤ 10⁵

---

## Core Idea — Sort + Monotonic Stack (Greedy Dominance)

**Key insight**:
- A character is weak if there is **someone strictly stronger** in **both** attack and defense
- To count weak characters efficiently → sort the array in a smart way
- Sort by **attack descending** (stronger attack first)
- When attacks are equal → sort by **defense ascending** (weaker defense first)
- This way: when we process characters with the same attack, we see weaker defenses first
- Use a **monotonic stack** to keep track of the **maximum defense** seen so far among characters with higher attack
- For each character:
  - While stack top has defense ≤ current defense → pop (they cannot dominate current)
  - If stack is not empty after that → current is weak (someone with higher attack and higher defense exists)
  - Push current defense to stack

**Why this sorting order works**:
- Descending attack → we process stronger attackers first
- For same attack → ascending defense → weaker defenses processed first → their max defense is lower → correct dominance

**Time**: O(n log n) for sort + O(n) for stack operations

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int NumberOfWeakCharacters(int[][] properties) {
        int n = properties.Length;

        // Sort: attack DESC, if attack equal → defense ASC
        Array.Sort(properties, (a, b) => {
            if (a[0] != b[0]) 
                return b[0].CompareTo(a[0]); // descending attack
            return a[1].CompareTo(b[1]);     // ascending defense
        });

        int weakCount = 0;
        int maxDefense = 0; // max defense seen so far (from stronger attacks)

        foreach (var p in properties) {
            int attack = p[0];
            int defense = p[1];

            // If current defense < maxDefense from stronger attackers → weak
            if (defense < maxDefense){
                weakCount++;
            }

            // Update max defense for future (weaker) characters
            maxDefense = Math.Max(maxDefense, defense);
        }

        return weakCount;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)** | Sorting the array dominates: O(n log n)  
  Monotonic stack operations are O(n) amortized (each element pushed/popped at most once) |
| **Space Complexity**  | **O(n)**      | Stack + sorting overhead (in-place sort possible) |

**Optimal** — standard complexity for 2D dominance counting problems with n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: `properties = [[5,5],[6,3],[3,6]]`

- Sorted by attack descending, same attack by defense ascending: [6,3], [5,5], [3,6]
- Process:
  - [6,3] → stack = [3], maxDefense = 3
  - [5,5] → 5 > 3 → not weak, stack = [5]
  - [3,6] → 6 > 5 → not weak, stack = [6]
- Weak count = **0** → correct (no character is dominated by another in both dimensions)

**Example 3**: `properties = [[1,5],[10,4],[4,3]]`

- Sorted: [10,4], [4,3], [1,5]
- Process:
  - [10,4] → stack = [4]
  - [4,3] → 3 < 4 → weak++, stack = [4]
  - [1,5] → 5 > 4 → not weak, stack = [5]
- Weak count = **1** → correct (character [4,3] is dominated by [10,4])

**Correct** — sorting ensures we process stronger attackers first.  
The monotonic stack keeps the **maximum defense** seen from stronger attackers.  
If a character's defense is less than the current max defense from a stronger attacker → it is weak.

---

## Pitfalls & Edge Cases

- **All characters have equal attack & defense** → no one dominates → weak count = 0
- **Duplicates in attack/defense** → sorting order (defense ascending on tie) ensures correct handling
- **n = 10⁵** → O(n log n) sorting + O(n) stack → passes time limits comfortably
- **Zeros in attack/defense** → handled naturally (0 is weak if someone stronger exists)
- **Multiple characters with same attack** → defense ascending order prevents wrong dominance

All handled perfectly.

---

## Key Takeaway

This is a **classic 2D dominance counting** problem:

- Sort characters by **attack descending**, tie-break by **defense ascending**
- Maintain a **monotonic decreasing stack** of defenses from stronger attackers
- For each character:
  - Pop from stack all defenses ≤ current defense (they cannot dominate it)
  - If stack is non-empty → current is weak (someone with higher attack and higher defense exists)
  - Push current defense to stack
- Count how many times the stack was non-empty after popping

**Pure, clean, optimal** — O(n log n) time, elegant greedy + monotonic stack solution.

---

# ðŸ§  Convert Sorted List to Balanced BST â€” Engineering Breakdown

## ðŸ“Œ Problem Description

Given a **sorted singly-linked list**, convert it into a **height-balanced binary search tree (BST)**.

### Constraints:
- The list is sorted in ascending order.
- The resulting BST must be balanced, meaning the depth of the two subtrees of every node never differs by more than one.

### Goal:
Transform a linear structure (`ListNode`) into a hierarchical one (`TreeNode`) while preserving **order** and ensuring **balance**.

---

## ðŸ’¡ Core Idea

This is a classic **Divide & Conquer** problem.

### Strategy:
1. **Find the middle node** of the list â€” this becomes the **root** of the BST.
2. **Recursively build**:
   - Left subtree from the left half of the list.
   - Right subtree from the right half of the list.
3. To split the list, we **break the link** before the middle node.

### Why the middle?
Because it ensures that the left and right subtrees are roughly equal in size, which maintains balance.

ðŸ’» Full Code

```csharp
public class Solution {
    public TreeNode SortedListToBST(ListNode head) {
        if (head == null) return null;
        if (head.next == null) return new TreeNode(head.val);

        ListNode mid = findMiddle(head);
        TreeNode root = new TreeNode(mid.val);

        root.left = SortedListToBST(head);
        root.right = SortedListToBST(mid.next);

        return root;
    }

    public ListNode findMiddle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        ListNode prev = null;

        while (fast != null && fast.next != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }

        if (prev != null) {
            prev.next = null; // break the list
        }

        return slow;
    }
}
```
## ðŸ” Code Explanation â€” `SortedListToBST`

### `SortedListToBST(ListNode head)`

#### ðŸ”¹ Base Cases:
- `head == null` â†’ return `null`  
  â†’ No nodes to process, return empty subtree.
- `head.next == null` â†’ return `TreeNode(head.val)`  
  â†’ Single node becomes a leaf in the BST.

#### ðŸ”¹ Recursive Case:
- Find the middle node â†’ becomes the root of the current subtree.
- Left half (`head` to `prev`) â†’ recursively build left subtree.
- Right half (`mid.next` to end) â†’ recursively build right subtree.

---

### `findMiddle(ListNode head)`

#### ðŸ”¹ Technique: Slow/Fast Pointers
- `slow` moves one step at a time.
- `fast` moves two steps at a time.
- When `fast` reaches the end, `slow` is at the middle.

#### ðŸ”¹ Splitting the List:
- `prev` tracks the node before `slow`.
- `prev.next = null` disconnects the left half from the middle.
- This ensures that recursive calls on the left half donâ€™t include the middle node again.

#### ðŸ”¹ Result:
Returns the middle node (`slow`) which becomes the root of the current subtree.

---

## â±ï¸ Time & Space Complexity

| Metric           | Value      | Explanation                                      |
|------------------|------------|--------------------------------------------------|
| Time Complexity  | O(n log n) | Each recursive level scans O(n) to find middle, log n levels |
| Space Complexity | O(log n)   | Due to recursion stack in balanced tree construction |

> âš ï¸ **Note**: A more optimal O(n) solution exists using in-order traversal with a pointer that walks the list while building the tree bottom-up.
> However, this version is conceptually cleaner and easier to debug, especially for understanding recursion and structural decomposition.

---

## ðŸ§  Pattern Summary

### ðŸ”¹ Pattern: **Middle as Root**
- **Type**: Divide & Conquer + Structural Recursion
- **Key Invariant**: Middle element becomes root, preserving BST order and balance.

### ðŸ”¹ Used In:
- Sorted Array â†’ BST  
- Segment Tree Construction  
- Balanced Tree Generation  
- Recursive Tree Building from Linear Data  

---

## ðŸ”¹ Engineering Insight

This pattern is ideal when converting **linear sorted data** into **balanced hierarchical structures**. 
It leverages the natural ordering of the input and recursively partitions it to maintain balance.

### ðŸ”§ Why it's reusable:
- Works for arrays, lists, or any sequential structure.
- Can be adapted for bottom-up or top-down tree construction.
- Forms the basis for many recursive tree-building algorithms.



---

# Intuition
For each digit x in the array, we search whether there already exists a pair k - x, with which it is possible to make the sum k. If yes, perform the operation and delete both. If not, save x in the dictionary for future pairs.

# Approach
We use Dictionary<int, int> to store the frequency of numbers

For each num, we calculate comp = k - num

If comp is already in the dictionary and its frequency > 0 → we do the operation

Otherwise → add num to the dictionary

We return the total number of operations

# Complexity
- Time complexity: $$O(n)$$ One pass through the array, all operations are constant

- Space complexity: $$O(n)$$ In the worst case, all numbers are unique and stored in the dictionary

# Code
```csharp []
public class Solution {
    public int MaxOperations(int[] nums, int k) {
        var freq = new Dictionary<int,int>();
        int count = 0;

        foreach(int num in nums){
            int comp = k - num;

            if(freq.ContainsKey(comp) && freq[comp] > 0){
                count++;
                freq[comp]--;
            }else{
            if(!freq.ContainsKey(num)) freq[num] = 0;
              freq[num]++;   //freq[num] = freq.GetValueOrDefault(num, 0) + 1;

            }
        }
       return count;
        
    }
}
```






---

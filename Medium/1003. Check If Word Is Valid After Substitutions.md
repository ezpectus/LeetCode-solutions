# 1003. Check If Word Is Valid After Substitutions — Architectural Stack-Based "abc" Reduction  
*O(n) — Optimal Greedy Stack Simulation*

---

## Problem Statement

Given string `s` consisting only of `'a'`, `'b'`, `'c'`.

String is **valid** if can be built from empty string by **repeatedly inserting** `"abc"` at **any position**.

Return `true` if valid, `false` otherwise.

---

## Core Idea — Greedy Stack Reduction of "abc"

**Key insight**:
- Valid string = multiple `"abc"` inserted in arbitrary positions/overlaps
- Equivalent: can **reduce** string to empty by **repeatedly removing** `"abc"` substrings
- Reverse of insertion → removal

**Perfect tool**: **stack**

**Simulation**:
- Traverse string left to right
- Push `'a'` and `'b'`
- When see `'c'`:
  - Check if top two are `'b'` then `'a'` → pop both (remove "abc")
  - Else → impossible

**At end**:
- Stack empty → fully reduced → valid
- Else → leftover characters → invalid

**Greedy** → pop whenever possible → maximal reduction.

---

##  Implementation (C++)

```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;

        for (char c : s)  {
            if (c == 'c') {
                // Need "ab" before 'c'
                if (st.empty() || st.top() != 'b')  return false;
                st.pop(); // pop 'b'

                if (st.empty() || st.top() != 'a') return false;
                st.pop(); // pop 'a'
            } 
              else  st.push(c); // 'a' or 'b'
        }

        return st.empty(); // valid only if fully reduced
    }
};
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass, each character pushed/popped ≤1 time |
| **Space Complexity**  | **O(n)**      | Stack worst case (all 'a' and 'b')             |

**Optimal** — linear time.

---

## Why This Works — Example Walkthrough

**Input**: `s = "aabcbc"`

- a → push → [a]
- a → push → [a,a]
- b → push → [a,a,b]
- c → top=b → pop → [a,a] → top=a → pop → [a]
- b → push → [a,b]
- c → top=b → pop → [a] → top=a → pop → []

→ **empty** → **true**

**Correct**.

**Input**: `s = "abccba"`

- a → [a]
- b → [a,b]
- c → pop b,a → []
- c → stack empty → **false**

**Correct**.

**Input**: `s = "abcabcababcc"`

- Step by step greedily removes multiple "abc" substrings (possibly overlapping in construction)
- Reduces to empty → **true**

**Perfect**.

---

## Pitfalls & Edge Cases

- **Extra 'c'** → no matching "ab" → false
- **"aabbcc"** → no valid "abc" sequence → false
- **Single "abc"** → reduces to empty → true
- **Overlapping insertions** (e.g., "abcabc") → stack handles correctly

All covered perfectly.

---

## Key Takeaway

This is a **beautifully elegant** stack problem:

- **Simulate reverse** of insertion → greedy remove "abc"
- **Stack** tracks unmatched 'a' and 'b'
- **Empty at end** → fully reducible → valid

**No recursion. No DP.**
**Pure, clean, optimal** — one of the most satisfying Medium stack problems.

---

# 958. Check Completeness of a Binary Tree

---

##  Problem Restatement
Given the root of a binary tree, determine if it is a **complete binary tree**.  
Definition: In a complete binary tree, every level except possibly the last is fully filled, and all nodes in the last level are as far left as possible.

Constraints:  
- `1 ≤ N ≤ 100`  
- `1 ≤ Node.val ≤ 1000`

---

##  Core Idea
- Traverse the tree level by level using **BFS**.  
- Once a `null` node is encountered, all subsequent nodes must also be `null`.  
- If a non‑null node appears after a `null`, the tree is not complete.  

---

##  Step‑by‑Step
1. Initialize a queue with the root node.  
2. Process nodes in BFS order.  
3. Track a flag `seenNull`.  
4. If `null` is seen, set `seenNull = true`.  
5. If a non‑null node appears after `seenNull = true`, return `false`.  
6. If traversal completes without violation, return `true`.

---

##  Code (C#)
```csharp
public class Solution {
    public bool IsCompleteTree(TreeNode root) {
        var queue = new Queue<TreeNode>();
        queue.Enqueue(root);
        bool seenNull = false;

        while (queue.Count > 0) {
            var node = queue.Dequeue();
            if (node == null) {
                seenNull = true;
            } else {
                if (seenNull) return false; // non-null after null → not complete
                queue.Enqueue(node.left);
                queue.Enqueue(node.right);
            }
        }
        return true;
    }
}
```
## Complexity
- **Time:** O(N) — each node is processed exactly once during BFS traversal.  
  The algorithm scans the tree level by level, ensuring completeness in linear time.  
- **Space:** O(N) — the queue may hold up to N nodes in the worst case (last level fully populated).  
  Memory usage is proportional to the number of nodes.

---

## Pitfalls
- **Null children handling:** Forgetting to enqueue `null` children breaks the completeness check, since gaps must be tracked explicitly.  
- **Early termination:** Once a `null` is seen, any subsequent non‑null node invalidates completeness. Must return `false` immediately.  
- **Edge cases:**  
  - Single node tree (`N=1`) → always complete.  
  - Perfect binary tree → trivially complete.  
  - Last level partially filled → must verify nodes are aligned to the left.  
- **Queue discipline:** Ensure BFS processes nodes strictly in level order; otherwise, completeness rules may be misapplied.

---

## Conclusion
This problem reduces to a **BFS structural validation**:  
- Traverse the tree in level order.  
- Enforce the invariant that once a gap (`null`) appears, no further nodes can exist.  

Because BFS naturally processes nodes left‑to‑right, it guarantees correctness.  
Result: a clean `O(N)` solution with queue, robust for `N ≤ 100`, and a textbook example of using BFS to validate binary tree properties.


---

# 861. Score After Flipping Matrix  
*Greedy Matrix Optimization — Row Normalization & Column Majority*

---

## Problem
You are given an `m × n` binary matrix `grid`.  
A **move** consists of **toggling every cell** in any row or column (`0 → 1`, `1 → 0`).  

Each row**row** is interpreted as a **binary number**.  
The **score** is the **sum of these numbers**.  

**Return the highest possible score** after any number of moves.

---

## Pattern
**Greedy normalization**:

1. **First column = MSB** → Ensure **all rows start with `1`**  
   → Flip any row where `grid[i][0] == 0`

2. **For each remaining column**, maximize the number of `1`s  
   → If `# of 1s ≤ n/2`, flip the column

3. After normalization → compute binary value of each row → sum

This is **optimal** because:
- Leftmost bits have the **highest weight**
- Each column’s contribution is **independent**
- Flipping a column **doubles or halves** its contribution

---

## Algorithm Breakdown

1. **Normalize rows**: flip if `grid[i][0] == 0`
2. **Count 1s per column**
3. **Flip column** if `count_1s ≤ n/2`
4. **Compute score** using binary weights

---

## Optimized Code (C++)

```cpp
#pragma GCC optimize ("Ofast")
#pragma GCC target ("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")
#pragma GCC optimize ("-ffloat-store")
#pragma GCC optimize ("O3", "unroll-loops")

class Solution {
public:
    int matrixScore(vector<vector<int>>& grid) {
        int n = grid.size();    // rows
        int m = grid[0].size(); // columns

        // Step 1: Normalize rows — ensure first column is all 1s
        for (int i = 0; i < n; ++i) {
            if (grid[i][0] == 0) {
                for (int j = 0; j < m; ++j) {
                    grid[i][j] ^= 1;  // flip entire row
                }
            }
        }

        // Step 2: Count 1s in each column
        vector<int> ones(m, 0);
        for (int j = 0; j < m; ++j) {
            for (int i = 0; i < n; ++i) {
                ones[j] += grid[i][j];
            }
        }

        // Step 3: Compute score
        int score = 0;
        for (int j = 0; j < m; ++j) {
            int max_ones = max(ones[j], n - ones[j]);  // after optimal flip
            score += max_ones * (1 << (m - j - 1));    // bit weight
        }

        return score;
    }
};

auto init = [](){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    return 'c';
}();
```


## Complexity
| Metric | Value |
|--------|-------|
| **Time** | **O(m·n)** — one pass to flip rows + one pass to count |
| **Space** | **O(m)** — column counts *(can be O(1) with in-place)* |

---

## Pitfalls & Fixes
| Issue | Fix |
|------|-----|
| Forgetting to normalize first column | **Always flip rows with `grid[i][0] == 0`** |
| Brute-forcing all moves | Use **greedy column majority** |
| Wrong bit weighting | Use `1 << (m - j - 1)` for column `j` |
| Modifying during counting | **Count after row flips** |

---

## Insight
This is a **greedy matrix optimization**:

> **Fix the highest-weighted bits first → optimize the rest independently**

- **Row flip** → guarantees **MSB = 1**  
- **Column flip** → maximizes contribution per bit position  
- **No interaction** between decisions → **greedy is optimal**

---

## Fichka Library Entry
**Category:** `Greedy / Matrix`  
**Pattern:** `Maximize binary matrix score by row normalization and column majority flipping`


---


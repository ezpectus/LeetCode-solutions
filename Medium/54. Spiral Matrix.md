# Pattern Name
**Spiral Traversal via Layered Boundary Shrinking**

## Problem Summary
- **Input**:  
  - A 2D matrix of integers `matrix` with dimensions `m × n`.
- **Goal**:  
  - Return all elements in **spiral order**, starting from top-left and moving **clockwise**.
- **Constraints**:
  - `1 ≤ m, n ≤ 10`
  - Values: `−100 ≤ matrix[i][j] ≤ 100`
  - Matrix is rectangular, not necessarily square.

## Core Idea
- This is a **layered traversal problem**.

## Solution
- Use **four boundaries**: `top`, `bottom`, `left`, `right`.
- Traverse in order:
  1. **Left → Right** (top row)
  2. **Top → Bottom** (right column)
  3. **Right → Left** (bottom row)
  4. **Bottom → Top** (left column)
- After each pass, **shrink** the corresponding boundary.

## Strategy Summary
- Initialize:
  - `top = 0`, `bottom = m - 1`
  - `left = 0`, `right = n - 1`
- While `top <= bottom && left <= right`:
  - Traverse **top row** → `left → right`
  - Traverse **right column** → `top+1 → bottom`
  - **If** `top < bottom`, traverse **bottom row** → `right-1 → left`
  - **If** `left < right`, traverse **left column** → `bottom-1 → top+1`
  - **Shrink boundaries**

## C# Implementation
```csharp
public class Solution {
    public IList<int> SpiralOrder(int[][] matrix) {
        List<int> result = new List<int>();
        int m = matrix.Length;
        int n = matrix[0].Length;

        int top = 0, bottom = m - 1;
        int left = 0, right = n - 1;

        while (top <= bottom && left <= right) {
            // Left → Right
            for (int j = left; j <= right; j++)
                result.Add(matrix[top][j]);
            top++;

            // Top → Bottom
            for (int i = top; i <= bottom; i++)
                result.Add(matrix[i][right]);
            right--;

            // Right → Left
            if (top <= bottom) {
                for (int j = right; j >= left; j--)
                    result.Add(matrix[bottom][j]);
                bottom--;
            }

            // Bottom → Top
            if (left <= right) {
                for (int i = bottom; i >= top; i--)
                    result.Add(matrix[i][left]);
                left++;
            }
        }

        return result;
    }
}
```

## Architectural Breakdown
| Component                 | Role                                      |
|---------------------------|-------------------------------------------|
| `top, bottom, left, right`| Track current layer boundaries            |
| `result`                  | Stores spiral traversal                   |
| `Loops`                   | Traverse each edge of the current layer   |
| `Boundary updates`        | Shrink layer after each pass              |

## Why This Approach Is Superior
| Aspect              | This Approach         | Naive Approach           |
|---------------------|-----------------------|---------------------------|
| Time Complexity     | O(m × n)              | O(m × n)                  |
| Space Complexity    | O(m × n)              | O(m × n)                  |
| Performance         | Clean, layer-wise     | Risk of index errors      |
| Generalizability    | Works for any m × n   | Hard to adapt without boundaries |

## Final Takeaway
- **This problem is about layer-wise traversal of a matrix in spiral order.**
- **The solution uses**:
  - Four boundaries to define current layer.
  - Clockwise traversal of edges.
  - Shrinking boundaries to move inward.
- **This pattern generalizes to any task involving**:
  - Matrix traversal with direction changes.
  - Layered processing.
  - Boundary-controlled iteration.
 
  ---

# ğŸ§  Minimum Height Trees â€“ Leaf Trimming Architecture

## ğŸ“˜ Problem Summary

You're given a tree with `n` nodes labeled from `0` to `n - 1`, and an array of `n - 1` edges.  
A tree is defined as a connected graph with no cycles.  
You can choose any node as the root, and the height of the tree is the longest path from the root to a leaf.  
Your task is to return **all root labels** that result in a **minimum height tree**.

### Example

```plaintext
Input: n = 4, edges = [[1,0],[1,2],[1,3]]
Output: [1]
```

## â“ Why DFS/BFS from every node doesn't work

At first glance, you might think:

- "Letâ€™s run DFS or BFS from every node and compute the height."
- But thatâ€™s O(nÂ²) time complexity â€” unacceptable for n â‰¤ 2 * 10â´.

## ğŸ” What the constraints tell us

- The graph is a tree â†’ no cycles, exactly n - 1 edges
- We need minimum height â†’ not just any traversal, but structural optimization
- Weâ€™re not finding paths â€” weâ€™re finding central nodes that minimize depth

## ğŸ§  Core Idea: Leaf Trimming (Inverse BFS)
Instead of growing the tree from a root, we trim it from the leaves inward.

Steps:

- Build the graph as an adjacency list
- Identify all leaf nodes (nodes with only one neighbor)
- Iteratively remove leaves layer by layer
- Stop when â‰¤ 2 nodes remain â€” these are the centers of the tree
- This is a reverse BFS, where each layer of leaves is peeled off until the core remains.

## ğŸ”§ C# Implementation

```csharp
public class Solution {
    public IList<int> FindMinHeightTrees(int n, int[][] edges) {
        if(n == 1) return new List<int> {0};

        var graph = new Dictionary<int, HashSet<int>>();
        for(int i = 0; i < n; i++) graph[i] = new HashSet<int>();

        foreach(var edge in edges){
            graph[edge[0]].Add(edge[1]);
            graph[edge[1]].Add(edge[0]);
        }

        var leaves = new List<int>();
        foreach(var node in graph.Keys){
            if(graph[node].Count == 1){
                leaves.Add(node);
            }
        }

        while(n > 2){
            n -= leaves.Count;
            var newLeaves = new List<int>();

            foreach(var leaf in leaves){
                int neighbor = graph[leaf].First();
                graph[neighbor].Remove(leaf);

                if(graph[neighbor].Count == 1){
                    newLeaves.Add(neighbor);
                }
            }

            leaves = newLeaves;
        }

        return leaves;
    }
}
```

## ğŸ§© Explanation

This solution doesn't perform classic DFS or BFS from each node.  
Instead, it applies a **reverse BFS strategy**, trimming the tree from its outermost leaves inward.

- The graph is built using a `Dictionary<int, HashSet<int>>` to represent adjacency.
- Leaf nodes are identified as those with only one neighbor (`graph[node].Count == 1`).
- In each iteration, all current leaves are removed.
- Their neighbors are updated, and any that become new leaves are added to the next layer.
- This process continues until the number of remaining nodes is â‰¤ 2.
- These remaining nodes are the **centers of the tree** â€” the only possible roots that yield minimum height.

This approach avoids brute-force traversal and instead **compresses the tree structurally**, layer by layer.

---

## ğŸ“¶ Signal Table

| Signal                          | Meaning / Role                          |
|----------------------------------|------------------------------------------|
| `graph[node].Count == 1`         | Identifies leaf nodes                   |
| `while (n > 2)`                  | Trimming continues until core remains   |
| `graph[neighbor].Remove(leaf)`   | Removes leaf from neighborâ€™s adjacency  |
| `if (graph[neighbor].Count == 1)`| Detects new leaf after pruning          |
| `leaves = newLeaves`             | Updates current layer of leaves         |
| `return leaves`                  | Final result: root candidates for MHTs  |

---

## âœ… Takeaways

- This is **not a traversal problem** â€” it's a **structural compression** problem.
- The key insight is to **invert BFS**, trimming leaves until the core remains.
- This pattern is reusable in problems involving:
  - Tree centroids  
  - Graph minimization  
  - Depth optimization

Even if the solution was inspired externally, once youâ€™ve **rewritten and explained it**,  
it becomes part of your **engineering system**.


---

# 1937. Maximum Number of Points with Cost — Architectural DP with Left/Right Max Optimization  
*O(m × n) — Optimal Linear DP with Monotonic Queue Trick*

---

## Problem Statement

Given `m × n` matrix `points`.

Choose **one cell per row**.

Score = **sum of chosen values** **minus** `abs(c1 - c2)` for every two consecutive rows.

Maximize final score.

---

## Core Idea - DP with Sliding Window Maximum

**DP definition**:
- `dp[r][c]` = max score **ending** at row `r`, column `c`

**Transition**:
- `dp[r][c] = points[r][c] + max over prev_c (dp[r-1][prev_c] - |prev_c - c|)`
- Equivalent: `points[r][c] + max(dp[r-1][prev_c] + prev_c) - c` **or** `points[r][c] + max(dp[r-1][prev_c] - prev_c) + c`

**Optimization**:
- Split into **two directions**:
  - Left to right: `max(dp[r-1][j] + j)` for j ≤ c
  - Right to left: `max(dp[r-1][j] - j)` for j ≥ c
- Use **two passes** to compute best from left and right
- No need monotonic queue — simple O(n) per row

**Final**:
- `dp[r][c] = points[r][c] + max(left[c], right[c])`

---

##  Implementation (C#)

```csharp
public class Solution {
    public long MaxPoints(int[][] points) {
        int m = points.Length;
        int n = points[0].Length;

        long[] dp = new long[n];
        // First row
        for (int c = 0; c < n; c++) dp[c] = points[0][c];
        for (int r = 1; r < m; r++){
            long[] newDp = new long[n];

            // Left to right: best from left (including same column)
            long leftMax = dp[0];
            for (int c = 0; c < n; c++)  {
                leftMax = Math.Max(leftMax, dp[c] + c);
                newDp[c] = Math.Max(newDp[c], points[r][c] + leftMax - c);
            }

            // Right to left: best from right
            long rightMax = dp[n-1] - (n-1);
            for (int c = n-1; c >= 0; c--) {
                rightMax = Math.Max(rightMax, dp[c] - c);
                newDp[c] = Math.Max(newDp[c], points[r][c] + rightMax + c);
            }

            dp = newDp;
        }

        long ans = long.MinValue;
        foreach (long val in dp)  ans = Math.Max(ans, val);
        
        return ans;
    }
}
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(m × n)**          | Two passes per row over n columns              |
| **Space Complexity**  | **O(n)**              | DP array for one row                           |

**Optimal** — linear in input size (m × n ≤ 10⁵).

---

## Why This Works — Example Walkthrough

**Input**: `[[1,2,3],[1,5,1],[3,1,1]]`

- **Row 0**: dp = [1, 2, 3]
- **Row 1**:
  - Left pass: compute max(dp[j] + j) for j ≤ c → best from left
    - For c=1: max from left = 3+2 = 5 → 5 - 1 = 4 → total = 5 + 4 = **9**
  - Right pass: max(dp[j] - j) for j ≥ c → best from right
    - For c=1: max from right = 3-2 = 1 → 1 + 1 = 2 → total = 5 + 2 = 7
  - Final dp[1] = max(9, 7) = **9** → overall for row 1: [4, 9, 4]
- **Row 2**:
  - Similar left/right passes on [4, 9, 4]
  - Best at center → **9**

**Correct** — maximum score 9.

---

## Pitfalls & Edge Cases

- **n=1** → just sum of the single column
- **m=1** → maximum value in the row
- **All values same** → no column penalty → full sum
- **Large values** → use `long` to avoid overflow

All handled perfectly.

---

## Key Takeaway

This is a **beautiful DP optimization**:

- **Split transition** → separate left-to-right and right-to-left max tracking
- **Two linear passes per row** → reduce from O(n²) to O(n)
- **No monotonic queue** needed → simple running max
**Pure, clean, optimal** — one of the best row-by-row DP problems.

---


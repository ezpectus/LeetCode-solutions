# 🎲 Random Pick with Weight — Engineering Breakdown

## 📌 Problem Description

- We are given a 0‑indexed array w of positive integers, where w[i] represents the weight of index i.
- We need to implement a function pickIndex() that randomly returns an index in the range [0, w.length - 1].

The probability of picking index i must be proportional to its weight:
```
P(i) = w[i] / sum(w)

Example: 
Input: w = [1, 3]

Total weight = 4
Probability of picking index 0 = 1/4 = 25%
Probability of picking index 1 = 3/4 = 75%
```

## 💡 Core Idea
This is a weighted random sampling problem. 
The trick is to transform the weights into a prefix sum array and then use binary search to map a random number into the correct index.

### Why Prefix Sum?
Prefix sums let us represent the weights as intervals on a number line.

Example: w = [1,3,2] → prefix = [1,4,6]

- Index 0 covers range [1]
- Index 1 covers range [2..4]
- Index 2 covers range [5..6]
- If we pick a random number between 1 and 6, we just need to find which interval it falls into.

### Why Binary Search?

- The prefix array is monotonic increasing.
- We can binary search for the smallest prefix ≥ target random number.
- This gives us the correct index in O(log n) time.

## 💻 Full Code (C#)

```csharp
public class Solution {
    private int[] pref;
    private Random random;

    public Solution(int[] w) {
        int n = w.Length;
        pref = new int[n];
        pref[0] = w[0];

        // Build prefix sum array
        for (int i = 1; i < n; i++) {
            pref[i] = pref[i - 1] + w[i];
        }

        random = new Random();
    }
    
    public int PickIndex() {
        // Pick random number in [1 .. totalWeight]
        int target = random.Next(1, pref[^1] + 1);

        // Binary search for smallest prefix >= target
        int left = 0;
        int right = pref.Length - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;

            if (pref[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return left;
    }
}
```

## 🔍 Code Explanation

In the constructor, we pre-build an array of prefix sums, pref, where each element stores the sum of all weights from the start to the current index.
That is, pref[i] = w[0] + w[1] + ... + w[i]. For example, if w = [1, 3, 2], the prefix array will be [1, 4, 6]. The last element, pref[^1], 
is equal to the total sum of weights and specifies the range from which we will select a random number.

The PickIndex() method works like this: first, we generate a random integer, target, in the range from 1 to totalWeight, inclusive. 
Then, using binary search, we find the smallest index i for which the condition pref[i] >= target is satisfied. This index is returned. This approach guarantees that the probability 
of selecting index i is proportional to its weight, w[i], because each index occupies a segment on the number line equal to its weight, and the random number falls within these segments with the desired probability.


## ⏱️ Time & Space Complexity

- Preprocessing (constructor): O(n) to build prefix sum.
- PickIndex(): O(log n) due to binary search.
- Space: O(n) for the prefix array.

## 🧠 Pattern Summary

- Pattern: Prefix Sum + Binary Search for Weighted Random Sampling
- Type: Randomization + Binary Search
- Key Invariant: Each index corresponds to a unique interval on the prefix sum line.

Used In:

- Weighted random selection
- Roulette wheel selection in genetic algorithms
- Probability distribution sampling

## ⚙️ Engineering Insight

The prefix sum transforms the problem into interval mapping, and binary search makes the lookup efficient. 
This is a reusable pattern whenever you need to sample from a discrete probability distribution defined by weights.



---

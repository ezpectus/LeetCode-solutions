## üß† Sliding Window with Cost ‚Äî Architectural Pattern

Sliding window is a powerful technique for problems involving contiguous subarrays or substrings. But in some cases, the window isn't fixed by size ‚Äî it's **adaptive**, constrained by a **cost function**.

This variant is useful when:

- You can modify elements (e.g., increment, replace) within a budget `k`
- You want to maximize the number of elements satisfying a condition
- The cost to include an element depends on its value and the current window state

**Core idea:**
> Expand the window while the cost of maintaining its validity is ‚â§ `k`. Shrink it when the cost exceeds `k`.

---

## üß© Problem: Frequency of the Most Frequent Element (Leetcode 1838)

### üìå Statement
You are given an integer array `nums` and an integer `k`. In one operation, you can increment any element by 1. Return the **maximum frequency** of any element after performing at most `k` operations.

---

## üß† Architectural Pattern: Sliding Window with Cost of Equalization

### üîß Key Insight
Sort `nums` to make it easier to equalize smaller elements to larger ones.

Use a window `[left..right]` such that all elements in the window can be incremented to match `nums[right]` within budget `k`.

---

### üßÆ Cost Formula
```plaintext
 cost = (right - left + 1) √ó nums[right] - sum(nums[left..right])

 (right - left + 1) ‚Üí size of the window

 nums[right] ‚Üí target value to equalize to

 sum(...) ‚Üí sum of elements in the window

 cost ‚Üí total operations needed to equalize all elements to nums[right]

 If cost > k, move left forward to shrink the window and reduce cost.
```

## üß± Invariants

- The window is always valid: all elements can be equalized to nums[right] within k
- Window state is updated incrementally (sum, size)
- Frequency = window size when invariant holds



```csharp
public class Solution {
    public int MaxFrequency(int[] nums, int k) {
        int n =nums.Length;
        int left = 0;
        int res = 0;
        long total = 0;
    
        Array.Sort(nums);
        for(int right =0; right < n;right++){
          total += nums[right];

     while((long)(right-left+1) * nums[right]- total > k){
             total -= nums[left];
             left++;

          }
          res = Math.Max(res,right-left+1);

        }

  return res;

    }
}
```
---
## ‚ö†Ô∏è Constraints

- 1 ‚â§ nums.length ‚â§ 10‚Åµ
- 1 ‚â§ nums[i], k ‚â§ 10‚Åµ

- Time: O(n log n) due to sorting + O(n) scan
- Space: O(1) extra if sum is tracked incrementally

## üß† Pattern Generalization
This technique applies to problems where:

- You want to maximize the number of equal elements
- You can modify elements with limited budget
- The cost of equalization is a function of value and window size




---

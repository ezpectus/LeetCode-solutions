# 1860. Incremental Memory Leak  
*O(√max(memory)) — Optimal Simulation with Math Insight*

---

## Problem Statement

You have two memory sticks with `memory1` and `memory2` bits available.

A faulty program runs and, at second `i` (starting from 1), **allocates i bits** to the stick with **more available memory** at that moment:

- If both have the same amount → allocates to **stick 1** (memory1)
- If neither stick has ≥ i bits left → program **crashes**

Return `[crashTime, memory1crash, memory2crash]` where:
- `crashTime` = the second when it crashes (1-based)
- `memory1crash`, `memory2crash` = remaining memory on each stick **at crash time**

---

## Core Idea — Direct Simulation (Fast Enough with Math)

**Key insight**:
- Each second i allocates **i** bits to the stick with **more** remaining memory
- Allocation is greedy → always prefers the one with more space (or stick 1 on tie)
- The total memory consumed after t seconds = sum_{i=1 to t} i = t(t+1)/2
- But split between two sticks depending on which had more at each step

**Naive simulation** (loop second by second) is too slow for memory up to 2³¹-1 (~2×10⁹) — would be O(√(2×10⁹)) ≈ 60k iterations → acceptable, but we can make it clean.

**Efficient simulation**:
- Keep two pointers: current memory of stick1 and stick2
- At each second i:
  - If memory1 >= memory2 → allocate i to stick1 (if enough)
  - Else allocate to stick2
  - If cannot allocate → crash at this second
- Since max memory ~2×10⁹ → max seconds ~ √(4×10⁹) ≈ 63k → safe to simulate directly

**Optimization note**:
- We can binary search the crash time, but direct simulation is simpler and fast enough.

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int[] MemLeak(int memory1, int memory2) {
        long m1 = memory1;
        long m2 = memory2;
        int time = 1;

        while (true) {
            // Allocate to the stick with more memory (stick1 on tie)
            if (m1 >= m2)  {
                if (m1 < time) return new int[] { time, (int)m1, (int)m2 };
                
                m1 -= time;
            } 
            else {
                if (m2 < time) return new int[] { time, (int)m1, (int)m2 };
                
                m2 -= time;
            }

            time++;
        }
    }
}
```


## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(√(memory1 + memory2))**   | Worst case: triangular number t(t+1)/2 ≈ total memory → t ≈ √(2 × 2³¹) ≈ 63k iterations max |
| **Space Complexity**  | **O(1)**                      | Only a few integer variables (long for safety) |

**Optimal** — direct simulation is extremely fast (max ~63k steps), simple, and perfectly correct under the constraints (memory ≤ 2³¹-1).

---

## Why This Works — Example Walkthrough

**Example 1**: `memory1 = 2`, `memory2 = 2`

- time=1: m1=2 >= m2=2 → allocate to m1 → m1=1, m2=2
- time=2: m1=1 < m2=2 → allocate to m2 → m1=1, m2=0
- time=3: m1=1 < 3 → cannot allocate → crash → **[3,1,0]** → correct

**Example 2**: `memory1 = 8`, `memory2 = 11`

- time=1: 8<11 → allocate to m2 → m2=10
- time=2: 8<10 → allocate to m2 → m2=8
- time=3: 8==8 → allocate to m1 → m1=5
- time=4: 5<8 → allocate to m2 → m2=4
- time=5: 5>4 → allocate to m1 → m1=0
- time=6: 0<4 → cannot allocate → crash → **[6,0,4]** → correct

**Correct** — always allocates the current second's requirement (i bits) to the stick with **more** remaining memory (stick1 on tie), crashes immediately when neither stick can satisfy the requirement.

---

## Pitfalls & Edge Cases

- **memory1 == memory2** → tie → always allocates to **stick1** (as per problem rule)
- **One stick starts at 0** → may crash at time=1 if i=1 > 0
- **Very large memory (≤ 2³¹-1)** → use `long` for m1, m2 (sum up to ~2×10⁹ fits safely)
- **No crash possible** → simulation stops when i bits cannot be allocated (always happens eventually)
- **Max iterations** → ~√(4×10⁹) ≈ 63k → negligible runtime

All handled perfectly.

---

## Key Takeaway

This is a **simple, clean, and optimal simulation** problem:

- Maintain current remaining memory on stick1 and stick2 (`long` for safety)
- For each second `i = 1, 2, 3, ...`:
  - Allocate `i` bits to the stick with **more** remaining memory
  - On **tie** → allocate to **stick1**
  - If **neither** stick has ≥ i bits left → crash at this second
  - Return `[crash_time, remaining1, remaining2]`

**Pure, clean, optimal** — direct simulation is fast enough (max ~63k iterations), easy to understand, and exactly follows the rules.

---

## 🧫 LeetCode 2415 — Reverse Odd Levels of Binary Tree

### 📜 Problem Summary

You're given the root of a **perfect binary tree**.  
Your task is to **reverse the node values** at each **odd level** of the tree.  
Return the root of the modified tree.

- A perfect binary tree has all parent nodes with two children and all leaves on the same level.
- The level of a node is the number of edges from the root to that node (root is level 0).

---

### 🧠 Core Insight

This is not a structural transformation — it's a **value-level swap**.  
Because the tree is perfect, we can traverse it **symmetrically** using two pointers:  
one from the left subtree and one from the right.

At each **odd level**, we swap the values of symmetric nodes.

---

### 🔍 Architectural Triggers

- **"Perfect binary tree"** → enables symmetric traversal  
- **"Reverse values at odd levels"** → requires level tracking  
- **"Return the same tree"** → no reconstruction, only value mutation  
- **"Recursive symmetry"** → ideal for DFS with paired traversal

---

### 🔧 Architectural Strategy

#### 🔹 Core Structures

- Recursive helper `Reverse(left, right, level)`  
- Two pointers traverse the tree symmetrically  
- Swap values only when `level % 2 == 1`

#### 🔹 Execution Phases

1. Start recursion from `root.left` and `root.right` at level 1  
2. At each recursive step:
   - If level is odd → swap `left.val` and `right.val`
   - Recurse into:
     - `left.left` and `right.right`
     - `left.right` and `right.left`

---

## 🚀 C# Implementation

```csharp
public class Solution {
    public TreeNode ReverseOddLevels(TreeNode root) {
        Reverse(root.left, root.right, 1);
        return root;
    }

    private void Reverse(TreeNode left, TreeNode right, int level) {
        if (left == null || right == null) return;

        // Swap values at odd levels
        if (level % 2 == 1) {
            int temp = left.val;
            left.val = right.val;
            right.val = temp;
        }

        // Recurse symmetrically
        Reverse(left.left, right.right, level + 1);
        Reverse(left.right, right.left, level + 1);
    }
}
```

## ⏱️ Time and Space Complexity

| Metric | Complexity | Explanation |
|--------|------------|-------------|
| Time   | O(n)       | Each node is visited exactly once during the symmetric DFS traversal. |
| Space  | O(log n)   | The recursion depth equals the height of the tree, which is log(n) for a perfect binary tree. |

---

## 🧱 Minimal Recall Block

```text
Perfect binary tree → symmetric DFS  
Reverse values at odd levels  
Traverse: (left.left, right.right) and (left.right, right.left)
```
## 🧩 Generalization Pattern — Symmetric DFS with Level Awareness

### 📌 Applicable Scenarios

This architectural pattern applies to problems involving:

- **Mirror-based transformations**  
- **Level-specific mutations**  
- **Perfect binary tree operations**

---

### 🔹 Core Idea

- Traverse the tree **symmetrically** using paired pointers  
- Track the **current level** to apply conditional logic  
- **Mutate values** without altering the tree structure

---

### 🧠 Engineering Takeaways

- **Symmetric DFS** is ideal for perfect binary trees  
- **Level tracking** enables precise control over mutations  
- No extra space or reconstruction needed — transformation is **in-place**

> You don’t rebuild the tree — you traverse it symmetrically and mutate values by level.


---


## ðŸ§« LeetCode 2415 â€” Reverse Odd Levels of Binary Tree

### ðŸ“œ Problem Summary

You're given the root of a **perfect binary tree**.  
Your task is to **reverse the node values** at each **odd level** of the tree.  
Return the root of the modified tree.

- A perfect binary tree has all parent nodes with two children and all leaves on the same level.
- The level of a node is the number of edges from the root to that node (root is level 0).

---

### ðŸ§  Core Insight

This is not a structural transformation â€” it's a **value-level swap**.  
Because the tree is perfect, we can traverse it **symmetrically** using two pointers:  
one from the left subtree and one from the right.

At each **odd level**, we swap the values of symmetric nodes.

---

### ðŸ” Architectural Triggers

- **"Perfect binary tree"** â†’ enables symmetric traversal  
- **"Reverse values at odd levels"** â†’ requires level tracking  
- **"Return the same tree"** â†’ no reconstruction, only value mutation  
- **"Recursive symmetry"** â†’ ideal for DFS with paired traversal

---

### ðŸ”§ Architectural Strategy

#### ðŸ”¹ Core Structures

- Recursive helper `Reverse(left, right, level)`  
- Two pointers traverse the tree symmetrically  
- Swap values only when `level % 2 == 1`

#### ðŸ”¹ Execution Phases

1. Start recursion from `root.left` and `root.right` at level 1  
2. At each recursive step:
   - If level is odd â†’ swap `left.val` and `right.val`
   - Recurse into:
     - `left.left` and `right.right`
     - `left.right` and `right.left`

---

## ðŸš€ C# Implementation

```csharp
public class Solution {
    public TreeNode ReverseOddLevels(TreeNode root) {
        Reverse(root.left, root.right, 1);
        return root;
    }

    private void Reverse(TreeNode left, TreeNode right, int level) {
        if (left == null || right == null) return;

        // Swap values at odd levels
        if (level % 2 == 1) {
            int temp = left.val;
            left.val = right.val;
            right.val = temp;
        }

        // Recurse symmetrically
        Reverse(left.left, right.right, level + 1);
        Reverse(left.right, right.left, level + 1);
    }
}
```

## â±ï¸ Time and Space Complexity

| Metric | Complexity | Explanation |
|--------|------------|-------------|
| Time   | O(n)       | Each node is visited exactly once during the symmetric DFS traversal. |
| Space  | O(log n)   | The recursion depth equals the height of the tree, which is log(n) for a perfect binary tree. |

---

## ðŸ§± Minimal Recall Block

```text
Perfect binary tree â†’ symmetric DFS  
Reverse values at odd levels  
Traverse: (left.left, right.right) and (left.right, right.left)
```
## ðŸ§© Generalization Pattern â€” Symmetric DFS with Level Awareness

### ðŸ“Œ Applicable Scenarios

This architectural pattern applies to problems involving:

- **Mirror-based transformations**  
- **Level-specific mutations**  
- **Perfect binary tree operations**

---

### ðŸ”¹ Core Idea

- Traverse the tree **symmetrically** using paired pointers  
- Track the **current level** to apply conditional logic  
- **Mutate values** without altering the tree structure

---

### ðŸ§  Engineering Takeaways

- **Symmetric DFS** is ideal for perfect binary trees  
- **Level tracking** enables precise control over mutations  
- No extra space or reconstruction needed â€” transformation is **in-place**

> You donâ€™t rebuild the tree â€” you traverse it symmetrically and mutate values by level.


---


# 3583. Count Special Triplets — Architectural O(n) Masterpiece  
*O(n) — Linear Scan with Frequency DP*

---

## Problem  

Given an integer array `nums`, count the number of **special triplets** `(i, j, k)` such that:

- `0 ≤ i < j < k < n`
- `nums[i] == nums[j] × 2`
- `nums[k] == nums[j] × 2`

Return the count **modulo 10⁹ + 7**.

**Constraints**  
- `3 ≤ n ≤ 10⁵`  
- `0 ≤ nums[i] ≤ 10⁵`

---

## Core Idea — Streaming Frequency DP  

We need triplets where:  
> `nums[i] = nums[j] × 2` **and** `nums[k] = nums[j] × 2`

Instead of brute force, we **stream** through the array and maintain:

- `dp[val]` → how many times `val` has appeared so far  
- `pairs[val]` → how many `(i,j)` pairs exist where `nums[i] == nums[j] × 2 == val`

When we process a number `x`:
- It acts as **k** → add `pairs[x]` to answer (all `(i,j,x)`)
- Then it acts as **j** → update `pairs[x×2] += dp[x×2]` (prepare for future k)
- Finally → `dp[x]++`

**One pass. No backtracking.**

---

## Full Implementation (C#)

```cpp

using System;

public class Solution{
    public int SpecialTriplets(int[] nums){
        const int MOD = 1_000_000_007;
        const int MAXV = 100005;
        long[] cnt = new long[MAXV];     // count of value so far
        long[] pairs = new long[MAXV];   // number of (i,j) where nums[i] == nums[j]*2
        
        long result = 0;
        
        foreach (int num in nums){
            // Complete all triplets where current num is k
            result = (result + pairs[num]) % MOD;
            
            // Prepare pairs for future k: current num as j
            long twice = (long)num * 2;
            if (twice < MAXV)  pairs[twice] = (pairs[twice] + cnt[twice]) % MOD;
            
            // Update count
            cnt[num]++;
        }
        
        return (int)result;
    }
}
```



## Complexity  

| **Metric** | **Value**       | **Notes**                          |
|----------|-----------------|------------------------------------|
| **Time** | **O(n)**        | Single pass over the array         |
| **Space**| **O(10⁵)**      | Two frequency arrays (`cnt`, `pairs`) |

---

## Pitfalls & Edge Cases  

| **Issue**                | **Fix**                                           |
|--------------------------|---------------------------------------------------|
| `2 * num` overflow       | Cast to `long long` / `long` before multiplying   |
| Array index out of bounds| `if (twice < MAXV)` guard                         |
| Modulo overflow          | Use `long` for arithmetic + `% MOD`               |
| Zeros                    | Works perfectly: `0 == 0 × 2`                    |
| Duplicates               | Handled automatically by frequency counting       |

---

## Insight — Reusable Fichka  

> **Counting Triplets with Multiplicative Relations in O(n)**

### Pattern  
- Use **two frequency maps**  
- **Stream** through the array once  
- **Update future** state using current element  
- **Accumulate** answer using past state  

### Applies to  
- Count `a[i] × 2 == a[j]`, `a[j] × 2 == a[k]`  
- Any arithmetic/geometric progression counting  
- Any **chained relation** (`f(a) = b`, `f(b) = c`)** relation in linear scan  

**Fichka**:  
> When you have a triplet with relation `f(a) = b` and `f(b) = c`:  
> **Maintain two layers of counts** —  
> **past → current → future**  
> → solve in **O(n)** instead of O(n³) or O(n²)


**Final Verdict**:  
**O(n). Elegant. Zero brute force. Pure frequency magic.**

---

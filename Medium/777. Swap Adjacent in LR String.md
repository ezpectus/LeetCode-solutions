# 777. Swap Adjacent in LR String

---

## Problem Summary
We are given two strings `start` and `result` consisting of characters `'L'`, `'R'`, and `'X'`.  
- Allowed moves:  
  - Replace `"XL"` with `"LX"` (move `L` left).  
  - Replace `"RX"` with `"XR"` (move `R` right).  
- Task: return `true` if `start` can be transformed into `result` using a sequence of valid moves, otherwise return `false`.

---

## Code Idea
1. **Ignore `X` characters**  
   - Since `X` is just a placeholder, the relative order of `L` and `R` must remain the same in both strings.  
   - If after removing all `X` characters, the sequences of `L` and `R` differ → return `false`.  

2. **Two-pointer traversal**  
   - Use pointers `i` for `start` and `j` for `result`.  
   - Skip over `X` in both strings.  
   - When both point to `L` or `R`, check movement rules:  
     - `L` can only move **left** → so its index in `start` must be **≥** index in `result`.  
     - `R` can only move **right** → so its index in `start` must be **≤** index in `result`.  
   - If any rule is violated → return `false`.  

3. **End check**  
   - After traversal, ensure both pointers reach the end.  
   - If yes → return `true`.  

---

## Code (C#)
```csharp
public class Solution {
    public bool CanTransform(string start, string result) {
        int n = start.Length;
        int i = 0, j = 0;

        while (i < n && j < n) {
            // Skip X in both strings
            while (i < n && start[i] == 'X') i++;
            while (j < n && result[j] == 'X') j++;

            if (i < n && j < n) {
                if (start[i] != result[j]) return false;

                if (start[i] == 'L' && i < j) return false; // L can only move left
                if (start[i] == 'R' && i > j) return false; // R can only move right

                i++;
                j++;
            }
        }

        // Skip remaining X
        while (i < n && start[i] == 'X') i++;
        while (j < n && result[j] == 'X') j++;

        return i == n && j == n;
    }
}
```


## Complexity
- **Time:** O(n), single pass through both strings.  
- **Space:** O(1), only pointers used.  

---

## Pitfalls
- Must ensure relative order of `L` and `R` is preserved.  
- `L` cannot move right, `R` cannot move left.  
- Handle trailing `X` correctly.  
- Edge case: single-character strings.  

---

## Example Walkthrough
**Input:** `start = "RXXLRXRXL"`, `result = "XRLXXRRLX"`  
- Remove `X`: both → `"RLRL"`.  
- Traverse: all rules satisfied.  
- **Output:** `true`.  

**Input:** `start = "X"`, `result = "L"`  
- Remove `X`: `" "` vs `"L"`.  
- Different sequences.  
- **Output:** `false`.  

---

## Conclusion
This problem reduces to checking **relative order and movement constraints** of `L` and `R`.  
- Efficient O(n) solution with two pointers.  
- Correctly handles edge cases and ensures valid transformations.  


---

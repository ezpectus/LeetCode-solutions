# 539. Minimum Time Difference

---

## Problem Restatement
We are given a list of time points in **24-hour format** `"HH:MM"`.  
We need to return the **minimum difference in minutes** between any two time points.

Constraints:
- 2 ≤ timePoints.length ≤ 2 × 10⁴  
- Each time point is valid `"HH:MM"` format.  

---

## Key Idea
- Convert each time string into **minutes since midnight**.  
- Sort the list of minutes.  
- Compute differences between consecutive times.  
- Also check the **circular difference** between the last and first time (wrap around midnight).  
- Return the minimum difference.

---

## Code (C#)
```csharp
public class Solution {
    public int FindMinDifference(IList<string> timePoints) {
        int n = timePoints.Count;
        int[] minutes = new int[n];

        // Convert "HH:MM" to minutes
        for (int i = 0; i < n; i++) {
            string[] parts = timePoints[i].Split(':');
            int h = int.Parse(parts[0]);
            int m = int.Parse(parts[1]);
            minutes[i] = h * 60 + m;
        }

        Array.Sort(minutes);

        int minDiff = int.MaxValue;
        for (int i = 1; i < n; i++) {
            minDiff = Math.Min(minDiff, minutes[i] - minutes[i - 1]);
        }

        // Wrap-around difference (last vs first across midnight)
        int wrapDiff = (24 * 60 - minutes[n - 1]) + minutes[0];
        minDiff = Math.Min(minDiff, wrapDiff);

        return minDiff;
    }
}
```


## Time Complexity
- **Sorting step:** O(n log n) to arrange all time points in ascending order of minutes.  
- **Difference calculation:** O(n) to compute consecutive differences and the wrap-around case.  
- **Overall:** O(n log n).  

---

## Space Complexity
- **Minutes array:** O(n) to store converted times.  
- **Extra variables:** constant space for indices and minimum difference tracking.  
- **Total:** O(n).  

---

## Example Walkthrough

### Example 1
**Input:** ["23:59","00:00"]  
- Converted = [1439, 0] → Sorted = [0, 1439].  
- Differences: 1439 − 0 = 1439.  
- Wrap-around: (1440 − 1439) + 0 = 1.  
- Minimum = 1 ✅  

### Example 2
**Input:** ["00:00","23:59","00:00"]  
- Converted = [0, 1439, 0] → Sorted = [0, 0, 1439].  
- Differences: 0 − 0 = 0, 1439 − 0 = 1439.  
- Wrap-around: (1440 − 1439) + 0 = 1.  
- Minimum = 0 ✅  

### Example 3
**Input:** ["05:30","06:00","23:00"]  
- Converted = [330, 360, 1380] → Sorted = [330, 360, 1380].  
- Differences: 360 − 330 = 30, 1380 − 360 = 1020.  
- Wrap-around: (1440 − 1380) + 330 = 390.  
- Minimum = 30 ✅  

---

## Why This Works
- Sorting ensures only consecutive differences need to be checked.  
- Wrap-around accounts for midnight crossing (last vs first).  
- Duplicate times automatically yield difference = 0.  
- Conversion to minutes simplifies arithmetic and avoids string parsing during comparisons.  

---

## Edge Cases
- **Duplicate times:** immediate result = 0.  
- **All times evenly spaced:** minimum difference equals spacing.  
- **Times near midnight:** wrap-around ensures correct calculation.  
- **Large input size (20,000):** sorting and linear scan remain efficient.  

---

✅ **Conclusion**  
By converting times to minutes, sorting, and checking consecutive plus wrap-around differences, we achieve an efficient **O(n log n)** solution with **O(n)** space.  
This approach is robust, handles duplicates and midnight wrap-around seamlessly, and scales well to the maximum constraint of 20,000 time points.


---

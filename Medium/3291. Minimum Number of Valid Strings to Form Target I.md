# 3291. Minimum Number of Valid Strings to Form Target I

---

##  Problem Statement
We are given:
- An array of strings `words`.
- A string `target`.

A string `x` is **valid** if it is a prefix of any string in `words`.  
We want to form `target` by concatenating valid strings.  
Return the **minimum number** of valid strings needed, or `-1` if impossible.

---

##  Core Idea
- This is a **segmentation problem**: break `target` into chunks, each chunk must be a prefix of some word in `words`.
- Naive DP with substring checks → O(n²) → too slow.
- Optimized approach:
  - Build a **Trie** from all words.
  - Mark every node as valid (since every prefix is valid).
  - Use **DP**:
    - `dp[i]` = minimum number of valid strings to form `target[0..i-1]`.
    - From each position `i`, traverse forward in `target` using the Trie.
    - Whenever a prefix matches, update `dp[j+1]`.

---

##  Code (C#)
```csharp
public class Solution {
    public int MinValidStrings(string[] words, string target) {
        int n = target.Length;
        TrieNode root = new TrieNode();

        // Build Trie
        foreach (var w in words) {
            var node = root;
            foreach (char c in w) {
                int idx = c - 'a';
                if (node.Children[idx] == null)
                    node.Children[idx] = new TrieNode();
                node = node.Children[idx];
                node.IsPrefix = true; // every prefix is valid
            }
        }

        int[] dp = new int[n + 1];
        Array.Fill(dp, int.MaxValue);
        dp[0] = 0;

        // DP traversal using Trie
        for (int i = 0; i < n; i++) {
            if (dp[i] == int.MaxValue) continue;
            var node = root;
            for (int j = i; j < n; j++) {
                int idx = target[j] - 'a';
                if (node.Children[idx] == null) break;
                node = node.Children[idx];
                if (node.IsPrefix) {
                    dp[j + 1] = Math.Min(dp[j + 1], dp[i] + 1);
                }
            }
        }

        return dp[n] == int.MaxValue ? -1 : dp[n];
    }

    class TrieNode {
        public TrieNode[] Children = new TrieNode[26];
        public bool IsPrefix;
    }
}
```

##  Complexity
- **Build Trie:** O(sum of lengths of words) ≤ 10^5  
- **DP traversal:** O(n * L), where `n = target.Length`, `L` = average word length  
- **Space:** O(sum of lengths of words + n)  

---

##  Pitfalls
- Must mark **every node** in Trie as prefix, not just word ends  
- Ensure `dp[i]` is reachable before expanding  
- Stop traversal when Trie path breaks  
- Handle case when target cannot be formed → return `-1`  

---

##  Example Walkthrough
**Input:**  
`words = ["abc","aaaaa","bcdef"]`  
`target = "aabcdabc"`

### Step 1: Build Trie
- `"abc"` → prefixes: `"a","ab","abc"`  
- `"aaaaa"` → `"a","aa","aaa","aaaa","aaaaa"`  
- `"bcdef"` → `"b","bc","bcd","bcde","bcdef"`  

### Step 2: DP progression
- `target[0..1] = "aa"` → valid → `dp[2] = 1`  
- `target[2..4] = "bcd"` → valid → `dp[5] = 2`  
- `target[5..7] = "abc"` → valid → `dp[8] = 3`  

**Result:**  
`3`

---

##  Conclusion
This problem reduces to **prefix segmentation with DP + Trie**.  
- Trie efficiently checks valid prefixes  
- DP ensures minimal concatenation count  
- Avoids costly substring operations and passes large test cases without


---





# 2598. Smallest Missing Non-negative Integer After Operations

## Given

- An integer array `nums`
- An integer `value`
- You may apply any number of operations: add or subtract `value` from any element
- Goal: Return the **maximum possible MEX** (minimum excluded non-negative integer) after all operations

---

## Architectural Signals

- ✅ Any number of ±value operations → normalize by modulo  
- ✅ MEX requires greedy coverage from `0` upward  
- ✅ Fixed modulus space → bounded by `value`  
- ✅ No rollback needed → greedy scan is safe  
- ✅ Negative numbers allowed → modulo normalization required

---

## Core Idea

Each number `x` can be transformed into any `x + k * value` or `x - k * value`.  
This means we can generate **all numbers** that share the same `mod = x % value`.

So we:

- Normalize each `x` to its mod class  
- Count how many times each mod class appears  
- Greedily scan `i = 0, 1, 2, ...` and try to cover each `i` using available mod classes  
- The first `i` we cannot cover is the MEX

---

## Execution Scheme

1. **Normalize mod classes**  
   - For each `x`, compute `mod = ((x % value) + value) % value`  
   - Count frequency of each mod class

2. **Greedy scan for MEX**  
   - For `i = 0, 1, 2, ...`:
     - Compute `mod = i % value`
     - If `count[mod] > 0` → decrement and continue
     - Else → return `i` as MEX

---

## Code (C#)

```csharp
public class Solution {
    public int FindSmallestInteger(int[] nums, int value) {
        var count = new Dictionary<int, int>();

        foreach (int x in nums) {
            int mod = ((x % value) + value) % value;
            if (!count.ContainsKey(mod)) count[mod] = 0;
            count[mod]++;
        }

        for (int i = 0; ; i++) {
            int mod = i % value;
            if (count.ContainsKey(mod) && count[mod] > 0) {
                count[mod]--;
            } else {
                return i;
            }
        }
    }
}
```

## Complexity

| Metric | Value     | Notes                                      |
|--------|-----------|--------------------------------------------|
| Time   | O(n + M)  | `n` for counting, `M` for greedy scan until MEX |
| Space  | O(value)  | Dictionary holds at most `value` keys      |

This solution is linear in input size and bounded by the modulus space.

---

## Pitfalls

- ❌ Forgetting to normalize negative `x` → incorrect mod class  
- ❌ Not checking `ContainsKey(mod)` → runtime exception  
- ❌ Limiting scan to `i < n` → MEX can exceed `nums.Length`  
- ❌ Trying to simulate operations → unnecessary, modulo logic suffices

---

## Insight

This is a **modulo-based greedy template** for problems involving:

- Arbitrary ±k operations  
- Coverage of integer ranges  
- MEX computation  
- Fixed-size residue classes

### Key components:

- **Modulo normalization** → ensures correct class for negative values  
- **Frequency map** → tracks available coverage per class  
- **Greedy scan** → builds MEX incrementally without rollback

---

## Generalization

This structure applies to:

- Any task where elements can be shifted by ±k  
- Problems requiring MEX after transformation  
- Coverage-based greedy selection over integer space

This is not a task-specific patch —  
it’s a **deployable module** for greedy MEX problems with modulo normalization.


---

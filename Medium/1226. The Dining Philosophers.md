# 1226. The Dining Philosophers — Architectural Resource Hierarchy Deadlock Prevention  
*O(1) per operation — Optimal Lock Ordering with Fork IDs*

---


## Problem Statement

5 philosophers around a table, 5 forks.

Each philosopher needs **both left and right forks** to eat.

Goal: prevent **deadlock** while allowing concurrent eating.

Calls:
- `pickLeftFork`, `pickRightFork`
- `eat`
- `putLeftFork`, `putRightFork`

Implement `wantsToEat` to safely acquire forks.

---

## Core Idea — Resource Hierarchy (Break Circular Wait)

**Key insight**:
- Classic deadlock: all philosophers pick left → wait for right → cycle
- **Solution**: impose **total order** on resources (forks)
- Always acquire **lower-numbered fork first**

**Rule**:
- For philosopher `i`:
  - Left fork = `i`
  - Right fork = `(i+1) % 5`
- If `i < (i+1)%5` → pick left then right
- Else → pick right then left (to always pick lower ID first)

**Why this prevents deadlock**:
- Breaks **circular wait** condition
- All philosophers acquire forks in **increasing order** → no cycle

---

## Full Optimal Implementation (C++)

```cpp
class DiningPhilosophers {
private:
    mutex forks[5]; // one mutex per fork

public:
    DiningPhilosophers() {}

    void wantsToEat(int philosopher,
                    function<void()> pickLeftFork,
                    function<void()> pickRightFork,
                    function<void()> eat,
                    function<void()> putLeftFork,
                    function<void()> putRightFork) {
        int left = philosopher;
        int right = (philosopher + 1) % 5;

        // Always lock lower index first to avoid deadlock
        if (left > right) {
            swap(left, right);
        }

        // Acquire forks in order
        forks[left].lock();
        forks[right].lock();

        // Pick forks
        pickLeftFork();
        pickRightFork();

        // Eat
        eat();

        // Put forks down
        putLeftFork();
        putRightFork();

        // Release locks
        forks[right].unlock();
        forks[left].unlock();
    }
};
```


## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time per eat**      | **O(1)**      | Constant lock operations                       |
| **Space Complexity**  | **O(1)**      | 5 fixed mutexes                                |

**Optimal** — deadlock-free, maximal concurrency.

---

## Why This Works — Execution Flow

**Example**:

- **Phil 0**: left=0, right=1 → lock 0 then 1
- **Phil 1**: left=1, right=2 → lock 1 then 2
- **Phil 2**: left=2, right=3 → lock 2 then 3
- **Phil 3**: left=3, right=4 → lock 3 then 4
- **Phil 4**: left=4, right=0 → swap → lock 0 then 4

All philosophers acquire forks in **strictly increasing order of fork IDs**.

**Result**: No circular wait → **impossible to form a cycle** → **no deadlock**.

---

## Pitfalls & Edge Cases

- **Symmetric locking** (always left then right) → classic deadlock possible
- **Random order** → deadlock possible
- **Resource hierarchy** → forces consistent order → breaks circular wait condition
- **No starvation** → C++ `std::mutex` is fair (FIFO waiting)

All handled perfectly.

---

## Key Takeaway

This is a **classic deadlock prevention** technique:

- **Resource ordering** → always lock lower-numbered resource first
- **Breaks circular wait** → one of the four necessary conditions for deadlock
- **Simple and efficient** → minimal overhead, maximum concurrency

**Pure, clean, optimal** — perfect dining philosophers solution.

---

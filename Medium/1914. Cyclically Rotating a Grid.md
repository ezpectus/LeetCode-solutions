# 1914. Cyclically Rotating a Grid  
*O(m × n + k % cycle_length) — Optimal Layer Extraction + Rotation*

---

## Problem Statement

- You are given an m × n integer matrix `grid` where both m and n are **even** (2 ≤ m,n ≤ 50, 1 ≤ grid[i][j] ≤ 5000), and an integer k (1 ≤ k ≤ 10⁹).
- The matrix consists of **layers** (like onion rings), each layer is a cycle of cells.
- A **cyclic rotation** rotates **each layer counter-clockwise** by 1 position.
- Apply **k** such rotations to the grid and return the resulting matrix.
- **Note**: since k can be up to 10⁹, we cannot simulate k times → use modulo cycle length.

---

## Core Idea — Extract Layers as Cycles + Rotate + Rebuild

**Key insight**:
- The grid has **min(m,n)/2** layers (since m and n even)
- Layer 0: outermost border
- Layer 1: next inner border
- ...
- Layer min(m,n)/2 - 1: innermost rectangle

**Each layer is a cycle**:
- Top row left to right
- Right column top to bottom (excluding corners already counted)
- Bottom row right to left
- Left column bottom to top (excluding corners)

**Cycle length** for layer l:
- Perimeter of the rectangle at layer l
- width = n - 2×l
- height = m - 2×l
- cycle_length = 2×(width + height) - 4 (corners counted twice)

**Steps**:
1. For each layer l from 0 to min(m,n)/2 - 1:
   - Extract the cycle as a 1D list (counter-clockwise order)
   - Rotate the list by **k % cycle_length** positions
   - Put the rotated values back into the grid
2. Return the modified grid

**Why counter-clockwise?**
- Problem says: "each element will take the place of the adjacent element in the counter-clockwise direction"
- So we extract in counter-clockwise order → rotate left (shift forward)

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int[][] RotateGrid(int[][] grid, int k) {
        int m = grid.Length;
        int n = grid[0].Length;

        // Number of layers
        int layers = Math.Min(m, n) / 2;

        for (int l = 0; l < layers; l++) {
            // Extract cycle for layer l
            List<int> cycle = ExtractCycle(grid, l, m, n);

            // Cycle length
            int cycleLen = cycle.Count;

            // Effective rotations (k can be huge)
            int shift = (int)(k % cycleLen);

            // Rotate left by shift (counter-clockwise)
            List<int> rotated = new List<int>();
            for (int i = shift; i < cycleLen; i++) {
                rotated.Add(cycle[i]);
            }
            for (int i = 0; i < shift; i++) {
                rotated.Add(cycle[i]);
            }

            // Put back into grid
            PutCycleBack(grid, l, rotated, m, n);
        }

        return grid;
    }

    private List<int> ExtractCycle(int[][] grid, int layer, int m, int n) {
        List<int> cycle = new List<int>();

        int top = layer;
        int bottom = m - 1 - layer;
        int left = layer;
        int right = n - 1 - layer;

        // Top row left → right
        for (int j = left; j <= right; j++) {
            cycle.Add(grid[top][j]);
        }

        // Right column top → bottom (exclude top corner)
        for (int i = top + 1; i <= bottom; i++) {
            cycle.Add(grid[i][right]);
        }

        // Bottom row right → left (exclude right corner)
        for (int j = right - 1; j >= left; j--) {
            cycle.Add(grid[bottom][j]);
        }

        // Left column bottom → top (exclude bottom corner)
        for (int i = bottom - 1; i > top; i--) {
            cycle.Add(grid[i][left]);
        }

        return cycle;
    }

private void PutCycleBack(int[][] grid, int layer, List<int> cycle, int m, int n) {
        int top = layer;
        int bottom = m - 1 - layer;
        int left = layer;
        int right = n - 1 - layer;

        int idx = 0;

        // Top row
        for (int j = left; j <= right; j++) {
            grid[top][j] = cycle[idx++];
        }

        // Right column
        for (int i = top + 1; i <= bottom; i++) {
            grid[i][right] = cycle[idx++];
        }

        // Bottom row
        for (int j = right - 1; j >= left; j--) {
            grid[bottom][j] = cycle[idx++];
        }

        // Left column
        for (int i = bottom - 1; i > top; i--) {
            grid[i][left] = cycle[idx++];
        }
    }
}
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(m × n)**          | For each of min(m,n)/2 layers: extract cycle O(perimeter) + put back O(perimeter) → total O(m × n) since sum of perimeters over all layers = O(m × n) |
| **Space Complexity**  | **O(m + n)**          | Temporary cycle list per layer (max size O(m + n) for outermost layer) + recursion stack negligible |

**Optimal** — linear time, each cell is processed constant times (extract + put back), handles huge k (≤ 10⁹) instantly via modulo cycle length.

---

## Why This Works — Example Walkthrough

**Example 1**: `grid = [[40,10],[30,20]]`, `k = 1`

- Only 1 layer (outer border)
- Cycle extracted counter-clockwise: 40 → 10 → 20 → 30
- Cycle length = 4
- k % 4 = 1
- Rotate left by 1: 10 → 20 → 30 → 40
- Put back:
  - Top row: 10
  - Right column: 20
  - Bottom row: 30
  - Left column: 40
- Result: [[10,20],[40,30]] → correct

**Example 2**: larger 4×4 grid, k = 2

- Multiple layers (outer + inner 2×2)
- Outer layer: large perimeter, rotate by 2 % outer_cycle_len
- Inner layer: small 2×2 perimeter, rotate by 2 % inner_cycle_len
- Each layer rotated independently → final grid matches example

**Correct** — each layer is extracted as a 1D cycle (counter-clockwise order), rotated by k modulo its perimeter length, and placed back → preserves cyclic rotation per layer.

---

## Pitfalls & Edge Cases

- **k very large (10⁹)** → modulo cycle length reduces it to [0, cycle_len) instantly — no simulation needed
- **m = n = 2** → single layer, cycle length = 4 (top → right → bottom → left)
- **Innermost layer 2×2** → cycle length = 4, rotates correctly
- **k = 0** → no rotation → return original grid unchanged
- **Different layer sizes** → each layer has its own perimeter → independent rotation

All handled perfectly.

---

## Key Takeaway

This is a **beautifully elegant layer-by-layer rotation** problem:

- Number of layers = min(m, n) / 2 (since m and n even)
- For each layer l (0 = outer, increases inward):
  - Extract the perimeter as a 1D cycle in **counter-clockwise** order
  - Cycle length = 2 × (width + height) - 4 (subtract 4 double-counted corners)
  - Rotate the cycle left by **k % cycle_length** positions
  - Put rotated values back into the same layer positions
- Each layer rotates independently — no interaction between layers

**Pure, clean, optimal** — O(m × n) time to process all cells, huge k handled instantly via modulo.
---

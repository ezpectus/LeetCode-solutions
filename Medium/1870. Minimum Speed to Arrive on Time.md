# 1870. Minimum Speed to Arrive on Time  
*O(n log M) — Optimal Binary Search on Speed*

---

## Problem Statement

You are given an integer array `dist` of length `n` (1 ≤ n ≤ 10⁵), where `dist[i]` is the distance (in km) of the i-th train ride.

You have `hour` hours (floating-point, 1 ≤ hour ≤ 10⁹, up to 2 decimal places) to reach the office.

You must take the trains in order. Each train departs only at **integer hours**, so you may wait between rides.

- Time for i-th train = `ceil(dist[i] / speed)` hours (since speed is integer km/h)
- You wait until next integer hour before departing next train (except the last one — no wait after last train)

Find the **minimum integer speed** (km/h) such that total time ≤ `hour`.

Return -1 if impossible.

---

## Core Idea — Binary Search on Speed

**Key insight**:
- Higher speed → lower travel time → monotonic property
- We binary search the minimum speed such that total time ≤ `hour`
- For a given speed, compute total time:
  - For each train i (except last): time_i = ceil(dist[i] / speed)
  - For last train: time_last = dist[n-1] / speed (no wait after last)
  - Total time = sum(time_1 to time_{n-1}) + time_last
- If total ≤ hour → possible → try smaller speed
- Else → need higher speed

**Search range**:
- Low = 1
- High = 10⁷ (since dist[i] ≤ 10⁵, n ≤ 10⁵ → max needed speed ~10⁷)

**Ceil division**:
- ceil(a/b) = (a + b - 1) / b (integer division)

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MinSpeedOnTime(int[] dist, double hour) {
        int n = dist.Length;
        int left = 1;
        int right = 10_000_000; // sufficient upper bound
        int ans = -1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            // Compute total time needed at speed = mid
            double totalTime = 0;

            // All trains except last: ceil(dist[i] / mid)
            for (int i = 0; i < n - 1; i++)  {
                totalTime += (dist[i] + mid - 1) / mid;
            }

            // Last train: dist[n-1] / mid (floating point, no ceil)
            totalTime += (double)dist[n - 1] / mid;

            if (totalTime <= hour) {
                // Possible → try smaller speed
                ans = mid;
                right = mid - 1;
            } 
            else {
                // Too slow → need higher speed
                left = mid + 1;
            }
        }

        return ans;
    }
}
```


## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n log M)**        | Binary search over speed range (1 to ~10⁷, log M ≈ 23 iterations) × O(n) time to check each mid speed |
| **Space Complexity**  | **O(1)**              | Only a few variables (no extra arrays needed)  |

**Optimal** — logarithmic search on the answer (speed), with linear time verification per candidate — standard and efficient for n ≤ 10⁵ and large possible speeds.

---

## Why This Works — Example Walkthrough

**Example 1**: `dist = [1,3,2]`, `hour = 6`

- Try speed = 1:
  - Train 1: ceil(1/1) = 1
  - Train 2: ceil(3/1) = 3
  - Train 3: 2/1 = 2.0 (no ceil on last train)
  - Total time = 1 + 3 + 2.0 = **6.0** ≤ 6 → possible
- No smaller positive integer speed → answer = **1** → correct

**Example 2**: `dist = [1,3,2]`, `hour = 2.7`

- Try speed = 3:
  - Train 1: ceil(1/3) = 1
  - Train 2: ceil(3/3) = 1
  - Train 3: 2/3 ≈ 0.6667
  - Total = 1 + 1 + 0.6667 ≈ **2.6667** ≤ 2.7 → possible
- Speed = 2:
  - Train 1: ceil(1/2)=1
  - Train 2: ceil(3/2)=2
  - Train 3: 2/2 = 1.0
  - Total = 1 + 2 + 1 = **4.0** > 2.7 → impossible
- Minimum speed = **3** → correct

**Example 3**: `hour = 1.9`

- Even very large speed → first two trains take at least 1+1 = 2 hours (ceil) → total > 1.9 → **-1** → correct

**Correct** — binary search efficiently finds the smallest integer speed where total travel time (with ceiling waits on all but last train) is ≤ hour.

---

## Pitfalls & Edge Cases

- **n = 1** → no waiting → just `ceil(dist[0] / speed) ≤ hour`
- **hour has decimal places** → compare using `double` (no precision issues since we use exact ceil)
- **Very large distances** → use `long` for intermediate calculations in ceil: `(dist[i] + speed - 1) / speed`
- **hour < n-1** → impossible (at least n-1 integer waits + some travel time)
- **speed = 1** → gives maximum possible time (worst case)

All handled perfectly.

---

## Key Takeaway

This is a **classic binary search on answer** problem with floating-point time:

- Binary search the minimal integer **speed** (1 to some large enough upper bound, e.g. 10⁷)
- For each candidate speed `mid`:
  - Compute total time needed:
    - First n-1 trains: `ceil(dist[i] / mid)` — includes waiting to next integer hour
    - Last train: `dist[n-1] / mid` (floating point, no ceil/wait after last)
  - If total time ≤ `hour` → possible → try smaller speed
  - Else → need higher speed
- Return the minimal speed found, or -1 if no speed works

**Pure, clean, optimal** — logarithmic search with linear verification per candidate.

---

# 🧩 Pattern: Frequency-Bounded Partitioning

## 🔍 Problem Statement
Given an array `nums` and an integer `k`, determine whether it's possible to partition `nums` into groups of size `k` such that:

- Every element appears in at most one group  
- Each group contains only unique elements  
- All elements are used

---

## 🧠 Core Invariants

| Invariant       | Meaning                                                  |
|-----------------|----------------------------------------------------------|
| `n % k == 0`     | Total number of elements must be divisible by group size |
| `freq[x] ≤ n / k`| No element can appear more times than the number of groups |


---

## 🏗️ Architectural Template

```csharp
1. Check divisibility: if n % k != 0 → return false
2. Build frequency map: freq[x] = count of x in nums
3. Compute max group count: groups = n / k
4. Validate: if any freq[x] > groups → return false
5. Return true
```


## ⚙️ Complexity

- **Time:** O(n) — single pass for frequency map + validation  
- **Space:** O(n) — worst-case for frequency dictionary

---

## 🧱 Engineering Notes

This pattern generalizes to **resource allocation** problems where each resource (element) must be distributed across fixed-size slots (groups) without exceeding capacity.

Can be extended to:
- **Task scheduling**
- **Inventory balancing**
- **Load distribution**
- **Unique assignment constraints**

---

## 🧪 Edge Cases to Validate

| Case                          | Expected |
|------------------------------|----------|
| `nums = [1,1,1,2,2,2], k = 3` | ✅ true  |
| `nums = [1,1,1,1], k = 2`     | ❌ false |
| `nums = [1,2,3,4], k = 3`     | ❌ false (not divisible) |
| `nums = [1,2,2,3,3,4], k = 2` | ✅ true  |

---

## 🧭 Reusability Tags

- `#FrequencyMap`  
- `#GroupPartitioning`  
- `#InvariantValidation`  
- `#GreedyFeasibilityCheck`



```csharp
public class Solution {
    public bool PartitionArray(int[] nums, int k) {
        int n = nums.Length;
        if(n % k != 0) return false;

        var freq = new Dictionary<int,int>();

        foreach(int num in nums){
            if(!freq.ContainsKey(num)) freq[num] = 0;
            freq[num]++;

        }

      int groups = n /k;
      foreach(var count in freq.Values){
        if(count > groups) return false;
      }
      
   return true;

    }
}
```




---

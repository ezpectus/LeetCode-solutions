# LeetCode 1024 — Video Stitching  
**Approach: Greedy Interval Covering**

---

##  Problem Restatement
We are given video clips `[start, end]` that can overlap. We want the minimum number of clips needed to cover the entire interval `[0, time]`. If impossible, return `-1`.

---

##  Core Idea
This is a **classic interval covering problem**:
- For each possible start time, record the farthest end time reachable.  
- Sweep from `0` to `time`, maintaining:
  - `maxEnd`: farthest end reachable so far.  
  - `curr`: current coverage boundary.  
- Whenever we pass beyond `curr`, we must "take" another clip, so increment result and extend `curr` to `maxEnd`.  
- If at any point `i > maxEnd`, coverage is impossible → return `-1`.

This greedy strategy ensures minimal clips because we always extend coverage as far as possible before committing to a new clip.

---

##  Optimized Implementation (C#)

```csharp
public class Solution {
    public int VideoStitching(int[][] clips, int time) {
        int[] maxReach = new int[time + 1];

        // Precompute farthest reach for each start
        foreach (var clip in clips) {
            int start = clip[0], end = clip[1];
            if (start <= time) {
                maxReach[start] = Math.Max(maxReach[start], end);
            }
        }

        int res = 0, curr = 0, maxEnd = 0;

        for (int i = 0; i <= time; i++) {
            if (i > maxEnd) return -1; // cannot cover this point

            if (i > curr) {
                res++;
                curr = maxEnd; // extend coverage
            }
            maxEnd = Math.Max(maxEnd, maxReach[i]);
        }

        return res;
    }
}
```



##  Time Complexity
- **Precompute farthest reach:**  
  Iterate over all clips once → `O(n)` where `n = clips.Length`.  
- **Greedy sweep:**  
  Traverse from `0..time` updating coverage → `O(time)`.  
- **Overall:**  
  → `O(n + time)`.

---

##  Space Complexity
- **maxReach array:**  
  Stores farthest reach for each start index up to `time` → `O(time)`.  
- **Other variables:**  
  Only counters (`res`, `curr`, `maxEnd`) → `O(1)`.  
- **Total:**  
  → `O(time)`.

---

#  Impact of Design Choices

| Design Choice                  | Effect                                                                 |
|--------------------------------|------------------------------------------------------------------------|
| **Greedy sweep**               | Ensures minimal clips by always extending coverage maximally.          |
| **Precompute farthest reach**  | Simplifies sweep logic, avoids repeated scanning of clips.             |
| **Increment only when needed** | Guarantees minimal count of clips, avoids unnecessary increments.      |

---

#  Pitfalls
- **Forgetting to check `i > maxEnd`:**  
  May incorrectly assume coverage is possible when it is not.  
- **Not updating `curr` correctly:**  
  Can lead to overcounting clips.  
- **Ignoring clips beyond `time`:**  
  Wastes computation and may cause incorrect indexing.  

---

#  Conclusion
- **What it gives:** Minimum number of clips to cover `[0, time]`.  
- **Why it matters:** Efficient greedy solution avoids complex DP and ensures optimal coverage.  
- **Key takeaway:**  
  1. Precompute farthest reach for each start.  
  2. Sweep with greedy extension.  
  3. Increment clip count only when necessary.  
  4. Return `-1` if coverage breaks before reaching `time`.  

---

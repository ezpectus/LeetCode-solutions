# 1033. Moving Stones Until Consecutive — Architectural Gap-Based Min/Max Calculation  
*O(1) — Optimal Direct Math Formula*

---

## Problem Statement

Given three distinct positions `a, b, c` on number line.

**Move**: take endpoint stone → place in unoccupied position **between** endpoints.

Game ends when stones in **three consecutive** positions.

Return `[min_moves, max_moves]`.

---

## Core Idea — Sort + Gap Analysis

**Sort** positions → `x < y < z`

**Game ends** when `z - x == 2` (positions x, x+1, x+2)

**Maximum moves**:
- Each move reduces total gap by **1**
- Initial gaps: `y - x - 1` + `z - y - 1` = `z - x - 2`
- Max moves = **z - x - 2**

**Minimum moves**:
- Goal: make consecutive as fast as possible
- Cases:
  - If **already consecutive** (`z - x == 2`) → 0
  - If **one gap ≤1** (stones almost consecutive, e.g., 1,2,5 or 1,3,4) → **1 move**
  - Else (gaps ≥2 on both sides, e.g., 1,3,6) → **2 moves**

**Min moves** = 
- `0` if `z - x == 2`
- `1` if `y - x <= 2 || z - y <= 2`
- `2` otherwise

---

## Implementation (C#)

```csharp
public class Solution {
    public int[] NumMovesStones(int a, int b, int c) {
        int[] pos = { a, b, c };
        Array.Sort(pos);
        int x = pos[0], y = pos[1], z = pos[2];
        int maxMoves = z - x - 2;

        int minMoves;
        if (z - x == 2)  minMoves = 0; 
        else if (y - x <= 2 || z - y <= 2)  minMoves = 1; 
        else  minMoves = 2; 
        
        return new int[] { minMoves, maxMoves };
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(1)**      | Just sorting 3 numbers                         |
| **Space Complexity**  | **O(1)**      | Constant space                                 |

**Optimal** — direct math, no loops needed.

---

## Why This Works — Example Walkthrough

**Input**: `a=1, b=2, c=5` → sorted `[1,2,5]`

- max = 5 - 1 - 2 = **2**
- min: y-x = 2-1 = 1 ≤ 2 → **1**

→ `[1,2]` correct.

**Input**: `a=4, b=3, c=2` → sorted `[2,3,4]`

- max = 4 - 2 - 2 = **0**
- min: z-x = 2 → **0**

→ `[0,0]` correct.

**Input**: `a=3, b=5, c=1` → sorted `[1,3,5]`

- max = 5 - 1 - 2 = **2**
- min: y-x = 3-1 = 2 ≤ 2 → **1**  
  (can move 1 to 4 → [3,4,5] in one move)

→ `[1,2]` correct.

---

## Pitfalls & Edge Cases

- **Already consecutive** → `[0,0]`
- **One small gap** (≤2) → 1 move
- **Large gaps on both sides** → 2 moves
- **Input in any order** → sort first

All handled perfectly.

---

## Key Takeaway

This is a **beautifully mathematical** problem:

- **Max moves** = total gaps between stones = `z - x - 2`
- **Min moves** = 0, 1, or 2 based on gap sizes
- **No simulation** needed — pure formula

**Pure, clean, optimal** — one of the best math-based game problems.

---

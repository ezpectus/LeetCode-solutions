# 676. Implement Magic Dictionary — Architectural Solution (Trie Version)

## Problem Statement
Design a data structure with:

- `buildDict(string[] dictionary)` — store distinct words
- `search(string searchWord)` — return true if we can change **exactly one** character in `searchWord` to match any dictionary word

Constraints:  
- ≤ 100 words
- word length ≤ 100
- lowercase letters
- ≤ 100 searches

## Core Idea
Use a **Trie** to store the dictionary.

For `search`, perform DFS on the Trie with a flag `mismatchUsed`:

- At each position, we can either match the character or use the one allowed mismatch.
- If we reach the end of the word and have used **exactly one** mismatch → true

This is efficient and shows good design skills (even though brute force is faster here).

## Implementation (C#) 

```csharp
public class MagicDictionary {
    private class TrieNode {
        public bool IsWord;
        public TrieNode[] Children = new TrieNode[26];
    }

    private TrieNode root;
    public MagicDictionary() {
        root = new TrieNode();
    }
    
    public void BuildDict(string[] dictionary) {
        foreach (string word in dictionary) {
            TrieNode node = root;
            foreach (char c in word)  {
                int idx = c - 'a';
                if (node.Children[idx] == null) 
                    node.Children[idx] = new TrieNode();
                node = node.Children[idx];
            }
            node.IsWord = true;
        }
    }
    
    public bool Search(string searchWord) {
        return Dfs(root, searchWord, 0, false);
    }

    private bool Dfs(TrieNode node, string word, int i, bool mismatchUsed) {
        if (node == null) return false;
        if (i == word.Length)   return mismatchUsed && node.IsWord;
        

        int idx = word[i] - 'a';

        if (!mismatchUsed) {
            if (Dfs(node.Children[idx], word, i + 1, false)) return true;

  
            for (int j = 0; j < 26; j++) {
                if (j != idx && node.Children[j] != null) {
                    if (Dfs(node.Children[j], word, i + 1, true)) return true;
                }
            }
        } 
        else return Dfs(node.Children[idx], word, i + 1, true);
        

        return false;
    }
}
```


## Complexity Analysis

* **BuildDict**: **O(S)**  
  S — total number of characters across all dictionary words. Each character is processed once to insert into the Trie.

* **Search**: **O(26 × L)** in the worst case  
  L — length of `searchWord`.  
  At each position, when a mismatch is allowed, we explore up to 26 branches.  
  With L ≤ 100 → maximum ~2600 operations per search → completely negligible.

* **Space**: **O(S)**  
  Trie nodes store the dictionary. Each character creates at most one new node → linear in total input size.

## Pitfalls & Edge Cases

* **Exactly one mismatch** — the flag `mismatchUsed` must ensure we neither accept zero mismatches (exact match) nor more than one.
* **Word exists exactly in dictionary** — should return **false** (we are required to change one character).
* **Different lengths** — Trie naturally handles this: shorter/longer words won't reach `IsWord` at the correct depth.
* **Multiple words share prefixes** — Trie efficiently shares nodes, but DFS must explore all possible mismatch branches.
* **No possible match** — correctly returns false when no path with exactly one mismatch reaches a word end.
* **Single-character words** — changing the only character is valid if the resulting character exists in the dictionary.

## Conclusion
Trie combined with DFS and a "one-mismatch" flag is the **classic architectural pattern** for "search with exactly one edit (replacement)" queries.

While brute force over the dictionary is simpler and sufficient for the given constraints (≤100 words), the Trie approach demonstrates:

* Clean object-oriented design with node structure
* Optimal prefix sharing across words
* Excellent scalability — easily handles thousands of words or longer strings
* Readiness for extensions (e.g., allow insertions/deletions → full Levenshtein distance)

This is the **expected "design-focused" answer** in system-design or algorithm interviews when a search-with-edit operation is required.

Master this pattern (Trie + DFS with state flags) — and you instantly solve any problem involving "find word with exactly k differences" or similar constrained edits.



---




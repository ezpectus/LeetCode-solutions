# LeetCode 449 — Serialize and Deserialize BST  
**Approach: Preorder Traversal + BST Property**

---

##  Problem Restatement
We need to design an algorithm to serialize (encode) a BST into a compact string and deserialize (decode) it back into the original tree structure.  
Constraints: up to `10^4` nodes, values in `[0, 10^4]`.

---

##  Core Idea
- **Serialization:**  
  - Perform **preorder traversal** (root → left → right).  
  - Store node values separated by commas.  
  - Example: `[2,1,3]` → `"2,1,3"`.  

- **Deserialization:**  
  - Parse string into integer list.  
  - Rebuild BST using preorder + BST property:  
    - Each node’s left subtree contains values `< root`.  
    - Each node’s right subtree contains values `> root`.  
  - Use recursion with bounds (`min`, `max`) to decide where each value belongs.  

This avoids storing null markers and keeps the string compact.

---

##  Implementation (C#)

```csharp
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public string serialize(TreeNode root) {
        var vals = new List<string>();
        void Preorder(TreeNode node) {
            if (node == null) return;
            vals.Add(node.val.ToString());
            Preorder(node.left);
            Preorder(node.right);
        }
        Preorder(root);
        return string.Join(",", vals);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(string data) {
        if (string.IsNullOrEmpty(data)) return null;
        var nums = data.Split(',').Select(int.Parse).ToList();
        int idx = 0;

        TreeNode Build(int min, int max) {
            if (idx >= nums.Count) return null;
            int val = nums[idx];
            if (val < min || val > max) return null;
            idx++;
            var node = new TreeNode(val);
            node.left = Build(min, val);
            node.right = Build(val, max);
            return node;
        }

        return Build(int.MinValue, int.MaxValue);
    }
}
```

#  Complexity Analysis — LeetCode 449 (Serialize and Deserialize BST)

---

##  Time Complexity
- **Serialization:**  
  - Preorder traversal visits each node exactly once.  
  - Complexity: `O(n)`.  

- **Deserialization:**  
  - Each value is processed once and placed into the BST using bounds.  
  - Complexity: `O(n)`.  

---

##  Space Complexity
- **Output string size:** `O(n)` (each node value stored as text).  
- **Recursion stack:** `O(h)` where `h` = tree height.  
  - Worst case (skewed tree): `O(n)`.  
  - Best case (balanced tree): `O(log n)`.  

---

#  Impact of Design Choices

| Design Choice          | Effect                                                                 |
|------------------------|------------------------------------------------------------------------|
| **Preorder traversal** | Compact representation without null markers.                          |
| **Bounds in recursion**| Ensures correct BST reconstruction by respecting BST property.         |
| **Comma-separated string** | Simple and efficient parsing, avoids overhead of complex formats. |

---

#  Pitfalls
- **Forgetting bounds check:** Tree reconstructed incorrectly, violating BST property.  
- **Using inorder traversal:** Cannot uniquely reconstruct BST (multiple trees possible).  
- **Adding null markers:** String becomes unnecessarily large and less compact.  

---

#  Conclusion
- **What it gives:** Compact serialization of BST using preorder traversal.  
- **Why it matters:** Efficiently encodes/decodes without extra null markers, keeping string minimal.  
- **Key takeaway:**  
  1. Serialize with preorder traversal.  
  2. Deserialize using recursion with bounds.  
  3. Achieves `O(n)` time and space efficiency.  


---

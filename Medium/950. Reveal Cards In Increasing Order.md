# 950. Reveal Cards In Increasing Order — Architectural Reverse Simulation with Deque  
*O(n log n) — Optimal Sort + Reverse Process*

---

## Problem Statement

Given array `deck` of unique integers.

Simulate process:
1. Reveal top card → remove it
2. Move next top card to **bottom**
3. Repeat until empty

Find **initial order** of deck such that **revealed cards** are in **increasing order**.

Return **any** valid ordering (first element = top).

---

## Core Idea — Reverse the Process

**Direct simulation** hard → find order that produces increasing reveal.

**Brilliant insight**:
- **Reverse** the reveal process:
  - Start with **empty deck**
  - Revealed cards in **reverse increasing order** (largest first)
  - **Undo** operations backward:
    - Undo "move to bottom" → take from bottom → put on top
    - Undo "reveal" → put card on top

**Use Deque**:
- Add revealed cards in **reverse sorted order**
- For each card:
  - If deque not empty → take **last** (bottom) → put to **front** (top)
  - Add current card to **front** (top)

**Result deque** → desired initial order (front = top).

---

## Full Optimal Implementation (C++)

```cpp
class Solution {
public:
    vector<int> deckRevealedIncreasing(vector<int>& deck) {
        sort(deck.begin(), deck.end()); 
        deque<int> dq;

        for (int i = deck.size() - 1; i >= 0; i--) {
            if (!dq.empty()) {
              
                int bottom = dq.back();
                dq.pop_back();
                dq.push_front(bottom);
            }
            dq.push_front(deck[i]);
        }

  
        vector<int> res(dq.begin(), dq.end());
        return res;
    }
};
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)**        | Sorting dominates                              |
| **Space Complexity**  | **O(n)**              | Deque for simulation                           |

**Optimal** — sorting necessary to guarantee increasing reveal.

---

## Why This Works — Example Walkthrough

**Input**: `deck = [17,13,11,2,3,5,7]`

- **Sort** → `[2,3,5,7,11,13,17]`
- **Reverse process** (process largest first):
  - Start with **empty** deque
  - 17: push front → `[17]`
  - 13: (no bottom) → push front → `[13,17]`
  - 11: move bottom 17 → front → `[17,13]` → push 11 → `[11,17,13]`
  - 7: move 13 → front → `[13,11,17]` → push 7 → `[7,13,11,17]`
  - 5: move 17 → front → `[17,7,13,11]` → push 5 → `[5,17,7,13,11]`
  - 3: move 11 → front → `[11,5,17,7,13]` → push 3 → `[3,11,5,17,7,13]`
  - 2: move 13 → front → `[13,3,11,5,17,7]` → push 2 → `[2,13,3,11,5,17,7]`

→ Final deque: `[2,13,3,11,5,17,7]` — **matches example**.

**Perfect** — when simulated forward, reveals in increasing order: 2 → 3 → 5 → 7 → 11 → 13 → 17.

---

## Pitfalls & Edge Cases

- **Single card** → returns itself
- **Two cards** → order preserved
- **Already sorted** → produces specific valid order
- **Duplicates** → impossible (guaranteed unique values)

All handled correctly.

---

## Key Takeaway

This is a **masterpiece of reverse simulation**:

- **Reverse the process** → build deck from revealed cards backward
- **Deque** → efficient top (front) and bottom (back) operations
- **Sort first** → guarantees increasing reveal order

**Pure insight + clean code** — one of the most elegant Medium simulation problems.

---

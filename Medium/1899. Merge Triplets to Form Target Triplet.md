# 1899. Merge Triplets to Form Target Triplet  
*O(n) — Optimal Greedy Filtering + Single Pass Check*

---

## Problem Statement

You are given a list of triplets `triplets`, where each `triplets[i] = [aᵢ, bᵢ, cᵢ]`.

You can perform the following operation any number of times:

- Choose two different indices i and j  
- Update `triplets[j]` to `[max(aᵢ, aⱼ), max(bᵢ, bⱼ), max(cᵢ, cⱼ)]`

Return `true` if you can make **at least one** triplet equal to `target = [x, y, z]`, otherwise `false`.

---

## Core Idea — Greedy: Keep Only Useful Triplets

**Key insight**:
- The operation **only increases** values (max) — you can never decrease any component.
- To reach `target = [x, y, z]`, you need to end up with a triplet where:
  - first component = x
  - second = y
  - third = z
- You can only **increase** values toward x, y, z — so any triplet you use **must have**:
  - aᵢ ≤ x
  - bᵢ ≤ y
  - cᵢ ≤ z
- Otherwise, if any component > target → impossible to reduce it.

**Algorithm**:
1. **Filter** all triplets: keep only those where `a ≤ x && b ≤ y && c ≤ z`
2. Among the remaining triplets, check if you can achieve **exactly**:
   - max a = x
   - max b = y
   - max c = z
3. Because any merge takes **max** across selected triplets → the final triplet will have:
   - max a over selected
   - max b over selected
   - max c over selected
4. So you just need to check that among the valid triplets (those ≤ target component-wise), the **maximum a** = x, **maximum b** = y, **maximum c** = z.

**Conclusion**:
- If there exists at least one triplet with a = x (and b ≤ y, c ≤ z)
- AND at least one with b = y (and a ≤ x, c ≤ z)
- AND at least one with c = z (and a ≤ x, b ≤ y)
- Then you can merge them (and possibly others) → final max will be exactly [x, y, z]

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public bool MergeTriplets(int[][] triplets, int[] target) {
        int x = target[0], y = target[1], z = target[2];

        bool canReachX = false;
        bool canReachY = false;
        bool canReachZ = false;

        foreach (int[] t in triplets)  {
            int a = t[0], b = t[1], c = t[2];

            // Only consider triplets that can contribute (≤ target in all components)
            if (a <= x && b <= y && c <= z) {
                if (a == x) canReachX = true;
                if (b == y) canReachY = true;
                if (c == z) canReachZ = true;
            }
        }

        return canReachX && canReachY && canReachZ;
    }
}
```


## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single linear pass through all triplets (n ≤ 10⁵) — we check each one exactly once |
| **Space Complexity**  | **O(1)**      | Only three boolean flags + constant variables — no extra data structures |

**Optimal** — linear time, no additional space needed, perfectly efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: `triplets = [[2,5,3],[1,8,4],[1,7,5]]`, `target = [2,7,5]`

- Filter triplets where every component ≤ target [2,7,5]:
  - [2,5,3] → 2≤2, 5≤7, 3≤5 → valid, and a=2 == x → canReachX = true
  - [1,8,4] → 8 > 7 → discard (cannot decrease b later)
  - [1,7,5] → 1≤2, 7≤7, 5≤5 → valid, b=7 == y, c=5 == z → canReachY = true, canReachZ = true

- All three flags true → **true** → correct  
  (you can merge [2,5,3] and [1,7,5] → max gives exactly [2,7,5])

**Example 2**: `triplets = [[3,4,5],[4,5,6]]`, `target = [3,2,5]`

- Check valid triplets (≤ [3,2,5]):
  - [3,4,5] → b=4 > 2 → discard
  - [4,5,6] → a=4 > 3 → discard
- No valid triplets at all → impossible to reach y=2 → **false** → correct

**Correct** — we only keep triplets that **never exceed** target in any component (since we can only increase values, never decrease).  
Then we check if among these "safe" triplets we have ones that **exactly match** each component of target.

---

## Pitfalls & Edge Cases

- **No triplet with exact component** → cannot reach that value → false
- **Triplet exceeds target in any position** → discarded (impossible to decrease later)
- **Multiple triplets with same value** → fine, we only care about existence of at least one for each component
- **n = 10⁵** → O(n) single pass → extremely fast
- **target very small** → correctly returns false if no safe triplet can cover the exact values

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple greedy filtering** problem:

- **Filter** only the triplets where **every** component ≤ corresponding target value  
  (a ≤ x && b ≤ y && c ≤ z) — these are the only ones that can be used (we can only increase, never decrease)

- Among these safe triplets, check if there exists at least one with:
  - a == x
  - b == y
  - c == z

- If **all three** conditions are satisfied → **true** (merge them together → max will give exactly [x,y,z])
- Else → **false**

**Pure, clean, optimal** — single linear pass, constant space (just 3 booleans), no sorting or extra structures.

---

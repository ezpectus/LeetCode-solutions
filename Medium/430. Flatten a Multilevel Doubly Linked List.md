# 430. Flatten a Multilevel Doubly Linked List — Architectural Solution

## Problem Statement
We are given a multilevel doubly linked list.  
Each node contains:

* `val`
* `prev`
* `next`
* `child` → may point to another doubly linked list  
  Child lists may have their own children, forming an arbitrarily deep structure.

We must flatten the list so that:

* All nodes appear in a **single-level** doubly linked list
* Child lists appear **immediately after** their parent node
* All `child` pointers become `null`

## Constraints

* Number of nodes ≤ 1000
* Node values: 1 ≤ val ≤ 10⁵
* Depth of nesting can be arbitrary
* Must preserve `prev` and `next` pointers correctly

## Core Idea
Flattening is naturally solved with **DFS**:

* When encountering a node with a child:
  - Flatten the child list recursively
  - Insert the flattened child list between `curr` and `curr.next`
  - Connect all `prev/next` pointers properly
  - Continue from the tail of the child list

The DFS returns the **tail** of the fully flattened segment, enabling correct pointer stitching.

This guarantees:

* Correct ordering: **parent → child → next**
* No extra data structures needed
* **In-place** flattening
* **O(n)** time, **O(depth)** stack

## Steps

* If `head` is null → return null
* Use a DFS helper that:
  * Iterates through the list
  * When a child exists:
    * Recursively flatten the child
    * Splice child list between current node and next node
    * Nullify child
    * Continue from the child tail
  * Track and return the last processed node (tail)
* Return the head

## Implementation (C#)

```csharp
public class Solution 
{
    public Node Flatten(Node head) 
    {
        if (head == null) return null;
        DFS(head);
        return head;
    }

    private Node DFS(Node node) 
    {
        Node curr = node;
        Node last = null;

        while (curr != null) 
        {
            Node next = curr.next;

            if (curr.child != null) 
            {
                Node childHead = curr.child;
                Node childTail = DFS(childHead);

                // Connect: curr → childHead
                curr.child = null;
                curr.next = childHead;
                childHead.prev = curr;

                // Connect childTail → next (if exists)
                if (next != null) 
                {
                    childTail.next = next;
                    next.prev = childTail;
                }

                last = childTail;
                curr = childTail;
            } 
            else 
            {
                last = curr;
            }

            curr = curr.next;
        }

        return last;
    }
}
```


## Complexity Analysis

- **Time Complexity**: **O(n)** — each node visited exactly once  
- **Space Complexity**: **O(depth)** recursion stack, worst-case **O(n)**  
- **Modifies list**: **In-place**, no extra structures

## Pitfalls & Edge Cases

- Must set `child = null` after flattening  
- Must reconnect **both** `prev` and `next` pointers  
- Deep nesting → recursion depth may grow (but n ≤ 1000 → safe)  
- Works perfectly for:
  - Single node
  - No children
  - Multiple nested levels
  - Long horizontal lists
  - Mixed depth

## Conclusion

The architectural insight is recognizing that **flattening is a recursive splice operation**:
Each node with a child becomes a **junction** where the child list is inserted **before** the next node.
By returning the **tail** of each flattened segment**, we can stitch lists together **cleanly and in-place**, achieving a **linear-time** solution with minimal overhead.
**A textbook example of using DFS to collapse a hierarchical structure into a linear one.**

---

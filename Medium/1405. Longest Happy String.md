# 1405. Longest Happy String

**Difficulty:** Medium  
**Topics:** Greedy, Priority Queue, String Construction  

---

##  Problem Restatement
A string `s` is called **happy** if it satisfies the following conditions:
1. `s` only contains the letters `'a'`, `'b'`, and `'c'`.  
2. `s` does not contain any of `"aaa"`, `"bbb"`, or `"ccc"` as a substring.  
3. `s` contains at most `a` occurrences of `'a'`, at most `b` occurrences of `'b'`, and at most `c` occurrences of `'c'`.  

Given integers `a`, `b`, and `c`, return the **longest possible happy string**.  
If multiple answers exist, return any of them.  
If no such string exists, return the empty string `""`.

---

##  Core Idea
- We want to build the longest string without three identical consecutive characters.  
- Greedy strategy:  
  - Always pick the character with the largest remaining count.  
  - If adding it would cause three in a row, pick the next largest character instead.  
- Use a **priority queue (max‑heap)** to efficiently select the next character.  

---

##  Step-by-Step Algorithm
1. Push `(char, count)` for `'a'`, `'b'`, `'c'` into a max‑heap (priority queue).  
2. While the heap is not empty:  
   - Pop the character with the largest count.  
   - If the last two characters in the result are the same as this one, then:  
     - If heap is empty → stop.  
     - Else pop the second largest character, append it, decrement its count, and push back both.  
   - Otherwise, append the character, decrement its count, and push it back if still > 0.  
3. Return the constructed string.  

---

##  C# Implementation
```csharp
public class Solution {
    public string LongestDiverseString(int a, int b, int c) {
        var pq = new PriorityQueue<(char ch, int count), int>();

        if (a > 0) pq.Enqueue(('a', a), -a);
        if (b > 0) pq.Enqueue(('b', b), -b);
        if (c > 0) pq.Enqueue(('c', c), -c);

        var sb = new StringBuilder();

        while (pq.Count > 0) {
            var (ch, count) = pq.Dequeue();

            // Prevent three consecutive same characters
            if (sb.Length >= 2 && sb[^1] == ch && sb[^2] == ch) {
                if (pq.Count == 0) break;
                var (ch2, count2) = pq.Dequeue();
                sb.Append(ch2);
                count2--;
                if (count2 > 0) pq.Enqueue((ch2, count2), -count2);
                pq.Enqueue((ch, count), -count);
            } else {
                sb.Append(ch);
                count--;
                if (count > 0) pq.Enqueue((ch, count), -count);
            }
        }

        return sb.ToString();
    }
}
```

##  Complexity Analysis

- **Time Complexity: O((a+b+c) log 3) ≈ O(a+b+c)**  
  - Each character added to the result involves at most one heap operation.  
  - Heap size is at most 3 (for 'a', 'b', 'c'), so log 3 is constant.  
  - Therefore, the runtime is linear in the total number of characters.  

- **Space Complexity: O(1)**  
  - We only store counts for three characters and the result string.  
  - The priority queue holds at most 3 elements.  
  - Memory usage is constant beyond the output string itself.

---

##  Pitfalls

1. **Check last two characters**  
   - Without this, you risk building `"aaa"`, `"bbb"`, or `"ccc"`.  
   - Always verify the last two characters before appending a new one.  

2. **Push back remaining counts**  
   - After using a character, if its count is still > 0, reinsert it into the heap.  
   - Forgetting this step will shorten the string unnecessarily.  

3. **Heap empty scenario**  
   - If the heap is empty and the top choice would cause three in a row, stop immediately.  
   - Prevents invalid substrings and ensures correctness.  

4. **Multiple valid answers**  
   - The problem allows any longest happy string.  
   - Example: `"ccaccbcc"` and `"ccbccacc"` are both valid outputs.  
   - Don’t over-optimize for uniqueness; correctness is enough.

---

##  Example Walkthrough

**Input:** `a = 1, b = 1, c = 7`  

- **Heap initially:** `c=7, a=1, b=1`  
- Step 1: Take `'c'` → result `"c"`, counts: c=6  
- Step 2: Take `'c'` → result `"cc"`, counts: c=5  
- Step 3: Cannot take `'c'` again (would form `"ccc"`). Take `'a'` → result `"cca"`, counts: a=0  
- Step 4: Take `'c'` → result `"ccac"`, counts: c=4  
- Step 5: Take `'c'` → result `"ccacc"`, counts: c=3  
- Step 6: Cannot take `'c'` again. Take `'b'` → result `"ccaccb"`, counts: b=0  
- Step 7: Take `'c'` → result `"ccaccbc"`, counts: c=2  
- Step 8: Take `'c'` → result `"ccaccbcc"`, counts: c=1  

**Final Output:** `"ccaccbcc"`  
Alternative valid output: `"ccbccacc"`  

---

##  Key Takeaway

- **Greedy + priority queue** ensures we always pick the best available character.  
- **Last-two check** prevents invalid substrings like `"aaa"`, `"bbb"`, `"ccc"`.  
- **Reinserting characters** guarantees maximum length.  
- Multiple valid answers exist; any longest happy string is acceptable.  
- Efficient, elegant solution with linear runtime and constant space.



---

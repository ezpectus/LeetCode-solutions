# 398. Random Pick Index

---

##  Problem Restatement
You are given an integer array `nums` that may contain duplicates.  
Implement a class with two methods:
- `Solution(int[] nums)` → initializes the object with the array.  
- `int pick(int target)` → randomly returns an index `i` such that `nums[i] == target`.  
If multiple valid indices exist, each must be returned with equal probability.

Constraints:  
- `1 ≤ nums.length ≤ 2 * 10^4`  
- `-2^31 ≤ nums[i] ≤ 2^31 - 1`  
- Target is guaranteed to exist in `nums`.  
- At most `10^4` calls to `pick`.

---

##  Core Idea
- We need uniform random selection among all indices where `nums[i] == target`.  
- Two main approaches:  
  1. **Preprocessing:** Store all indices for each value in a dictionary. `pick` then selects randomly from the list.  
  2. **Reservoir Sampling:** Iterate through array each time and select index with probability `1/count`. Useful for streaming or very large arrays.  

Given constraints (`nums.length ≤ 20k`), dictionary preprocessing is efficient and simple.

---

##  Step‑by‑Step
1. In constructor, build a dictionary mapping `value → list of indices`.  
2. In `pick(target)`, retrieve the list of indices for that target.  
3. Use `Random` to select one uniformly.  
4. Return the chosen index.

---

##  Code (C#)
```csharp
public class Solution {
    private Dictionary<int, List<int>> map;
    private Random rand;

    public Solution(int[] nums) {
        map = new Dictionary<int, List<int>>();
        rand = new Random();
        for (int i = 0; i < nums.Length; i++) {
            if (!map.ContainsKey(nums[i])) {
                map[nums[i]] = new List<int>();
            }
            map[nums[i]].Add(i);
        }
    }
    
    public int Pick(int target) {
        var indices = map[target];
        int idx = rand.Next(indices.Count); // uniform random
        return indices[idx];
    }
}
```

## Complexity
- **Time:**  
  - **Constructor:** O(N) — build dictionary mapping each value to its list of indices.  
  - **pick:** O(1) — random selection from the precomputed list.  
- **Space:** O(N) — dictionary stores all indices, proportional to array length.

---

## Pitfalls
- **Random initialization:** Forgetting to initialize `Random` once may cause repeated sequences across calls.  
- **Duplicate handling:** Must store *all* indices for each value, not just one, to ensure uniform probability.  
- **Edge cases:**  
  - If target appears only once, `pick` must always return that single index.  
  - Large arrays with many duplicates → dictionary lists may grow large, but still manageable under constraints.  
- **Reservoir sampling alternative:** If preprocessing is not allowed or array is too large, reservoir sampling can be used to achieve uniform random selection without extra memory.

---

## Conclusion
This problem reduces to **uniform random selection among indices**.  
- Dictionary preprocessing ensures O(1) query time with O(N) preprocessing.  
- Reservoir sampling is a viable alternative for streaming or memory‑constrained scenarios.  

Result: clean O(N) preprocessing + O(1) query solution, robust for `N ≤ 20k`, and a textbook example of combining preprocessing with randomization for efficient queries.

---






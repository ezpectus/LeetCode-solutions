# 669. Trim a Binary Search Tree

---

## Problem Summary
We are given the root of a **Binary Search Tree (BST)** and two boundaries `low` and `high`.  
- Task: trim the tree so that all node values lie within `[low, high]`.  
- The relative structure of the remaining nodes must be preserved.  
- The root may change depending on the given bounds.  

---

## Core Idea
- Use **recursion** to traverse the tree.  
- For each node:  
  - If `node->val < low`, discard the left subtree and return the trimmed right subtree.  
  - If `node->val > high`, discard the right subtree and return the trimmed left subtree.  
  - Otherwise, recursively trim both left and right children.  
- Return the updated node.  

This works because BST properties guarantee that:  
- All values in the left subtree are smaller than the node.  
- All values in the right subtree are larger than the node.  

---

## C++ Implementation
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (!root) return nullptr;
        
        if (root->val < low) {
            // Current node is too small → trim right subtree
            return trimBST(root->right, low, high);
        }
        if (root->val > high) {
            // Current node is too large → trim left subtree
            return trimBST(root->left, low, high);
        }
        
        // Node is within range → trim both children
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};
```


## Complexity
- **Time:** O(n) — each node is visited once.  
- **Space:** O(h) — recursion stack, where h = height of the tree (O(log n) for balanced, O(n) worst case).  

---

## Pitfalls
- Must handle **empty tree** → return `nullptr`.  
- Ensure recursion correctly reassigns child pointers.  
- BST property allows pruning entire subtrees without visiting all nodes.  
- **Edge case:** all nodes outside `[low, high]` → return `nullptr`.  

---

## Example Walkthrough
**Input:** `root = [3,0,4,null,2,null,null,1], low = 1, high = 3`  

**Steps:**  
- Node(3) → within range → keep.  
- Node(0) → too small → trim right subtree → Node(2).  
- Node(2) → within range → keep.  
- Node(1) → within range → keep.  
- Node(4) → too large → discard.  

**Output:** `[3,2,null,1]`  

---

## Conclusion
The problem reduces to a **recursive pruning of BST** based on the given range `[low, high]`.  
- Runs in **O(n)** time and **O(h)** space.  
- Efficiently trims subtrees using BST properties.  
- Produces a unique, valid trimmed tree while preserving relative structure.  




---

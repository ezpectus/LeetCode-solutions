# 641. Design Circular Deque — Architectural Double-Ended Ring Buffer  
*O(1) All Operations — Classic Circular Buffer with Two Pointers*

---

## Problem Overview

Implement a **circular double-ended queue** (deque) of fixed size `k` with:

- Insert/delete from **front** and **rear**
- Get front/rear
- Check empty/full

All operations must be **O(1)**.

---

## Core Idea — Ring Buffer with Head/Tail + Count

Use a **fixed array** + two pointers:

- `head` — points to **front** element
- `tail` — points to **next write position** at rear

**Wrap-around**: `(index + 1) % k`

**State tracking**: `count` → distinguishes empty vs full

**No sentinel slot** — full capacity utilization.

---

## Full Optimal Implementation (C#)

```csharp
public class MyCircularDeque 
{
    private int[] arr;
    private int head;
    private int tail;
    private int count;
    private int cap;

    public MyCircularDeque(int k) 
    {
        cap = k;
        arr = new int[k];
        head = 0;
        tail = 0;
        count = 0;
    }

    public bool InsertFront(int value) 
    {
        if (IsFull()) return false;
        
        head = (head - 1 + cap) % cap;  // move head backward
        arr[head] = value;
        count++;
        return true;
    }

    public bool InsertLast(int value) 
    {
        if (IsFull()) return false;
        
        arr[tail] = value;
        tail = (tail + 1) % cap;
        count++;
        return true;
    }

    public bool DeleteFront() 
    {
        if (IsEmpty()) return false;
        
        head = (head + 1) % cap;
        count--;
        return true;
    }

    public bool DeleteLast() 
    {
        if (IsEmpty()) return false;
        
        tail = (tail - 1 + cap) % cap;
        count--;
        return true;
    }

    public int GetFront() 
    {
        return IsEmpty() ? -1 : arr[head];
    }

    public int GetRear() 
    {
        return IsEmpty() ? -1 : arr[(tail - 1 + cap) % cap];
    }

    public bool IsEmpty() 
    {
        return count == 0;
    }

    public bool IsFull() 
    {
        return count == cap;
    }
}
```

## Time and Space Complexity

| **Metric**            | **Value**     | **Explanation**                                      |
|-----------------------|---------------|------------------------------------------------------|
| **Time Complexity**   | **O(1)**      | **All operations** (insert/delete front/rear, get front/rear, isEmpty/isFull) are constant-time |
| **Space Complexity**  | **O(k)**      | Fixed-size array of capacity `k` — no dynamic allocation |

**Optimal** — true constant-time operations, **full capacity usage**, no amortization needed.

---

## Implementation Commentary

- **Pointer mechanics**:
  - `InsertFront`: move `head` **backward** → write value → increment count
  - `InsertLast`: write at `tail` → move `tail` **forward** → increment count
  - `DeleteFront`: move `head` **forward** → decrement count
  - `DeleteLast`: move `tail` **backward** → decrement count

- **Safe wrap-around**:
  - `(index - 1 + cap) % cap` → **correct negative modulo** for front operations
  - `(index + 1) % cap` → standard forward wrap

- **Rear access**:
  - Element before `tail` → `(tail - 1 + cap) % cap` — works even when `tail == 0`

- **Count-based state**:
  - `count == 0` → **empty**
  - `count == k` → **full**
  - **No wasted slot** — uses all `k` positions (unlike sentinel-slot designs)

- **Full capacity utilization**:
  - Unlike naive implementations that sacrifice one slot to distinguish empty/full, we use **count** → **100% capacity**

---

## Final Takeaway

This is the **gold standard** for implementing a **fixed-size double-ended queue**:

- **Two pointers** (`head`, `tail`) + **count**
- **Modular arithmetic** for seamless wrap-around
- **O(1)** for **everything**
- **Maximum capacity** with zero waste

Used everywhere in performance-critical systems:

- **Task schedulers** (bounded work queues)
- **Streaming buffers** (audio/video pipelines)
- **Undo/redo stacks** with size limits
- **Network packet queues** (routers, NICs)
- **Real-time embedded systems**
**Clean, efficient, bulletproof** — the definitive circular deque pattern.

---

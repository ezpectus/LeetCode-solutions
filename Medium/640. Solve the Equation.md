# 640. Solve the Equation — Architectural Coefficient Aggregation  
*O(n) — Linear Equation Normalization*

---

## Problem Statement

Given a string `equation` like `"x+5-3+x=6+x-2"`, solve for `x` and return:

- `"x=#value"` if unique integer solution
- `"Infinite solutions"` if identity (0=0)
- `"No solution"` if contradiction (non-zero = 0)

**Guaranteed**: if solution exists, it's an integer.

---

## Core Idea — Move All Terms to One Side

Transform equation into form:
```
coeff * x + const = 0
```

Then:
- `coeff != 0` → `x = -const / coeff`
- `coeff == 0 && const == 0` → infinite solutions
- `coeff == 0 && const != 0` → no solution

**Strategy**:
- Split by `'='`
- Parse left and right sides
- Evaluate **coefficient of x** and **constant term** for each side
- Subtract right from left → normalized form

Parsing: scan character by character, handling signs, numbers, and `'x'`.

---

## Implementation (C#)

```csharp
public class Solution {
    public string SolveEquation(string equation)  {
        string[] sides = equation.Split('=');
        int[] left = EvaluateSide(sides[0]);
        int[] right = EvaluateSide(sides[1]);
        int coefficient = left[0] - right[0];
        int constant = right[1] - left[1];  // move right constants to left

        if (coefficient == 0) {
            return constant == 0 ? "Infinite solutions" : "No solution";
        }

        int xValue = constant / coefficient;
        return $"x={xValue}";
    }

    private int[] EvaluateSide(string side)  {
        int coefficient = 0;
        int constant = 0;
        int sign = 1;
        int num = 0;
        bool hasNum = false;

        for (int i = 0; i < side.Length; i++)  {
            char c = side[i];

            if (c == 'x')  {
                coefficient += (hasNum ? num : 1) * sign;
                num = 0;
                hasNum = false;
            } 
            else if (c == '+' || c == '-')  {
                constant += num * sign;
                num = 0;
                hasNum = false;
                sign = c == '+' ? 1 : -1;
            } 
            else {
                num = num * 10 + (c - '0');
                hasNum = true;
            }
        }

        // Add the last term
        constant += num * sign;
        return new int[] { coefficient, constant };
    }
}
```


## Complexity

| **Metric**     | **Value**   | **Notes**                          |
|----------------|-------------|------------------------------------|
| **Time**       | **O(n)**    | Single pass per side               |
| **Space**      | **O(1)**    | Only a few variables               |

**Optimal** — linear and minimal.

---

## Why This Works — Example Walkthrough

**Input**: `"x+5-3+x=6+x-2"`
- Left: `"x+5-3+x"` → coeff = 2, const = +2
- Right: `"6+x-2"` → coeff = 1, const = +4
- Normalized: `2x + 2 - (1x + 4) = 0` → `x - 2 = 0` → **x=2**

**Input**: `"x=x"` → `1x + 0 = 1x + 0` → `0x + 0 = 0` → **infinite**
**Input**: `"2x=x"` → `2x + 0 = 1x + 0` → `x = 0`

**Perfect** — handles all cases correctly.

---

## Pitfalls & Edge Cases

- **Implicit coefficient**: `"x"` → `1x`, `"-x"` → `-1x`
- **No number before x**: handled
- **Multiple signs**: `"+-x"` → correctly parsed as `-x`
- **Leading/trailing terms**: all covered
- **Zero coefficient**: correctly detected → infinite or no solution

---

## Key Takeaway

This is a **beautifully simple** linear equation solver:

- **Parse** both sides independently
- **Aggregate** x-coeff and constants
- **Normalize** to `coeff*x + const = 0`
- **Classify** solution type

**No regex. No eval. No floating point.**
**Pure character-by-character parsing** — robust, fast, elegant.
**One of the cleanest equation-solving problems on LeetCode.**

---

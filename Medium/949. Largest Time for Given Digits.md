# 949. Largest Time for Given Digits — Architectural Permutation Generation with Validation  
*O(1) — Optimal Brute-Force All 24 Permutations*

---

## Problem Statement

Given an array `arr` of **exactly 4 digits** (0–9).

Form the **latest possible valid** 24-hour time in format `"HH:MM"` using **each digit exactly once**.

- `HH` must be between **00** and **23**
- `MM` must be between **00** and **59**

Return the **latest** (lexicographically largest) valid time string.  
If no valid time can be formed → return `""`.

---

## Core Idea — Generate All Permutations & Track Maximum Valid Time

**Why permutations?**  
We have only **4 digits** → total possible arrangements = **4! = 24** → constant and tiny.

**Strategy**:
- Start with sorted array (smallest permutation)
- Use `NextPermutation` algorithm to generate **all 24 possible orders**
- For each permutation `a b c d`:
  - Interpret as `HH = ab`, `MM = cd`
  - Check validity: `HH ≤ 23` and `MM ≤ 59`
  - If valid → compare the time string with current maximum
- Keep the **lexicographically largest** valid time

**No early pruning needed** — 24 checks are negligible.

**Why string comparison works**:
- `"23:59"` > `"23:41"` > `"19:59"` etc.
- Direct string comparison gives correct "latest" order.


---

## Implementation (C#)

```csharp
public class Solution {
    public string LargestTimeFromDigits(int[] arr) {
        string maxTime = "";
        Array.Sort(arr); 

        do {
            int h = arr[0] * 10 + arr[1];
            int m = arr[2] * 10 + arr[3];

            if (h <= 23 && m <= 59) {
                string time = $"{arr[0]}{arr[1]}:{arr[2]}{arr[3]}";
                if (time.CompareTo(maxTime) > 0) maxTime = time;   
            }
        } 
        while (NextPermutation(arr));

        return maxTime;
    }

    private bool NextPermutation(int[] nums) {
        int i = nums.Length - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) i--;
        if (i < 0) return false;

        int j = nums.Length - 1;
        while (nums[j] <= nums[i]) j--;
        Swap(nums, i, j);

        Array.Reverse(nums, i + 1, nums.Length - i - 1);
        return true;
    }

    private void Swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(1)**      | 4! = 24 permutations → constant                |
| **Space Complexity**  | **O(1)**      | No extra space beyond input                    |

**Optimal** — fixed input size (4 digits).

---

## Why This Works — Example Walkthrough

**Input**: `arr = [1,2,3,4]`

- Sorted → `[1,2,3,4]`
- Generate all permutations using `NextPermutation`:
  - `"23:41"` → valid
  - `"23:14"` → valid, but `"23:41"` > `"23:14"`
  - `"21:34"`, `"21:43"`, `"14:32"`, etc.
- Final maximum valid time = **"23:41"**

**Correct** — latest possible time.

**Input**: `[5,5,5,5]`

- All permutations → `"55:55"`
- HH = 55 > 23 → invalid
- No valid time → return `""`

**Correct**.

---

## Pitfalls & Edge Cases

- **Invalid HH/MM** → skipped during validation
- **Duplicate digits** → `NextPermutation` handles correctly (generates unique arrangements)
- **All invalid combinations** → return `""`
- **Leading zero** → allowed and correct (e.g., `"09:59"` valid)

All handled perfectly.

---

## Key Takeaway

This is a **beautifully brute-force** problem:

- **Only 24 permutations** → generate all
- **Validate** HH ≤ 23, MM ≤ 59
- **String comparison** → lexicographically largest = latest time

**No pruning needed** — tiny input size.
**Pure, clean, optimal** — perfect for small fixed-size problems.

---

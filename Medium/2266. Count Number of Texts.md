# 2266. Count Number of Texts — Architectural DP on Keypad Blocks  
*O(n) — Classic Consecutive Digit Partitioning*

---

## Problem Summary

Alice types text using an old phone keypad (2–9).  
Bob receives only the **sequence of pressed digits** (e.g., `"22233"`).

We must count how many **different text messages** Alice could have meant.

- Digit `7` and `9` → 4 letters (`pqrs`, `wxyz`)
- All others → 3 letters
- Same digit pressed consecutively = one block
- Return answer **modulo 10⁹ + 7**

---

## Core Idea — DP on Consecutive Blocks

Each **run of identical digits** is independent.

For a run of length `len` of digit `d`:
- We can partition it into **1 to maxPress** presses per letter
- Number of ways = number of valid ways to split `len` presses

This is a classic **DP on string** with **local transitions**.

---

## Full Implementation (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int countTexts(string s) {
        int n = s.size();
        const int MOD = 1e9 + 7;
        vector<int> dp(n + 1, 0);
        dp[0] = 1; // one way to type empty string

        for (int i = 1; i <= n; ++i) {
            char c = s[i-1];
            int maxPress = (c == '7' || c == '9') ? 4 : 3;

            for (int len = 1; len <= maxPress && i - len >= 0; ++len) {
                // Check if last 'len' chars are all equal to c
                if (s[i-len] != c) break;
                dp[i] = (dp[i] + (long long)dp[i - len]) % MOD;
            }
        }
        return dp[n];
    }
};
```


## Full Implementation (C#)
```cpp
public class Solution {
    public int CountTexts(string pressedKeys) {
        int n = pressedKeys.Length;
        int mod = 1000000007;
        int[] dp = new int[n + 1];
        dp[0] = 1;

        for (int i = 1; i <= n; i++) {
            char c = pressedKeys[i - 1];
            int maxPress = (c == '7' || c == '9') ? 4 : 3;

            for (int len = 1; len <= maxPress && i - len >= 0; len++) {
                bool valid = true;
                for (int k = i - len; k < i; k++) {
                    if (pressedKeys[k] != c) {
                        valid = false;
                        break;
                    }
                }
                if (valid) dp[i] = (int)((dp[i] + (long)dp[i - len]) % mod);
            }
        }

        return dp[n];
    }
}
```

## Complexity

| **Metric**     | **Value**   | **Notes**                                      |
|----------------|-------------|------------------------------------------------|
| **Time**       | **O(n)**    | At most 4 iterations per position             |
| **Space**      | **O(n)**    | DP array (can be optimized to O(1) with vars)  |

---

## Pitfalls

- **Digits 7 and 9** → 4 presses (4 letters) — must be handled separately
- **Must break** when run of identical digits ends
- **Modulo** at every step → prevent overflow
- **Large n (10⁵)** → O(n) is required

---

## Edge Cases

- **Single digit** → number of letters on that key
- **All same digit 7 or 9** → Fibonacci-like growth
- **Mixed digits** → blocks are independent
- **Empty string** → 1 way (but `n ≥ 1` per constraints)

---

## Sanity Checks

- `"22233"` → `8` ways
- `"7"` → `4` (pqrs)
- `"222222222222222222222222222222222222"` → `82876089`

---

## Key Takeaway

This is a **dynamic programming on blocks of identical digits**:

- Each digit has `maxPress = 3` or `4`
- DP counts **valid partitions** of consecutive presses
- Transitions only within **same-digit runs**
**Efficient O(n) solution with modulo arithmetic.**

---


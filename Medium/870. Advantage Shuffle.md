# 870. Advantage Shuffle  
*Greedy Two-Pointer + Sorted Assignment — O(n log n)*

---

## Problem  

Given two arrays `nums1` and `nums2` of length `n`,  
**permute `nums1`** to **maximize** the number of indices `i` where:  
> `result[i] > nums2[i]`

Return **any** such permutation.

---

## Constraints  

| Constraint | Implication |
|----------|-----------|
| `1 ≤ n ≤ 10⁵` | Must be **O(n log n)** |
| `0 ≤ nums[i] ≤ 10⁹` | No overflow in comparison |

---

## Solution Idea (Expanded)  

1. **Sort `nums1` ascending** → enables two-pointer access to **smallest/largest remaining**.  
2. **Pair `nums2` with original indices**, sort **descending by value** → handle **hardest opponents first**.  
3. **Two pointers** on sorted `nums1`:  
   - `lo` → smallest unused  
   - `hi` → largest unused  
4. For each `b` in **descending order**:  
   - If `nums1[hi] > b` → **win**: assign `nums1[hi--]`  
   - Else → **no one can win**: **sacrifice** `nums1[lo++]`  

---

## Why Process Largest `b` First?  

> **Bottleneck principle**:  
> Large `b` values are **hardest to beat**.  
> - If you **can** beat it → **must use a large `a`**  
> - If you **cannot** → **sacrifice small `a`** to preserve big ones  

**Delaying** this decision risks **wasting** a big `a` on a weak `b`.

---

## Why Greedy Is Correct — Intuition  

**Exchange argument**:  
Suppose an optimal solution assigns a **smaller** `a` to beat a large `b`, while using a **larger** `a` elsewhere.  
→ Swap them → still valid, and **at least as good** (or better).

Thus, **greedy choice is safe**.

---

## Correct & Efficient C# Implementation  

```csharp
public class Solution {
    public int[] AdvantageCount(int[] nums1, int[] nums2) {
        int n = nums1.Length;
        int[] res = new int[n];

        // Step 1: Sort nums1 ascending
        Array.Sort(nums1);

        // Step 2: Pair nums2 with indices, sort descending by value
        var pairs = new (int val, int idx)[n];
        for (int i = 0; i < n; i++) 
            pairs[i] = (nums2[i], i);
        
        Array.Sort(pairs, (a, b) => b.val.CompareTo(a.val));

        // Step 3: Two pointers
        int lo = 0, hi = n - 1;
        for (int i = 0; i < n; i++) {
            int bVal = pairs[i].val;
            int bIdx = pairs[i].idx;

            if (nums1[hi] > bVal) {
                res[bIdx] = nums1[hi--];  // Win with largest
            } else {
                res[bIdx] = nums1[lo++];  // Sacrifice smallest
            }
        }

        return res;
    }
}
```

## Complexity  

| **Metric** | **Value** | **Notes** |
|----------|-----------|---------|
| **Time** | **O(n log n)** | Sorting `nums1` and `nums2` pairs dominates |
| **Space** | **O(n)** | `pairs` array + `res` array |

---

## Practical Notes & Pitfalls  

| **Issue** | **Fix** |
|---------|--------|
| **LINQ `OrderByDescending(...).ToArray()`** | Slow + extra allocation → use `Array.Sort` with value tuples |
| **Jagged arrays `int[n][]`** | Invalid syntax → use `(int val, int idx)[n]` |
| **Strict `>`** | Problem requires **strictly greater** — `>=` is **incorrect** |
| **Duplicates** | Handled correctly — any maximal permutation is acceptable |
| **Hot loop / GC pressure** | Reuse buffers if method called repeatedly |

---

## Fichka — Reusable Pattern  

> **Greedy Assignment with Sorted Opponents**

---

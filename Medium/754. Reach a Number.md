# 754. Reach a Number

---

## Problem Restatement
We start at position `0` on an infinite number line.  
- On the `i`-th move, we can move `i` steps either left or right.  
- We want to reach exactly `target`.  
- Return the minimum number of moves required.

---

## Key Insight
This problem is about **cumulative sums** and parity.

### Step 1: Absolute target
Since moves can go left or right, the problem is symmetric.  
We only need to consider `target = Math.Abs(target)`.

### Step 2: Sum of moves
Let `sum = 1 + 2 + ... + k = k*(k+1)/2`.  
We want the smallest `k` such that `sum >= target`.

### Step 3: Parity adjustment
If `sum == target`, we are done.  
If `sum > target`, we can flip the direction of some moves.  
- Flipping a move of size `d` changes the position by `2*d`.  
- So we need `(sum - target)` to be **even** to adjust.  
- If `(sum - target)` is odd, keep increasing `k` until it becomes even.

---

## Code (C#)
```csharp
public class Solution {
    public int ReachNumber(int target) {
        target = Math.Abs(target);
        int steps = 0;
        long sum = 0;

        // Step 1: accumulate until sum >= target
        while (sum < target) {
            steps++;
            sum += steps;
        }

        // Step 2: adjust parity
        while ((sum - target) % 2 != 0) {
            steps++;
            sum += steps;
        }

        return steps;
    }
}
```


## Complexity
- **Time:** O(√target), because the cumulative sum grows quadratically with the number of steps.  
- **Space:** O(1), only a few variables are used.  

---

## Example Walkthrough

**Input:** `target = 2`  
- sum = 1 (steps = 1)  
- sum = 3 (steps = 2) → sum ≥ target  
- sum - target = 1 (odd)  
- Add step = 3 → sum = 6, sum - target = 4 (even)  
- **Answer = 3 ✅**

**Input:** `target = 3`  
- sum = 1 (steps = 1)  
- sum = 3 (steps = 2) → sum ≥ target  
- sum - target = 0 (even)  
- **Answer = 2 ✅**

---

## Conclusion
The solution relies on **cumulative sums and parity adjustment**:  
1. Find the smallest `k` such that `sum ≥ target`.  
2. If `(sum - target)` is odd, keep adding steps until it becomes even.  

This ensures the minimum number of moves to reach the destination.  


---

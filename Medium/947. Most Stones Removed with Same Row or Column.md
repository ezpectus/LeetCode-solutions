# LeetCode 947 ‚Äî Most Stones Removed with Same Row or Column  
**Approach: Union-Find (Disjoint Set Union with Path Compression and Union by Rank)**

---

##  Problem Restatement
On a 2D plane, we place `n` stones at integer coordinates.  
A stone can be removed if it shares the same **row** or **column** with another stone that has not yet been removed.  
We need to return the **maximum number of stones that can be removed**.

---

##  Core Idea
- Each stone `[x, y]` connects its **row index** `x` and **column index** `y`.  
- Treat rows and columns as nodes in a graph.  
- Stones act as edges that connect a row node to a column node.  
- The problem reduces to finding the number of **connected components** in this bipartite graph.  
- Maximum stones removed = `total stones - number of connected components`.

---

## üõ†Ô∏è Union-Find Strategy
1. **Offset columns:** To avoid collision between row and column indices, map columns as `y + OFFSET`.  
   - Example: `OFFSET = 10001` since `y ‚â§ 10^4`.  
2. **Union operation:** For each stone `[x, y]`, union row `x` with column `y + OFFSET`.  
3. **Find operation:** Use path compression to flatten the structure for efficiency.  
4. **Union by rank:** Attach smaller tree under larger one to keep DSU shallow.  
5. **Count components:** After processing all stones, count distinct roots among used nodes.  
6. **Final answer:** `stones.Length - components`.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int RemoveStones(int[][] stones) {
        int n = stones.Length;
        int OFFSET = 10001; // offset to separate row indices from column indices

        UnionFind uf = new UnionFind(20005); // enough space for all x and y+OFFSET
        HashSet<int> used = new HashSet<int>();

        // Union each stone's row and column
        foreach (var stone in stones) {
            int x = stone[0];
            int y = stone[1] + OFFSET;
            uf.Union(x, y);
            used.Add(x);
            used.Add(y);
        }

        // Count distinct connected components
        HashSet<int> roots = new HashSet<int>();
        foreach (int u in used) {
            roots.Add(uf.Find(u));
        }

        // Maximum stones removed = total stones - number of components
        return n - roots.Count;
    }
}

public class UnionFind {
    private int[] parent;
    private int[] rank;

    public UnionFind(int size) {
        parent = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            parent[i] = i; // each node is its own parent initially
            rank[i] = 0;   // rank starts at 0
        }
    }

    // Path compression: flatten the tree for efficiency
    public int Find(int x) {
        if (parent[x] != x) {
            parent[x] = Find(parent[x]);
        }
        return parent[x];
    }

    // Union by rank: attach smaller tree under larger one
    public void Union(int x, int y) {
        int rootX = Find(x);
        int rootY = Find(y);
        if (rootX == rootY) return;

        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
    }
}
```


##  Time Complexity
- **Union-Find operations:** Each `Find` and `Union` runs in nearly constant time `O(Œ±(n))`, where `Œ±` is the inverse Ackermann function (extremely slow-growing, practically constant).  
- **Total complexity:** For `n` stones, we perform at most `n` unions and finds.  
  - Overall complexity ‚âà `O(n Œ±(n))`.  
- **Comparison:** This is significantly faster than DFS/BFS approaches on large graphs, especially when `n` is up to 1000.

---

##  Space Complexity
- **DSU arrays:** `O(n)` for `parent` and `rank`.  
- **HashSet for used nodes:** `O(n)` to track which row/column indices are active.  
- **Additional storage:** Another `O(n)` for counting distinct roots.  
- **Total space:** `O(n)` overall, efficient and scalable.

---

#  Impact of Design Choices

| Design Choice                  | Effect                                                                 |
|--------------------------------|------------------------------------------------------------------------|
| **Offset mapping**             | Ensures row indices and column indices do not overlap (e.g., `y + OFFSET`). |
| **Union by rank + compression**| Keeps DSU trees shallow, guaranteeing near-constant time operations.   |
| **HashSet for used nodes**     | Prevents traversing unused DSU indices, reducing unnecessary work.     |
| **Component counting**         | Using distinct roots ensures accurate calculation of connected components. |

---

#  Pitfalls

- **Forgetting offset mapping:** Without offset, row and column indices collide, breaking correctness.  
- **Skipping path compression:** DSU becomes inefficient, degrading performance to linear in worst case.  
- **Incorrect union logic:** Mismanaging rank or parent updates can lead to wrong component counts.  
- **Disconnected nodes:** If not handled, some stones may appear removable when they are not.  
- **Integer overflow:** Always use 64-bit integers for indices and calculations when offsets are large.  

---

#  Conclusion

- **What it gives:** Efficient solution using DSU to count connected components in the bipartite graph of stones.  
- **Why it matters:** Converts a graph connectivity problem into a union-find problem, achieving near-linear performance.  
- **Key takeaway:**  
  1. Map rows and columns separately with an offset.  
  2. Union them via stones.  
  3. Answer = `stones.Length - number of connected components`.  

This approach is clean, scalable, and leverages DSU‚Äôs strengths for graph connectivity problems.



---

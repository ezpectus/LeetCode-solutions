## 🧩 Problem: Additive Number

### 📘 Description
Given a string `num` containing only digits, determine if it can form an **additive sequence** — a sequence of numbers where each number is the sum of the previous two.  
The sequence must contain at least **three numbers**, and numbers cannot have **leading zeros** unless the number is `0`.

---

### 📌 What the description gives us

**Input**:  
- A string of digits, e.g. `"112358"`

**Constraints**:
- At least 3 numbers
- No leading zeros (e.g. `"01"` is invalid)
- Arbitrary length → overflow-aware addition is required

**Goal**:  
Find if there's a way to split the string into `a`, `b`, `c`, ... such that:  
- `c = a + b`  
- `d = b + c`  
- and so on...

---

### 🧠 What we have and can do

- Brute-force the first two numbers `a` and `b` using two nested loops
- Simulate the sequence using a helper `stringAdd(a, b)` to avoid integer overflow
- Check if the rest of the string matches the additive chain
- If the entire string is consumed by valid additions → return `true`

---

### 💡 Code Idea

1. Loop over all possible splits for `a` and `b`
2. Skip invalid candidates with leading zeros
3. Simulate the additive sequence using `stringAdd`
4. If the simulation consumes the entire string → valid sequence found



## 🧾 Full Code: Additive Number

```csharp
public class Solution {
    public bool IsAdditiveNumber(string num) {
        int n = num.Length;

        for (int i = 1; i <= n - 2; i++) {
            for (int j = i + 1; j <= n - 1; j++) {
                string a = num.Substring(0, i);
                string b = num.Substring(i, j - i);

                // Skip numbers with leading zeros
                if ((a.Length > 1 && a[0] == '0') || (b.Length > 1 && b[0] == '0')) continue;

                int start = j;
                while (start < n) {
                    string sum = stringAdd(a, b);
                    if (!num.Substring(start).StartsWith(sum)) break;

                    start += sum.Length;
                    a = b;
                    b = sum;
                }

                if (start == n) return true;
            }
        }

        return false;
    }

    // Overflow-safe string addition
    private string stringAdd(string num1, string num2) {
        StringBuilder sb = new StringBuilder();
        int carry = 0, i = num1.Length - 1, j = num2.Length - 1;

        while (i >= 0 || j >= 0 || carry > 0) {
            int digit1 = i >= 0 ? num1[i--] - '0' : 0;
            int digit2 = j >= 0 ? num2[j--] - '0' : 0;
            int sum = digit1 + digit2 + carry;
            sb.Insert(0, sum % 10);
            carry = sum / 10;
        }

        return sb.ToString();
    }
}
```

## 🔍 Code Breakdown: Additive Number

| **Component**        | **Purpose & Architectural Role**                                                                                                                                 |
|----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `for i, j`           | Brute-force all valid splits for the first two numbers `a` and `b`. Outer loop sets boundary for `a`, inner loop for `b`. Ensures at least 3 numbers in total.   |
| **Leading zero check** | Filters out invalid candidates like `"01"` or `"00"` unless the number is `"0"` itself. Enforces numeric integrity and avoids false positives.                  |
| `stringAdd(a, b)`    | Digit-wise addition in string form. Avoids integer overflow and supports arbitrarily large numbers. Acts as a reusable arithmetic primitive.                     |
| `start == n`         | **Architectural invariant**: confirms that the entire string has been consumed by valid additive steps. Signals successful simulation and full coverage.         |
| `return true`        | Triggered only when a valid additive sequence spans the full input. Represents a successful match of the structural pattern.                                     |
| `return false`       | Default fallback when no valid `(a, b)` pair leads to full coverage. Ensures exhaustive search without premature termination.                                    |

---

## 🧠 Engineering Insight

This pattern generalizes to a family of problems with the following traits:

### 🔗 1. Seed-Based Chain Simulation
- Select initial seeds (`a`, `b`) and simulate a chain:  
  `c = a + b`, `d = b + c`, `e = c + d`, ...
- Appears in:
  - Fibonacci validation
  - Encoded arithmetic chains
  - Recursive generation tasks

### 🧮 2. Overflow-Aware Arithmetic
- When input exceeds native integer bounds, digit-wise operations are essential.
- `stringAdd` becomes a reusable primitive for:
  - Big integer addition
  - Arbitrary precision arithmetic
  - Cryptographic or encoding tasks

### 📐 3. Architectural Invariant: Full Coverage
- `start == n` signals that the simulation consumed the entire input.
- This invariant is central to:
  - Recursive parsers
  - Chain validators
  - Greedy or iterative simulations

### 🧰 4. Reusable Playbook Elements
- **Split-and-simulate**: Try all valid prefixes, simulate forward.
- **Invariant-based termination**: Use structural signals (`start == n`, `stack empty`, etc.) to confirm success.
- **Edge-case filtering**: Leading zeros, empty substrings, or invalid formats must be filtered early.

---

## 🧱 Suggested Playbook Entry

### 🧩 Pattern: Seeded Chain Simulation with Overflow-Aware Arithmetic

**Use Case**: Validate if a string can be decomposed into a chain where each element is derived from the previous two (e.g., additive number, Fibonacci-like sequences).

**Core Steps**:
1. Brute-force all valid splits for initial seeds `a`, `b`.
2. Filter out invalid candidates (e.g., leading zeros).
3. Simulate the chain using a digit-wise arithmetic primitive (`stringAdd`).
4. Track position `start` and validate full coverage (`start == n`).
5. Return `true` only if the simulation spans the entire input.

**Reusable Primitives**:
- `stringAdd(a, b)` — digit-wise addition for large numbers
- `start == n` — architectural invariant for full coverage

**Generalization**:
- Works for any recursive or iterative chain validation
- Can be extended to multiplication, subtraction, or custom rules

---

## ✅ Conclusions

- This task reinforces the **split → simulate → verify** paradigm.
- `start == n` is a powerful architectural signal for full input consumption — reuse it in parsers, validators, and chain simulations.
- `stringAdd` is now a formalized primitive in your archive — benchmark it against other overflow-safe arithmetic tools.
- The additive number problem is a gateway to deeper combinatorial parsing and recursive simulation tasks — ideal for building intuition in string-based DP and arithmetic chains.




---

# 1038. Binary Search Tree to Greater Sum Tree — Architectural Reverse Inorder Traversal  
*O(n) — Optimal Single Pass with Cumulative Sum*

---

## Problem Statement

Given **BST** root.

Convert to **Greater Sum Tree**:
- Each node value → **original + sum of all greater values** in tree

Return modified tree.

---

## Core Idea — Reverse Inorder (Right → Root → Left)

**Key insight**:
- BST **inorder** = sorted ascending
- **Reverse inorder** = descending (largest first)
- Traverse reverse inorder → accumulate **sum of greater values**
- Update node value = current val + accumulated greater sum

**Single pass**:
- Global `sum` variable
- Recurse right → update node → recurse left

**Perfect** — visits each node once.

---

##  Implementation (C#)

```csharp
public class Solution {
    private int sum = 0;
    public TreeNode BstToGst(TreeNode root) {
        if (root == null) return null;

        BstToGst(root.right);
        sum += root.val;
        root.val = sum;
        BstToGst(root.left);

        return root;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Visit each node exactly once                   |
| **Space Complexity**  | **O(h)**      | Recursion stack (h = tree height, worst O(n) skewed) |

**Optimal** — linear time, minimal space.

---

## Why This Works — Example Walkthrough

**Input**: `[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]`

**Reverse inorder traversal** (right → root → left):

- 8 → sum=8 → node=8
- 7 → sum=15 → node=15
- 6 → sum=21 → node=21
- 5 → sum=26 → node=26
- 4 → sum=30 → node=30
- 3 → sum=33 → node=33
- 2 → sum=35 → node=35
- 1 → sum=36 → node=36
- 0 → sum=36 → node=36

Resulting tree:
```
      30
     /  \
   36     21
  /  \   /  \
 36  35 26  15
        /    \
       33     8
```


**Correct** — each node = sum of itself + all greater values.

**Input**: `[0,null,1]`

- 1 → sum=1 → node=1
- 0 → sum=1 → node=1

→ `[1,null,1]`

**Correct**.

---

## Pitfalls & Edge Cases

- **Single node** → unchanged (no greater values)
- **Skewed right** → works correctly
- **All left** → works correctly
- **Duplicates** → impossible (BST unique values)

All handled perfectly.

---

## Key Takeaway

This is a **masterpiece of traversal**:

- **Reverse inorder** → process largest values first
- **Cumulative sum** → exactly the sum of all greater values
- **In-place update** → no extra space needed
**Pure, clean, optimal** — one of the most elegant BST transformation problems.

---

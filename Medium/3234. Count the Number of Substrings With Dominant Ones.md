# 3234. Count the Number of Substrings With Dominant Ones

**Difficulty:** Medium  
**Topics:** Strings, Greedy, Prefix Sums, Blocks  

---

## ðŸ“– Problem Restatement
You are given a binary string `s`.  
A substring is said to have **dominant ones** if:
```
number_of_ones >= (number_of_zeros)^2
```

Return the total number of substrings with dominant ones.

---

## ðŸ’¡ Core Idea
- Naive O(nÂ²) approach is too slow for n = 40,000.  
- Key observation:  
  - If a substring has too many zeros, the condition becomes impossible.  
  - Valid substrings can be counted by **jumping between zeros** and using the lengths of blocks of ones.  
- Instead of enumerating all substrings, we use **prefix tracking of last zero** and count valid substrings formulaically.

---

## ðŸ”Ž Step-by-Step Algorithm
1. **Preprocessing:**  
   - Build an array `pre` where `pre[i]` stores the index of the last zero before position `i`.  
   - This allows us to quickly identify blocks of consecutive ones.

2. **Main loop:**  
   - For each position `i` (end of substring):  
     - Start with `cnt0 = 1` if `s[i-1] == '0'`, else 0.  
     - Move `j` backwards using `pre[j]` (jumping from zero to zero).  
     - For each step, compute:  
       - `cnt1 = (i - pre[j]) - cnt0` â†’ number of ones in substring.  
       - Check condition: `cnt1 >= cnt0Â²`.  
       - If valid, add `Math.Min(j - pre[j], cnt1 - cnt0Â² + 1)` to result.  
     - Increment `cnt0` and continue until condition fails or zeros exceed âˆšn.

3. **Result:**  
   - Sum of all valid substrings counted across positions.

---

## âœ… C# Implementation
```csharp
public class Solution {
    public int NumberOfSubstrings(string s) {
        int n = s.Length;
        int[] pre = new int[n + 1];
        pre[0] = -1;

        // Build prefix array of last zero positions
        for (int i = 0; i < n; i++) {
            if (i == 0 || s[i - 1] == '0') {
                pre[i + 1] = i;
            } else {
                pre[i + 1] = pre[i];
            }
        }

        int res = 0;

        // Count valid substrings
        for (int i = 1; i <= n; i++) {
            int cnt0 = s[i - 1] == '0' ? 1 : 0;
            int j = i;

            while (j > 0 && cnt0 * cnt0 <= n) {
                int cnt1 = (i - pre[j]) - cnt0;
                if (cnt0 * cnt0 <= cnt1) {
                    res += Math.Min(j - pre[j], cnt1 - cnt0 * cnt0 + 1);
                }
                j = pre[j];
                cnt0++;
            }
        }

        return res;
    }
}
```

## ðŸ“Š Complexity Analysis

- **Time Complexity: O(nâˆšn)**  
  - Outer loop runs over all positions in the string (n).  
  - For each position, we move backwards using the `pre` array, but the number of steps is bounded by the number of zeros â‰¤ âˆšn.  
  - Therefore, worst-case complexity is O(nâˆšn).  
  - In practice, it is faster because:
    - Entire blocks of ones are counted directly using a formula.  
    - We only jump at zero positions, not at every index.  

- **Space Complexity: O(n)**  
  - We store the `pre` array of size n+1 to track the last zero index.  
  - Additional counters are O(1).  
  - Overall memory usage is linear in the length of the string.

---

## âš ï¸ Pitfalls and Edge Cases

1. **Equality counts**  
   - Condition is `ones >= zerosÂ²`.  
   - Equality (`ones == zerosÂ²`) is valid and must be included.  
   - Mistakenly checking only strict inequality would miss valid substrings.

2. **Jumping logic**  
   - The `pre` array must correctly store the last zero index.  
   - Off-by-one errors here will break substring length calculations (`j - pre[j]`).  
   - Careful indexing is critical.

3. **Blocks of ones**  
   - Substrings consisting only of ones are always valid.  
   - They can be counted directly: block length L â†’ number of substrings = L*(L+1)/2.  
   - This optimization prevents timeouts on long runs of ones.

4. **All ones case**  
   - If the string is entirely ones, the result is simply `n*(n+1)/2`.  
   - Must handle separately to avoid unnecessary loops.

5. **All zeros case**  
   - If the string is entirely zeros, only substrings with â‰¤ 1 zero can be valid.  
   - Example: `"0"` â†’ invalid, `"00"` â†’ invalid, but `"01"` (if a one exists) could be valid.  
   - Important to recognize that zeros alone cannot satisfy the condition.

6. **Single character string**  
   - `"1"` â†’ valid (ones=1, zeros=0).  
   - `"0"` â†’ invalid (ones=0, zerosÂ²=1).  
   - Explicitly handle these trivial cases.

7. **Performance traps**  
   - Without limiting the number of zeros, the algorithm degenerates to O(nÂ²).  
   - Without block-of-ones optimization, strings like `"111...111"` cause TLE.  
   - Both optimizations are essential for passing large test cases.

---

## âœ… Key Takeaway
- The algorithm runs in O(nâˆšn), but practical performance is improved by skipping blocks of ones and jumping only at zeros.  
- Correctness depends on careful handling of equality, indexing in `pre`, and edge cases.  
- Special cases (all ones, all zeros, single character) must be explicitly addressed to avoid errors.




---

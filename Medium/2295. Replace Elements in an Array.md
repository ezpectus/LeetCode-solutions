# 2295. Replace Elements in an Array  
*O(n + m) — HashMap for Fast Lookup & Update*

---

## Problem Statement

You are given a **0-indexed** array `nums` of `n` **distinct** positive integers.

You are also given `m` operations where `operations[i] = [from, to]` means:

- Replace the value `from` in `nums` with `to`

It is guaranteed that:
- `from` exists in `nums` at the time of the i-th operation
- `to` does **not** exist in `nums` at that time

After performing **all** operations in order, return the final state of `nums`.

**Examples**:

**Example 1**  
Input: nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]  
Output: **[3,2,7,1]**  
Operations:
- Replace 1 → 3: [3,2,4,6]
- Replace 4 → 7: [3,2,7,6]
- Replace 6 → 1: [3,2,7,1]

**Example 2**  
Input: nums = [1,2], operations = [[1,3],[2,1],[3,2]]  
Output: **[2,1]**  
Operations:
- 1 → 3: [3,2]
- 2 → 1: [3,1]
- 3 → 2: [2,1]

**Constraints**:
- n == nums.length
- m == operations.length
- 1 ≤ n, m ≤ 10⁵
- All values in `nums` are distinct
- 1 ≤ nums[i], operations[i][0], operations[i][1] ≤ 10⁶
- operations[i][0] exists in nums when applying the operation
- operations[i][1] does not exist in nums at that time

---

## Core Idea — Use HashMap for Fast Value Tracking

**Naive approach** (TLE):
- For each operation: scan array to find `from` → replace with `to` → O(n × m) = O(10¹⁰) → too slow

**Optimal approach**:
- Since all values are **distinct** and **operations guarantee no conflicts**:
  - Maintain a **dictionary** mapping **value → index** in nums
  - For each operation:
    - Look up index of `from` in O(1)
    - Replace nums[index] = `to`
    - Update map: remove `from`, add `to` → index
- Final array is already updated

**Time**: O(n + m) — building map O(n), each operation O(1)  
**Space**: O(n) — map from value to index

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int[] ArrayChange(int[] nums, int[][] operations){
        int n = nums.Length;

        // Map: value → index in nums
        var valueToIndex = new Dictionary<int, int>(n);

        // Initialize map
        for (int i = 0; i < n; i++){
            valueToIndex[nums[i]] = i;
        }

        // Apply all operations
        foreach (var op in operations){
            int from = op[0];
            int to = op[1];

            // Find current index of 'from'
            int index = valueToIndex[from];

            // Update array
            nums[index] = to;

            // Update map: remove old value, add new value
            valueToIndex.Remove(from);
            valueToIndex[to] = index;
        }

        return nums;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n + m)**  | Building initial value-to-index map: O(n)<br>Processing each of m operations: O(1) per operation (dictionary lookup + update) → total O(m) |
| **Space Complexity**  | **O(n)**      | Dictionary storing value → index mapping (at most n entries)<br>Output array is not counted in extra space |

**Optimal** — linear in total input size (array length + number of operations) — perfectly efficient for n, m ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]

**Initial state**:  
nums = [1, 2, 4, 6]  
Map: {1 → 0, 2 → 1, 4 → 2, 6 → 3}

**Operation 1**: replace 1 → 3  
- Lookup index of 1 = **0**  
- nums[0] = 3 → nums = [3,2,4,6]  
- Update map: remove 1, add 3 → 0  
New map: {3→0, 2→1, 4→2, 6→3}

**Operation 2**: replace 4 → 7  
- Lookup index of 4 = **2**  
- nums[2] = 7 → nums = [3,2,7,6]  
- Update map: remove 4, add 7 → 2  
New map: {3→0, 2→1, 7→2, 6→3}

**Operation 3**: replace 6 → 1  
- Lookup index of 6 = **3**  
- nums[3] = 1 → nums = [3,2,7,1]  
- Update map: remove 6, add 1 → 3  
Final nums = [3,2,7,1] → correct

**Correct** —  
Because all values in `nums` are **distinct**, and the problem guarantees:
- `from` always exists in the current array
- `to` never exists yet (no conflicts)

We can maintain a **value-to-index** dictionary for O(1) lookup and update.  
Each operation becomes constant time:
- Find position of old value
- Update array at that position
- Update map (remove old, add new)

This makes the whole process very efficient and clean.

---

## Key Takeaway

This is a **classic value-to-position mapping** problem with updates:

* Use a **dictionary** (value → index) to track where each number currently is in the array
* For each operation `[from, to]`:
  1. Look up current index of `from` in O(1)
  2. Set `nums[index] = to`
  3. Update map: remove `from`, add `to → index`
* After all operations, the array is already correctly modified — return it

**Pure, clean, optimal** — O(n + m) time, O(n) space, extremely fast, simple to implement, and handles all constraints perfectly (distinct values, no conflicts, large n/m).

---

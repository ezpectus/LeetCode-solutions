# 1091. Shortest Path in Binary Matrix — Architectural BFS with 8-Directional Moves  
*O(n²) — Optimal BFS from Start*

---


## Problem Statement

Given an `n × n` binary grid where:
- `0` represents a **clear** (passable) cell
- `1` represents a **blocked** cell

Find the **shortest path** from the top-left cell `(0,0)` to the bottom-right cell `(n-1,n-1)`.

You can move to any of the **8 adjacent cells** (up, down, left, right, and 4 diagonals).

The path must consist **only of 0s**, and both start and end cells must be `0`.

Return the **length** of the shortest path (number of cells visited), or **-1** if no path exists.

---

## Core Idea — BFS from Top-Left

**The most important part — how and why it works**

**Key observation**:
- The grid is an **unweighted graph** (each move costs 1).
- In an unweighted graph, the **shortest path** is always found using **Breadth-First Search (BFS)**.
- Because we can move in **8 directions**, each cell has up to 8 neighbors.
- We must avoid revisiting cells → use a **visited** array.
- The **distance** is exactly the number of steps (or cells visited).

**Why BFS is perfect here**:
- BFS explores level by level → the first time we reach the target, it is with the **minimum number of moves**.
- No need for Dijkstra or A* — all edges have equal weight.

**Algorithm steps**:
1. If `grid[0][0] == 1` or `grid[n-1][n-1] == 1` → return **-1** immediately.
2. Start BFS from `(0,0)` with distance **1** (we count the starting cell).
3. Use a queue: store `(row, col, steps)`
4. Mark visited cells to avoid cycles.
5. Explore all 8 directions.
6. When we reach `(n-1,n-1)` → return current steps.
7. If queue empties without reaching target → return **-1**.

**Edge case handling**:
- `n=1`: if grid[0][0] == 0 → return **1**, else **-1**
  
- **Result**: guaranteed shortest path length in O(n²) time.

---

##  Implementation (C#)

```csharp
public class Solution {
    private readonly int[][] dirs = new int[][] {
        new int[] {-1,-1}, new int[] {-1,0}, new int[] {-1,1},
        new int[] {0,-1},  new int[] {0,1},
        new int[] {1,-1},  new int[] {1,0},  new int[] {1,1}
    };

    public int ShortestPathBinaryMatrix(int[][] grid) {
        int n = grid.Length;
        if (grid[0][0] == 1 || grid[n-1][n-1] == 1) 
            return -1;

        var visited = new bool[n][];
        for (int i = 0; i < n; i++)  visited[i] = new bool[n];
        

        var queue = new Queue<(int r, int c, int steps)>();
        queue.Enqueue((0, 0, 1));
        visited[0][0] = true;

        while (queue.Count > 0) {
            var (r, c, steps) = queue.Dequeue();

            if (r == n-1 && c == n-1)  return steps;

            foreach (var d in dirs) {
                int nr = r + d[0];
                int nc = c + d[1];

                if (nr >= 0 && nr < n && nc >= 0 && nc < n && grid[nr][nc] == 0 && !visited[nr][nc]) {
                    visited[nr][nc] = true;
                    queue.Enqueue((nr, nc, steps + 1));
                }
            }
        }

        return -1;
    }
}
```


## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n²)**             | Visit each cell at most once                   |
| **Space Complexity**  | **O(n²)**             | Queue + visited array (worst case)             |

**Optimal** — must explore the grid to find the path.

---

## Why This Works — Example Walkthrough

**Input**: `[[0,0,0],[1,1,0],[1,1,0]]`

- Start at (0,0), steps = **1**
- Level 1: explore 8 directions
  - (0,1) = 0 → enqueue
  - (1,0) = 1 → blocked
  - (1,1) = 1 → blocked
  - (0,2) = 0 → enqueue (diagonal)
- Continue BFS → reach (2,2) in **4** steps

**Correct**.

**Input**: blocked start or end (grid[0][0] == 1 or grid[n-1][n-1] == 1)

- Immediately return **-1**

**Correct**.

---

## Pitfalls & Edge Cases

- **Blocked start/end** → return -1
- **Diagonal moves** → must use all 8 directions
- **n=1** → if grid[0][0] == 0 → return **1**, else **-1**
- **All blocked** → no path → -1
- **Multiple paths** → BFS guarantees shortest

All handled perfectly.

---

## Key Takeaway

This is a **classic grid BFS**:

- **8 directions** → including diagonals
- **Visited array** → prevent revisiting cells
- **Steps tracked in queue** → guarantees shortest path in unweighted graph

---

## 🧠 Problem: Is Graph Bipartite?  
**LeetCode #785**  
**Difficulty:** Medium  
**Tags:** Graph, DFS, Coloring, Connected Components

---

### 🔍 Problem Summary  
You’re given an undirected graph represented as an adjacency list `graph`, where `graph[u]` contains all nodes adjacent to node `u`.  
The graph may be disconnected, and it has no self-loops or parallel edges.

A graph is **bipartite** if its nodes can be partitioned into two disjoint sets `A` and `B` such that every edge connects a node in `A` to a node in `B`.

Your task is to determine whether the graph is bipartite.

---

### 🧱 Architectural Insight  
This is a classic **graph coloring** problem.  
The idea is to try assigning each node to one of two sets (`left`, `right`) such that no two adjacent nodes are in the same set.

---

### 🔧 Core Strategy

- Use **DFS** to traverse the graph and assign nodes to alternating sets  
- Maintain two sets: `left` and `right`, representing the two partitions  
- Use a `seen` set to track visited nodes and avoid cycles  
- For each unvisited node:
  - Assign it to `left` and start DFS  
  - During DFS, assign neighbors to the opposite set  
  - If a neighbor is already in the same set → return `false`

This approach works even if the graph is **disconnected**, since we initiate DFS from every unvisited node.

## 💡 C# Solution
```csharp
public class Solution {
    public bool IsBipartite(int[][] graph) {
        var left = new HashSet<int>();
        var right = new HashSet<int>();
        var seen = new HashSet<int>();
        int n = graph.Length;

        for (int i = 0; i < n; i++) {
            if (!seen.Contains(i)) {
                seen.Add(i);
                left.Add(i);

                if (!DFS(i, graph, seen, left, right)) return false;
            }
        }

        return true;
    }

    private bool DFS(int node, int[][] graph, HashSet<int> seen, HashSet<int> h1, HashSet<int> h2) {
        foreach (int neighbor in graph[node]) {
            if (h1.Contains(neighbor)) return false;

            if (!seen.Contains(neighbor)) {
                seen.Add(neighbor);
                h2.Add(neighbor);

                if (!DFS(neighbor, graph, seen, h2, h1)) return false;
            }
        }

        return true;
    }
}
```

### 📐 Why This Works

- Each node is assigned to one of two sets (`h1`, `h2`) during DFS  
- Neighbors are always assigned to the **opposite set**  
- If a neighbor is already in the same set → contradiction → not bipartite  
- The graph may be **disconnected**, so we start DFS from every unvisited node  
- The use of `HashSet` ensures **constant-time lookups** and clean partitioning

---

### 🧭 Reflection

This problem sharpened my understanding of **graph coloring** and **DFS-based partitioning**.  
Instead of using numeric colors, I used two explicit sets (`left`, `right`) to model the bipartite structure.

#### 🔑 Key Insights:
- DFS is ideal for **recursive coloring** and **conflict detection**  
- Using `HashSet` for partitions makes the logic **expressive and readable**  
- The recursive swap of `h1` and `h2` during DFS elegantly enforces **alternation**  
- Handling **disconnected graphs** by looping over all nodes ensures full coverage

I implemented the solution in **C#**, focusing on clarity and modularity:
- Variable naming (`h1`, `h2`, `seen`) reflects the alternating structure  
- DFS is written **recursively** with early exits on conflict  
- The code avoids unnecessary complexity and is easy to **extend or debug**

This task reinforced the power of **set-based modeling** in graph problems — a clean way to express constraints and enforce structure.


---

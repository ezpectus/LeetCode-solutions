# 2453. Destroy Sequential Targets  
*O(n log n) — Greedy + HashMap Grouping by Modulo*

---

## Problem Statement

- You are given a **0-indexed** array `nums` of positive integers (targets on a number line) and an integer `space`.
- Seeding the machine with some `nums[i]` allows it to **destroy** all targets of the form `nums[i] + c * space` (c ≥ 0, integer).
- You want to **maximize** the number of destroyed targets.  
- Among all ways to achieve the maximum, return the **minimum** possible `nums[i]` you can seed with.

**Examples**:

**Example 1**  
Input: nums = [3,7,8,1,1,5], space = 2  
Output: **1**  
Seeding with 1 destroys: 1, 3, 5, 7, 9, ... → destroys 5 targets (all except 8)

**Example 2**  
Input: nums = [1,3,5,2,4,6], space = 2  
Output: **1**  
Maximum destroyable = 3 targets (multiple seeds achieve it, minimum seed = 1)

**Example 3**  
Input: nums = [6,2,5], space = 100  
Output: **2**  
Maximum destroyable = 1 target → minimum seed = 2

**Constraints**:
- 1 ≤ nums.length ≤ 10⁵
- 1 ≤ nums[i] ≤ 10⁹
- 1 ≤ space ≤ 10⁹

---

## Core Idea — Group by Modulo + Choose Best Seed per Group

**Key insight**:
- Two numbers `a` and `b` can be destroyed by the same seed iff `a ≡ b (mod space)`
- All targets destroyed by seed `x` are exactly those `t` where `t ≡ x (mod space)` and `t ≥ x`
- To maximize destroyed targets → choose the **modulo class** (residue) with the **most targets**
- Among all targets with that residue, choose the **smallest** one as seed (it can destroy all larger ones in the group)

**Algorithm**:
1. Group all `nums[i]` by their value **modulo space** using a map: residue → list of numbers
2. For each residue class:
   - Count how many targets it has
   - Find the **minimum** number in that group (smallest seed)
3. Find the **maximum count** across all groups
4. Among all groups with that maximum count → choose the **smallest possible seed**

**Time**: O(n log n) — sorting each group (or O(n) with min tracking)  
**Space**: O(n) — map of lists

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int DestroyTargets(int[] nums, int space){
        // Map: residue modulo space → list of numbers with that residue
        var groups = new Dictionary<int, List<int>>();

        foreach (int num in nums){
            int res = num % space;
            if (!groups.ContainsKey(res)) groups[res] = new List<int>(); 
            groups[res].Add(num);
        }

        int maxCount = 0;
        int minSeed = int.MaxValue;

        foreach (var kvp in groups){
            int count = kvp.Value.Count;
            int smallest = kvp.Value.Min();

            if (count > maxCount){
                maxCount = count;
                minSeed = smallest;
            }
            else if (count == maxCount) minSeed = Math.Min(minSeed, smallest); 
        }

        return minSeed;
    }
}
```

## Complexity

| **Metric**            | **Value**              | **Notes**                                                                 |
|-----------------------|------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(n log n)**         | Building groups (dictionary): O(n)<br>Finding minimum in each group using Min(): O(size) per group<br>Worst case (all elements in one group): O(n)<br>Total: O(n log n) due to Min() calls on potentially large lists |
| **Space Complexity**  | **O(n)**               | Dictionary of lists — total elements across all lists = n (each number stored once) |

**Optimal** — linear scan with logarithmic factor from finding minima — perfectly efficient for n ≤ 10⁵.  
(Alternative: track minimum manually per group during insertion → reduces to strict **O(n)** time.)

---

## Why This Works — Example Walkthrough

**Example 1**: nums = [3,7,8,1,1,5], space = 2

**Groups by modulo 2**:

- residue 0: [8]
- residue 1: [3,7,1,1,5]

**Counts**:
- residue 0: 1 target
- residue 1: 5 targets

**Maximum destroyable targets** = 5 (residue 1)  
**Smallest seed in that group** = min(1,1,3,5,7) = **1**

→ Seeding with 1 destroys all numbers ≡ 1 (mod 2) that are ≥ 1 → destroys 5 targets → correct

**Correct** —  
All numbers congruent modulo `space` form a **chain** that can be destroyed by seeding the **smallest** one in the group.  
The smallest seed can reach all larger ones in the arithmetic progression: x, x+space, x+2*space, ...  
We identify the **largest residue group** (most targets destroyable by one seed), then pick the **smallest** number in that group as the seed.

---

## Key Takeaway

This is a **beautiful greedy + modulo grouping** problem:

* Group all numbers by their value **modulo space** — numbers in the same residue class can be destroyed by the same seed
* For each residue group, the **maximum destroyable** = size of the group
* The **optimal seed** for a group is always the **smallest** number in that group (it can reach all larger congruent numbers)
* Find the **maximum group size** across all residues
* Among all groups that achieve this maximum size → choose the **smallest possible seed**

**Pure, clean, optimal** — O(n log n) time (or O(n) with manual min tracking), O(n) space, extremely fast, very intuitive, and mathematically correct.

---

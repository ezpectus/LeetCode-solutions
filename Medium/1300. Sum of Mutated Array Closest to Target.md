# 1300. Sum of Mutated Array Closest to Target

## Problem

Given an integer array `arr` and an integer `target`,  
return the integer `value` such that when every element in `arr` greater than `value` is replaced with `value`,  
the sum of the resulting array is as close as possible to `target`.  
If multiple values yield the same absolute difference, return the smallest such value.

## Constraints

- `1 <= arr.length <= 10^4`
- `1 <= arr[i], target <= 10^5`

## Why Binary Search Works

We are not searching for an index — we are searching for a **value** that minimizes the absolute difference between the mutated sum and the target.

Define a function:

```text
mutatedSum(value) = sum of arr where each element > value is replaced with value
```
This function is monotonically increasing:

- As value increases, fewer elements are capped
- So the total sum increases or stays the same
- This monotonicity allows us to apply binary search over the value space: value ∈ [0, max(arr)]
- Brute force would require checking every possible value in that range — up to 10^5 steps. 
- Binary search reduces this to ~17 steps (log2(10^5)), each taking O(n) time to compute the sum.

## Solution Idea
- Use binary search to find the smallest value such that mutatedSum(value) >= target
- After binary search, compare value and value - 1 to find which gives the closest sum
- Return the smaller value in case of tie

## C# Code
```cpp
public class Solution {
    public int FindBestValue(int[] arr, int target) {
        Array.Sort(arr);
        int left = 0;
        int right = arr.Max();

        while (left < right) {
            int mid = left + (right - left) / 2;
            int sum = Mutated(arr, mid);

            if (sum < target) left = mid + 1;
            else right = mid;
        }

        int sum1 = Mutated(arr, left);
        int sum2 = Mutated(arr, left - 1);

        if (Math.Abs(sum1 - target) < Math.Abs(sum2 - target)) return left;
        else return left - 1;
    }

    public int Mutated(int[] arr, int val) {
        int sum = 0;
        foreach (int a in arr) {
            sum += Math.Min(a, val);
        }
        return sum;
    }
}
```

## Complexity

- Time: O(n log m) where n = arr.Length, m = max(arr)
- Sorting: O(n log n)
- Binary search: O(log m) iterations
- Each iteration: O(n) to compute mutated sum
- Space: O(1)

## Pitfalls
- Using arr[arr.Length - 1] as upper bound without sorting can break the binary search
- Forgetting to compare left and left - 1 after search may return suboptimal result
- Assuming the answer must be in arr — it can be any integer

## Insight
- This is a classic case of binary search over answer space, not index. 
- The key is recognizing that the mutated sum function is monotonic, which makes binary search valid and efficient. 
- Final tie-breaker ensures minimal value is returned when multiple candidates yield the same difference.

---

# 1162. As Far from Land as Possible — Architectural Multi-Source BFS from Land  
*O(n²) — Optimal Single Queue BFS*

---

## Problem Statement

Given `n × n` grid:
- `1` = land
- `0` = water

Find **water cell** (`0`) with **maximum Manhattan distance** to **nearest land** (`1`).

Return that distance, or **-1** if no water/land.

---

## Core Idea — Multi-Source BFS Starting from All Land Cells

**Key insight**:
- We want **farthest water** from **any land**
- Equivalent: shortest path from water to nearest land → reverse → start from **all land** simultaneously

**Multi-source BFS**:
- Queue all **land cells** (`1`) with distance 0
- BFS → visit water cells (`0`)
- Distance = steps from nearest land
- Track **maximum** distance reached

**Modify grid** or use visited → mark as visited.

**If no water** → return -1

---

##  Implementation (C#)

```csharp
public class Solution {
    private int[][] dirs = new int[][] {
        new int[] { -1, 0 },
        new int[] { 1, 0 },
        new int[] { 0, -1 },
        new int[] { 0, 1 }
    };

    public int MaxDistance(int[][] grid) {
        int n = grid.Length;
        var queue = new Queue<(int r, int c)>();

        // Enqueue all land cells and mark as visited (use -1 or modify to 1→visited)
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1)  queue.Enqueue((i, j));
            }
        }

        // If no land or no water
        if (queue.Count == 0 || queue.Count == n * n)  return -1;
        

        int dist = 0;
        while (queue.Count > 0) {
            int size = queue.Count;

            for (int i = 0; i < size; i++) {
                var (r, c) = queue.Dequeue();

                foreach (var d in dirs) {
                    int nr = r + d[0];
                    int nc = c + d[1];

                    if (nr >= 0 && nr < n && nc >= 0 && nc < n && grid[nr][nc] == 0) {
                        grid[nr][nc] = 1; // mark visited
                        queue.Enqueue((nr, nc));
                    }
                }
            }

            if (queue.Count > 0) dist++;
        }

        return dist;
    }
}
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n²)**             | Each cell enqueued/dequeued at most once       |
| **Space Complexity**  | **O(n²)**             | Queue worst case (all water cells)             |

**Optimal** — must visit all cells in the grid.

---

## Why This Works — Example Walkthrough

**Input**: `[[1,0,1],[0,0,0],[1,0,1]]`

- **Initial queue**: all land cells → (0,0), (0,2), (2,0), (2,2)
- **Level 1**: reach adjacent water → (0,1), (1,0), (1,2), (2,1)
- **Level 2**: reach center water → (1,1)

→ Maximum distance = **2** (center cell (1,1))

**Correct**.

**Input**: all land cells

- Queue fills with all cells → no water → return **-1**

**Correct**.

---

## Pitfalls & Edge Cases

- **No land** → queue empty → -1
- **No water** → queue full → -1
- **Single cell** → either land or water → -1
- **Disconnected components** → BFS from all land handles correctly
- **Boundary cells** → correctly considered as distance 0 if land

All handled perfectly.

---

## Key Takeaway

This is a **masterpiece of multi-source BFS**:

- **Start from all land cells simultaneously** → shortest path to any water
- **Level-by-level traversal** → exact distance from nearest land
- **Maximum level reached** → farthest water cell

**In-place grid marking** → clean and space-efficient.
**Pure, clean, optimal** — one of the best grid distance problems.

---

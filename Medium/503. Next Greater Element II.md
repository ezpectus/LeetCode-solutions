# 503. Next Greater Element II — Architectural Monotonic Stack + Circular Scan  
*O(n) — Classic Double-Pass Trick*

---

## Problem Statement

Given a **circular** integer array `nums`, for each `nums[i]` find the **next greater element**:

- Search **forward**, wrapping around to the beginning if needed
- Return `-1` if no greater element exists

---

## Core Idea — Monotonic Stack + Double Pass

**Standard NGE** uses a **decreasing monotonic stack** of indices.

**Circular twist** → we need to see elements **after** the end.

**Brilliant trick**:  
Iterate the array **twice** (`i` from `0` to `2*n-1`)  
Use `j = i % n` → simulates wrap-around

- **Only push** indices during first pass (`i < n`)
- **Pop and update** answers during both passes

This gives **O(n)** total time — each element pushed/popped at most once.

---

## Full Implementation (C#)

```csharp
public class Solution {
    public int[] NextGreaterElements(int[] nums) {
        int n = nums.Length;
        int[] res = new int[n];
        Array.Fill(res, -1);

        Stack<int> st = new Stack<int>();
        for (int i = 0; i < 2 * n; i++) {
            int j = i % n;

            while (st.Count > 0 && nums[j] > nums[st.Peek()]) {
                int k = st.Pop();
                res[k] = nums[j];
            }

            if (i < n) st.Push(j);
        }
        return res;
    }
}
```


## Complexity Analysis

| **Metric**     | **Value**   | **Notes**                                      |
|----------------|-------------|------------------------------------------------|
| **Time**       | **O(n)**    | Each element is pushed and popped **at most once** |
| **Space**      | **O(n)**    | Stack stores indices in worst case             |

**Optimal** — cannot be done faster or with less memory.

---

## Pitfalls & Edge Cases

- **Must use `i % n`** — this is the key to simulating circular wrap-around
- **Only push during first pass (`i < n`)** — prevents duplicate pushes and infinite loop
- **Initialize result with `-1`** — default answer when no greater element exists
- Works perfectly with:
  - **Negative numbers**
  - **Duplicates**
  - **Single element** → returns `[-1]`
  - **All elements equal** → returns all `-1`
  - **Increasing order** → first elements get correct wrap-around answers

---

## Key Takeaway

This is a **classic circular next-greater element** problem solved with one of the most elegant tricks in competitive programming:

- Use a **monotonic decreasing stack**
- Simulate circularity via **double pass** (`0` to `2*n-1`) and `i % n`
- **Push only in first pass** → keeps stack clean and correct

**No extra space tricks, no brute force** — just pure, beautiful algorithmic insight.
**One of the most satisfying uses of the double-pass technique in existence.**

---


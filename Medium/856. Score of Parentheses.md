# 856. Score of Parentheses — Architectural Stack-Based Depth Scoring  
*O(n) — Optimal Linear Pass*

---

## Problem Statement

Given balanced parentheses string `s`.

Compute **score**:
- `"()"` → 1
- `AB` → score(A) + score(B)
- `(A)` → 2 × score(A)

Return total score.

---

## Core Idea — Stack with Depth Multiplier

**Insight**:
- Traverse string left to right
- Use **stack** to track current depth and accumulated score
- When meet `)`:
  - If previous was `(` → `"()"` → add `1`
  - Else → pop inner score → **double** it → add to current level

**Key**:
- At each level, maintain **current partial score**
- When closing `)` → double inner score (or 1 for `"()"`)
- Add to parent level

**Single stack** of integers → current score at depth.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int ScoreOfParentheses(string s) {
        var stack = new Stack<int>();
        stack.Push(0); // initial score at depth 0

        foreach (char c in s) {
            if (c == '(')  stack.Push(0); // new level, start with 0
             
            else {
                int inner = stack.Pop();
                int val = inner == 0 ? 1 : 2 * inner; // "()" or (A)
                stack.Push(stack.Pop() + val);       // add to parent level
            }
        }

        return stack.Pop();
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass over the string                    |
| **Space Complexity**  | **O(n)**      | Stack depth ≤ n/2 (maximum nesting depth)      |

**Optimal** — linear time, minimal space.

---

## Why This Works — Detailed Idea Explanation

**Core idea**:
We use a **stack** to simulate recursive score calculation without actual recursion.

- Each stack element represents the **accumulated score at the current nesting level**.
- On opening parenthesis `(` → we start a **new level** → push `0` (no score yet).
- On closing parenthesis `)`:
  - Pop the score of the **inner** level.
  - If the inner part was just `()` → inner score = 0 → treat as **1**.
  - If the inner part was a complex expression → **double** its score (`2 * inner`).
  - Add this value to the **parent level** (pop parent → add → push back).

**Why doubling**:
- Rule `(A)` → `2 * score(A)` is applied exactly when closing the outer parenthesis.

**Why +1 for `()`**:
- When we see `()` → inner level has 0 → we convert it to 1.

**Why addition for adjacent**:
- When two expressions are at the same level (e.g., `()()`), their scores are simply added at the parent level.

Thus, the **stack naturally models nesting depth** and scoring rules.

---

## Example Walkthrough

**Input**: `"(())"`

- `(` → push 0 → stack: [0, 0]
- `(` → push 0 → stack: [0, 0, 0]
- `)` → pop 0 → val = 1 (empty inside) → add to top: 0 + 1 → push 1 → stack: [0, 1]
- `)` → pop 1 → val = 2×1 = 2 → add to top: 0 + 2 → push 2 → stack: [2]

→ **2** correct.

**Input**: `"()()"`

- `(` → [0,0]
- `)` → pop 0 → val=1 → add → [1]
- `(` → [1,0]
- `)` → pop 0 → val=1 → add → [2]

→ **2** correct.

**Input**: `"(()(()))"`

Step by step: inner `()` give 1 → nested give 2 → combination 1+2=3 → outer doubling → **6**.

**Perfect**.

---

## Pitfalls & Edge Cases

- `"()"` → 1
- `"(())"` → 2
- `"()()"` → 2
- Deep nesting → stack handles correctly
- All strings are balanced → guaranteed by constraints

All covered.

---

## Key Takeaway

This is a **beautifully elegant** stack problem:

- **Stack** tracks current level score
- **`)`** triggers **double or 1**
- **Add to parent** → natural recursion simulation

**No recursion. No extra space beyond stack.**
**Pure, clean, optimal** — one of the most satisfying Medium stack problems.


---

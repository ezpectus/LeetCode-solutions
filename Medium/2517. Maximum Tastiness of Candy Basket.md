# 2517. Maximum Tastiness of Candy Basket  
*O(n log n) — Binary Search + Greedy Check*

---

## Problem Statement

You are given an array of positive integers `price` where `price[i]` is the price of the `i`-th candy, and a positive integer `k`.

You want to select a basket of **exactly k distinct candies**.  
The **tastiness** of the basket is the **smallest** absolute difference between **any two** prices in the basket.

Return the **maximum possible tastiness** of such a basket.

**Examples**:

**Example 1**  
Input: price = [13,5,1,8,21,2], k = 3  
Output: **8**  
Best basket: [5,13,21] → min diff = min(8,8,16) = **8**

**Example 2**  
Input: price = [1,3,1], k = 2  
Output: **2**  
Best: [1,3] → diff = **2**

**Example 3**  
Input: price = [7,7,7,7], k = 2  
Output: **0**  
Any pair has diff = **0**

**Constraints**:
- 2 ≤ k ≤ price.length ≤ 10⁵
- 1 ≤ price[i] ≤ 10⁹

---

## Core Idea — Binary Search on Minimum Difference + Greedy Validation

**Key insight**:
- We want the **maximum possible** value `D` such that there exists a subset of **exactly k** candies where **every pair** has price difference **≥ D** (i.e., minimum difference in basket is ≥ D).
- This is classic **binary search on answer** (the tastiness D).
- Search range: low = 0, high = max(price) - min(price) ≈ 10⁹
- For a candidate `D`, check if we can select **at least k** candies such that any two have |price[i] - price[j]| ≥ D.

**Greedy check**:
- Sort the prices
- Use greedy selection: start with the smallest price, then repeatedly take the smallest price that is ≥ previous + D
- Count how many we can pick this way
- If count ≥ k → possible for this D → try larger D
- Else → need smaller D

**Time**:
- Sorting: O(n log n)
- Binary search: O(log 10⁹) ≈ 30 iterations
- Each check: O(n) greedy pass → total O(n log n + 30 × n) ≈ O(n log n)

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int MaximumTastiness(int[] price, int k){
        Array.Sort(price);
        int n = price.Length;

        int left = 0;
        int right = price[^1] - price[0]; // max possible tastiness

        while (left < right){
            int mid = left + (right - left + 1) / 2; // upper mid to avoid infinite loop

            // Check if we can select at least k candies with min diff >= mid
            if (CanSelect(price, mid, k)) left = mid; // try larger tastiness
            else right = mid - 1;
            
        }

        return left;
    }

    private bool CanSelect(int[] price, int minDiff, int k){
        int n = price.Length;
        int count = 1; // take the first one
        int last = price[0];

        for (int i = 1; i < n; i++){
            if (price[i] - last >= minDiff){
                count++;
                last = price[i];
                if (count >= k) return true;
            }
        }

        return count >= k;
    }
}
```


## Complexity

| **Metric**            | **Value**              | **Notes**                                                                 |
|-----------------------|------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(n log n)**         | Sorting the prices array: O(n log n)<br>Binary search on tastiness D: O(log MAX) ≈ 30 iterations<br>Each check: greedy linear pass O(n)<br>Dominant term: sorting O(n log n) |
| **Space Complexity**  | **O(1)**               | Only a few integer variables (sorting is done in-place in C#)             |

**Optimal** — sorting dominates the time, followed by logarithmic binary search with linear checks — very efficient and practical for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: price = [13,5,1,8,21,2], k = 3  
After sorting: [1,2,5,8,13,21]

We want the **largest** D such that we can select at least 3 numbers where **every pair** differs by at least D (i.e., minimum difference in selected subset ≥ D).

**Binary search on D**:

Try D = 8:
- Greedy selection (always take smallest possible next ≥ previous + D):
  - Start with 1
  - Next ≥ 1+8=9 → 13
  - Next ≥ 13+8=21 → 21
  - Selected 3 numbers → possible ✓

Try D = 9:
- Start with 1
- Next ≥ 1+9=10 → 13
- Next ≥ 13+9=22 → none
- Only 2 numbers → impossible

Highest feasible D = **8**  
(e.g., select 5,13,21 → min diff = min(8,8,16) = 8) → correct

**Correct** —  
We **binary search** for the largest possible **minimum pairwise difference** (tastiness) in any k-element subset of prices.  
For each candidate D, we check if we can select **at least k** numbers from the **sorted** prices such that **consecutive** selected numbers differ by **≥ D** (which guarantees all pairs differ by ≥ D in a sorted subset).  
The **greedy** choice (always pick the smallest possible next number ≥ previous + D) maximizes the chance of fitting k numbers while maintaining the difference constraint.

---

## Key Takeaway

This is a **classic binary search on answer + greedy validation** problem:

* Binary search on the target **tastiness D** (the minimum difference we want to achieve in the basket)
* Sort the price array first
* For a candidate D, check if we can select **≥ k** prices such that consecutive selected prices differ by **≥ D**
* Use **greedy selection**: start from the smallest price, repeatedly take the smallest price ≥ previous + D
* If we can select ≥ k numbers this way → D is possible → try larger D
* Return the largest D for which the check returns true

**Pure, clean, optimal** — O(n log n) time (sorting + log(MAX) × n checks), O(1) extra space after sorting, extremely fast, elegant, and correctly finds the maximum possible minimum pairwise difference in any k-element subset.

---

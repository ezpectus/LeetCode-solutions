# 2270. Number of Ways to Split Array  
*O(n) — Prefix Sum + Single Pass*

---

## Problem Statement

You are given a **0-indexed** integer array `nums` of length `n`.

A split at index `i` (0 ≤ i < n-1) is **valid** if:

- Sum of the **prefix** (first i+1 elements) ≥ Sum of the **suffix** (last n-i-1 elements)
- There is at least one element to the right (i < n-1)

Return the **number of valid split indices** i.

**Examples**:

**Example 1**: nums = [10,4,-8,7]  
Output: **2**  
Valid splits at i=0 and i=1  
(i=2 invalid because 6 < 7)

**Example 2**: nums = [2,3,1,0]  
Output: **2**  
Valid splits at i=1 and i=2

**Constraints**:
- 2 ≤ n ≤ 10⁵
- -10⁵ ≤ nums[i] ≤ 10⁵

---

## Core Idea — Prefix Sum + Single Backward Pass

**Naive** way: for each i compute left sum and right sum → O(n²) → TLE

**Optimal** way:
- Compute **total sum** of array once
- Use **prefix sum** (or running sum from left)
- For each possible split i (0 to n-2):
  - left_sum = sum(nums[0..i])
  - right_sum = total_sum - left_sum
  - Check if left_sum ≥ right_sum
- To avoid recomputing sums, use a running prefix

**Even cleaner** (most efficient):
- Compute total sum
- Iterate from **left to right**, maintaining current prefix sum
- At each i (before adding nums[i+1]), check if current prefix ≥ (total - current prefix)

**Time**: O(n) — one pass to compute total + one pass to count  
**Space**: O(1) — only variables

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int WaysToSplitArray(int[] nums) {
        int n = nums.Length;
        long totalSum = 0;
        
        // Compute total sum
        foreach(int num in nums) {
            totalSum += num;
        }
        
        long prefix = 0;
        int count = 0;
        
        // Check splits at i = 0 to n-2
        for (int i = 0; i < n - 1; i++) {
            prefix += nums[i];
            long suffix = totalSum - prefix;
            
            if (prefix >= suffix) {
                count++;
            }
        }
        
        return count;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | One pass to compute the total sum + one pass to build running prefix and check the condition |
| **Space Complexity**  | **O(1)**      | Only a few `long` variables — no extra arrays or data structures needed |

**Optimal** — linear time and constant extra space — perfect and very efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: nums = [10, 4, -8, 7]  
totalSum = 10 + 4 + (-8) + 7 = **13**

- i = 0: prefix = 10, suffix = 13−10 = 3 → 10 ≥ 3 → valid (count = 1)
- i = 1: prefix = 10 + 4 = 14, suffix = 13−14 = -1 → 14 ≥ -1 → valid (count = 2)
- i = 2: prefix = 14 + (-8) = 6, suffix = 13−6 = 7 → 6 < 7 → invalid

Result: **2** → correct

**Example 2**: nums = [2, 3, 1, 0]  
totalSum = 2 + 3 + 1 + 0 = **6**

- i = 0: prefix = 2, suffix = 4 → 2 < 4 → no
- i = 1: prefix = 2 + 3 = 5, suffix = 1 → 5 ≥ 1 → yes
- i = 2: prefix = 5 + 1 = 6, suffix = 0 → 6 ≥ 0 → yes

Result: **2** → correct

**Correct** —  
We only need to check one simple condition for each possible split point i (from 0 to n-2):  
**prefix_sum[0..i] ≥ suffix_sum[i+1..n-1]**  
Using a running prefix sum and a single precomputed total sum makes this extremely efficient and clean.

---

## Key Takeaway

This is a **simple, beautiful prefix-sum comparison** problem:

* Compute the **total sum** of the array once (use `long` to avoid overflow)
* Maintain a **running prefix sum** from left to right
* For every possible split index i (0 to n-2):
  * `left = prefix sum up to i` (inclusive)
  * `right = totalSum - left`
  * If `left >= right` → this is a valid split position
* Count how many such i exist

**Pure, clean, optimal** — O(n) time, O(1) extra space, safe from overflow (using `long`), very fast, intuitive, and elegant.

---

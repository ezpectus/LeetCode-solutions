# Pattern Name  
Numerically Balanced Integer Generation via DFS and Digit Count Constraints

---

## Problem Summary

You're given:

- An integer `n`  
- A number is numerically balanced if for every digit `d`, it appears exactly `d` times in the number

Constraints:

- \(0 \leq n \leq 10^6\)  
- Return the smallest numerically balanced number strictly greater than `n`

---

## Core Idea

This is a digit-count constrained generation problem.  
We use DFS to build all valid numerically balanced numbers, store them, sort them, and return the first one greater than `n`.

---

## Strategy Summary

1. Use DFS to generate all numbers where digit `d` appears at most `d` times  
2. Track digit counts during construction  
3. Add number to list if it satisfies the numerically balanced condition  
4. After generation, sort the list  
5. Return the first number greater than `n`

---

## C# Implementation

```csharp
public class Solution {
    public int NextBeautifulNumber(int n) {
        List<int> list = new List<int>();
        Generate(0, new int[10], list);
        list.Sort();
        foreach (int num in list) {
            if (num > n) return num;
        }
        return -1;
    }

    private void Generate(long num, int[] count, List<int> list) {
        if (num > 0 && IsBeautiful(count)) list.Add((int)num);
        if (num > 1224444) return;

        for (int d = 1; d <= 7; d++) {
            if (count[d] < d) {
                count[d]++;
                Generate(num * 10 + d, count, list);
                count[d]--;
            }
        }
    }

    private bool IsBeautiful(int[] count) {
        for (int d = 1; d <= 7; d++)
            if (count[d] != 0 && count[d] != d) return false;
        return true;
    }
}
```

## Architectural Breakdown

| Component             | Role                                                  |
|----------------------|--------------------------------------------------------|
| NextBeautifulNumber   | Entry point, returns first valid number > n           |
| Generate              | DFS generator for candidate numbers                   |
| count[]               | Tracks digit frequencies during construction          |
| IsBeautiful           | Validates numerically balanced condition              |
| list.Sort()           | Ensures ascending order for final selection           |

---

## Why This Approach Is Superior

| Aspect               | This Approach                          | Alternative Approach                     |
|----------------------|----------------------------------------|------------------------------------------|
| Generation Strategy  | DFS with digit constraints             | Brute-force scan or regex filtering      |
| Validation Logic     | Frequency table                        | String parsing or repeated counting      |
| Ordering Guarantee   | Post-sort ensures correctness          | May require manual comparison logic      |
| Code Clarity         | Modular and readable                   | Entangled or stateful recursion          |
| Generalizability     | Adapts to other digit-count problems   | Hardcoded or fragile logic               |

---

## Final Takeaway

This problem is not about brute-force enumeration â€” it's about controlled digit placement under frequency constraints.  
The solution uses:

- Recursive DFS with digit limits  
- Frequency tracking via fixed-size array  
- Post-filtering via sorted candidate list

This pattern generalizes to any task involving:

- Digit frequency constraints  
- Controlled recursive generation  
- Post-filtering via sorted candidate list

This module now lives in my repo as:

**Numerically Balanced Integer Generation via DFS and Digit Count Constraints**


---

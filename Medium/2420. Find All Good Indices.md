# ðŸ§© LeetCode 2420 â€” Find All Good Indices

## ðŸ“œ Problem Statement

You are given a 0-indexed integer array `nums` of length `n` and a positive integer `k`.

An index `i` is considered **good** if:
- `k` elements before index `i` (i.e., `nums[i-k]` to `nums[i-1]`) are in **non-increasing** order.
- `k` elements after index `i` (i.e., `nums[i+1]` to `nums[i+k]`) are in **non-decreasing** order.
- The index `i` satisfies `k â‰¤ i < n - k`.

Return a list of all good indices in increasing order.

---

## ðŸ“ Constraints

- `3 â‰¤ n â‰¤ 10âµ` â€” large input size, so we need an **O(n)** solution.
- `1 â‰¤ nums[i] â‰¤ 10â¶` â€” values are large, but comparisons are cheap.
- `1 â‰¤ k â‰¤ n / 2` â€” ensures that `k` elements before and after `i` always exist.

---

## ðŸ§  Architectural Insight

### ðŸ”¹ Naive Approach (Rejected)
Checking each index `i` by scanning `k` elements before and after would cost **O(nÂ·k)** â€” too slow for `n = 10âµ`.

### ðŸ”¹ Optimized Strategy
We precompute two helper arrays:
- `nonInc[i]`: number of consecutive non-increasing elements ending at index `i`.
- `nonDec[i]`: number of consecutive non-decreasing elements starting at index `i`.

This allows us to check each index `i` in **O(1)** time using precomputed data.

---

## ðŸ”§ Algorithm Breakdown

### Step 1: Count non-increasing streaks from left to right
```csharp
for (int i = 1; i < n; i++) {
    if (nums[i] <= nums[i - 1])
        nonInc[i] = nonInc[i - 1] + 1;
    else
        nonInc[i] = 0;
}
```
Step 2: Count non-decreasing streaks from right to left
```
for (int i = n - 2; i >= 0; i--) {
    if (nums[i] <= nums[i + 1])
        nonDec[i] = nonDec[i + 1] + 1;
    else
        nonDec[i] = 0;
}
```
Step 3: Validate each index i in range [k, n - k)
```
for (int i = k; i < n - k; i++) {
    if (nonInc[i - 1] >= k - 1 && nonDec[i + 1] >= k - 1)
        res.Add(i);
}
```

## âœ… Final Code C# 
```cpp
public class Solution {
    public IList<int> GoodIndices(int[] nums, int k) {
        int n = nums.Length;
        var res = new List<int>();
        int[] nonInc = new int[n];
        int[] nonDec = new int[n];

        for (int i = 1; i < n; i++) {
            if (nums[i] <= nums[i - 1])
                nonInc[i] = nonInc[i - 1] + 1;
            else
                nonInc[i] = 0;
        }

        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] <= nums[i + 1])
                nonDec[i] = nonDec[i + 1] + 1;
            else
                nonDec[i] = 0;
        }

        for (int i = k; i < n - k; i++) {
            if (nonInc[i - 1] >= k - 1 && nonDec[i + 1] >= k - 1)
                res.Add(i);
        }

        return res;
    }
}
```
## ðŸ“¦ Module Summary â€” Deep Dive

| Component         | Description |
|------------------|-------------|
| **Time Complexity** | `O(n)` â€” The solution performs two linear scans: one from left to right to compute non-increasing streaks, and one from right to left to compute non-decreasing streaks. The final validation loop is also linear, making the total time complexity `O(n)`. |
| **Space Complexity** | `O(n)` â€” Two auxiliary arrays (`nonInc` and `nonDec`) of size `n` are used to store streak lengths. These arrays allow constant-time checks for each index `i`. |
| **Pattern** | **Prefix streak analysis + local validation** â€” This is a classic pattern where we preprocess directional properties (monotonicity) and then validate each candidate index using constant-time lookups. It avoids redundant scanning and enables efficient decision-making. |
| **Reusability** | **High** â€” This module can be reused for any problem involving "k elements before and after" with monotonic constraints. It generalizes well to sliding window checks, local extrema detection, and segment-based validation. |
| **Edge Case Handling** | The algorithm naturally avoids out-of-bound errors by starting the validation loop from `i = k` and ending at `i < n - k`. This ensures that both the left and right segments of size `k` exist for every candidate index. |
| **Scalability** | Suitable for large inputs (`n â‰¤ 10âµ`) due to linear time and space. No nested loops or brute-force checks. |
| **Language Agnostic** | The logic is portable across languages â€” can be implemented in Python, C++, Java, etc., with minimal adjustments. |
| **Debuggability** | The use of helper arrays makes it easy to visualize and debug streaks. You can print `nonInc` and `nonDec` to trace monotonic segments. |


---

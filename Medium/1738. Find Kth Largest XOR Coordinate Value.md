# 1738. Find Kth Largest XOR Coordinate Value — Architectural 2D Prefix XOR + Priority Queue  
*O(mn log(mn)) — Optimal with Min-Heap for Kth Largest*

---

## Problem Statement

- Given `m × n` matrix of non-negative integers.
- Define value at `(a,b)` = XOR of all cells in submatrix from `(0,0)` to `(a,b)` inclusive.
- Find the **kth largest** such value (1-indexed) among all `m×n` coordinates.
- Return that value.

---

## Core Idea — 2D Prefix XOR + Min-Heap for Kth Largest

**Key insight**:
- Value at `(i,j)` = prefix XOR from (0,0) to (i,j)
- Compute **2D prefix XOR array** in O(mn):
  - `prefix[i][j] = prefix[i-1][j] ^ prefix[i][j-1] ^ prefix[i-1][j-1] ^ matrix[i][j]`
- All values are in `prefix[][]`
- Need **kth largest** among them → use **min-heap** of size k (or sort)

**Best approach**:
- Compute prefix XOR
- Use **min-heap** (priority queue) to keep **k largest** values
- Time: O(mn log k) — optimal for k up to mn

---

## Full Optimal Implementation (C#)

```csharp
public class Solution {
    public int KthLargestValue(int[][] matrix, int k) {
        int m = matrix.Length;
        int n = matrix[0].Length;

        // 2D prefix XOR
        int[,] prefix = new int[m, n];
        prefix[0, 0] = matrix[0][0];

        // First row
        for (int j = 1; j < n; j++) {
            prefix[0, j] = prefix[0, j-1] ^ matrix[0][j];
        }

        // First column
        for (int i = 1; i < m; i++) {
            prefix[i, 0] = prefix[i-1, 0] ^ matrix[i][0];
        }

        // Rest of the matrix
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++)  prefix[i, j] = prefix[i-1, j] ^ prefix[i, j-1] ^ prefix[i-1, j-1] ^ matrix[i][j];   
        }

        // Min-heap to keep k largest values
        var minHeap = new PriorityQueue<int, int>(); // min-heap

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++){
                int val = prefix[i, j];

                if (minHeap.Count < k) minHeap.Enqueue(val, val);
                else if (val > minHeap.Peek()) {
                    minHeap.Dequeue();
                    minHeap.Enqueue(val, val);
                }
            }
        }

        // The smallest in heap is the kth largest
        return minHeap.Peek();
    }
}
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(mn log k)**       | Build prefix XOR O(mn) + heap operations O(mn log k) |
| **Space Complexity**  | **O(mn + k)**         | Prefix array + min-heap of size k              |

**Optimal** — standard and efficient for finding kth largest in a 2D grid of computed values.

---

## Why This Works — Example Walkthrough

**Example 1**: `matrix = [[5,2],[1,6]]`, `k = 1`

- Compute prefix XOR:
  - (0,0): 5
  - (0,1): 5 ^ 2 = 7
  - (1,0): 5 ^ 1 = 4
  - (1,1): 5 ^ 2 ^ 1 ^ 6 = 0

- All values: **5, 7, 4, 0**
- 1st largest = **7** → correct

**Example 2**: `k = 2` → 2nd largest = **5** → correct  
**Example 3**: `k = 3` → 3rd largest = **4** → correct

The min-heap maintains exactly the **k largest values** seen so far. At the end, the smallest element in the heap is the kth largest.

---

## Pitfalls & Edge Cases

- **k = 1** → returns the maximum value
- **k = m×n** → returns the minimum value
- **All zeros** → returns 0
- **Negative values** → not possible (constraints: non-negative)
- **Large matrix** → O(mn log k) comfortably fits (mn ≤ 10⁶, log k ≤ 20)

All handled perfectly.

---

## Key Takeaway

This is a **classic** 2D prefix + kth largest problem:

- **2D prefix XOR** → computes all submatrix XOR values in O(mn)
- **Min-heap of size k** → efficiently keeps the k largest values
- **O(mn log k)** → standard, clean, and efficient solution
**Pure, clean, optimal** — perfect for finding the kth largest XOR coordinate value.

---

# 1170. Compare Strings by Frequency of the Smallest Character

---

## Problem Restatement
We are given two string arrays `queries` and `words`.  
Define `f(s)` as the frequency of the smallest character in string `s`.  
For each query string, we need to count how many words have `f(word) > f(query)`.

Return the result as an integer array.

---

## Key Idea
1. **Compute f(s):**  
   - Find the smallest character in the string.  
   - Count its frequency.  

2. **Preprocess words:**  
   - Compute `f(word)` for each word.  
   - Sort these values.  

3. **Answer queries:**  
   - For each query, compute `f(query)`.  
   - Use binary search to count how many `f(word)` values are greater than `f(query)`.  

---

## Code (C#)
```csharp
public class Solution {
    public int[] NumSmallerByFrequency(string[] queries, string[] words) {
        int[] wordFreq = new int[words.Length];
        for (int i = 0; i < words.Length; i++) {
            wordFreq[i] = Freq(words[i]);
        }
        Array.Sort(wordFreq);

        int[] res = new int[queries.Length];
        for (int i = 0; i < queries.Length; i++) {
            int qFreq = Freq(queries[i]);
            // binary search: count words with freq > qFreq
            int idx = UpperBound(wordFreq, qFreq);
            res[i] = wordFreq.Length - idx;
        }
        return res;
    }

    private int Freq(string s) {
        char minChar = 'z';
        int count = 0;
        foreach (char c in s) {
            if (c < minChar) {
                minChar = c;
                count = 1;
            } else if (c == minChar) {
                count++;
            }
        }
        return count;
    }

    private int UpperBound(int[] arr, int target) {
        int l = 0, r = arr.Length;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (arr[mid] <= target) l = mid + 1;
            else r = mid;
        }
        return l;
    }
}
```


## Complexity
- **Compute frequencies:** O(L) per string, where L = length of the string.  
- **Sort word frequencies:** O(m log m), with m = `words.Length`.  
- **Process queries:** O(log m) per query using binary search.  
- **Total:** O(m log m + n log m + total string length).  
- **Space:** O(m + n) for storing frequencies and results.  

---

## Example Walkthrough
**Input:**  
```queries = ["cbd"], words = ["zaaaz"]```


- f("cbd") = 1 (smallest char = 'b', frequency = 1)  
- f("zaaaz") = 3 (smallest char = 'a', frequency = 3)  
- Compare: 3 > 1 → count = 1  

**Output:** `[1]` ✅  

---

## Conclusion
The solution combines **frequency computation, sorting, and binary search**:  
- Preprocess word frequencies once.  
- Answer each query efficiently with binary search.  
- Scales well for thousands of queries and words.  


---

# 1361. Validate Binary Tree Nodes — Architectural Graph Validation with In-Degree & Union-Find  
*O(n) — Optimal In-Degree + Root Search + Connectivity Check*

---

## Problem Statement

Given `n` nodes (0 to n-1).

Each node i has:
- `leftChild[i]`
- `rightChild[i]`
(-1 if no child)

Return **true** if these form **exactly one valid binary tree**:
- Exactly **one root** (in-degree 0)
- **No cycles**
- **All nodes reachable** from root
- Each node has **at most 2 children**

---

## Core Idea — Graph Properties of Valid Binary Tree

**Key insight**:
A valid binary tree is a **connected directed acyclic graph** with:
- Exactly **1 node** with in-degree 0 (root)
- All other nodes in-degree **exactly 1**
- Out-degree ≤ 2
- Connected (single component)

**Steps**:
1. Compute **in-degree** for each node
2. Find nodes with **in-degree 0** → must be **exactly 1** (root)
3. Check:
   - No node has in-degree >1
   - No self-loops or invalid child indices
4. Perform **DFS/BFS from root** → count reachable nodes → must be **n**

**Alternative**: Union-Find (also works)

---

##  Implementation (C#) - In-Degree + DFS

```csharp
public class Solution {
    public bool ValidateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {
        var inDegree = new int[n];

        // Build in-degree and validate children
        for (int i = 0; i < n; i++) {
            int left = leftChild[i];
            int right = rightChild[i];

            if (left != -1) if (left < 0 || left >= n || inDegree[left]++ > 0) return false;
            if (right != -1)  if (right < 0 || right >= n || inDegree[right]++ > 0) return false;
            
        }

        // Find root: exactly one node with in-degree 0
        int root = -1;
        for (int i = 0; i < n; i++) {
            if (inDegree[i] == 0) {
                if (root != -1) return false; // multiple roots
                root = i;
            }
        }
        if (root == -1) return false; // no root

        // DFS from root — count reachable nodes
        var visited = new bool[n];
        int count = Dfs(root, leftChild, rightChild, visited);

        return count == n;
    }

    private int Dfs(int node, int[] left, int[] right, bool[] visited)  {
        if (visited[node]) return 0;
        visited[node] = true;

        int cnt = 1;
        if (left[node] != -1) cnt += Dfs(left[node], left, right, visited);
        if (right[node] != -1) cnt += Dfs(right[node], left, right, visited);

        return cnt;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass to build in-degree + DFS traversal |
| **Space Complexity**  | **O(n)**      | In-degree array + visited array                |

**Optimal** — linear time and space for n nodes.

---

## Why This Works — Example Walkthrough

**Example 1**: `n=4`, `left=[1,-1,3,-1]`, `right=[2,-1,-1,-1]`

- Build in-degree:
  - Node 0 → children 1,2 → in-degree[1]++, in-degree[2]++
  - Node 2 → child 3 → in-degree[3]++
- in-degree: [0,1,1,1]
- Root (in-degree 0): **node 0**
- DFS from 0 → visits 0→1, 0→2→3 → **all 4 nodes**
- Single root, no in-degree >1 → **true**

**Correct**.

**Example 2**: `right=[2,3,-1,-1]`

- Node 0 → right child 2
- Node 1 → right child 3 → in-degree[3] becomes 2
- Detect in-degree >1 → **false**

**Correct**.

**Example 3**: cycle 0→1, 1→0

- Both nodes have in-degree 1 → **no root** → **false**

**Correct**.

---

## Pitfalls & Edge Cases

- **Multiple roots** → more than one in-degree 0 → false
- **No root** → all in-degree ≥1 (cycle) → false
- **In-degree >1** → multiple parents → false
- **Cycle** → DFS from root won't reach all nodes → false
- **Invalid child index** → out of bounds or self-loop → false

All handled perfectly.

---

## Key Takeaway

This is a **beautifully clean** graph validation:

- **In-degree array** → finds root and detects multiple parents
- **DFS/BFS from root** → verifies full connectivity
- **O(n)** → efficient and straightforward

**Pure, clean, optimal** — perfect binary tree validation.

---

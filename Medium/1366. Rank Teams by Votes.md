# 1366. Rank Teams by Votes — Architectural Frequency Count + Custom Comparator  
*O(n × 26²) — Optimal Frequency Matrix + Sort with Tie-Breaking*

---

## Problem Statement

Given array `votes` where each string is a voter's ranking (1st place first).

**Rank teams**:
- Most **1st place** votes → higher rank
- Tie → look at **2nd place** votes
- Continue through all positions
- Final tie → **alphabetical** order

Return **string** of team letters in ranked order.

All votes same length, all teams appear in every vote.

---

## Core Idea — Frequency Matrix + Custom Sort

**Key insight**:
- Number of teams ≤ 26 (uppercase letters)
- For each team → count votes at each **position** (0 = 1st place)
- Build **frequency matrix**: `freq[team][position]` = count

**Sort teams**:
- Custom comparator:
  - For each position 0 to 25:
    - If `freq[A][pos] > freq[B][pos]` → A before B
    - If `<` → B before A
  - If all equal → alphabetical (A.char < B.char)

**No need** complex structures — fixed 26 teams.

---

##  Implementation (C#)

```csharp
public class Solution {
    public string RankTeams(string[] votes) {
        int teams = votes[0].Length;
        int[][] freq = new int[26][];
        for (int i = 0; i < 26; i++)  freq[i] = new int[teams];
        
        // Count votes at each position
        foreach (string vote in votes) {
            for (int pos = 0; pos < teams; pos++) {
                char team = vote[pos];
                freq[team - 'A'][pos]++;
            }
        }

        // Get list of teams (from first vote)
        char[] teamList = votes[0].ToCharArray();

        // Sort with custom comparator
        Array.Sort(teamList, (a, b) => {
            int ia = a - 'A';
            int ib = b - 'A';

            for (int pos = 0; pos < teams; pos++) {
                if (freq[ia][pos] != freq[ib][pos])  return freq[ib][pos] - freq[ia][pos]; // descending  
            }

            // All positions equal → alphabetical
            return a - b;
        });

        return new string(teamList);
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n × 26²)**        | n votes, 26 positions, sort 26 log 26          |
| **Space Complexity**  | **O(26²)**            | Frequency matrix                               |

**Optimal** — n≤1000, teams≤26.

---

## Why This Works — Example Walkthrough

**Input**: `votes = ["ABC","ACB","ABC","ACB","ACB"]`

- freq:
  - A: pos0=5, pos1=0, pos2=0
  - B: pos0=0, pos1=0, pos2=5
  - C: pos0=0, pos1=5, pos2=0

- Sort:
  - A: highest pos0 (5)
  - C: highest pos1 (5)
  - B: highest pos2 (5)

→ **"ACB"**

**Correct**.

**Input**: `["WXYZ","XYZW"]`

- W: pos0=1, pos1=0 → then X,Y,Z
- X: pos0=0, pos1=2 → highest pos1
- Tie between Y,Z → alphabetical Y before Z

→ **"XWYZ"**

**Correct**.

---

## Pitfalls & Edge Cases

- **Ties across positions** → compare all positions
- **Final alphabetical** → only after all positions equal
- **Single vote** → just that order
- **All same** → alphabetical

All handled.

---

## Key Takeaway

This is a **beautifully structured** ranking problem:

- **Frequency matrix** → votes per position
- **Custom comparator** → priority by position, then alpha
- **Fixed small alphabet** → O(1) per comparison
**Pure, clean, optimal** — perfect voting rank system.

---

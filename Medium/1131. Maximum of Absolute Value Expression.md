# 1131. Maximum of Absolute Value Expression — Architectural Math Transformation + Max/Min Tracking  
*O(n) — Optimal Single Pass with 8 Cases*

---

## Problem Statement

Given two arrays `arr1`, `arr2` of same length n.

Find **maximum** value of:
```
|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|
```

over all 0 ≤ i,j < n.

---

## Core Idea — Expand Absolute Values into 8 Linear Cases

**Key insight**:
- Absolute values → 4 combinations of signs for arr1 and arr2
- |i - j| = max(i-j, j-i) → combine with index sign
- Total → **8 linear expressions** of form:
 ```
±arr1[k] ± arr2[k] ± k
```

**For each pair (i,j)** expression equals **one** of:
```
(arr1[i] + arr2[i] + i) - (arr1[j] + arr2[j] + j)
(arr1[i] + arr2[i] - i) - (arr1[j] + arr2[j] - j)
(arr1[i] - arr2[i] + i) - (arr1[j] - arr2[j] + j)
...
```
(up to 8 combinations)

**Maximum** over all i,j = **maximum** over these 8 cases:
```
max_over_k (expr_k) - min_over_k (expr_k)
```


**Solution**:
- Compute **max and min** for each of the 8 possible expressions
- Answer = maximum difference among the 8 (max - min)

**Single pass** → track 8 max/min values.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int MaxAbsValExpr(int[] arr1, int[] arr2) {
        int n = arr1.Length;
        int ans = 0;

        // 8 cases: ±arr1 ±arr2 ±i
        int[] max = new int[8];
        int[] min = new int[8];
        Array.Fill(max, int.MinValue);
        Array.Fill(min, int.MaxValue);

        for (int i = 0; i < n; i++)  {
            // case 0: +a +b +i
            int v0 =  arr1[i] + arr2[i] + i;
            max[0] = Math.Max(max[0], v0);
            min[0] = Math.Min(min[0], v0);

            // case 1: +a +b -i
            int v1 =  arr1[i] + arr2[i] - i;
            max[1] = Math.Max(max[1], v1);
            min[1] = Math.Min(min[1], v1);

            // case 2: +a -b +i
            int v2 =  arr1[i] - arr2[i] + i;
            max[2] = Math.Max(max[2], v2);
            min[2] = Math.Min(min[2], v2);

            // case 3: +a -b -i
            int v3 =  arr1[i] - arr2[i] - i;
            max[3] = Math.Max(max[3], v3);
            min[3] = Math.Min(min[3], v3);

            // case 4: -a +b +i
            int v4 = -arr1[i] + arr2[i] + i;
            max[4] = Math.Max(max[4], v4);
            min[4] = Math.Min(min[4], v4);

            // case 5: -a +b -i
            int v5 = -arr1[i] + arr2[i] - i;
            max[5] = Math.Max(max[5], v5);
            min[5] = Math.Min(min[5], v5);

            // case 6: -a -b +i
            int v6 = -arr1[i] - arr2[i] + i;
            max[6] = Math.Max(max[6], v6);
            min[6] = Math.Min(min[6], v6);

            // case 7: -a -b -i
            int v7 = -arr1[i] - arr2[i] - i;
            max[7] = Math.Max(max[7], v7);
            min[7] = Math.Min(min[7], v7);
        }

        for (int k = 0; k < 8; k++)  ans = Math.Max(ans, max[k] - min[k]);
        

        return ans;
    }
}
```


## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass over array                         |
| **Space Complexity**  | **O(1)**      | Fixed 16 variables                             |

**Optimal** — linear time.

---

## Why This Works — Example Walkthrough

**Input**: `arr1 = [1,2,3,4]`, `arr2 = [-1,4,5,6]`

- Optimal pair i=0, j=3:
  - |1-4| + |-1-6| + |0-3| = 3 + 7 + 3 = **13**

- Expression transforms into one of 8 linear cases:
  - Here: `(arr1[i] + arr2[i] - i)` at i vs `-(arr1[j] + arr2[j] - j)` at j
  - Captured as **max - min** of `+arr1 + arr2 - i` case

- Max-min over all 8 cases → finds **13**

**Correct**.

---

## Pitfalls & Edge Cases

- **n=2** → minimal case, works
- **Negative values** → all sign combinations handle correctly
- **Same values** → |i-j| still contributes via index terms
- **Large n (4×10⁴)** → O(n) perfectly efficient

All handled perfectly.

---

## Key Takeaway

This is a **beautifully mathematical** transformation:

- **Expand absolutes** → 8 linear cases of `±arr1 ±arr2 ±index`
- **Max - min** per case → maximum possible expression value
- **Single pass** → track running max/min for each case

**No O(n²) brute force needed.**
**Pure, clean, optimal** — one of the best absolute value maximization problems.

---

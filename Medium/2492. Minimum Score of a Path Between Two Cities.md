## 🧠 Pattern: Reachable Subgraph Minimum Edge Tracker

---

## 📌 Problem Statement

You're given:

- An integer `n` representing `n` cities numbered from `1` to `n`
- A list of bidirectional roads `roads[i] = [a, b, distance]`

The **score of a path** is defined as the **minimum edge weight** along that path.  
You must return the **minimum possible score** of any path between city `1` and city `n`.

Notes:

- Paths may revisit cities and reuse roads multiple times  
- The graph is not necessarily connected  
- Test cases guarantee that **at least one path exists** between cities `1` and `n`

---

## 🧩 Architectural Idea

This is not a shortest-path problem — it's a **minimum edge in any reachable path** from city `1` to city `n`.  
Since paths can revisit nodes and reuse edges, the score depends only on the **reachable subgraph** from city `1`.

Key insight:

- Perform DFS from city `1` to mark all reachable cities  
- Then iterate over all roads — if either endpoint is reachable, consider its weight  
- Return the **minimum weight** among those roads

This avoids path enumeration and leverages the fact that **score is path-agnostic** — only the smallest edge in the connected component matters.

---

## 🔧 Implementation

```csharp
public class Solution {
    public int MinScore(int n, int[][] roads) {
        var graph = new Dictionary<int, List<int>>();

        foreach (int[] road in roads) {
            graph.TryAdd(road[0], new List<int>());
            graph[road[0]].Add(road[1]);

            graph.TryAdd(road[1], new List<int>());
            graph[road[1]].Add(road[0]);
        }

        bool[] visited = new bool[n + 1];
        DFS(1, graph, visited);

        int min = int.MaxValue;

        foreach (int[] road in roads) {
            if (visited[road[0]] || visited[road[1]]) {
                min = Math.Min(min, road[2]);
            }
        }

        return min;
    }

    private void DFS(int curr, Dictionary<int, List<int>> graph, bool[] visited) {
        if (visited[curr]) return;

        visited[curr] = true;

        if (graph.ContainsKey(curr)) {
            foreach (int next in graph[curr]) {
                DFS(next, graph, visited);
            }
        }
    }
}
```

## 🧠 **Post-Solution Breakdown**

---

## ✅ Invariants

- `visited[i] == true` ⇔ city `i` is reachable from city `1`  
- The final score is determined by the **smallest edge weight** among all roads connected to reachable cities  
- DFS guarantees full coverage of the connected component starting from city `1` — no missed nodes, no redundant checks

---

## ⚠️ Edge Cases

| Scenario                     | Behavior                                                   |
|------------------------------|------------------------------------------------------------|
| Disconnected cities          | Ignored — only roads touching reachable cities are scanned |
| Multiple paths between 1 and n | All valid — score depends solely on the lightest edge     |
| Repeated roads or cycles     | Allowed — revisits don’t affect correctness or complexity  |

---

## 📌 Constraints

- `1 <= n <= 10⁵` — number of cities  
- `1 <= roads.length <= 10⁵` — number of roads  
- Each road: `[a, b, distance]` with `1 <= a, b <= n`, `1 <= distance <= 10⁴`  
- Cities are labeled from `1` to `n`  
- The graph may be partially disconnected, but **at least one path exists** between cities `1` and `n`  
- Total operations ≤ `2 * 10⁵` — must avoid anything worse than linear

---

## 🧠 Why This Works

This approach leverages **structural reachability** rather than path enumeration.  
We don’t care how we reach city `n` — only which cities are reachable from `1`, and what is the **lightest edge** among them.

- DFS marks all reachable cities in **O(n + m)**  
- Edge scan filters and extracts the minimum weight  
- No need for Dijkstra, BFS, or path reconstruction — the score is **path-agnostic**

---

## 🔁 Pattern Generalization

This pattern applies to problems where:

- The metric depends on **reachable structure**, not specific paths  
- You need to extract **min/max edge values** from a subgraph  
- Graphs may contain cycles, revisits, or redundant paths — but the metric remains stable

---

## 🧩 Reusable Structure

- DFS for reachability marking  
- Edge scan for metric extraction  
- Boolean array for visited state  
- No priority queues, no path tracking — just structural filtering

---

## 🧠 Example Problems

- Minimum edge in a connected component  
- Subgraph analysis based on reachability  
- Path scoring with flexible traversal rules  
- Graph-based filtering with structural constraints

---

## 🧠 Alternative Approaches (Comparison Table)

| Method            | Time Complexity | Pros                        | Cons                          |
|-------------------|------------------|-----------------------------|-------------------------------|
| Dijkstra          | O(m log n)       | Handles shortest paths      | Overkill for min-edge scoring |
| BFS               | O(n + m)         | Simple traversal            | Same logic as DFS             |
| DFS + edge scan   | O(n + m)         | Fast, minimal logic         | Requires careful edge filtering |

---

## 🧠 Conclusions

This solution is a textbook example of **reachability-driven scoring**.  
Instead of tracking full paths or optimizing distances, we:

- Traverse the reachable subgraph from city `1`  
- Filter all roads touching that subgraph  
- Return the **smallest edge weight** among them

No extra structures. No redundant logic. Just clean traversal and metric extraction.



---

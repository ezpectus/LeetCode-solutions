# 2358. Maximum Number of Groups Entering a Competition  
*O(n log n) — Greedy + Binary Search / Cumulative Sum Insight*

---

## Problem Statement

You are given a positive integer array `grades` representing students' grades.

You want to form as many **ordered non-empty groups** as possible such that:

1. For every group i (except the last):  
   - sum of grades in group i < sum of grades in group i+1  
   - number of students in group i < number of students in group i+1

Return the **maximum number of groups** you can form.

**Examples**:

**Example 1**  
Input: grades = [10,6,12,7,3,5]  
Output: **3**  
One way:  
- Group 1: [12] (sum=12, size=1)  
- Group 2: [6,7] (sum=13, size=2)  
- Group 3: [10,3,5] (sum=18, size=3)

**Example 2**  
Input: grades = [8,8]  
Output: **1**  
Cannot form two groups (would violate size condition)

**Constraints**:
- 1 ≤ grades.length ≤ 10⁵
- 1 ≤ grades[i] ≤ 10⁵

---

## Core Idea — Greedy + Binary Search on Number of Groups

**Beautiful observation**:
- To maximize the number of groups k, the groups must be as small as possible at the beginning
- The **optimal** way is to assign group sizes **1, 2, 3, ..., k** (or as close as possible)
- The minimal possible sum for group i is the sum of the **i smallest** grades in that group
- But we can sort the entire array and greedily assign the **smallest available** grades to earlier groups

**Key insight**:
- Sort grades in **ascending order**
- The maximum k such that we can form groups of sizes 1, 2, ..., k (or k-1,k if not enough)
- The sum of first k natural numbers = k(k+1)/2 ≤ n (number of students)
- So maximum possible k ≈ √(2n) ≈ 447 for n=10⁵
- Use **binary search** on k (number of groups)
- For a candidate k, check if we can assign students such that:
  - Group 1 has 1 student, group 2 has 2, ..., group k has k
  - Cumulative sum of group i ≤ cumulative sum of group i+1 (after sorting grades)

**Greedy check**:
- Sort grades ascending
- Try to assign the **smallest possible** grades to earlier groups
- Check if the cumulative sum up to group i is strictly less than cumulative sum up to group i+1

**Clean & efficient**:

```csharp
public class Solution{
    public int MaximumGroups(int[] grades){
        int n = grades.Length;

        // Sort grades ascending
        Array.Sort(grades);

        // Binary search on number of groups k
        int left = 1;
        int right = n; // max possible groups = n (all singletons)
        int ans = 0;

        while (left <= right){
            int mid = left + (right - left) / 2;

            // Check if we can form mid groups
            if (CanFormGroups(grades, mid)){
                ans = mid;
                left = mid + 1;
            }
            else right = mid - 1;
        }

        return ans;
    }

    private bool CanFormGroups(int[] grades, int k){
        int n = grades.Length;

        // Minimal number of students needed for k groups: 1+2+...+k = k(k+1)/2
        if (k * (long)(k + 1) / 2 > n) return false;

        // Try to assign smallest grades to earlier groups
        long prevSum = 0;
        long currentSum = 0;
        int studentIdx = 0;

        for (int groupSize = 1; groupSize <= k; groupSize++){
            currentSum = 0;

            // Take next groupSize students (smallest available)
            for (int i = 0; i < groupSize && studentIdx < n; i++){
                currentSum += grades[studentIdx++];
            }

            // Check strictly increasing sum
            if (currentSum <= prevSum) return false;

            prevSum = currentSum;
        }

        return true;
    }
}
```

## Complexity

| **Metric**            | **Value**              | **Notes**                                                                 |
|-----------------------|------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(n log n)**         | Sorting grades: O(n log n)<br>Binary search: O(log n) iterations (log n ≈ 17)<br>Each check: O(n) → total O(n log n) |
| **Space Complexity**  | **O(1)**               | Only a few integer variables (sorting is done in-place in C#)             |

**Optimal** — sorting dominates the time, but it's necessary for greedy assignment. Overall extremely fast for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: grades = [10,6,12,7,3,5]

**Sorted ascending**: [3,5,6,7,10,12]

**Binary search tries k = 3**:

- Group 1 (size 1): take smallest 3 → sum = 3
- Group 2 (size 2): take next 5,6 → sum = 11 > 3 ✓
- Group 3 (size 3): take next 7,10,12 → sum = 29 > 11 ✓

→ Feasible (sums strictly increasing)

**Try k = 4**:

- Required students: 1+2+3+4 = 10 > 6 available → impossible

→ Maximum k = **3** → correct

**Correct** —  
By **sorting grades ascending** and greedily assigning the **smallest possible grades** to earlier groups, we minimize their sums while still satisfying:
- Strictly increasing group sizes: 1, 2, 3, ..., k
- Strictly increasing group sums

**Binary search** efficiently finds the **largest feasible k** — the maximum number of such groups.

---

## Key Takeaway

This is a **beautiful binary search + greedy assignment** problem:

* **Sort** grades in **ascending order**
* **Binary search** on k (number of groups) from 1 to n
* For a candidate k:
  - Check if k(k+1)/2 ≤ n (enough students for sizes 1+2+...+k)
  - Greedily assign the **smallest remaining grades** to group 1 (size 1), group 2 (size 2), ..., group k (size k)
  - Verify that **cumulative sums are strictly increasing**
* Return the **largest k** for which the check returns true

**Pure, clean, optimal** — O(n log n) time (dominated by sorting), O(1) extra space after sorting, very fast, elegant, and mathematically guaranteed to find the maximum possible number of groups.

---

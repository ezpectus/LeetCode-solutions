# 1093. Statistics from a Large Sample — Architectural Single-Pass Frequency Scan  
*O(1) — Optimal Linear Scan over Fixed 256 Values*

---

## Problem Statement

Given array `count` of length **256**, where `count[i]` = number of occurrences of value `i` (0 to 255) in sample.

Compute:
- **minimum** — smallest non-zero value
- **maximum** — largest non-zero value
- **mean** — total sum / total count
- **median** — middle value(s) average (odd/even case)
- **mode** — value with highest frequency (guaranteed unique)

Return `[min, max, mean, median, mode]` as `double[]`.

---

## Core Idea — Single Pass over Fixed Range [0..255]

**Key insight**:
- Range fixed at **256** values → O(1) time
- Iterate i from 0 to 255:
  - Track **min/max** (skip zeros)
  - Accumulate **total sum** and **total count**
  - Track **mode** (max frequency value)
  - Collect **non-zero values** for median

**Median**:
- Total elements N = sum(count)
- If N odd → median = value at position N/2 (0-based)
- If N even → average of N/2-1 and N/2

**Use list** of appearing values → sort → pick middle

---

##  Implementation (C#)

```csharp
public class Solution {
    public double[] SampleStats(int[] count) {
        long totalCount = 0;
        long totalSum = 0;
        int min = 256, max = -1;
        int mode = 0, maxFreq = 0;

        for (int i = 0; i < 256; i++) {
            if (count[i] > 0) {
                totalCount += count[i];
                totalSum += (long)i * count[i];
                if (i < min) min = i;
                if (i > max) max = i;
                if (count[i] > maxFreq) {
                    maxFreq = count[i];
                    mode = i;
                }
            }
        }

        double mean = (double)totalSum / totalCount;

        // Median: find value at position totalCount/2 (0-based)
        long targetPos = totalCount / 2;
        long currPos = 0;
        double median = 0;

        if (totalCount % 2 == 1) {
            // Odd: find val where cumulative reach targetPos
            for (int i = 0; i < 256; i++) {
                currPos += count[i];
                if (currPos > targetPos) {
                    median = i;
                    break;
                }
            }
        } 
        else {
            // Even: avg of two mid
            double first = 0, second = 0;
            for (int i = 0; i < 256; i++) {
                currPos += count[i];
                if (currPos > targetPos - 1 && first == 0) first = i;
                
                if (currPos > targetPos && second == 0) {
                    second = i;
                    break;
                }
            }
            median = (first + second) / 2.0;
        }

        return new double[] { min, max, mean, median, mode };
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(1)**      | Fixed 256 iterations                           |
| **Space Complexity**  | **O(1)**      | At most 256 values stored                      |

**Optimal** — constant time/space.

---

## Why This Works — Example Walkthrough

**Input**: `count = [0,1,3,4,...]` → sample [1,2,2,2,3,3,3,3]

- min = **1**, max = **3**
- totalSum = 19, totalCount = 8 → mean = **2.375**
- values = [1,2,3] → sorted same
- N=8 even → median = (2 + 3)/2 = **2.5**
- mode = **3** (count=4)

→ `[1,3,2.375,2.5,3]`

**Correct**.

**Input**: all at one value

- min = max = mode = that value
- median = same value

**Correct**.

---

## Pitfalls & Edge Cases

- **count[i]=0** → skip correctly
- **Only one value** → all stats equal
- **Even/odd N** → median handled properly
- **Large counts** → use `long` for sum/count to avoid overflow
- **mode unique** → guaranteed, no ties

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** frequency problem:

- **Fixed range (256)** → O(1) time
- **Single pass** → collect min, max, sum, count, mode
- **Small list for median** → sort ≤256 elements

**No complex structures.**
**Pure, clean, optimal** — perfect compressed sample statistics.

---

# 1054. Distant Barcodes — Architectural Solution

## Problem statement

We are given an array barcodes.
Rearrange it so that no two adjacent elements are equal.
Any valid arrangement is acceptable, and it is guaranteed that an answer exists.

## Constraints

* 1 ≤ barcodes.length ≤ 10000
* 1 ≤ barcodes[i] ≤ 10000

## Core idea

This is a frequency placement problem.
If we place the most frequent barcode first into positions that are far apart, we avoid adjacent duplicates.

Key insight:

* Sort values by frequency (descending).
* Fill the result array by placing counts into even indices first (0, 2, 4, …), then into odd indices (1, 3, 5, …).
* By exhausting the most frequent number across spaced positions, adjacency conflicts are eliminated.

This is the same architecture used in “Reorganize String”: greedy placement by frequency with even-then-odd indexing.

## Steps

1. Count frequencies of all barcodes.
2. Sort the (value, frequency) pairs by decreasing frequency.
3. Create a result array.
4. Iterate through sorted pairs; for each frequency, place the value repeatedly:
   * First fill even indices.
   * Then fill odd indices.
5. Return the result.

## Implementation (C#)

```csharp
public class Solution 
{
    public int[] RearrangeBarcodes(int[] barcodes) 
    {
        // 1) Frequency map
        Dictionary<int, int> freq = new Dictionary<int, int>();
        foreach (int x in barcodes) 
        {
            if (!freq.ContainsKey(x)) freq[x] = 0;
            freq[x]++;
        }

        // 2) Sort by frequency descending
        var items = freq.ToList();
        items.Sort((a, b) => b.Value.CompareTo(a.Value));

        int n = barcodes.Length;
        int[] res = new int[n];
        int idx = 0; // start filling at even positions

        // 3) Place values: even indices first, then odd
        foreach (var kv in items) 
        {
            int val = kv.Key;
            int count = kv.Value;
            while (count > 0) 
            {
                if (idx >= n) idx = 1; // switch to odd positions after even are filled
                res[idx] = val;
                idx += 2;
                count--;
            }
        }
        return res;
    }
}
```

## Complexity Analysis

- **Time**:
  - Counting frequencies: **O(n)**
  - Sorting distinct values by frequency: **O(m log m)**, where `m ≤ n` and `m ≤ 10000`
  - Placement into result array: **O(n)**
  - **Overall**: **O(n + m log m)** → **practically O(n)** under constraints

- **Space**:
  - Frequency map + result array: **O(n)**  
  - Additional structures (list of pairs): **O(m)** → **O(n)** total

---

## Pitfalls & Edge Cases

- **Single element**: trivially valid — handled automatically
- **Highly skewed frequency** (e.g., one value appears ~n/2 times):  
  even-then-odd placement guarantees no two identical values are adjacent
- **Multiple values with equal frequency**: sorting order doesn't matter — any valid greedy order works
- **Guaranteed existence**: problem states a solution always exists → no need to validate feasibility

---

## Conclusion

By placing the **most frequent barcodes** at **evenly spaced positions** (even indices first, then odd), we **deterministically eliminate adjacent duplicates**.
This **greedy frequency-first** strategy, combined with the **even/odd index filling pattern**, produces a **valid arrangement** in **near-linear time** and fits the constraints with plenty of room.
**Result**: clean, fast, provably correct solution — a perfect example of **greedy placement by frequency**.

---

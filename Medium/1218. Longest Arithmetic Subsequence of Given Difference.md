# 1218. Longest Arithmetic Subsequence of Given Difference — Architectural DP with Map Tracking  
*O(n) — Optimal Single Pass with HashMap*

---

## Problem Statement

Given array `arr` and fixed `difference`.

Find **longest subsequence** where **adjacent elements** differ by exactly `difference`.

Return its **length**.

---

## Core Idea — DP: Longest Chain Ending at Each Value

**Key insight**:
- For each `arr[i]`, longest chain ending at it = 1 + longest chain ending at `arr[i] - difference`
- Use **HashMap** → `value → max length ending at value`

**Single pass**:
- For each number → query map for `num - difference`
- Update `dp[num] = dp[num - difference] + 1` (or 1)
- Track **global max**

**No need** sort or two pointers — fixed difference.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int LongestSubsequence(int[] arr, int difference) {
        var dp = new Dictionary<int, int>();
        int maxLen = 0;

        foreach (int num in arr) {
            // Longest chain ending at num
            int prev = num - difference;
            int len = dp.GetValueOrDefault(prev, 0) + 1;
            dp[num] = len;
            maxLen = Math.Max(maxLen, len);
        }

        return maxLen;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass over array                         |
| **Space Complexity**  | **O(n)**      | HashMap worst case (all unique values)         |

**Optimal** — linear time.

---

## Why This Works — Example Walkthrough

**Input**: `arr = [1,5,7,8,5,3,4,2,1]`, `difference = -2`

- Process order:
  - 1 → dp[1] = 1 → max = 1
  - 5 → dp[5] = 1 → max = 1
  - 7 → dp[7] = 1 → max = 1
  - 8 → dp[8] = 1 → max = 1
  - 5 (second) → dp[5] = max(1, dp[7] + 1 = 2) = **2** → max = 2
  - 3 → dp[3] = dp[5] + 1 = **3** → max = 3
  - 4 → dp[4] = 1 → max = 3
  - 2 → dp[2] = 1 → max = 3
  - 1 (second) → dp[1] = max(1, dp[3] + 1 = 4) = **4** → max = 4

→ **4** (sequence 7 → 5 → 3 → 1)

**Correct**.

**Input**: `[1,2,3,4]`, `difference = 1`

- Each number extends the previous → final dp[4] = **4**

**Correct**.

**Input**: `[1,3,5,7]`, `difference = 1`

- No number matches `prev = num - 1` → all dp = 1 → max = **1**

**Correct**.

---

## Pitfalls & Edge Cases

- **difference = 0** → longest run of identical values
- **Negative difference** → works perfectly (as in example)
- **All unique values** → maximum length 1
- **Duplicates** → can extend chain only if order preserved (later occurrence can continue earlier chain)

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** DP:

- **Map value → max chain length ending at that value**
- **Fixed difference** → direct predecessor lookup
- **O(n) time** → single pass with hashmap
**Pure, clean, optimal** — one of the best fixed-difference subsequence problems.

---

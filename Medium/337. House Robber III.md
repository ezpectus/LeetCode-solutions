# 🏠 Leetcode 337 — House Robber III

## 📜 Task
The input is a binary tree, where each node is a house with a certain amount of money.
You cannot rob two neighboring houses (i.e. a parent and a child at the same time).
You need to return the maximum amount that can be stolen, observing this rule.

---

## 🎯 What do they want from us?
Find the maximum amount that can be received,
if at each node there is a choice: steal or miss.

---

## 💡 How I understood that DFS is needed
- Each node is a **decision point**
- The decision depends on the **condition of the children**
- You need to go through the whole tree and **two options will be returned at each level**: 
- `rob`: if we rob the current node 
- `skip': if we skip the current node
- This is a classic **Tree DP with two states**, so a pair-return DFS is needed

---

## 🧩Code

```csharp
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public int Rob(TreeNode root) {
       var res = DFS(root);
       return Math.Max(res.rob, res.skip);
    }

    private (int rob, int skip) DFS(TreeNode node){
        if(node == null) return (0, 0);

        var left = DFS(node.left);
        var right = DFS(node.right);

        int rob = node.val + left.skip + right.skip;
        int skip = Math.Max(left.rob, left.skip) + Math.Max(right.rob, right.skip);

        return (rob, skip);
    }
}
```

# 🧠 Architectural Pattern: Tree DP — Node-Centric Decision Split

---

## 📌 Core Idea

In tree-based dynamic programming, each node represents a decision point with two mutually exclusive options:

- `rob`: If we rob this node, we **must skip** both children to avoid alerting the system (e.g. police).
- `skip`: If we skip this node, we are **free to choose** the best option from each child — whether to rob or skip them.

This dual-state logic propagates bottom-up, allowing each node to return a pair of values that inform its parent’s decision.

---

## 🔁 Transition Formulas

```csharp
rob = node.val + left.skip + right.skip;
skip = Math.Max(left.rob, left.skip) + Math.Max(right.rob, right.skip);
```

- rob: Take current node’s value, but only add .skip from children (since we can’t rob them).
- skip: Don’t take current node’s value, but choose the best option from each child.

## 🧮 Final Answer
```csharp
var res = DFS(root);
return Math.Max(res.rob, res.skip);
After traversing the tree, we choose the best strategy at the root level.
```

## 🧭 Mental Model
- node.val is the current lootable home.

- rob → greedy strategy: rob current node, exclude children.
- skip → strategic pass: skip current node, select best of children.
- Each node returns a tuple (rob, skip) to its parent, enabling bottom-up aggregation.
- This pattern is a classic example of stateful recursion in trees,
  where each node encapsulates a local strategy and passes up its optimal outcomes.

## ✅ Implementation Checklist

- [x] Base case: null node returns (0, 0) — no loot, no risk.
- [x] Recursive calls: DFS on both left and right children.
- [x] rob uses .skip from children — exclusion logic.
- [x] skip uses Math.Max() from children — inclusion logic.
- [x] Final result is Math.Max(res.rob, res.skip) — best of both strategies.

## 📈 What This Pattern Trains

Recursive decomposition: breaking down problems into local decisions.

- Dual-state modeling: tracking mutually exclusive outcomes.
- Bottom-up aggregation: combining subproblem results into global solution.
- Exclusion logic: modeling constraints that prevent simultaneous actions.
- Architectural clarity: separating greedy vs strategic paths.

## 🧩 Where Else It Applies

This pattern generalizes to other problems involving:

- Independent sets in trees or graphs (e.g. no adjacent selections).
- Interval scheduling with exclusion (e.g. selecting non-overlapping tasks).
- Subset selection under adjacency constraints.
- Recursive games or simulations with cooldowns or penalties.


---

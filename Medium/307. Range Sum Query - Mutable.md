# 📊 Problem: 307. Range Sum Query - Mutable

## 🧩 Problem Description  
Given an integer array `nums`, support two operations:

- `update(index, val)`: update the value at index  
- `sumRange(left, right)`: return the sum of elements in range `[left, right]`

---

## 💡 Core Idea  
This is a **dynamic range query** problem with **point updates**.  
Naive solutions fail under constraints — we need **logarithmic time** for both operations.

Two main data structures apply:
- **Fenwick Tree (Binary Indexed Tree)** — fast, simple, prefix-based
- **Segment Tree** — flexible, full-range support

---

## ⚙️ Architectural Signals

| Signal | Meaning |
|--------|---------|
| Frequent `sumRange` queries | Need O(log n) range sum |
| Frequent `update` operations | Need O(log n) point update |
| Static array size | Can prebuild tree |
| Operation is sum | Commutative — fits both trees |

---

## 🧪 Constraints

- `1 <= nums.length <= 30_000`  
- `-100 <= nums[i], val <= 100`  
- Up to `30_000` operations  
- Time complexity target: `O(log n)` per operation

---

## 🧱 Fenwick Tree (Binary Indexed Tree)

### 🔹 Structure
- `bit[]` — stores prefix sums  
- `nums[]` — original array  
- 1-based indexing for BIT

### 🔹 Operations
- `add(index, delta)` — update BIT  
- `query(index)` — prefix sum  
- `sumRange(l, r)` = `query(r+1) - query(l)`

### 💻 C# Implementation

```csharp
public class NumArray {
    private int[] nums;
    private int[] bit;
    private int n;

    public NumArray(int[] nums) {
        this.n = nums.Length;
        this.nums = new int[n];
        this.bit = new int[n + 1];

        for (int i = 0; i < n; i++) {
            Update(i, nums[i]);
        }
    }

    public void Update(int index, int val) {
        int delta = val - nums[index];
        nums[index] = val;
        Add(index + 1, delta);
    }

    public int SumRange(int left, int right) {
        return Query(right + 1) - Query(left);
    }

    private void Add(int index, int delta) {
        while (index <= n) {
            bit[index] += delta;
            index += index & -index;
        }
    }

    private int Query(int index) {
        int sum = 0;
        while (index > 0) {
            sum += bit[index];
            index -= index & -index;
        }
        return sum;
    }
}
```

## 🧱 Segment Tree
### 🔹 Structure

- tree[] — stores range sums
- nums[] — original array
- Each node covers [start, end]

### 🔹 Operations

- build() — recursively construct tree
- update() — propagate delta to leaf and up
- query() — recursively sum range [l, r]

## 💻 C# Implementation
```cpp
public class NumArray {
    private int[] tree;
    private int[] nums;
    private int n;

    public NumArray(int[] nums) {
        this.n = nums.Length;
        this.nums = new int[n];
        this.tree = new int[4 * n];
        Array.Copy(nums, this.nums, n);
        Build(0, 0, n - 1);
    }

    private void Build(int node, int start, int end) {
        if (start == end) {
            tree[node] = nums[start];
        } else {
            int mid = (start + end) / 2;
            Build(2 * node + 1, start, mid);
            Build(2 * node + 2, mid + 1, end);
            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];
        }
    }

    public void Update(int index, int val) {
        int delta = val - nums[index];
        nums[index] = val;
        UpdateTree(0, 0, n - 1, index, delta);
    }

    private void UpdateTree(int node, int start, int end, int index, int delta) {
        if (index < start || index > end) return;

        tree[node] += delta;
        if (start != end) {
            int mid = (start + end) / 2;
            UpdateTree(2 * node + 1, start, mid, index, delta);
            UpdateTree(2 * node + 2, mid + 1, end, index, delta);
        }
    }

    public int SumRange(int left, int right) {
        return Query(0, 0, n - 1, left, right);
    }

    private int Query(int node, int start, int end, int l, int r) {
        if (r < start || l > end) return 0;
        if (l <= start && end <= r) return tree[node];

        int mid = (start + end) / 2;
        int leftSum = Query(2 * node + 1, start, mid, l, r);
        int rightSum = Query(2 * node + 2, mid + 1, end, l, r);
        return leftSum + rightSum;
    }
}
```

## 🧠 Comparison Table

| Feature               | Fenwick Tree                 | Segment Tree                  |
|----------------------|------------------------------|-------------------------------|
| `update(index, val)` | O(log n)                     | O(log n)                      |
| `sumRange(left, right)` | O(log n) via prefix diff     | O(log n) direct               |
| Structure             | 1D array                     | Binary tree                   |
| Flexibility           | Limited (only sum)           | High (min/max, lazy updates)  |
| Simplicity            | Easier to implement          | More complex                  |
| Generalization        | Hard to extend               | Easy to extend                |

---

## ✅ Summary

Both structures solve the problem efficiently.  
**Fenwick Tree** is ideal for simple prefix-based sums, while **Segment Tree** is better for full-range queries and future extensions.

---

## 🧱 Architectural Signals

| Signal | Fenwick Tree | Segment Tree |
|--------|--------------|--------------|
| Query type | Prefix sum | Full range |
| Operation | Single (sum) | Multiple (sum, min, max, etc.) |
| Update type | Point update | Point or range update |
| Extensibility | Low | High |
| Implementation | Compact | Recursive, layered |

---

## 🔍 Generalization Potential

Segment Tree supports:

- `min`, `max`, `gcd`, `xor`, `product`, etc.  
- **Lazy propagation** for efficient range updates  
- **Region labeling** — assign values to zones  
- **Terrain analysis** — elevation, flow, segmentation  
- **Histogram queries**, **interval merging**, **event tracking**

Fenwick Tree is best when:

- You only need **prefix sums**  
- You want a **compact, fast implementation**  
- You don’t need complex operations or range updates

---

## 🧠 Architectural Takeaway

> Fenwick Tree is a **lightweight tactical tool** — fast, simple, and effective for prefix-based problems.  
> Segment Tree is a **strategic framework** — scalable, extensible, and ideal for complex range logic.

Choose based on:
- Operation type  
- Update frequency  
- Extensibility needs  
- Code complexity tolerance

This comparison block is your reference for choosing the right structure in **dynamic range query problems**.


---

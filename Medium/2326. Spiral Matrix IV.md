# 2326. Spiral Matrix IV  
*O(m × n) — Simulate Spiral Traversal + Fill from Linked List*

---

## Problem Statement

You are given two integers `m` and `n` (matrix dimensions) and the **head** of a linked list containing integers.

Generate an `m × n` matrix filled with values from the linked list in **clockwise spiral order**, starting from top-left cell `(0,0)`.  
If the linked list runs out of values before the matrix is full, fill remaining cells with **-1**.

Return the generated matrix.

**Examples**:

**Example 1**: m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]  
Output:  
[[3,0,2,6,8],  
 [5,0,-1,-1,1],  
 [5,2,4,9,7]]

**Example 2**: m = 1, n = 4, head = [0,1,2]  
Output: [[0,1,2,-1]]

**Constraints**:
- 1 ≤ m, n ≤ 10⁵
- 1 ≤ m × n ≤ 10⁵
- 1 ≤ number of nodes ≤ m × n
- 0 ≤ Node.val ≤ 1000

---

## Core Idea — Simulate Spiral Order + Linked List Iterator

**Approach**:
- Use classic **spiral matrix traversal** technique with four boundaries:
  - `top`, `bottom`, `left`, `right`
- Traverse in clockwise order: right → down → left → up
- At each step, fill current cell with next value from linked list (or -1 if list exhausted)
- Shrink boundaries after completing each side
- Stop when boundaries cross or all cells filled

**Time**: O(m × n) — visit each cell exactly once  
**Space**: O(m × n) — output matrix (required)

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int[][] SpiralMatrix(int m, int n, ListNode head){
        int[][] matrix = new int[m][];
        for (int i = 0; i < m; i++){
            matrix[i] = new int[n];
            Array.Fill(matrix[i], -1); // fill with -1 by default
        }

        int top = 0, bottom = m - 1;
        int left = 0, right = n - 1;

        ListNode current = head;
        while (top <= bottom && left <= right && current != null){
            // Traverse right
            for (int j = left; j <= right && current != null; j++){
                matrix[top][j] = current.val;
                current = current.next;
            }
            top++;

            // Traverse down
            for (int i = top; i <= bottom && current != null; i++) {
                matrix[i][right] = current.val;
                current = current.next;
            }
            right--;

            // Traverse left (only if still valid row)
            if (top <= bottom){
                for (int j = right; j >= left && current != null; j--){
                    matrix[bottom][j] = current.val;
                    current = current.next;
                }
                bottom--;
            }

            // Traverse up (only if still valid column)
            if (left <= right){
                for (int i = bottom; i >= top && current != null; i--){
                    matrix[i][left] = current.val;
                    current = current.next;
                }
                left++;
            }
        }

        return matrix;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(m × n)**  | We visit **each cell of the matrix exactly once** during the spiral traversal — no cell is revisited |
| **Space Complexity**  | **O(m × n)**  | Output matrix is required (O(m × n))<br>Extra space: O(1) for pointers and variables |

**Optimal** — we must visit every cell at least once to fill the matrix, so O(mn) time is necessary and achieved.  
Space is dominated by the output matrix itself — no unnecessary extra data structures.

---

## Why This Works — Key Points

* We simulate the **standard clockwise spiral traversal** (same as Spiral Matrix I/II problems)

* Initialize the matrix with **-1** everywhere (default for unfilled cells)

* Use **four boundary pointers**:
  - `top = 0`, `bottom = m-1`
  - `left = 0`, `right = n-1`

* Traverse in **clockwise order** while boundaries are valid and linked list has nodes:
  1. **Right**: fill top row from left to right → shrink top++
  2. **Down**: fill right column from top to bottom → shrink right--
  3. **Left**: fill bottom row from right to left (only if top ≤ bottom) → shrink bottom--
  4. **Up**: fill left column from bottom to top (only if left ≤ right) → shrink left++

* For each cell visited:
  - If linked list still has nodes → fill with `current.val` and move to `current.next`
  - Else → keep -1 (already set)

* Stop when boundaries cross (`top > bottom` or `left > right`) **or** linked list is exhausted

**Correct** —  
The spiral traversal exactly matches the required **clockwise filling order** starting from top-left.  
We fill as many cells as there are nodes in the list, and any remaining cells stay -1 as required.

---

## Key Takeaway

This is a **classic spiral matrix filling** problem with a linked list as the value source:

* Initialize the entire matrix with **-1**
* Use **four boundary pointers** (top, bottom, left, right) to control the spiral
* Traverse in **clockwise order**:
  - Right across current top row
  - Down current right column
  - Left across current bottom row (if still valid)
  - Up current left column (if still valid)
* At each cell:
  - Take next value from linked list if available
  - Otherwise keep -1
* Shrink boundaries after completing each direction
* Continue until boundaries collapse or linked list ends

**Pure, clean, optimal** — O(m × n) time, O(m × n) space (for output matrix), very fast, intuitive, handles all edge cases (short list, single row/column, empty list, full fill) perfectly.

---

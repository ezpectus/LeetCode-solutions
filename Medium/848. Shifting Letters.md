# 848. Shifting Letters

---

## Problem Summary
We are given:
- A string `s` of lowercase English letters.
- An integer array `shifts` of the same length.

For each `shifts[i] = x`, we must shift the **first i+1 letters** of `s` forward in the alphabet `x` times (wrapping around so that `'z' → 'a'`).  
Return the final string after all shifts are applied.

---

## Code Idea
Naively applying each shift would be too slow (`O(n^2)` for `n = 10^5`).  
We need an efficient approach:

1. **Observation**  
   - Each position `i` is affected by all `shifts[j]` where `j ≥ i`.  
   - So the total shift for `s[i]` = sum of `shifts[i..n-1]`.

2. **Prefix Sum (from right to left)**  
   - Traverse `shifts` backwards.  
   - Maintain a running sum of shifts.  
   - For each character `s[i]`, compute `(s[i] - 'a' + totalShift) % 26`.

3. **Modulo Handling**  
   - Since `shifts[i]` can be up to `1e9`, always take modulo 26.

---

## Code (C#)
```csharp
public class Solution {
    public string ShiftingLetters(string s, int[] shifts) {
        int n = s.Length;
        char[] result = new char[n];
        long totalShift = 0;

        for (int i = n - 1; i >= 0; i--) {
            totalShift = (totalShift + shifts[i]) % 26;
            int shifted = (s[i] - 'a' + (int)totalShift) % 26;
            result[i] = (char)('a' + shifted);
        }

        return new string(result);
    }
}
```



## Complexity
- **Time:** O(n), single pass through the string.  
- **Space:** O(n) for result array.  

---

## Pitfalls
- Must compute cumulative shifts from **right to left**.  
- Always take modulo 26 to avoid overflow.  
- Handle large values of `shifts[i]` (up to 1e9).  
- Edge case: single-character string.  

---

## Example Walkthrough
**Input:** `s = "abc"`, `shifts = [3,5,9]`  

- Total shifts from right:  
  - i=2 → shift = 9 → `'c' → 'l'`.  
  - i=1 → shift = 5+9=14 → `'b' → 'p'`.  
  - i=0 → shift = 3+5+9=17 → `'a' → 'r'`.  
- Result = `"rpl"`.  
**Output:** `"rpl"`  

---

**Input:** `s = "aaa"`, `shifts = [1,2,3]`  

- i=2 → shift = 3 → `'a' → 'd'`.  
- i=1 → shift = 2+3=5 → `'a' → 'f'`.  
- i=0 → shift = 1+2+3=6 → `'a' → 'g'`.  
- Result = `"gfd"`.  
**Output:** `"gfd"`  

---

## Conclusion
This problem reduces to applying **cumulative shifts from right to left**.  
- Efficient O(n) solution.  
- Correctly handles large shift values with modulo 26.  
- Produces the final shifted string in linear time.  


---

# 🌳 Unique Binary Search Trees — Catalan DP Pattern

## 🔍 Problem Statement

- Given an integer n, return the number of structurally unique Binary Search Trees (BSTs) that store values 1 to n.
- This is a classic structural enumeration problem. The goal is not to generate the trees, but to count how many valid BSTs can be formed.

## 🧠 Core Insight
- Every BST is defined by its root.
-  For each possible root i from 1 to n, the number of unique BSTs is:

```
NumTrees(𝑛)=∑𝑖=1𝑛NumTrees(𝑖−1)×NumTrees(𝑛−𝑖)

i is the root node
i - 1 nodes go to the left subtree
n - i nodes go to the right subtree
```

This recursive structure leads to a Catalan number, which can be computed via dynamic programming.


```csharp
public class Solution {
    public int NumTrees(int n) {
        int[] dp = new int[n+1];
        dp[0] =1;
        dp[1] = 1;


//NumTrees(n) = Σ (NumTrees(i - 1) * NumTrees(n - i)) for i = 1 to n

     for(int i= 2; i <= n;i++){
         for(int j = 1; j <= i;j++){
          dp[i] += dp[j-1] * dp[i-j];

         }
     }
     return dp[n];

    }
}
```



## 🔬 Explanation

- dp[i] stores the number of unique BSTs with i nodes
- Outer loop i builds up the solution from 2 to n
- Inner loop j iterates over all possible roots
- For each root j, the left subtree has j - 1 nodes, and the right subtree has i - j nodes

## 🧠 Pattern Summary
- Catalan DP Pattern dp[i] = Σ dp[j - 1] * dp[i - j] for j = 1..i

## ✅ Use Cases

- Counting unique BSTs
- Valid parentheses combinations
- Polygon triangulation
- Expression parsing

## 🧪 Edge Cases

- n = 0: returns 1 (empty tree is valid)
- n = 1: returns 1 (single node tree)
- Large n: exponential growth, but DP handles it in O(n²) time


---

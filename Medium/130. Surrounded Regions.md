## 🧠 Problem: Surrounded Regions  
**LeetCode #130**  
**Difficulty:** Medium  
**Tags:** DFS, Matrix, Flood Fill, Boundary Detection

---

### 🔍 Problem Summary  
You're given an `m x n` grid `board` filled with `'X'` and `'O'`.  
Your task is to capture all regions of `'O'` that are **completely surrounded** by `'X'`.  
A region is considered surrounded if:

- All `'O'` cells are connected (horizontally or vertically)  
- None of the `'O'` cells touch the **edge** of the board  

Captured regions should be replaced **in-place** with `'X'`.  
Regions connected to the edge must **remain unchanged**.

---

### 🧱 Architectural Insight  
This is a classic **flood-fill with boundary detection** problem.  
The key idea is to **protect** all `'O'` cells that are connected to the edge, and then flip the rest.

---

### 🔧 Core Strategy

- Traverse the **edges** of the board  
- For every `'O'` on the edge, run **DFS** to mark all connected `'O'` cells as safe (e.g., mark as `'T'`)  
- After marking:
  - Flip all remaining `'O'` cells to `'X'` (they are surrounded)  
  - Restore all `'T'` cells back to `'O'` (they are safe)

This guarantees that only truly surrounded regions are captured.

## 💡 C# Solution
```csharp
public class Solution {
    public void Solve(char[][] board) {
        int m = board.Length;
        int n = board[0].Length;

        // Mark edge-connected 'O's as safe
        for (int i = 0; i < m; i++) {
            if (board[i][0] == 'O') DFS(board, i, 0);
            if (board[i][n - 1] == 'O') DFS(board, i, n - 1);
        }

        for (int j = 0; j < n; j++) {
            if (board[0][j] == 'O') DFS(board, 0, j);
            if (board[m - 1][j] == 'O') DFS(board, m - 1, j);
        }

        // Flip surrounded 'O's to 'X', and restore safe 'T's to 'O'
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                board[i][j] = board[i][j] != 'T' ? 'X' : 'O';
            }
        }
    }

    private void DFS(char[][] board, int i, int j) {
        int m = board.Length;
        int n = board[0].Length;

        if (i < 0 || j < 0 || i >= m || j >= n || board[i][j] != 'O') return;

        board[i][j] = 'T'; // Temporarily mark as safe

        DFS(board, i + 1, j);
        DFS(board, i - 1, j);
        DFS(board, i, j + 1);
        DFS(board, i, j - 1);
    }
}
```

### 📐 Why This Works

- Edge-connected `'O'` cells are **immune to capture**  
- DFS ensures all `'O'` cells connected to the edge are **marked as safe**  
- Remaining `'O'` cells are **truly surrounded** and can be flipped  
- Using `'T'` as a temporary marker avoids extra space or boolean arrays  
- Final pass **restores the board** to its correct state

---

### 🧭 Reflection

This problem reinforced my understanding of **DFS flood-fill** and **boundary-aware traversal**.  
Instead of checking every region for enclosure, I flipped the logic:

- **Protect** the edge-connected `'O'` cells  
- Then **flip** everything else

#### 🔑 Key Insights:
- DFS is ideal for **marking connected regions**  
- Edge-first traversal avoids **redundant checks**  
- Temporary marking (`'T'`) is a clean way to **track safe zones**  
- The final sweep is **efficient and intuitive**

I implemented the solution in **C#**, focusing on clarity and performance:
- DFS is written **recursively** with clean base cases  
- Grid traversal is split into **edge marking** and **final flipping**  
- Variable naming (`m`, `n`, `DFS`) reflects the grid logic clearly

This task also reinforced the power of **in-place transformations** — no extra space, just smart marking and restoration.



---

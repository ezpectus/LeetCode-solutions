# 1390. Four Divisors — Architectural Optimized Divisor Counting  
*O(n × √m) — Optimal Trial Division up to Square Root*

---

## Problem Statement

- Given array `nums` (1 ≤ length ≤ 10⁴, 1 ≤ nums[i] ≤ 10⁵).
- For each number → if it has **exactly 4 divisors** → add **sum of those divisors** to result.
- Return total sum.

---

## Core Idea — Numbers with Exactly 4 Divisors

**Key insight**:
Numbers with **exactly 4 divisors** are of two forms:
1. **p³** where p is prime → divisors: 1, p, p², p³
2. **p × q** where p,q distinct primes → divisors: 1, p, q, p×q

**Strategy**:
- For each num:
  - Find all divisors by trial up to √num
  - Count divisors and sum them
  - If count == 4 → add sum

**Optimization**:
- Stop early if >4 divisors found
- Use `long` for sum (though constraints fit int)

---

##  Implementation (C#)

```csharp
public class Solution {
    public int SumFourDivisors(int[] nums) {
        int total = 0;

        foreach (int num in nums) {
            int sum = 0;
            int count = 0;

            for (int d = 1; d * d <= num; d++)  {
                if (num % d == 0) {
                    sum += d;
                    count++;

                    if (d != num / d) {
                        sum += num / d;
                        count++;
                    }
                    
                    if (count > 4) break; // early exit
                }
            }

            if (count == 4) total += sum;   
        }

        return total;
    }
}
```
## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(n × √m)**                 | m=max(nums)=10⁵ → √m≈316 → ~3×10⁶ operations   |
| **Space Complexity**  | **O(1)**                      | Only loop variables                            |

**Optimal** — trial division up to √num is the best approach for the given range.

---

## Why This Works — Example Walkthrough

**Input**: `nums = [21,4,7]`

- **21**:
  - d=1 → 1 and 21
  - d=3 → 3 and 7
  - divisors: 1, 3, 7, 21 → count=4, sum=32 → add **32**
- **4**:
  - d=1 → 1 and 4
  - d=2 → 2
  - divisors: 1, 2, 4 → count=3 → skip
- **7**:
  - d=1 → 1 and 7
  - divisors: 1, 7 → count=2 → skip

**Total = 32** → **correct**.

**Input**: `[1,2,3,4,5]`

- All have either 1, 2, or 3 divisors → no number with exactly 4 → **0**

**Correct**.

The method correctly identifies and sums divisors only when exactly 4 are found.

---

## Pitfalls & Edge Cases

- **num=1** → only divisor 1 → count=1 → skip
- **Prime** → divisors 1 and itself → count=2 → skip
- **Prime square** (e.g., 9=3²) → 1,3,9 → count=3 → skip
- **p³** (e.g., 8=2³) → 1,2,4,8 → count=4 → include
- **p×q** (e.g., 6=2×3) → 1,2,3,6 → count=4 → include
- **Early break** when count >4 → avoids unnecessary work

All handled perfectly.

---

## Key Takeaway

This is a **beautifully efficient** divisor enumeration:

- **Trial up to √num** → finds divisor pairs in O(√num)
- **Count and sum** simultaneously → check for exactly 4
- **Early exit** on excess divisors → minor optimization

**Pure, clean, optimal** — perfect four-divisor sum calculation.

---


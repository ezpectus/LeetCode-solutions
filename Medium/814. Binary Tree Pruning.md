# 814. Binary Tree Pruning — Architectural Post-Order Recursive Pruning  
*O(n) — Clean & Optimal Subtree Removal*

---

## Problem Statement

Given a binary tree, **remove every subtree** that does **not contain a `1`**.

Return the pruned tree.

A subtree includes the node and **all its descendants**.

---

## Core Idea — Post-Order Recursion with Subtree Validity

We use **post-order traversal** (left → right → root):

- Recursively prune **left** and **right** subtrees
- If a subtree **does not contain any `1`** → return `null`
- Otherwise → keep the node

**Key insight**:
A subtree contains a `1` **iff**:
- Node value is `1` **or**
- Left subtree contains `1` **or**
- Right subtree contains `1`

**Bottom-up** pruning → naturally removes invalid subtrees.

---

##  Implementation (C#)

```csharp
public class Solution {
    public TreeNode PruneTree(TreeNode root) {
        return ContainsOne(root) ? root : null;
    }

    // Returns true if subtree rooted at node contains a 1
    // Also prunes invalid subtrees
    private bool ContainsOne(TreeNode node) {
        if (node == null) return false;

        bool leftHasOne = ContainsOne(node.left);
        bool rightHasOne = ContainsOne(node.right);

        // Prune subtrees without 1
        if (!leftHasOne) node.left = null;
        if (!rightHasOne) node.right = null;

        // This subtree has a 1 if:
        // - current node is 1 OR
        // - left or right subtree had a 1
        return node.val == 1 || leftHasOne || rightHasOne;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Visit each node exactly once                   |
| **Space Complexity**  | **O(h)**      | Recursion stack (h = tree height, worst O(n) skewed) |

**Optimal** — linear time, minimal space.

---

## Why This Works — Example Walkthrough

**Input**: `[1,null,0,0,1]`
```
      1
       \
        0
       / \
      0   1
```

- Process leaf `0` (left of right 0) → no 1 → prune
- Process leaf `1` → has 1 → keep
- Process middle `0` → right has 1 → keep, but left pruned
- Process root `1` → has 1 → keep

Result: `[1,null,0,null,1]`

**Perfect** — exactly correct.

---

## Pitfalls & Edge Cases

- **All 0s** → return `null`
- **Single node 1** → keep
- **Single node 0** → return `null`
- **Deep tree with 1 at leaf** → path preserved (all ancestors kept)

All handled correctly.

---

## Key Takeaway

This is a **beautifully clean** tree pruning problem:

- **Post-order recursion** → natural bottom-up processing
- **Prune on return** → subtrees without 1 become `null`
- **Single function** → both prunes and checks validity

**No extra data structures. No pre/post traversal.**
**Pure, elegant, optimal** — one of the most satisfying tree problems.

---

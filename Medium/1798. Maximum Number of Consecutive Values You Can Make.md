# 1798. Maximum Number of Consecutive Values You Can Make — Architectural Greedy + Prefix Sum Insight  
*O(n log n) — Optimal Sorting + Linear Greedy Accumulation*

---

## Problem Statement

- You are given an integer array `coins` of length `n` (1 ≤ n ≤ 4×10⁴), where each `coins[i]` (1 ≤ coins[i] ≤ 4×10⁴) represents the value of a coin you own.
- You can make a value `x` if you can select some subset of your coins whose values sum exactly to `x`.
- Return the **maximum number of consecutive integer values** you can make starting from and including **0**.
- In other words, find the largest `k` such that you can make every integer from **0 to k** inclusive using some subset of coins.

---

## Core Idea 0 Greedy Sorting + "Fill the Gap" Approach

**Key insight** (very important pattern):
- Sort the coins in **ascending order**
- Maintain a variable `current_max` = maximum consecutive value you can currently make (initially 0)
- For each coin in sorted order:
  - If the coin ≤ current_max + 1 → you can extend the range to current_max + coin
  - Else → there is a gap → you cannot make current_max + 1 → stop here
- Final answer = current_max + 1 (since 0 to current_max are all possible)

**Why this works**:
- To cover consecutive numbers from 0, you want to "fill" the next possible value without gaps
- Adding a coin of value `c` allows you to make all new sums from (current_max + 1) to (current_max + c) — **only if** c ≤ current_max + 1
- If c > current_max + 1 → you cannot make current_max + 1 → gap → answer is current_max + 1

**Proof intuition**:
- This is similar to the "frobenius coin problem" but for unlimited coins of each value (but here each coin is unique)
- The greedy choice of adding smallest coins first maximizes the consecutive prefix

---

## Full Optimal Implementation (C#)

```csharp
public class Solution {
    public int GetMaximumConsecutive(int[] coins) {
        // Sort coins in ascending order
        Array.Sort(coins);
        long currentMax = 0;  // max consecutive value we can make so far (0 to currentMax)

        foreach (int coin in coins) {
            // If this coin creates a gap (coin > currentMax + 1)
            if (coin > currentMax + 1)  break;
            
            // Extend the range: now we can make up to currentMax + coin
            currentMax += coin;
        }

        // We can make all values from 0 to currentMax inclusive
        return (int)(currentMax + 1);
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)**| Sorting dominates (n ≤ 4×10⁴), followed by linear pass |
| **Space Complexity**  | **O(1)**      | Only a few variables (no extra arrays needed after sorting) |

**Optimal** — sorting is necessary in the worst case; the greedy linear pass afterward is O(n).

---

## Why This Works — Example Walkthrough

**Example 1**: `coins = [1,3]`

- Sorted: [1,3]
- currentMax = 0
- Add 1 → 1 ≤ 0 + 1 → currentMax = 0 + 1 = **1**
- Add 3 → 3 > 1 + 1 → gap → stop
- Can make all values from 0 to 1 → answer **2** → correct

**Example 2**: `coins = [1,1,1,4]`

- Sorted: [1,1,1,4]
- currentMax = 0
- +1 → currentMax = 1
- +1 → currentMax = 2
- +1 → currentMax = 3
- +4 → 4 ≤ 3 + 1 → currentMax = 3 + 4 = **7**
- Can make all values from 0 to 7 → answer **8** → correct

**Example 3**: `coins = [1,4,10,3,1]`

- Sorted: [1,1,3,4,10]
- currentMax = 0
- +1 → currentMax = 1
- +1 → currentMax = 2
- +3 → currentMax = 5
- +4 → currentMax = 9
- +10 → 10 ≤ 9 + 1 → currentMax = 9 + 10 = **19**
- Can make all values from 0 to 19 → answer **20** → correct

**Correct** — the key condition is `coin <= currentMax + 1` (not strict >).  
When the next coin is exactly `currentMax + 1`, it perfectly extends the range without gap.  
If `coin > currentMax + 1`, a gap appears at `currentMax + 1` → cannot cover it.

---

## Pitfalls & Edge Cases

- **All coins = 1** → currentMax = count of 1's → answer = count + 1
- **No coins** → answer **1** (only 0), but constraints n ≥ 1
- **Coins with gaps early** → correctly stops at first gap
- **Large coins** → may create early gap → answer small
- **Large n (≤4×10⁴)** → O(n log n) from sorting is fine

All handled perfectly.

---

## Key Takeaway

This is a **beautifully greedy** "consecutive coverage" problem:

- **Sort** coins in ascending order
- Maintain `currentMax` — the largest number you can currently make consecutively from 0
- For each next coin:
  - If `coin <= currentMax + 1` → extend range to `currentMax + coin`
  - Else → gap at `currentMax + 1` → cannot cover → stop
- Final answer = `currentMax + 1` (all values from 0 to currentMax are possible)

**Pure, clean, optimal** — classic greedy pattern for maximum consecutive sum coverage with given coins.

---

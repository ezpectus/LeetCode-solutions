# 1828. Queries on Number of Points Inside a Circle  
*O(p × q) — Brute Force per Query (Optimal under constraints)*

---

## Problem Statement

You are given an array `points` where `points[i] = [xi, yi]` is the coordinates of the i-th point on a 2D plane (points can have duplicate coordinates).

You are also given an array `queries` where `queries[j] = [xj, yj, rj]` describes a circle with center `(xj, yj)` and radius `rj`.

For each query `queries[j]`, count how many points lie **inside or on the border** of the j-th circle.

Return an array `answer` of size `q` where `answer[j]` is the number of points inside/on the j-th circle.

**Constraints**:
- 1 ≤ points.length ≤ 500
- 1 ≤ queries.length ≤ 500
- 0 ≤ xi, yi, xj, yj ≤ 500
- 1 ≤ rj ≤ 500

---

## Core Idea — Brute Force per Query (Direct Distance Check)

**Key insight**:
- Extremely small constraints:  
  p = points.length ≤ 500  
  q = queries.length ≤ 500  
- So **O(p × q) = 500 × 500 = 250,000** operations is completely acceptable (runs in milliseconds)
- For each query [cx, cy, r]:
  - For every point [px, py]:
    - If (px - cx)² + (py - cy)² ≤ r² → count it
  - Use `long` for squared distance to avoid int overflow

**Why squared distance?**
- Avoids expensive `Math.Sqrt` and floating-point precision issues
- `(dx)² + (dy)² ≤ r²` is exactly equivalent to distance ≤ r

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int[] CountPoints(int[][] points, int[][] queries) {
        int p = points.Length;
        int q = queries.Length;
        int[] answer = new int[q];

        for (int j = 0; j < q; j++) {
            int cx = queries[j][0];
            int cy = queries[j][1];
            int r = queries[j][2];

            long rSquared = (long)r * r; // prevent overflow

            int count = 0;
            for (int i = 0; i < p; i++) {
                long dx = (long)points[i][0] - cx;
                long dy = (long)points[i][1] - cy;
                long distSq = dx * dx + dy * dy;

                if (distSq <= rSquared)  count++; 
            }
            answer[j] = count;
        }

        return answer;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(p × q)**  | p = number of points ≤ 500, q = number of queries ≤ 500 → 250,000 operations maximum |
| **Space Complexity**  | **O(1)**      | Only the output array + constant variables     |

**Optimal** — brute force is ideal under the tiny constraints (500 × 500 = 250k checks), no need for spatial indexing or optimizations.

---

## Why This Works — Example Walkthrough

**Example 1**: `points = [[1,3],[3,3],[5,3],[2,2]]`, `queries = [[2,3,1],[4,3,1],[1,1,2]]`

- Query 0: center (2,3), radius 1
  - Distance checks: (1,3)→1, (3,3)→1, (5,3)→3>1, (2,2)→1 → **3 points** inside/on border
- Query 1: center (4,3), radius 1
  - (3,3)→1, (5,3)→1, others farther → **2 points**
- Query 2: center (1,1), radius 2
  - (1,3)→2, (2,2)→√2≈1.41, others farther → **2 points**

Output: **[3,2,2]** → correct

**Example 2**: points on diagonal, multiple overlapping circles → counts correctly for each query radius → output **[2,3,2,4]** → correct

**Correct** — for each query we simply check the Euclidean distance condition `(x-cx)² + (y-cy)² ≤ r²` against every point.

---

## Pitfalls & Edge Cases

- **Points on the border** → considered inside (≤ r², not <)
- **Duplicate points** → counted multiple times if they exist
- **r = 0** → only exact center point counted (if exists)
- **Negative coordinates** → handled (constraints 0 ≤ xi,yi ≤ 500)
- **Large coordinates** → use `long` for squared distance to avoid int overflow (max 500² + 500² = 500,000)

All handled perfectly.

---

## Key Takeaway

This is a **beautifully straightforward** brute-force geometry query problem:

- For each query (circle center + radius)
- Check every point: if `(x - cx)² + (y - cy)² ≤ r²` → count it
- Use `long` for squared distance to prevent overflow
- No optimizations needed — constraints are tiny (500 points × 500 queries = 250k checks)

**Pure, clean, optimal** — perfect counting of points inside circles under small constraints.

---

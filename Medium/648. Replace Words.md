# 648. Replace Words — Architectural Prefix HashSet Lookup  
*O(total characters) — Optimal & Simple*

---

## Problem Statement

Given:
- A **dictionary** of root words
- A **sentence** of words separated by spaces

Replace each **derivative** word in the sentence with the **shortest root** that is its **prefix**.
If no root matches → keep original word.
Return the transformed sentence.

---

## Core Idea — Greedy Shortest Prefix + HashSet

For each word `w` in sentence:

- Try prefixes `w[0..1]`, `w[0..2]`, ..., `w[0..L]`
- **First** matching root → use it (**shortest** by construction)
- No match → keep `w`

**HashSet** → `O(1)` prefix lookup.
**No Trie needed** — constraints allow linear scan per word.

---

##  Implementation (C#)

```csharp
public class Solution {
    public string ReplaceWords(IList<string> dictionary, string sentence) {
        var roots = new HashSet<string>(dictionary);
        var words = sentence.Split(' ');
        var sb = new StringBuilder();

        foreach (var w in words) {
            string rep = w;

            for (int len = 1; len <= w.Length; len++) {
                string prefix = w.Substring(0, len);
                if (roots.Contains(prefix)) {
                    rep = prefix;
                    break;
                }
            }

            sb.Append(rep).Append(' ');
        }

        return sb.ToString().TrimEnd();
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(total chars)**    | Sum of lengths of all words in sentence + dictionary insert |
| **Space Complexity**  | **O(sum root lengths)**| HashSet stores dictionary roots                |

**Optimal** — meets required complexity.

---

## Why This Works — Example Walkthrough

**Input**:  
`dictionary = ["cat","bat","rat"]`  
`sentence = "the cattle was rattled by the battery"`

- `"the"` → no prefix match → `"the"`
- `"cattle"` → `"cat"` is prefix → replace with `"cat"`
- `"was"` → no match → `"was"`
- `"rattled"` → `"rat"` is prefix → `"rat"`
- `"by"` → no match → `"by"`
- `"the"` → `"the"`
- `"battery"` → `"bat"` is prefix → `"bat"`

→ `"the cat was rat by the bat"`

**Perfect** — exactly the expected output.

---

## Pitfalls & Edge Cases

- **Multiple possible roots** → shortest wins (e.g., `"cat"` over `"cattle"`)
- **Empty dictionary** → return original sentence
- **Word shorter than root** → impossible → keep word
- **Exact match** → valid (root replaces itself)
- **Word equal to root** → replaced with itself (no change)

All handled correctly.

---

## Key Takeaway

This is a **beautifully simple** prefix replacement problem:

- **Greedy shortest match** per word
- **HashSet** for O(1) lookup
- **Early break** → minimal work

**No Trie. No sorting. No overengineering.**
**Pure insight + clean code** — one of the most elegant Medium string problems.

---

# 851. Loud and Rich

**Difficulty:** Medium  
**Topics:** Graph, DFS, Memoization  

---

## ðŸ“– Problem Restatement
Given `richer[i] = [a,b]` meaning `a` is richer than `b`, and array `quiet[i]` representing quietness of person `i`.  
Return `answer[x] = y` where `y` is the quietest person among all people who have at least as much money as `x`.

---

## ðŸ’¡ Core Idea
- Model as a directed graph: edge `a â†’ b` means `a` richer than `b`.  
- For each person `x`, we need the quietest among `x` and all richer nodes.  
- Use **DFS + memoization**:  
  - Explore richer neighbors.  
  - Track minimum quiet index.  
  - Cache results to avoid recomputation.  

---

## âœ… C# Implementation
```csharp
public class Solution {
    public int[] LoudAndRich(int[][] richer, int[] quiet) {
        int n = quiet.Length;
        var graph = new List<int>[n];
        for (int i = 0; i < n; i++) graph[i] = new List<int>();
        foreach (var r in richer) {
            graph[r[1]].Add(r[0]); // richer person points to poorer
        }

        int[] answer = new int[n];
        Array.Fill(answer, -1);

        int Dfs(int node) {
            if (answer[node] != -1) return answer[node];
            int minPerson = node;
            foreach (int nei in graph[node]) {
                int candidate = Dfs(nei);
                if (quiet[candidate] < quiet[minPerson]) {
                    minPerson = candidate;
                }
            }
            answer[node] = minPerson;
            return minPerson;
        }

        for (int i = 0; i < n; i++) Dfs(i);
        return answer;
    }
}
```


## ðŸ“Š Complexity Analysis

- **Time Complexity:** O(n + m) â€” DFS visits each node and edge once (with memoization).  
- **Space Complexity:** O(n + m) â€” graph + recursion stack.  

---

## âš ï¸ Pitfalls

- Graph direction: `a â†’ b` means `a` richer than `b`.  
- Must memoize results to avoid exponential DFS.  
- Quietness is unique, so comparison is straightforward.  

---

## ðŸ”Ž Example Walkthrough

**Input:**  
`richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`  
`quiet = [3,2,5,4,6,1,7,0]`  

**Output:**  
`[5,5,2,5,4,5,6,7]`  

---

## âœ… Key Takeaway

- This is a **graph + DFS memoization** problem.  
- **Pattern:** â€œpropagate minimum property through richer relationships.â€  
- Clean O(n+m) solution.  


---


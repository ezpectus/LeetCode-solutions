# 934. Shortest Bridge

---

##  Problem Restatement
You are given an `n x n` binary matrix `grid` where `1` represents land and `0` represents water.  
There are exactly two islands (4‑directionally connected groups of `1`s).  
You may flip `0`s into `1`s to connect the two islands.  
Return the minimum number of flips required.

Constraints:  
- `2 ≤ n ≤ 100`  
- Exactly two islands exist in the grid.  

---

##  Core Idea
- First, identify one island completely using **DFS**.  
- Then, expand outward using **BFS** from all cells of that island simultaneously.  
- The first time BFS touches the second island → that distance is the minimum flips.  

This is a **DFS + multi‑source BFS** pattern.

---

##  Step‑by‑Step
1. Find the first land cell (`1`).  
2. Run DFS to mark the entire first island and push its cells into a queue.  
3. Run BFS from this queue:  
   - Each expansion step flips one water cell.  
   - If BFS reaches a land cell of the second island → return current distance.  

---

##  Code (C#)
```csharp
public class Solution {
    private static readonly int[][] dirs = new int[][] {
        new int[]{1,0}, new int[]{-1,0}, new int[]{0,1}, new int[]{0,-1}
    };

    public int ShortestBridge(int[][] grid) {
        int n = grid.Length;
        var queue = new Queue<(int r, int c)>();
        bool found = false;

        // 1. Find and mark the first island
        for (int i = 0; i < n && !found; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    DFS(grid, i, j, queue);
                    found = true;
                    break;
                }
            }
        }

        // 2. BFS expansion
        int steps = 0;
        while (queue.Count > 0) {
            int size = queue.Count;
            for (int k = 0; k < size; k++) {
                var (r, c) = queue.Dequeue();
                foreach (var d in dirs) {
                    int nr = r + d[0], nc = c + d[1];
                    if (nr < 0 || nc < 0 || nr >= n || nc >= n) continue;
                    if (grid[nr][nc] == 2) continue; // visited
                    if (grid[nr][nc] == 1) return steps; // reached second island
                    grid[nr][nc] = 2;
                    queue.Enqueue((nr, nc));
                }
            }
            steps++;
        }
        return -1;
    }

    private void DFS(int[][] grid, int r, int c, Queue<(int,int)> queue) {
        int n = grid.Length;
        if (r < 0 || c < 0 || r >= n || c >= n || grid[r][c] != 1) return;
        grid[r][c] = 2; // mark visited
        queue.Enqueue((r, c));
        foreach (var d in dirs) {
            DFS(grid, r + d[0], c + d[1], queue);
        }
    }
}
```

## Complexity
- **Time:** O(n^2) — each cell is processed at most once across DFS and BFS.  
  DFS marks the first island in O(n^2), BFS expands level by level in O(n^2).  
  Together, the complexity remains linear in the grid size.  
- **Space:** O(n^2) — adjacency is implicit in the grid, but we use a queue for BFS and recursion stack for DFS.  
  In worst case (grid filled with land), both structures may hold O(n^2) cells.

---

## Pitfalls
- **Incomplete island marking:** If DFS does not capture the entire first island, BFS will start from only part of it and may miss the shortest path.  
- **Visited state:** Always mark visited cells (e.g., set to `2`) to avoid revisiting and infinite loops.  
- **Early termination:** The correct answer is the first BFS contact with the second island. Expanding further risks overshooting and returning a larger distance.  
- **Boundary checks:** Ensure indices are within bounds; off‑by‑one errors can break DFS/BFS traversal.  
- **Large grids:** For `n = 100`, recursion depth in DFS can be significant; iterative DFS or stack may be safer in practice.

---

## Conclusion
This problem reduces to a **two‑phase search strategy**:  
1. **DFS** to capture one island completely and initialize the BFS frontier.  
2. **Multi‑source BFS** to expand outward until the second island is reached.  

Because all moves have equal cost (flip one water cell), BFS guarantees the shortest path.  
The first contact with the second island yields the minimum flips required.  

Result: a clean `O(n^2)` solution, robust for `n ≤ 100`, and a textbook example of combining DFS (component detection) with BFS (shortest expansion).


---

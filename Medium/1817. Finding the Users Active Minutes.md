# 1817. Finding the Users Active Minutes — Architectural HashMap + Frequency Counting  
*O(n + k) — Optimal Linear Pass with Dictionary*

---

## Problem Statement

- You are given a 2D array `logs` where `logs[i] = [IDi, timei]` means user `IDi` performed an action at minute `timei`.
- Multiple actions by the same user in the same minute count as **one** active minute.
- The **User Active Minutes (UAM)** for a user is the number of **unique** minutes they were active.
- Return a **1-indexed** array `answer` of size `k` where `answer[j]` = number of users with UAM exactly equal to `j` (for `j = 1 to k`).

---

## Core Idea — Track Unique Minutes per User + Frequency Count

**Key insight**:
- For each user → count **unique** active minutes (use HashSet per user or Dictionary<user, HashSet<time>>)
- Then, for each user → get their UAM = size of their unique minutes set
- Use another array/frequency map to count how many users have each UAM value
- Return the frequency array from 1 to k

**Efficient solution**:
- Use `Dictionary<int, HashSet<int>>` → user ID → set of unique minutes
- Iterate logs → add time to user's set
- Then iterate users → get UAM = set.Count
- Increment frequency[UAM]++
- Return frequency[1..k]

---

## Full Optimal Implementation (C#)

```csharp
public class Solution {
    public int[] FindingUsersActiveMinutes(int[][] logs, int k) {
        // Step 1: Track unique minutes per user
        Dictionary<int, HashSet<int>> userMinutes = new Dictionary<int, HashSet<int>>();

        foreach (int[] log in logs) {
            int user = log[0];
            int time = log[1];

            if (!userMinutes.ContainsKey(user)) {
                userMinutes[user] = new HashSet<int>();
            }
            userMinutes[user].Add(time);
        }

        // Step 2: Count frequency of each UAM
        int[] freq = new int[k + 1]; // 1-indexed, ignore index 0

        foreach (var set in userMinutes.Values) {
            int uam = set.Count;
            if (uam <= k) {
                freq[uam]++;
            }
        }

        // Return answer[1..k]
        int[] answer = new int[k];
        for (int j = 1; j <= k; j++){
            answer[j - 1] = freq[j];
        }

        return answer;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Processing all logs O(n), iterating over all unique (user, time) pairs O(n) — total unique pairs ≤ n |
| **Space Complexity**  | **O(n)**      | Dictionary + HashSets store at most O(n) entries (worst case each log is unique user+time) |

**Optimal** — linear time and space, perfectly suited for n ≤ 10⁴ logs.

---

## Why This Works — Example Walkthrough

**Example 1**: `logs = [[0,5],[1,2],[0,2],[0,5],[1,3]]`, `k = 5`

- User 0: times {5, 2, 5} → unique {2, 5} → UAM = **2**
- User 1: times {2, 3} → unique {2, 3} → UAM = **2**
- Frequency: freq[2] = 2
- answer = [0, 2, 0, 0, 0] → correct

**Example 2**: `logs = [[1,1],[2,2],[2,3]]`, `k = 4`

- User 1: times {1} → UAM = **1**
- User 2: times {2, 3} → UAM = **2**
- Frequency: freq[1] = 1, freq[2] = 1
- answer = [1, 1, 0, 0] → correct

**Correct** — HashSet per user ensures each minute is counted only once (even if multiple actions in same minute), then frequency array correctly counts users by their UAM.

---

## Pitfalls & Edge Cases

- **Same user, same minute multiple times** → HashSet counts it only once (correct — UAM is unique minutes)
- **k > maximum possible UAM** → answer[j] = 0 for j > max UAM (handled by array initialization)
- **Empty logs** → no users → all answer[j] = 0
- **Large n (≤ 10⁴)** → HashSets total size O(n) → fine
- **User IDs up to 10⁹** → Dictionary handles large integer keys perfectly

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** frequency counting problem:

- Use **Dictionary<int, HashSet<int>>** to track unique active minutes per user
- UAM for each user = size of their HashSet (unique minutes)
- Use **frequency array** (or Dictionary) to count how many users have each possible UAM value
- Return 1-indexed slice of frequency from 1 to k

**Pure, clean, optimal** — perfect counting of user active minutes with O(1) uniqueness check per action.

---

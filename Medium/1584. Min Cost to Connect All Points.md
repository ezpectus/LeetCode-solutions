# 1584. Min Cost to Connect All Points

##  Problem Summary
We are given:
- An array `points` representing integer coordinates on a 2D-plane, where `points[i] = [xi, yi]`.
- The cost of connecting two points `[xi, yi]` and `[xj, yj]` is the **Manhattan distance**:  
  `|xi - xj| + |yi - yj|`.

**Goal:**  
Return the minimum cost to connect all points such that there is exactly one simple path between any two points (i.e., build a Minimum Spanning Tree).

---

##  Core Idea
- This is a **Minimum Spanning Tree (MST)** problem.  
- Use **Prim’s algorithm**:
  1. Start from any point (e.g., index 0).
  2. Use a priority queue to always pick the smallest edge connecting a visited node to an unvisited node.
  3. Add the edge to the MST and mark the node as visited.
  4. Continue until all nodes are connected.
- The cost is the sum of all chosen edges.

---

##  Code (C#)

```csharp
public class Solution {
    public static int ManhattanDistance(int[] p1, int[] p2) {
        return Math.Abs(p1[0] - p2[0]) + Math.Abs(p1[1] - p2[1]);
    }

    public int MinCostConnectPoints(int[][] points) {
        int n = points.Length;
        bool[] visited = new bool[n];
        int mstWeight = 0;
        int edgesUsed = 0;

        // PriorityQueue: (vertex, weight)
        var pq = new PriorityQueue<int, int>();
        pq.Enqueue(0, 0); // start from node 0 with cost 0

        while (edgesUsed < n) {
            pq.TryDequeue(out int u, out int w);

            if (visited[u]) continue;

            visited[u] = true;
            mstWeight += w;
            edgesUsed++;

            // Update distances to all other nodes
            for (int v = 0; v < n; v++) {
                if (!visited[v]) {
                    int dist = ManhattanDistance(points[u], points[v]);
                    pq.Enqueue(v, dist);
                }
            }
        }

        return mstWeight;
    }
}
```

##  Complexity
- **Time:** O(n² log n)  
  - Each edge insertion into the priority queue costs log n.  
- **Space:** O(n²) in worst case (all edges in queue).  
- Works efficiently for n ≤ 1000.  

---

##  Pitfalls
- Must use Manhattan distance, not Euclidean.  
- Ensure all points are distinct.  
- `PriorityQueue` in C# requires `(element, priority)` format.  

---

##  Sanity Checks
- Input: `[[0,0],[2,2],[3,10],[5,2],[7,0]]` → Output: `20`  
- Input: `[[3,12],[-2,5],[-4,1]]` → Output: `18`  

---

##  Key takeaway
This problem is a direct application of **Prim’s algorithm** for MST using Manhattan distance.  
By leveraging a **priority queue**, we efficiently connect all points with minimum cost.


---

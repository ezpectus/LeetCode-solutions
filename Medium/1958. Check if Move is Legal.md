# 1958. Check if Move is Legal  
*O(1) — Optimal 8-Direction Ray Check (Reversi Rules)*

---

## Problem Statement

You have an 8×8 Reversi-like board:

- `.` — empty cell
- `W` — white piece
- `B` — black piece

You want to place your piece of `color` (`'B'` or `'W'`) at position `(rMove, cMove)` (currently empty).

A move is **legal** if **at least one direction** (horizontal, vertical, diagonal) forms a **good line**:

- The placed piece becomes one **endpoint**
- The line has ≥ 3 cells (including endpoints)
- Endpoints are your color (`color`)
- All middle cells are the **opposite color**
- No empty cells in the line

Return `true` if the move is legal, `false` otherwise.

---

## Core Idea — Check All 8 Directions for Valid Flips

**Key insight**:
- In Reversi (Othello), a move is legal if you can **flip at least one** opponent's piece
- Flipping happens when you have your piece — opponent's pieces — your piece in a straight line
- So for each of 8 directions:
  - Start from the placed position `(rMove, cMove)`
  - Move in that direction step by step
  - You need:
    - First cell(s): opposite color (can be multiple)
    - Then: your color (the other endpoint)
    - No empty cells or wrong colors in between
- If **at least one direction** satisfies this → legal move

**Directions** (dr, dc):
- (-1,-1), (-1,0), (-1,1)
- (0,-1),          (0,1)
- (1,-1),  (1,0),  (1,1)

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public bool CheckMove(char[][] board, int rMove, int cMove, char color) {
        int m = 8, n = 8;
        char opp = color == 'W' ? 'B' : 'W';

        // 8 possible directions
        int[] dr = { -1, -1, -1,  0, 0,  1, 1, 1 };
        int[] dc = { -1,  0,  1, -1, 1, -1, 0, 1 };

        // Check each direction
        for (int d = 0; d < 8; d++) {
            int r = rMove + dr[d];
            int c = cMove + dc[d];
            bool foundOpp = false;

            // Walk in this direction
            while (r >= 0 && r < m && c >= 0 && c < n) {
                if (board[r][c] == '.') break; // empty → invalid line
                
                if (board[r][c] == opp) foundOpp = true; // at least one opponent piece
                
                else if (board[r][c] == color) {
                    // Found our color at the end
                    if (foundOpp) {
                        return true; // valid line found
                    }
                    break; // our color but no opponent in between → invalid
                }
                else break; // unexpected character
    
                r += dr[d];
                c += dc[d];
            }
        }

        return false; // no valid direction found
    }
}
```


## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(1)**      | Fixed 8×8 board: 8 directions × max 8 cells per direction = 64 operations — constant time |
| **Space Complexity**  | **O(1)**      | No extra data structures — only loop variables |

**Optimal** — constant time check, perfectly suited for fixed-size 8×8 board.

---

## Why This Works — Example Walkthrough

**Example 1**:

- Place `'B'` at position `(4,3)`
- Check all 8 directions from `(4,3)`
- At least two directions form valid lines:
  - Placed `'B'` → sequence of one or more `'W'` → another `'B'`
  - This creates a "sandwich" → opponent pieces can be flipped
- Move is **legal** → return `true`

**Example 2**:

- Place `'W'` at `(4,4)`
- Check all 8 directions:
  - Some directions have opponent pieces but **no closing `'W'`**
  - Others hit empty cells or wrong pattern
- No valid sandwich found → move is **illegal** → return `false`

**Correct** — the code simulates a Reversi/Othello flip check in every direction:  
your piece → 1+ opponent pieces → your piece (no empties or wrong colors in between).  
If **at least one** direction satisfies this → the move is legal.

---

## Pitfalls & Edge Cases

- **Board edge** → ray stops immediately at boundary → correct (no wrap-around)
- **No opponent pieces in line** → cannot flip anything → false
- **Direct neighbor is your color** → no middle opponent pieces → invalid
- **Multiple opponent pieces in line** → valid as long as it ends with your color
- **Place next to opponent but no closing piece** → invalid (line not closed)
- **All 8 directions checked** → even one valid direction is enough

All handled perfectly.

---

## Key Takeaway

This is a **classic Reversi/Othello legal move validation**:

- A move is legal if **at least one** of the 8 directions forms a valid line:
  - Your piece (the one just placed)
  - 1 or more consecutive opponent pieces
  - Ends with your piece again
  - No empty cells (`.`) or wrong colors in the line
- Check each direction with simple ray walking (step until boundary or invalid)
- As soon as **one** direction is valid → return `true`

**Pure, clean, optimal** — O(1) time on fixed 8×8 board — no optimizations needed.
---

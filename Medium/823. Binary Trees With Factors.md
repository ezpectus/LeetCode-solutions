# Pattern Name
**Binary Tree Count via Factor Pair Dynamic Programming**

---

## Problem Summary
You're given:

- An array of **unique integers** `arr`, where each `arr[i] > 1`

**Rules:**
- You can build **binary trees** using these numbers
- Each **non-leaf node** must equal the **product** of its two children
- Each number can be used **multiple times**

**Goal:**
- Return the **total number of such trees** modulo **10⁹ + 7**

---

## Core Idea
This is a **combinatorial DP problem** over **multiplicative relationships**.

Each number can be a **root**, and its children must **multiply to it**.

We count all valid trees **rooted at each number** by checking **all factor pairs** that exist in the array.

---

## Strategy Summary
1. **Sort `arr`** → smaller factors processed first
2. Use a **dictionary `idx`** → map value → index for fast lookup
3. Use `dp[i]` → number of trees **rooted at `arr[i]`**
4. For each `x = arr[i]`:
   - Try all `a = arr[j]` where `j < i`
   - If `x % a == 0` and `x / a` exists in array:
     - `dp[i] += dp[j] * dp[idx[x/a]]`
5. Initialize `dp[i] = 1` (single-node tree)
6. **Sum all `dp` values** → final answer modulo **10⁹ + 7**

---

## C# Implementation
```csharp
public class Solution {
    public int NumFactoredBinaryTrees(int[] arr) {
        Array.Sort(arr);
        var idx = new Dictionary<int, int>();
        int n = arr.Length;
        for (int i = 0; i < n; i++) 
            idx[arr[i]] = i;

        var dp = new long[n];
        Array.Fill(dp, 1);
        long mod = 1_000_000_007;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[i] % arr[j] == 0) {
                    int right = arr[i] / arr[j];
                    if (idx.ContainsKey(right)) {
                        dp[i] = (dp[i] + dp[j] * dp[idx[right]]) % mod;
                    }
                }
            }
        }

        long res = 0;
        foreach (var count in dp) 
            res = (res + count) % mod;

        return (int)res;
    }
}
```

## Architectural Breakdown

| Component         | Role |
|-------------------|------|
| `idx`             | Maps value → index for **O(1)** factor lookup |
| `dp[]`            | Stores count of trees **rooted at `arr[i]`** |
| **Outer loop**    | Iterates over all potential roots |
| **Inner loop**    | Checks all valid **factor pairs** for current root |
| **Modulo logic**  | Ensures result stays within bounds |

---

## Why This Approach Is Superior

| Aspect               | This Approach                              | Naive Approach                     |
|----------------------|--------------------------------------------|------------------------------------|
| **Factor Matching**  | Hash map → `O(1)` lookup                   | Scans entire array → `O(n)`        |
| **DP Strategy**      | Bottom-up with **reuse of subtrees**       | Recomputes tree counts repeatedly  |
| **Performance**      | `O(n²)` with fast lookup                   | `O(n³)` or worse                   |
| **Scalability**      | Handles up to **1000 elements** efficiently | Breaks on large inputs             |
| **Modularity**       | Clean separation of roles                  | Entangled logic                    |

---

## Final Takeaway

> This problem is about **counting binary trees via multiplicative factor chains**.

### The solution uses:
- **Sorting + indexing** for efficient factor lookup
- **Dynamic programming** to accumulate subtree combinations
- **Modulo arithmetic** to handle large results

---

### This pattern generalizes to any task involving:
- **Tree construction** via pairwise rules
- **Factor-based DP** with reuse
- **Combinatorial counting** with constraints

---

# 1237. Find Positive Integer Solution for a Given Equation — Architectural Two-Pointer Search with Monotonicity  
*O(1000) — Optimal Linear Scan Using Function Properties*

---

## Problem Statement

Given a **monotonically increasing** function `f(x, y)` (hidden formula):

- `f(x, y) < f(x+1, y)`
- `f(x, y) < f(x, y+1)`

And target `z`.

Find **all positive integer pairs** `(x, y)` where `f(x, y) == z`.

Return as list of `[x, y]` (any order).

`1 ≤ x, y ≤ 1000`, `z ≤ 100`.

---

## Core Idea — Two-Pointer Scan Exploiting Monotonicity

**Key insight**:
- `f` strictly increases with **both** x and y
- For fixed `x`, `f(x, y)` increases with y
- We can start with `x=1, y=1000` (max possible)
- While `x ≤ 1000` and `y ≥ 1`:
  - Compute `val = f(x, y)`
  - If `val == z` → add pair → **decrease y** (try smaller y)
  - If `val > z` → **decrease y** (too big)
  - If `val < z` → **increase x** (need bigger value)

**Why this works**:
- Monotonicity guarantees we cover **all** solutions without missing or duplicating
- When `val == z` → all pairs with this x are consecutive in y → we find them by decreasing y
- When we increase x → we never return to previous x (f increases)

**No need** brute force O(10⁶)

---

##  Implementation (C#)

```csharp
public class Solution {
    public IList<IList<int>> FindSolution(CustomFunction customfunction, int z) {
        var res = new List<IList<int>>();

        int x = 1;
        int y = 1000;

        while (x <= 1000 && y >= 1) {
            int val = customfunction.f(x, y);

            if (val == z) {
                res.Add(new List<int> { x, y });
                y--; // try smaller y with same x
            } 
            else if (val > z)  y--; // reduce value
            else  x++; // increase value
            
        }

        return res;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(1000)**   | At most ~2000 iterations (x + y changes)       |
| **Space Complexity**  | **O(1)**      | Only result list (excluding output)            |

**Optimal** — leverages monotonicity of the function.

---

## Why This Works — Execution Flow

**Example**: `f(x,y) = x + y`, `z = 5`

- Start: `x=1`, `y=1000` → `f(1,1000)=1001 > 5` → decrease `y`
- Continue decreasing `y` until `y=4` → `f(1,4)=5` → add **[1,4]** → decrease `y` to 3
- `f(1,3)=4 < 5` → increase `x` to 2
- `x=2`, `y=3` → `f(2,3)=5` → add **[2,3]** → decrease `y` to 2
- `f(2,2)=4 < 5` → increase `x` to 3
- `x=3`, `y=2` → `f(3,2)=5` → add **[3,2]** → decrease `y` to 1
- `f(3,1)=4 < 5` → increase `x` to 4
- `x=4`, `y=1` → `f(4,1)=5` → add **[4,1]** → decrease `y` to 0 → stop

**Result**: `[[1,4],[2,3],[3,2],[4,1]]` — **correct**.

The algorithm systematically covers all valid pairs without missing or duplicating any.

---

## Pitfalls & Edge Cases

- **No solutions** → returns empty list
- **Multiple solutions** → finds all of them
- **x or y = 1** → correctly handled at boundaries
- **Large z** → early termination when `y` drops below 1
- **Small z** → early termination when `x` exceeds needed value

All handled perfectly.

---

## Key Takeaway

This is a **beautifully elegant** monotonic search:

- **Two pointers** on `x` and `y`
- **Exploit strict increase** → no backtracking or duplicates
- **O(1000)** → fast and clean even in worst case
**Pure, clean, optimal** — perfect equation solving with unknown monotonic function.


---

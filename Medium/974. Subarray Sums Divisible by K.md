## 🔁 Subarrays Divisible by K — Pattern Formalization

### 🧠 Intuition
If two prefix sums have the same remainder when divided by `k`, their difference is divisible by `k`.  
This means we can count how often each remainder occurs and use that to find valid subarrays.

### 🧩 Architectural Pattern
- Maintain a running `prefixSum`.
- Normalize the remainder using:  
  `mod = ((prefixSum % k) + k) % k`  
  This ensures the remainder is always in `[0, k-1]`, even for negative sums.
- Use a frequency map `freq[mod]` to count how many times each remainder has occurred.
- For each new `mod`, add `freq[mod]` to the result — these are the subarrays ending at the current index that are divisible by `k`.

### 🔍 Why `((sum % k) + k) % k`?
In C#, `%` can return negative values.  
This normalization ensures consistent indexing into the frequency map.

Example:
```csharp
int sum = -2, k = 5;
int mod = ((sum % k) + k) % k; // → 3
```

## 📊 Complexity

- Time: $$O(n)$$ — single pass through array
- Space: $$O(k)$$ — at most k different remainders stored

  ## ✅ Final Code (C#)
```csharp
public class Solution {
    public int SubarraysDivByK(int[] nums, int k) {
        var freq = new Dictionary<int, int>();
        freq[0] = 1; // base case: prefix sum divisible by k
        int sum = 0, res = 0;

        foreach (int num in nums) {
            sum += num;
            int mod = ((sum % k) + k) % k; // normalize remainder

            if (freq.ContainsKey(mod)) {
                res += freq[mod]; // add count of previous same mod
            }

            if (!freq.ContainsKey(mod)) {
                freq[mod] = 0;
            }

            freq[mod]++;
        }

        return res;
    }

}
```

## 🧠 Denis-style Insight — Prefix Modulo Pattern Generalization

This pattern isn't just a one-off trick — it's a **modular architecture** that recurs across domains. Here's how it generalizes:

### 🔁 Core Principle
If two prefix states yield the same normalized signal (mod, XOR, parity, etc.), then the subarray between them satisfies a target condition.  
This enables **constant-time detection** of valid subarrays using a frequency map.

---

### 🧩 Generalized Applications

| Domain | Signal | Use Case | Normalization |
|--------|--------|----------|---------------|
| **Modulo arithmetic** | `prefixSum % k` | Subarrays divisible by `k` | `((x % k) + k) % k` |
| **XOR patterns** | `prefixXOR` | Subarrays with target XOR | No normalization needed |
| **Parity tracking** | `prefixSum % 2` | Even/odd subarray sums | `mod = sum & 1` |
| **Target difference** | `prefixSum - target` | Subarrays with exact sum | Hash map of prefix sums |
| **Rolling hash** | `prefixHash % base` | Substring matching / Rabin-Karp | Normalize to `[0, base-1]` |
| **Prefix frequency** | `count[char]` | Anagram detection / sliding window | Vector diff or hash |

---

### 🧠 Engineering Signals

- **Normalization formula**:  
  `((x % k) + k) % k` — ensures consistent indexing even with negative values  
  Use this in any cyclic or modular domain.

- **Frequency map**:  
  `Dictionary<signal, count>` — tracks how often each signal has occurred  
  Enables O(1) lookup for valid subarrays.

- **Prefix accumulation**:  
  `sum += nums[i]` or `xor ^= nums[i]` — builds the signal incrementally  
  Works for additive, bitwise, or hash-based domains.

- **Base case**:  
  Initialize `freq[0] = 1` — handles subarrays starting from index 0  
  Crucial for correctness in modulo and XOR tasks.

---

### 🔄 Reusability Across Platforms

This pattern appears in:
- Leetcode: subarray sum, XOR, parity, rolling hash
- Codeforces: prefix tricks, parity games, modular DP
- AtCoder: frequency-based combinatorics, normalized hashing
- Open-source: log analysis, streaming counters, cyclic buffers

---

### 🧱 Archive Placement

Add this to:
- `prefix_sum_patterns.md`
- Section: `Normalized Modulo & Frequency Tracking`
- Tag: `combinatorics`, `hashing`, `architectural invariant`

---

### 🧠 Bonus: Pattern Variants to Explore

- **Sliding window + frequency map** → for fixed-length subarrays
- **Prefix + suffix symmetry** → for palindromic or mirrored structures
- **Matrix prefix sums** → extend to 2D with `(i,j)` normalization
- **DP with mod states** → e.g., `dp[i][mod]` for constrained paths

---

This isn’t just a solved problem — it’s a **playbook entry**. You’ve locked the invariant, normalized the signal, and benchmarked the frequency map. That’s real engineering depth.



---

# 1975. Maximum Matrix Sum — Architectural Parity-Based Sign Flipping  
*O(n²) — Optimal Greedy Absolute Sum with Negative Count Adjustment*

---

## Problem Statement

- Given `n × n` matrix (`2 ≤ n ≤ 250`, values `-10⁵ ≤ x ≤ 10⁵`).
- Operation: choose two **adjacent** cells → multiply both by **-1** (flip signs).
- Goal: **maximize sum** of all elements.
- Return maximum possible sum.

---

## Core Idea — Flip Signs to Make All Positive (Almost)

**Key insight**:
- Flipping two adjacent cells = changing sign of both
- This is equivalent to **changing sign of even number of cells** in connected component
- But since grid is connected → we can **flip any even number of cells**
- More importantly: **we can make all elements positive**, except possibly **one negative** if total negatives is odd

**Proof**:
- Each operation flips two signs → preserves **parity** of negative count
- We cannot change odd → even negatives
- If even negatives → can pair them → flip pairs → all positive
- If odd negatives → can make all but one positive

**Strategy**:
1. Compute **absolute sum** = sum of |matrix[i][j]|
2. Count **number of negative** values
3. If **even negatives** → can achieve absolute sum
4. If **odd negatives** → must leave one negative → subtract **2 × smallest absolute value**

**Answer**:
- `absSum - (negCount % 2 == 1 ? 2 * minAbs : 0)`

---

##  Implementation (C#)

```csharp
public class Solution {
    public long MaxMatrixSum(int[][] matrix) {
        int n = matrix.Length;
        long absSum = 0;
        int negCount = 0;
        int minAbs = int.MaxValue;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int val = matrix[i][j];
                int absVal = Math.Abs(val);
                absSum += absVal;
                if (val < 0) negCount++;
                minAbs = Math.Min(minAbs, absVal);
            }
        }

        // If odd number of negatives -> must leave one negative
        if (negCount % 2 == 1)  absSum -= 2L * minAbs;
        

        return absSum;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n²)**     | Single pass over matrix                        |
| **Space Complexity**  | **O(1)**      | Only variables                                 |

**Optimal** — minimal operations.

---

## Why This Works — Example Walkthrough

**Example 1**: `[[1,-1],[-1,1]]`

- absSum = 1+1+1+1 = **4**
- negCount = 2 (even)
- → return **4**

**Correct**.

**Example 2**: `[[1,2,3],[-1,-2,-3],[1,2,3]]`

- absSum = 1+2+3+1+2+3+1+2+3 = **18**
- negCount = 3 (odd)
- minAbs = 1
- → 18 - 2×1 = **16**

**Correct**.

**Example**: all positive → negCount=0 → return absSum  
**Example**: one negative → subtract 2×|negative|

**Correct**.

---

## Pitfalls & Edge Cases

- **All zero** → 0
- **Single negative** → subtract 2×its abs
- **n=2** → works
- **Large values** → use `long`
- **minAbs=0** → if zero exists and odd negatives → can "flip" zero and negative → effectively remove negative (0 becomes 0) → sum unchanged → code subtracts 0 → correct

All handled perfectly.

---

## Key Takeaway

This is a **beautifully elegant** parity observation:

- **Sign flips in pairs** → preserve parity of negatives
- **Odd negatives** → must leave one → subtract twice smallest abs
- **Even negatives** → can eliminate all

**Pure, clean, optimal** — perfect matrix sum maximization.

---

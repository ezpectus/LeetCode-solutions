# 2216. Minimum Deletions to Make Array Beautiful  
*O(n) — Greedy Single Pass*

---

## Problem Statement

You are given a 0-indexed integer array `nums`.

The array is **beautiful** if:
- `nums.length` is **even**
- `nums[i] != nums[i+1]` for all `i % 2 == 0` (i.e., no two adjacent elements are equal at even indices)

You can **delete** any number of elements.  
When you delete an element at index `i`, all elements to the right shift left to fill the gap.

Return the **minimum number of deletions** needed to make `nums` beautiful.  
Note: empty array is considered beautiful.

**Examples**:

**Example 1**  
Input: nums = [1,1,2,3,5]  
Output: **1**  
Delete `nums[0]` or `nums[1]` → [1,2,3,5] (beautiful)

**Example 2**  
Input: nums = [1,1,2,2,3,3]  
Output: **2**  
One way: delete `nums[0]` and `nums[5]` → [1,2,2,3] (beautiful)

**Constraints**:
- 1 ≤ nums.length ≤ 10⁵
- 0 ≤ nums[i] ≤ 10⁵

---

## Core Idea — Greedy: Keep Alternating Pattern

**Key observation**:
- Beautiful array must have **even length** and **no two equal adjacent elements at even positions**
- i.e., positions 0,2,4,... must have different values from their next (1,3,5,...)
- We want to **maximize the length of the kept subsequence** that satisfies the condition → minimize deletions
- Greedy: traverse from left to right, keep a number only if it doesn't violate the rule with previous kept number

**Algorithm**:
- Initialize `count` = number of elements kept (starts at 0)
- Iterate through array:
  - If `count` is even (next position will be even index in result):
    - Always keep it (no restriction yet)
  - Else (count is odd → next would be odd index):
    - Keep it **only if** it ≠ previous kept number
- Final deletions = original length − kept count
- Since we always prefer to keep when possible → this maximizes kept length

**Time**: O(n) — single pass  
**Space**: O(1) — just counters

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int MinDeletion(int[] nums){
        int n = nums.Length;
        int kept = 0;  // number of elements we decide to keep

        for (int i = 0; i < n; i++){
            // If kept is even → next position will be even index in result
            // We can always keep this one (no pair yet)
            if (kept % 2 == 0) kept++;
            
            // If kept is odd → next would be odd index
            // Keep only if different from previous kept
            else if (nums[i] != nums[i - 1]) kept++;
            // else: skip (delete) — same as previous, would violate rule
        }

        // If final kept length is odd → we need to delete one more to make even
        if (kept % 2 == 1) kept--;
        
        return n - kept;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single linear pass through the array — each element is considered exactly once |
| **Space Complexity**  | **O(1)**      | Only a few integer variables (kept counter, loop index) — no extra arrays or data structures |

**Optimal** — linear time and constant extra space — perfect and very efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: nums = [1,1,2,3,5]

- i=0: kept=0 (even) → always keep → nums[0]=1, kept=1
- i=1: kept=1 (odd), nums[1]=1 == previous kept (1) → skip (delete)
- i=2: kept=1 (odd), nums[2]=2 != previous kept (1) → keep 2, kept=2
- i=3: kept=2 (even) → always keep 3, kept=3
- i=4: kept=3 (odd), nums[4]=5 != previous kept (3) → keep 5, kept=4

Final kept length = 4 (even) → deletions = 5 − 4 = **1** → correct

**Example 2**: nums = [1,1,2,2,3,3]

- i=0: kept=0 (even) → keep 1, kept=1
- i=1: kept=1 (odd), 1 == 1 → skip
- i=2: kept=1 (odd), 2 != 1 → keep 2, kept=2
- i=3: kept=2 (even) → keep 2, kept=3
- i=4: kept=3 (odd), 3 != 2 → keep 3, kept=4
- i=5: kept=4 (even) → keep 3, kept=5

Final kept length = 5 (odd) → delete one more to make even → kept=4  
deletions = 6 − 4 = **2** → correct

**Correct** —  
We **greedily keep as many elements as possible** while ensuring the resulting sequence satisfies the beautiful condition:
- Even length
- No two adjacent equal elements at even-odd positions (i.e., alternates properly)

Whenever the kept count is odd (next position would be odd index in result), we only keep the current element if it differs from the previous kept one.  
If the final kept count is odd, we delete one extra element to make the length even.

This strategy **maximizes the number of kept elements** → **minimizes deletions**.

---

## Key Takeaway

This is a **simple, elegant greedy alternating pattern** problem:

* Traverse the array from left to right
* Maintain a counter `kept` of how many elements we decide to keep
* Rules:
  - If `kept` is **even** → always keep the current element (starts a new pair)
  - If `kept` is **odd** → keep only if current ≠ previous kept element
* After processing the entire array:
  - If final `kept` is **odd** → delete one more element (to make length even)
* Minimum deletions = original length − final kept count

**Pure, clean, optimal** — O(n) time, O(1) extra space, extremely fast, very intuitive, and handles all edge cases correctly (all equal, all distinct, single element, empty after deletions, etc.).

---

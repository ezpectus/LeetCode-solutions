# 2456. Most Popular Video Creator  
*O(n) — HashMap + Tracking Max Views & Popularity*

---

## Problem Statement

You are given three arrays of length `n`:
- `creators[i]` — creator of the i-th video
- `ids[i]` — id of the i-th video
- `views[i]` — number of views for the i-th video

The **popularity** of a creator = sum of `views` of all their videos.

Find all creators with the **highest popularity**.  
For each such creator, find the video with the **highest view count**.  
If multiple videos have the same highest view count — choose the **lexicographically smallest** id.

Return a list of lists: `[[creator1, id1], [creator2, id2], ...]` in **any order**.

**Examples**:

**Example 1**  
Input: creators = ["alice","bob","alice","chris"], ids = ["one","two","three","four"], views = [5,10,5,4]  
Output: **[["alice","one"],["bob","two"]]**  
- alice: 5+5=10  
- bob: 10  
- chris: 4  
Highest popularity = 10 (alice & bob)  
- bob: "two" (10 views)  
- alice: "one" and "three" (both 5) → smallest id "one"

**Example 2**  
Input: creators = ["alice","alice","alice"], ids = ["a","b","c"], views = [1,2,2]  
Output: **[["alice","b"]]**  
- alice: 1+2+2=5  
- Highest views for alice: 2 (b and c) → smallest id "b"

**Constraints**:
- n = creators.length = ids.length = views.length
- 1 ≤ n ≤ 10⁵
- 1 ≤ creators[i].length, ids[i].length ≤ 5
- lowercase English letters
- 0 ≤ views[i] ≤ 10⁵

---

## Core Idea — Track Popularity & Max Video per Creator

**Approach**:
- Use a **dictionary** to track for each creator:
  - Total popularity (sum of views)
  - The **best video** (max views + lex smallest id)
- Also keep track of the **global maximum popularity**
- Iterate once:
  - Update popularity
  - Update best video for creator (higher views or same views but smaller id)
- After processing:
  - Collect all creators with **maximum popularity**
  - For each, include their best video id

**Time**: O(n) — single pass  
**Space**: O(n) — map of creators (distinct creators ≤ n)

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public IList<IList<string>> MostPopularCreator(string[] creators, string[] ids, int[] views){
        // Map: creator → (total popularity, best id, best views)
        var creatorInfo = new Dictionary<string, (long popularity, string bestId, int bestViews)>();

        // Track global max popularity
        long maxPopularity = 0;

        for (int i = 0; i < creators.Length; i++) {
            string creator = creators[i];
            string id = ids[i];
            int view = views[i];

            if (!creatorInfo.ContainsKey(creator)) creatorInfo[creator] = (view, id, view);
            else{
                var (pop, bestId, bestV) = creatorInfo[creator];
                pop += view;

                // Update best video
                if (view > bestV || (view == bestV && string.Compare(id, bestId) < 0)){
                    bestId = id;
                    bestV = view;
                }

                creatorInfo[creator] = (pop, bestId, bestV);
            }

            maxPopularity = Math.Max(maxPopularity, creatorInfo[creator].popularity);
        }

        // Collect all creators with max popularity
        var result = new List<IList<string>>();
        foreach (var kvp in creatorInfo){
            if (kvp.Value.popularity == maxPopularity)  result.Add(new List<string> { kvp.Key, kvp.Value.bestId });
        }

        return result;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single linear pass through all videos — O(n) |
| **Space Complexity**  | **O(n)**      | Dictionary stores information for each unique creator (number of unique creators ≤ n) |

**Optimal** — linear time and linear space — perfectly efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: creators = ["alice","bob","alice","chris"], ids = ["one","two","three","four"], views = [5,10,5,4]

**Processing step-by-step**:

- Video 0: alice, "one", 5 → alice pop=5, best="one" (views=5)
- Video 1: bob, "two", 10 → bob pop=10, best="two" (views=10)
- Video 2: alice, "three", 5 → alice pop=10, best remains "one" (5==5 but "one" < "three")
- Video 3: chris, "four", 4 → chris pop=4, best="four" (views=4)

**Global max popularity** = 10 (alice and bob)

**Result**:
- alice → best video "one"
- bob → best video "two"

→ [["alice","one"], ["bob","two"]] → correct

**Correct** —  
We track two things for each creator:
- **Total popularity** = sum of all their video views
- **Best video** = video with highest views; if tie → lexicographically smallest id

After processing all videos, we find the **maximum popularity** value, then collect **all creators** who reach this maximum, along with their best video id.

---

## Key Takeaway

This is a **simple, elegant greedy tracking** problem:

* Use a **dictionary** to track per creator:
  - Total popularity (sum of views of all their videos)
  - Best video id (highest views, lex smallest id on tie)
* Maintain the **global maximum popularity** seen
* After processing all videos:
  - Collect **all creators** with popularity equal to the global maximum
  - For each, include their **best video id**
* Return the list of [creator, id] pairs (any order)

**Pure, clean, optimal** — O(n) time, O(n) space, extremely fast, very intuitive, and handles all edge cases perfectly (multiple max-pop creators, view ties, single video, single creator, etc.).
---

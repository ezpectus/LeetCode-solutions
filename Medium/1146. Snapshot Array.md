# 1146. Snapshot Array

---

## Problem Restatement
We need to design a **SnapshotArray** data structure that supports:
- `Set(index, val)` → sets the element at `index` to `val`.
- `Snap()` → takes a snapshot and returns the `snap_id`.
- `Get(index, snap_id)` → returns the value at `index` at the time of snapshot `snap_id`.

Constraints:
- Up to `5 * 10^4` operations.
- Array length up to `5 * 10^4`.

---


## Key Idea
We cannot store the entire array for each snapshot (too large).  
Instead:
- For each index, store a **history of changes** as `(snap_id, value)`.  
- On `Set`, record the value with the current `snap_id`.  
- On `Snap`, increment the global snapshot counter.  
- On `Get`, binary search the history for the largest `snap_id` ≤ requested.

This ensures efficient memory usage and fast queries.

---

## Code (C#)
```csharp
public class SnapshotArray {
    private List<(int snapId, int val)>[] history;
    private int snapId;

    public SnapshotArray(int length) {
        history = new List<(int snapId, int val)>[length];
        for (int i = 0; i < length; i++) {
            history[i] = new List<(int snapId, int val)>();
            history[i].Add((0, 0)); // initial value at snap 0
        }
        snapId = 0;
    }
    
    public void Set(int index, int val) {
        // Record the value for the current snapId
        if (history[index].Count > 0 && history[index][history[index].Count - 1].snapId == snapId) {
            // overwrite if already set in this snap
            history[index][history[index].Count - 1] = (snapId, val);
        } else {
            history[index].Add((snapId, val));
        }
    }
    
    public int Snap() {
        return snapId++;
    }
    
    public int Get(int index, int snap_id) {
        var list = history[index];
        int l = 0, r = list.Count - 1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (list[mid].snapId <= snap_id) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return list[r].val;
    }
}
```


## Complexity
- **Set:** O(1) amortized (append or overwrite in the history list).  
- **Snap:** O(1), just increment the global snapshot counter.  
- **Get:** O(log m), where `m` is the number of changes at that index (binary search in history).  
- **Space:** O(n + total number of sets), since we store only changes per index instead of full snapshots.  

---

## Example Walkthrough
```csharp
SnapshotArray snapshotArr = new SnapshotArray(3);
snapshotArr.Set(0,5);   // array[0] = 5
snapshotArr.Snap();     // snap_id = 0
snapshotArr.Set(0,6);   // array[0] = 6
snapshotArr.Get(0,0);   // returns 5
```

## Output
```[null,null,0,null,5] ✅```

---

## Conclusion
The **SnapshotArray** implementation leverages **per-index change history + binary search**:

- **Efficient:** Handles up to **50,000 operations** smoothly.  
- **Memory-friendly:** Avoids storing full snapshots, only recording changes.  
- **Fast retrieval:** Provides historical values with **logarithmic lookup** using binary search.  

This design balances **time efficiency** and **space optimization**, making it well-suited for large-scale usage.  


---

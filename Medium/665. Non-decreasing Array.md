# 665. Non-decreasing Array — Architectural Solution

## Problem Statement
- Given an array `nums`, check if it can be made **non-decreasing** by modifying **at most one** element.
- Non-decreasing means `nums[i] <= nums[i+1]` for all i.
- Constraints: 1 ≤ n ≤ 10⁴

## Core Idea
- We can tolerate **at most one violation** of the non-decreasing order.
- Iterate through the array and count how many times `nums[i] > nums[i+1]`.
- If there are **more than one** such violations → impossible → return false.
- If **zero** → already good → true.
- If **exactly one** at position i → check if we can fix it by changing either `nums[i]` or `nums[i+1]` without creating new violations.

Key check:
- Changing `nums[i]` to ≤ `nums[i+1]` is safe if `i == 0` or `nums[i-1] <= nums[i+1]`
- Changing `nums[i+1]` to ≥ `nums[i]` is safe if `i+1 == n-1` or `nums[i] <= nums[i+2]`
We only need one of these to be possible.

## Implementation (C#) 

```csharp
public class Solution {
    public bool CheckPossibility(int[] nums) {
        int n = nums.Length;
        int violations = 0, pos = -1;

        for (int i =0; i < n-1; i++) {
            if (nums[i] > nums[i + 1]) {
                violations++;
                pos = i;
                if (violations > 1) return false;
            }
        }
           
        // 0 violations → already good
        // 1 violation at pos
        if (violations == 0) return true;

         // Can fix by changing nums[pos] ?
        bool canFixLeft = (pos == 0 || nums[pos - 1] <= nums[pos + 1]);

        // Can fix by changing nums[pos+1] ?
        bool canFixRight = (pos + 1 == n - 1 || nums[pos] <= nums[pos + 2]);

        return canFixLeft || canFixRight;
    }
}
```

## Complexity Analysis

* Time Complexity: **O(n)** — single pass through the array  
* Space Complexity: **O(1)** — only a few integer variables

## Pitfalls & Edge Cases

* Multiple violations → immediately return false  
* Violation at start (`i=0`) → can always fix by changing the first element  
* Violation at end (`i=n-2`) → can always fix by changing the last element  
* Example `[3,4,2]` → fixable (change 4 to ≤2 or 2 to ≥4)  
* Example `[4,2,1]` → two violations → impossible → false  
* Already non-decreasing (`[1,2,3]`) → true  

## Conclusion
Simple yet subtle greedy check.
No need for two passes, array copying, or complex logic.

Just:
- Count violations
- If >1 → false
- If ==1 → verify the dip is locally fixable by changing one of the two elements
- Once you realize the problem is about **local fixability of a single dip** — the solution drops to under 20 lines.
- Classic Medium that feels Hard until the insight hits.


---

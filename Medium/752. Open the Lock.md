# 752. Open the Lock — Architectural Bidirectional BFS in 4-Wheel State Space  
*O(1) — Optimal BFS with Deadend Pruning*

---

## Problem Statement

You have a 4-wheel combination lock, each wheel `'0'–'9'`.

- Start at `"0000"`
- Given `deadends` — states where wheels **freeze**
- Given `target` — the combination to open

Each move: turn **one wheel** **one slot** (up or down, wraps around).

Return **minimum moves** to reach `target`, or `-1` if impossible.

**Avoid deadends** — cannot pass through them.

---

## Core Idea — BFS on String States + Deadend HashSet

This is a **classic shortest path** in an **unweighted graph**:

- Nodes = all possible 4-digit combinations (`"0000"` to `"9999"`)
- Edges = 8 per node (4 wheels × 2 directions)

Total states: **10⁴ = 10,000** → tiny!

**Optimal solution**: **BFS** from `"0000"`, skip deadends.

**Bidirectional BFS** possible but unnecessary — 10k states are trivial.

**Key optimizations**:
- Use `HashSet<string>` for deadends → O(1) check
- Generate neighbors on-the-fly (no pre-build graph)

---

## Implementation (C#)

```csharp
public class Solution {
    public int OpenLock(string[] deadends, string target)  {
        var dead = new HashSet<string>(deadends);
        if (dead.Contains("0000")) return -1;

        var q = new Queue<string>();
        var seen = new HashSet<string>();
        
        q.Enqueue("0000");
        seen.Add("0000");
        int steps = 0;

        while (q.Count > 0)  {
            int size = q.Count;

            for (int i = 0; i < size; i++)  {
                string curr = q.Dequeue();

                if (curr == target) return steps;

                foreach (string next in GetNeighbors(curr)) {
                    if (!seen.Contains(next) && !dead.Contains(next)) {
                        seen.Add(next);
                        q.Enqueue(next);
                    }
                }
            }

            steps++;
        }

        return -1;
    }

    private IEnumerable<string> GetNeighbors(string s) {
        char[] arr = s.ToCharArray();

        for (int i = 0; i < 4; i++) {
            char original = arr[i];

            // Up
            arr[i] = original == '9' ? '0' : (char)(original + 1);
            yield return new string(arr);

            // Down
            arr[i] = original == '0' ? '9' : (char)(original - 1);
            yield return new string(arr);

            // Restore
            arr[i] = original;
        }
    }
}
```


## Complexity

| **Metric**     | **Value**   | **Notes**                          |
|----------------|-------------|------------------------------------|
| **Time**       | **O(1)**    | At most 10,000 states × 8 neighbors = 80,000 operations |
| **Space**      | **O(1)**    | Queue + visited ≤ 10,000 entries   |

**True O(1)** — bounded by state space size (10⁴).  
Practically instant.

---

## Why This Works

- **BFS** → guarantees **shortest path** in unweighted graph (each move = cost 1)
- **String as state** → simple, readable, no need for custom struct or bitmask
- **On-the-fly neighbors** → generate 8 possible moves directly → no pre-built graph
- **Deadend + visited check** → skip forbidden states and avoid cycles/infinite loops

**Bidirectional BFS** would be slightly faster in worst case, but **overkill** — 10k states are trivial for single-direction BFS.

---

## Pitfalls & Edge Cases

- **`"0000"` is deadend** → immediate `-1` (cannot even start)
- **`target == "0000"`** → return `0` if not dead
- **Wrap-around** `'9'→'0'`, `'0'→'9'` → correctly handled in neighbor generation
- **Multiple paths** → BFS always finds **shortest**
- **Deadends blocking paths** → correctly skipped

All covered — robust and complete.

---

## Key Takeaway

This is a **textbook BFS on small state space**:

- Model states as **strings**
- Generate **8 neighbors** per state
- Use **HashSet** for visited + deadends
- **Level-order** → exact minimum steps

**One of the cleanest Medium BFS problems** — pure, fast, elegant.
Perfect example of how **BFS shines** in bounded, discrete state spaces.

---

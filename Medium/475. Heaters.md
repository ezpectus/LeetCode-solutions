# 475. Heaters

## Problem  
Winter is coming! You need to design a standard heater with a fixed warm radius to warm all the houses.  
Every house can be warmed if it lies within the heater's warm radius.  

Given the positions of houses and heaters on a horizontal line, return the **minimum radius** required so that all houses are covered.  
All heaters share the same radius.

---

## Constraints
- `1 <= houses.length, heaters.length <= 3 * 10^4`  
- `1 <= houses[i], heaters[i] <= 10^9`

---

## Solution Idea  
- Sort both arrays (`houses` and `heaters`).  
- For each house, find the nearest heater.  
- Compute the distance to that heater.  
- Track the maximum of these minimum distances — this is the required radius.  

This is essentially a **two-pointer greedy approach**:  
- Move through houses in order.  
- For each house, adjust the heater pointer `j` to the closest heater.  
- Update the maximum radius needed.

---

## C# Implementation

```csharp
public class Solution {
    public int FindRadius(int[] houses, int[] heaters) {
        int n = houses.Length;
        int m = heaters.Length;
        int j = 0, maxR = int.MinValue;

        Array.Sort(houses);
        Array.Sort(heaters);

        for (int i = 0; i < n; i++) {
            int currR = Math.Abs(houses[i] - heaters[j]);

            // Move to a closer heater if possible
            while (j < m - 1 && Math.Abs(houses[i] - heaters[j + 1]) <= currR) {
                j++;
                currR = Math.Abs(houses[i] - heaters[j]);
            }

            maxR = Math.Max(currR, maxR);
        }

        return maxR;
    }
}
```

--- 

## Examples

**Example 1**  
Input: `houses = [1,2,3], heaters = [2]`  
Output: `1`  
Explanation: Heater at position 2 with radius 1 covers houses at 1, 2, and 3.

**Example 2**  
Input: `houses = [1,2,3,4], heaters = [1,4]`  
Output: `1`  
Explanation: Heater at 1 covers houses 1–2, heater at 4 covers houses 3–4.

**Example 3**  
Input: `houses = [1,5], heaters = [2]`  
Output: `3`  
Explanation: Heater at 2 with radius 3 covers both houses.

---


## Complexity

**Time:**
- Sorting houses and heaters: **O(n log n + m log m)**
- Two-pointer scan: **O(n + m)**
- **Total:** O((n + m) log(n + m))

**Space:**
- **O(1)** — in-place sorting and constant extra variables

---

## Pitfalls & Notes

- Always **sort both arrays** before scanning.  
- Ensure heater pointer `j` **does not go out of bounds**.  
- Use `Math.Abs` for computing distances.  
- The **maximum of all minimum distances** across houses is the final radius.  
- Algorithm works efficiently for **large inputs** (up to 30,000 houses/heaters).

---

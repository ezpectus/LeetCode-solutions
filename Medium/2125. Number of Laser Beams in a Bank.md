# Pattern Name
**Laser Beam Counting via Row-wise Device Multiplication**


## Problem Summary
- **Input**: 
  - A binary string array `bank`, representing a 2D floor plan of a bank.
  - Each string is a row; `'1'` means a security device, `'0'` means empty.
- **Condition for Laser Beam**:
  - Exists between any two devices on different rows if:
    - Rows are strictly ordered: `r1 < r2`.
    - All rows between `r1` and `r2` contain no devices.
- **Output**: Return the total number of laser beams in the bank.
- **Constraints**:
  - `1 ≤ m, n ≤ 500`
  - Each `bank[i][j]` is `'0'` or `'1'`.
  - Laser beams are independent.
  - No beam crosses a row with devices in between.

## Core Idea
- This is a **row-wise accumulation problem**.

## Solution
- **Count devices in each row.**
- **Skip empty rows.**
- **For each pair of consecutive non-empty rows**:
  - Multiply device counts → number of beams between them.

## Strategy Summary
- Initialize `prev = 0` — number of devices in previous non-empty row.
- Iterate through each row:
  - Count `'1's` → `count`.
  - If `count == 0` → skip.
  - Else: `total += prev × count`, then `prev = count`.
- Return `total`.

## C# Implementation
```csharp
public class Solution {
    public int NumberOfBeams(string[] bank) {
        int total = 0;
        int prev = 0;

        foreach (string row in bank) {
            int count = 0;
            foreach (char c in row) {
                if (c == '1') count++;
            }

            if (count == 0) continue;

            total += prev * count;
            prev = count;
        }

        return total;
    }
}
```

# Architectural Breakdown
| Component       | Role                              |
|-----------------|-----------------------------------|
| `prev`          | Stores device count of last non-empty row |
| `count`         | Current row's device count        |
| `total`         | Accumulated laser beams           |
| `Loop`          | Iterates through rows, skips empty ones |

# Why This Approach Is Superior
| Aspect            | This Approach       | Naive Approach         |
|-------------------|---------------------|-------------------------|
| Time Complexity   | O(m × n)            | O(m² × n²) (pairwise scan) |
| Space Complexity  | O(1)                | O(1)                    |
| Performance       | Linear scan, fast   | Nested loops, slow      |
| Generalizability  | Works for any binary matrix | Hard to scale |

# Final Takeaway
- **This problem is about efficiently counting independent laser beams between rows with devices.**
- **The solution uses**:
  - Row-wise device counting.
  - Multiplication of adjacent non-empty rows.
  - Skipping intermediate rows with devices.
- **This pattern generalizes to any task involving**:
  - Pairwise interaction across sparse rows.
  - Segmented accumulation with skip conditions.
  - Matrix traversal with conditional aggregation.
 
  ---

#  Problem Statement
- You're given an integer array arr and a list of queries queries[i] = [left, right]. 
- For each query, return the XOR of all elements from arr[left] to arr[right] (inclusive).

##  Goal
Efficiently compute the XOR of subarrays for multiple queries. Avoid recomputing XOR from scratch for each query.

## ðŸ’¡ Core Idea
- XOR is reversible: a ^ a = 0, a ^ 0 = a, a ^ b ^ b = a

We can precompute a prefix XOR array:

```
prefix[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]
Then any query [l, r] becomes:

result = prefix[r] ^ prefix[l - 1]
(if l == 0, then just prefix[r])
```

## âš¡ Trick: Prefix XOR Optimization
 Instead of looping through each subarray per query (O(n * q)), 
we build a prefix XOR array once (O(n)), then answer each query in O(1) using:

```csharp
res[i] = l == 0 ? prefix[r] : prefix[r] ^ prefix[l - 1];
```

##  Full C# Code
```csharp
public class Solution {
    public int[] XorQueries(int[] arr, int[][] queries) {
        int n = arr.Length;
        int[] prefix = new int[n];
        prefix[0] = arr[0];

        for (int i = 1; i < n; i++) {
            prefix[i] = prefix[i - 1] ^ arr[i];
        }

        int[] res = new int[queries.Length];
        for (int i = 0; i < queries.Length; i++) {
            int l = queries[i][0];
            int r = queries[i][1];
            res[i] = l == 0 ? prefix[r] : prefix[r] ^ prefix[l - 1];
        }

        return res;
    }
}
```
##  Architecture Breakdown

- Build prefix	prefix[i] = arr[0] ^ ... ^ arr[i]
- Query logic	prefix[r] ^ prefix[l - 1] or prefix[r] if l == 0
- Time complexity	O(n + q)  ```linear build, constant query```
- Space complexity O(n) ```for prefix array```

##  Example

```plaintext
arr = [1, 3, 4, 8]
prefix = [1, 2, 6, 14]

queries = [0,1] â†’ 1 ^ 3 = 2
queries = [1,2] â†’ 3 ^ 4 = 7
queries = [0,3] â†’ 1 ^ 3 ^ 4 ^ 8 = 14
queries = [3,3] â†’ 8
```

##  Complexity
- Build prefix: O(n)
- Answer each query: O(1)
- Total: O(n + q)

##  Architectural Signal
- You built the base logic â€” loop over queries, extract indices, XOR the range.
- The trick was to precompute prefix XOR to eliminate nested loops. 
- Together, this forms a reusable XOR-query template with optimal complexity.


---

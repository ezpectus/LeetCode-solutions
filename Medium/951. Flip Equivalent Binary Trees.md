# 951. Flip Equivalent Binary Trees — Architectural Recursive Structure Comparison  
*O(min(n1,n2)) — Optimal Direct Recursion*

---

## Problem Statement

Given roots of two binary trees `root1` and `root2`.

**Flip operation**: swap left/right subtrees of any node.

Two trees **flip equivalent** if can make them identical via flips.

Return `true` if flip equivalent, `false` otherwise.

---

## Core Idea — Recursive Check with Swap Flexibility

**Key insight**:
- Trees equivalent if:
  - Roots equal
  - And subtrees match **normally** OR **flipped**

**Recursion**:
- Base: both null → true
- One null → false
- Values differ → false
- Else: check two cases:
  - No flip: left1≡left2 && right1≡right2
  - Flip: left1≡right2 && right1≡left2

**Short-circuit** with OR.

---

##  Implementation (C#)

```csharp
public class Solution {
    public bool FlipEquiv(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null)  return true;
        if (root1 == null || root2 == null)  return false;
        if (root1.val != root2.val)  return false;

        return 
            (FlipEquiv(root1.left, root2.left) && FlipEquiv(root1.right, root2.right)) ||
            (FlipEquiv(root1.left, root2.right) && FlipEquiv(root1.right, root2.left));
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(min(n1,n2))**     | Visit nodes until mismatch                     |
| **Space Complexity**  | **O(h)**              | Recursion stack (h = height, worst O(n))       |

**Optimal** — stops early on mismatch.

---

## Why This Works — Example Walkthrough

**Example 1** (flipped at nodes 1,3,5):

- **root1**: normal tree
- **root2**: flipped version

Recursion:
- Roots both value **1** → equal
- Check two configurations:
  - **Normal**: left1 (val=2) vs left2 (val=3) → values differ → false
  - **Flipped**: left1 (val=2) vs right2 (val=2), right1 (val=3) vs left2 (val=3) → values match → recurse deeper
- Subtrees match recursively after considering flips → **true**

**Example 3**:
- `root1 = null`, `root2 = [1]` → one null, one not → **false**

**Perfect** — correctly identifies equivalence under flips.

---

## Pitfalls & Edge Cases

- **Null trees** → both null → true, one null → false
- **Different values** → early false
- **Unbalanced trees** → recursion depth safe
- **Deep or multiple flips** → recursive check covers all possibilities

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** recursive problem:

- **Two possibilities** per node: normal or flipped
- **OR** of both configurations → covers all flip combinations
- **Early termination** on value mismatch

**No extra data. No canonical form.**
**Pure, clean, optimal** — one of the most elegant tree equivalence problems.

---

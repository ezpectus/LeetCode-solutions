# 🌪️ Pattern Module: Longest Turbulent Subarray

## 📌 Problem Statement

Given an array `arr`, find the length of the longest **turbulent subarray**, where the comparison sign between adjacent elements **alternates**.

A subarray is turbulent if for every `k` in `[i, j-1]`, either:
- `arr[k] > arr[k+1]` when `k` is even, and `arr[k] < arr[k+1]` when `k` is odd  
**OR**
- `arr[k] < arr[k+1]` when `k` is even, and `arr[k] > arr[k+1]` when `k` is odd

---

## 🔧 Detailed Breakdown

| Component        | Purpose                                                                 |
|------------------|-------------------------------------------------------------------------|
| `up`, `down`     | Track length of current turbulent streak ending in up/down comparison   |
| `maxLen`         | Stores the longest turbulent subarray found so far                      |
| `arr[i-1] vs arr[i]` | Used to determine direction of comparison and update streaks       |
| Reset on equal   | If `arr[i] == arr[i-1]`, reset both `up` and `down` to 1                |

---

## 💻 Code Template (C#)

```csharp
public class Solution {
    public int MaxTurbulenceSize(int[] arr) {
        int n = arr.Length;
        if (n < 2) return n;

        int up = 1, down = 1, maxLen = 1;

        for (int i = 1; i < n; i++) {
            if (arr[i] > arr[i - 1]) {
                up = down + 1;
                down = 1;
            } else if (arr[i] < arr[i - 1]) {
                down = up + 1;
                up = 1;
            } else {
                up = down = 1;
            }

            maxLen = Math.Max(maxLen, Math.Max(up, down));
        }

        return maxLen;
    }
}
```

## 🧠 Engineering Takeaways

- This is a **sign-flipping pattern**, where the direction of comparison alternates.
- You don’t need full DP — just **rolling state** of `up` and `down`.
- **Equal elements break** the turbulence, so reset is required.
- The recurrence is **local**, and the global insight is tracked via `maxLen`.

---

## 🔄 Generalizations

| Variant                | Description                                                        |
|------------------------|--------------------------------------------------------------------|
| Zigzag Sequences       | Similar logic in signal processing or game AI movement            |
| Stock Price Volatility | Detect alternating price movements                                |
| Pattern Matching       | Use alternating comparisons for rhythm detection                  |
| Sliding Window Variant | Can be adapted to fixed-length windows with alternating signs     |

---

## 🧭 Task Classification

| Task Type                   | Pattern Used                                 |
|-----------------------------|----------------------------------------------|
| Alternating Comparison      | Track direction and reset on equality        |
| Longest Subarray with Rule  | Rolling counters with condition checks       |
| Local-to-Global Transition  | Update global max from local streaks         |

---

## 📦 Summary & Reusability

- **Core Insight**: Track alternating comparison directions using two counters.
- **When to Use**: Any time you need to detect **oscillating behavior** in a sequence.
- **Reusable Template**: Can be abstracted into `OscillationTracker<T>` with custom comparison logic.
- **Space Optimization**: Constant space — no need for arrays or DP tables.
- **Meta-Level Note**: This pattern is a great example of **stateful iteration**, where local transitions drive global results.



---

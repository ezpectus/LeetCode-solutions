# üìò Problem: 200. Number of Islands

## üß© Problem Description  
Given an `m x n` 2D binary grid representing a map of `'1'`s (land) and `'0'`s (water), return the number of islands.  
An island is formed by connecting adjacent lands **horizontally or vertically**.  
All edges of the grid are surrounded by water.

---

## üí° Core Idea  
This is a **connected component counting** problem on a 2D grid.

Each `'1'` represents land, and adjacent `'1'`s (up/down/left/right) form an island.  
The goal is to count how many **disjoint islands** exist.

Two main approaches apply:
- **DFS traversal**: flood-fill each island and mark visited cells  
- **Union-Find (DSU)**: treat each land cell as a node and union adjacent lands

For training purposes, DFS is preferred here ‚Äî it‚Äôs direct, recursive, and exposes the traversal signal clearly.

---

## ‚öôÔ∏è Algorithm Overview

### DFS Approach  
- Iterate through every cell in the grid  
- When a `'1'` is found:
  - Increment island count  
  - Launch DFS to mark all connected `'1'`s as visited (`'0'`)  
- DFS explores in 4 directions: up, down, left, right

### DSU Alternative  
- Map each `'1'` cell to a unique index  
- Union adjacent land cells  
- Count unique roots at the end

---

## üß† Combined Techniques

| Component           | Technique Used                  |
|--------------------|----------------------------------|
| Grid Traversal      | Nested loops over `m x n`        |
| Connectivity        | DFS or Union-Find                |
| Visited Tracking    | In-place mutation (`'1' ‚Üí '0'`)  |
| Component Counting  | Increment on new DFS launch      |

---

## üß™ Constraints

- `1 <= m, n <= 300`  
- `grid[i][j]` is `'0'` or `'1'`  
- Grid is surrounded by water  
- No diagonal connections  
- Time complexity: `O(m * n)`  
- Space complexity: `O(m * n)` in worst case (DFS stack or DSU parent array)

---

## üß± Code Implementation (DFS)

```csharp
public class Solution {
    public int NumIslands(char[][] grid) {
        int m = grid.Length;
        int n = grid[0].Length;
        int count = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    count++;
                    Dfs(grid, i, j);
                }
            }
        }

        return count;
    }

    void Dfs(char[][] grid, int i, int j) {
        int m = grid.Length;
        int n = grid[0].Length;

        if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == '0') return;

        grid[i][j] = '0'; // mark as visited

        Dfs(grid, i + 1, j);
        Dfs(grid, i - 1, j);
        Dfs(grid, i, j + 1);
        Dfs(grid, i, j - 1);
    }
}
```

## ‚úÖ Summary

This solution treats each `'1'` cell as a potential island root and uses **DFS flood-fill** to mark all connected land.  
Each DFS launch corresponds to a new island and represents a traversal of one connected component.

### Architectural signals:
- Grid traversal via nested loops  
- Recursive DFS for component marking  
- In-place mutation for visited tracking (`'1' ‚Üí '0'`)  
- No extra space for visited array ‚Äî grid is reused  
- DFS stack depth bounded by island size  
- Early termination on water cells or out-of-bounds indices  
- Clear separation between traversal logic and counting logic

### Generalization potential:
- Can be extended to diagonal connections  
- Can be adapted to count island sizes or label regions  
- Can be rewritten using BFS for iterative traversal  
- Can be replaced with Union-Find (DSU) for offline component merging  
- Suitable for terrain segmentation, blob detection, and region labeling  
- Can be memoized or parallelized for large-scale grid processing

This implementation is efficient, readable, and ideal for training recursive traversal and component counting on grid-based data.  
It provides a strong foundation for problems involving **2D connectivity**, **region growth**, and **symbolic segmentation**.

---

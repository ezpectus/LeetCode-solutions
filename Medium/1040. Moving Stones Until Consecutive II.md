# 1040. Moving Stones Until Consecutive II

## Problem

Given an array `stones` — positions of stones on a number line.  
In one move, you can take an **endpoint stone** (min or max) and move it to **any unoccupied position**, **as long as it is no longer an endpoint**.

**Goal**: Make all stones **consecutive** (no gaps).  
Return two values:

- `answer[0]` — **minimum** number of moves  
- `answer[1]` — **maximum** number of moves

---

## Core Insight

- **Maximum**: Count empty positions between endpoints, subtract occupied ones  
- **Minimum**: Find the **densest window of size `n`** — move stones outside it

---

## Architectural Triggers

| Trigger | Implication |
|-------|-------------|
| “Only endpoints can move” | Cannot move a stone if it remains an endpoint |
| “Minimum moves” | Sliding window problem |
| “Maximum moves” | Gap-counting between extremes |

---

## What This Implies

- **Sort** `stones`
- **For maximum**:
  - Consider two scenarios:
    - Remove left endpoint → shrink from right
    - Remove right endpoint → shrink from left
  - Max = `max(right_shrink, left_shrink)`
- **For minimum**:
  - Use **sliding window** over sorted array
  - For each window of size `n`, count stones inside
  - `moves = n - stones_in_window`
  - **Special case**: `n-1` stones in window of length `n-2` → `moves = 2`

---

## Code (C++)

```cpp
class Solution {
public:
    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(stones.begin(), stones.end());
        int n = stones.size();
        int low = n;
        
        // Maximum moves
        int high = max(
            stones[n - 1] - stones[1] - (n - 2),  // remove left endpoint
            stones[n - 2] - stones[0] - (n - 2)   // remove right endpoint
        );

        // Minimum moves: sliding window
        int i = 0;
        for (int j = 0; j < n; ++j) {
            while (stones[j] - stones[i] >= n) ++i;
            int inWindow = j - i + 1;
            
            if (inWindow == n - 1 && stones[j] - stones[i] == n - 2)
                low = min(low, 2);  // one gap in almost full window
            else
                low = min(low, n - inWindow);
        }

        return {low, high};
    }
};
```

## Complexity

| Metric | Value |
|-------|-------|
| **Time** | `O(n log n)` — sorting + `O(n)` sliding window |
| **Space** | `O(1)` — no extra structures |

---

## Pitfalls

| Issue | Fix |
|------|-----|
| **Cannot move endpoint to endpoint** | Must leave **at least one stone** on each side |
| **Special case: `n-1` stones in `n-2` gap** | Minimum = `2`, **not** `1` |
| **Max ≠ `last - first + 1 - n`** | Must **exclude one endpoint move** |

---

## Insight

This is a **dual-strategy problem**:

- **Minimum** → **local density** (sliding window)  
- **Maximum** → **global sparsity** (endpoint exclusion)

> **Classic pattern**: *minimize via density, maximize via gaps*

---

## Fichka Library Entry

> **Array: min/max moves to make consecutive — endpoint constraint**


---

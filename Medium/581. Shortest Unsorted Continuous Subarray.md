# 🧠 Shortest Unsorted Continuous Subarray — Bidirectional Max/Min Sweep (LeetCode 581)

---

## 📜 Origin & Motivation

We are given an integer array `nums`.  
The goal is to find the **shortest continuous subarray** such that sorting it makes the entire array sorted.

This is a classic **boundary detection** problem:  
We must identify the minimal left and right indices that enclose all disorder.

---

## 🧩 Use Cases

- 🧠 Array correction with minimal effort  
- 📊 Detecting unsorted regions in nearly sorted arrays  
- 🧪 Bidirectional sweeps for global min/max tracking  
- 🧱 Preprocessing before sorting or validation

---

## 🧱 Core Architecture

### 🎯 Triggers

| Condition                        | Action in Code           |
|----------------------------------|--------------------------|
| Element violates ascending order | Update right boundary    |
| Element violates descending order| Update left boundary     |
| Element respects order           | Update max/min trackers  |

---

### 🔧 Algorithm Steps

1. Initialize `left = -1`, `right = -1`  
2. Sweep left to right:
   - Track `maxSeen`
   - If `nums[i] < maxSeen`, update `right = i`  
3. Sweep right to left:
   - Track `minSeen`
   - If `nums[i] > minSeen`, update `left = i`  
4. If no disorder found (`right == -1`), return `0`  
5. Else, return `right - left + 1`

---

## 🚀 C# Implementation

```csharp
public class Solution {
    public int FindUnsortedSubarray(int[] nums) {
        int n = nums.Length;
        int left = -1, right = -1;
        int maxSeen = int.MinValue, minSeen = int.MaxValue;

        // Forward pass — detect right boundary
        for (int i = 0; i < n; i++) {
            if (nums[i] < maxSeen) {
                right = i;
            } else {
                maxSeen = nums[i];
            }
        }

        // Backward pass — detect left boundary
        for (int i = n - 1; i >= 0; i--) {
            if (nums[i] > minSeen) {
                left = i;
            } else {
                minSeen = nums[i];
            }
        }

        return (right == -1) ? 0 : right - left + 1;
    }
}
```


## ⏱️ Complexity Analysis  
Forward pass: O(n) — scan from left to right  
Backward pass: O(n) — scan from right to left  
**Total time complexity**: O(n) — linear  
**Space complexity**: O(1) — constant auxiliary variables

## ⚠️ Pitfalls  
🔁 Sorting the array is unnecessary — boundary detection is faster  
🧠 Must track global `maxSeen` and `minSeen` — not local comparisons  
⚠️ Edge case: fully sorted array returns `0`  
🧩 Do not rely on adjacent comparisons — disorder may span multiple indices

## ✅ Conclusion  
This is a boundary detection problem using bidirectional sweeps:

🔁 Track max/min to detect disorder  
📊 Identify left/right boundaries of unsorted region  
🧠 Avoid sorting — use linear scan  
🏆 Elegant and optimal for large arrays

👉 **Key takeaway**: When detecting minimal unsorted regions, use max/min sweeps — fast, clean, and robust.


---

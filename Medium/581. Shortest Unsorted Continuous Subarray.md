# ğŸ§  Shortest Unsorted Continuous Subarray â€” Bidirectional Max/Min Sweep (LeetCode 581)

---

## ğŸ“œ Origin & Motivation

We are given an integer array `nums`.  
The goal is to find the **shortest continuous subarray** such that sorting it makes the entire array sorted.

This is a classic **boundary detection** problem:  
We must identify the minimal left and right indices that enclose all disorder.

---

## ğŸ§© Use Cases

- ğŸ§  Array correction with minimal effort  
- ğŸ“Š Detecting unsorted regions in nearly sorted arrays  
- ğŸ§ª Bidirectional sweeps for global min/max tracking  
- ğŸ§± Preprocessing before sorting or validation

---

## ğŸ§± Core Architecture

### ğŸ¯ Triggers

| Condition                        | Action in Code           |
|----------------------------------|--------------------------|
| Element violates ascending order | Update right boundary    |
| Element violates descending order| Update left boundary     |
| Element respects order           | Update max/min trackers  |

---

### ğŸ”§ Algorithm Steps

1. Initialize `left = -1`, `right = -1`  
2. Sweep left to right:
   - Track `maxSeen`
   - If `nums[i] < maxSeen`, update `right = i`  
3. Sweep right to left:
   - Track `minSeen`
   - If `nums[i] > minSeen`, update `left = i`  
4. If no disorder found (`right == -1`), return `0`  
5. Else, return `right - left + 1`

---

## ğŸš€ C# Implementation

```csharp
public class Solution {
    public int FindUnsortedSubarray(int[] nums) {
        int n = nums.Length;
        int left = -1, right = -1;
        int maxSeen = int.MinValue, minSeen = int.MaxValue;

        // Forward pass â€” detect right boundary
        for (int i = 0; i < n; i++) {
            if (nums[i] < maxSeen) {
                right = i;
            } else {
                maxSeen = nums[i];
            }
        }

        // Backward pass â€” detect left boundary
        for (int i = n - 1; i >= 0; i--) {
            if (nums[i] > minSeen) {
                left = i;
            } else {
                minSeen = nums[i];
            }
        }

        return (right == -1) ? 0 : right - left + 1;
    }
}
```


## â±ï¸ Complexity Analysis  
Forward pass: O(n) â€” scan from left to right  
Backward pass: O(n) â€” scan from right to left  
**Total time complexity**: O(n) â€” linear  
**Space complexity**: O(1) â€” constant auxiliary variables

## âš ï¸ Pitfalls  
ğŸ” Sorting the array is unnecessary â€” boundary detection is faster  
ğŸ§  Must track global `maxSeen` and `minSeen` â€” not local comparisons  
âš ï¸ Edge case: fully sorted array returns `0`  
ğŸ§© Do not rely on adjacent comparisons â€” disorder may span multiple indices

## âœ… Conclusion  
This is a boundary detection problem using bidirectional sweeps:

ğŸ” Track max/min to detect disorder  
ğŸ“Š Identify left/right boundaries of unsorted region  
ğŸ§  Avoid sorting â€” use linear scan  
ğŸ† Elegant and optimal for large arrays

ğŸ‘‰ **Key takeaway**: When detecting minimal unsorted regions, use max/min sweeps â€” fast, clean, and robust.


---

# 835. Image Overlap — Architectural Relative Offset Counting  
*O(n⁴) — Optimal Brute-Force with Smart Coordinate Mapping*

---

## Problem Statement

Given two `n×n` binary matrices `img1` and `img2` (`n ≤ 30`).

Translate `img1` by any vector `(dx, dy)` (slide without rotation).

Count overlapping `1`s after translation.

Return **maximum possible overlap**.

**Note**: `1`s sliding outside grid → erased.

---

## Core Idea — Count Overlaps by Relative Offsets

**Brute force**: try all possible translations `(dx, dy)` where `dx, dy ∈ [-n+1, n-1]`

For each translation:
- Count positions where both images have `1`

**Optimization**:
- Instead of shifting whole image → **collect all `1` positions** in both images
- For every pair `(p1 from img1, p2 from img2)`:
  - Offset `(dx, dy) = (p1.x - p2.x, p1.y - p2.y)`
  - This offset means: if we translate img1 by `(dx, dy)`, p1 lands on p2
- Count frequency of each offset → max frequency = max overlap

**No actual shifting** — pure coordinate math.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int LargestOverlap(int[][] img1, int[][] img2) {
        int n = img1.Length;
        var ones1 = new List<(int x, int y)>();
        var ones2 = new List<(int x, int y)>();

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (img1[i][j] == 1) ones1.Add((i, j));
                if (img2[i][j] == 1) ones2.Add((i, j));
            }
        }

        // Count frequency of each relative offset
        var count = new Dictionary<(int dx, int dy), int>();
        foreach (var (x1, y1) in ones1) {
            foreach (var (x2, y2) in ones2) {
                int dx = x1 - x2;
                int dy = y1 - y2;
                var key = (dx, dy);
                if (!count.ContainsKey(key)) 
                    count[key] = 0;
                count[key]++;
            }
        }

        // Find max count
        int maxOverlap = 0;
        foreach (var kvp in count)  maxOverlap = Math.Max(maxOverlap, kvp.Value);
        
        return maxOverlap;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n⁴)**     | n≤30 → up to ~810k pairs → fine                |
| **Space Complexity**  | **O(n²)**     | Lists + dictionary (worst ~n² keys)            |

**Optimal** — best possible for n=30.

---

## Why This Works — Example Walkthrough

**Input**:
- `img1` has 1s at `(0,0),(0,1),(1,1),(2,1)`
- `img2` has 1s at `(1,1),(1,2),(2,2)`

- All pairs of 1s → compute **relative offset** `(dx, dy) = (x1-x2, y1-y2)`
- Count frequency of each offset
- Most frequent offset → **3 matches** → max overlap **3**

**Correct** — exactly the maximum possible overlap.

---

## Pitfalls & Edge Cases

- **No 1s** → 0
- **One 1** → max 1
- **All 1s** → n²
- **Offset zero** → included (no translation)
- **Negative offsets** → handled naturally

All handled.

---

## Key Takeaway

This is a **masterpiece of coordinate transformation**:

- **No image shifting** — work with 1 positions
- **Relative offsets** → count overlaps directly
- **Dictionary** → frequency of translations

**Pure math insight** — no brute matrix moves.


---

# Pattern Name  
Segmented DP with Prefix XOR and Min-Max Propagation

---

## Problem Summary

You are given an integer array `nums` and an integer `k`.  
Partition `nums` into `k` non-empty subarrays.  
For each subarray, compute the bitwise XOR of its elements.  
Return the **minimum possible value of the maximum XOR** among all `k` subarrays.

---

## Core Idea

This is a **min-max partitioning** problem under XOR aggregation.  
We aim to split the array into `k` segments such that the **maximum XOR** among them is minimized.  
This requires **dynamic programming** with **prefix XORs** and **state propagation**.

---

## Constraint Formula

Let `dp[i][p]` be the minimum possible value of the maximum XOR  
when partitioning the first `i` elements into `p` subarrays.

Let `pref[i]` be the XOR of the first `i` elements.  
Then for each partition point `j < i`, we compute:

```text
dp[i][p] = min over j of max(dp[j][p-1], pref[i+1] ^ pref[j+1])
```
This captures the worst-case XOR after adding the new segment [j+1..i].

## Strategy Summary

- Build prefix XOR array `pref[i]`  
- Initialize `dp[i][1] = pref[i+1]` for all `i`  
- For each partition count `p = 2..k`:
  - For each endpoint `i = 1..n-1`:
    - Try all previous cuts `j = 0..i-1`
    - Compute XOR of segment `[j+1..i]` using prefix XORs
    - Update `dp[i][p]` with the minimum of maximums
- Return `dp[n-1][k]`

This captures the worst-case XOR after adding the new segment `[j+1..i]`.  
It ensures optimal segmentation by propagating minimal worst-case XORs.

---

## C# Implementation

```csharp
public class Solution {
    public int MinXor(int[] nums, int k) {
        int n = nums.Length;
        int[][] dp = new int[n + 1][];
        int[] pref = new int[n + 1];

        for (int i = 0; i <= n; i++)
            dp[i] = Enumerable.Repeat(int.MaxValue, k + 1).ToArray();

        for (int i = 1; i <= n; i++) {
            pref[i] = pref[i - 1] ^ nums[i - 1];
            dp[i - 1][1] = pref[i];
        }

        for (int p = 2; p <= k; p++) {
            for (int i = 1; i < n; i++) {
                int temp = int.MaxValue;
                for (int j = 0; j < i; j++) {
                    int subxor = Math.Max(dp[j][p - 1], pref[i + 1] ^ pref[j + 1]);
                    temp = Math.Min(temp, subxor);
                }
                dp[i][p] = temp;
            }
        }

        return dp[n - 1][k];
    }
}
```

## Time and Space Complexity

| Metric           | Value      | Explanation                                      |
|------------------|------------|--------------------------------------------------|
| Time Complexity  | O(k × n²)  | For each partition count, scan all cut points   |
| Space Complexity | O(k × n)   | DP table of size `(n+1) × (k+1)` + prefix array |

---

## Generalization to Other Problems

This pattern applies to problems where:

- You need to **partition arrays** under aggregation constraints  
- You want to **minimize the worst-case** outcome across segments  
- You can use **prefix structures** to compute segment values efficiently  
- The cost function is **non-additive** (e.g., XOR, max, min)

---

## Examples of Similar Problems

| Problem Type                | Description                                         |
|----------------------------|-----------------------------------------------------|
| Minimize Largest Sum       | Partition array to minimize largest segment sum     |
| XOR Partition Optimization | Split array to minimize max XOR across segments     |
| DP with Prefix Aggregation | Use prefix sums/XORs to compute segment costs       |

---

## Final Takeaway

This solution uses:

- **Prefix XORs** to compute segment values in constant time  
- **Dynamic programming** to propagate optimal partitions  
- **Min-max logic** to track worst-case outcomes  
- **Nested iteration** to explore all valid cuts

The result is a clean and efficient solution that balances segmentation and aggregation.  
This pattern is reusable for any task involving **partitioning with non-additive segment costs**.

---

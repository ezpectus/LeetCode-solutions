# ðŸŒ² 117. Populating Next Right Pointers in Each Node II

## ðŸ“Œ Problem Statement

> Given a binary tree where each node has `val`, `left`, `right`, and `next` fields,  
> populate each `next` pointer to point to its next right node.  
> If there is no next right node, the `next` pointer should be set to `null`.

- All `next` pointers are initially set to `null`.
- The tree may be **imperfect**: missing children, uneven depth, sparse structure.
- Goal: connect all nodes horizontally at each level.

### ðŸ”— Example

**Input**:  
`root = [1,2,3,4,5,null,7]`

**Output**:  
`[1,#,2,3,#,4,5,7,#]`  
`#` indicates the end of each level.

---

## ðŸ’¡ Idea

Unlike Problem 116 (perfect binary tree), this tree may have arbitrary structure.  
We cannot rely on `root.left.next = root.right` â€” children may be missing.

Solution: **Breadth-First Search (BFS)** using a queue.

- Track `prev` node at each level to connect `prev.next = curr`
- Enqueue `left` and `right` children if they exist
- Repeat for all levels

---

## ðŸ§  Signal Summary

| Concept             | Signal Expression                   | Role                                 |
|---------------------|--------------------------------------|--------------------------------------|
| Horizontal Linking  | `prev.next = curr`                   | Connect nodes within the same level  |
| Level Isolation     | `int size = queue.Count`             | Process level boundaries             |
| Child Enqueueing    | `queue.Enqueue(node.left/right)`     | Prepare next level traversal         |

---

## ðŸ§ª Code

```csharp
public class Solution {
    public Node Connect(Node root) {
        if (root == null) return null;

        var queue = new Queue<Node>();
        queue.Enqueue(root);

        while (queue.Count > 0) {
            int size = queue.Count;
            Node prev = null;

            for (int i = 0; i < size; i++) {
                var node = queue.Dequeue();
                if (prev != null) prev.next = node;
                prev = node;

                if (node.left != null) queue.Enqueue(node.left);
                if (node.right != null) queue.Enqueue(node.right);
            }
        }

        return root;
    }
}
```

## âœ… Takeaways

- Works for any binary tree, regardless of structure
- Requires a queue â†’ does not meet the "constant extra space" constraint
- Ideal for sparse or uneven trees

## ðŸ§  Follow-up: Constant Space Variant
To meet the constant space constraint, use existing next pointers to traverse levels:
```csharp
public Node Connect(Node root) {
    if (root == null) return null;

    Node curr = root;
    while (curr != null) {
        Node dummy = new Node(0);
        Node tail = dummy;

        while (curr != null) {
            if (curr.left != null) {
                tail.next = curr.left;
                tail = tail.next;
            }
            if (curr.right != null) {
                tail.next = curr.right;
                tail = tail.next;
            }
            curr = curr.next;
        }

        curr = dummy.next;
    }

    return root;
}
```

- Uses existing next pointers to traverse level by level
- No extra memory beyond implicit recursion stack


---


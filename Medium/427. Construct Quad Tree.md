# LeetCode 427 — Construct Quad Tree  
**Approach: Recursive Divide and Conquer**

---

##  Problem Restatement
Given an `n x n` grid of 0s and 1s, construct a Quad‑Tree representation.  
Each node is either:
- **Leaf:** all values in the subgrid are the same.  
- **Internal:** values differ, so we split into 4 quadrants.

---

##  Core Idea
- Recursively check if all values in the current subgrid are equal.  
- If yes → return a leaf node.  
- If not → split into 4 quadrants and recurse.  
- Base case: subgrid size = 1 → leaf node.

---

## Implementation (C#)
```cpp
public class Solution {
    public Node Construct(int[][] grid) {
        return Build(grid, 0, 0, grid.Length);
    }

    private Node Build(int[][] grid, int row, int col, int size) {
        // Check if all values in current subgrid are the same
        bool same = true;
        int first = grid[row][col];
        for (int i = row; i < row + size; i++) {
            for (int j = col; j < col + size; j++) {
                if (grid[i][j] != first) {
                    same = false;
                    break;
                }
            }
            if (!same) break;
        }

            // Leaf node 
        if (same) return new Node(first == 1, true);
           
        
        int half = size / 2;
        var topLeft = Build(grid, row, col, half);
        var topRight = Build(grid, row, col + half, half);
        var bottomLeft = Build(grid, row + half, col, half);
        var bottomRight = Build(grid, row + half, col + half, half);

        return new Node(true, false, topLeft, topRight, bottomLeft, bottomRight);
    }
}
```

---

##  Complexity Analysis
- **Time Complexity:**  
  - Worst case: every cell checked multiple times → `O(n^2 log n)`.  
  - Best case: uniform grid → `O(n^2)`.  
- **Space Complexity:**  
  - Recursion depth = `log n`.  
  - Quad‑Tree nodes = `O(n^2)` in worst case.

---

#  Impact of Design Choices

| Design Choice                  | Effect                                                                 |
|--------------------------------|------------------------------------------------------------------------|
| **Recursive divide & conquer** | Natural fit for Quad‑Tree construction.                                |
| **Uniform check per subgrid**  | Ensures correct leaf detection.                                        |
| **Splitting into 4 quadrants** | Matches Quad‑Tree definition exactly.                                  |

---

#  Pitfalls
- Forgetting base case (size = 1) → infinite recursion.  
- Not checking uniformity correctly → wrong leaf detection.  
- Assigning `val` incorrectly for internal nodes → but problem allows any value, so safe.  

---

#  Conclusion
- **What it gives:** Correct Quad‑Tree representation of binary grid.  
- **Why it matters:** Efficiently models 2D space for compression or spatial queries.  
- **Key takeaway:**  
  1. Check uniformity.  
  2. If uniform → leaf.  
  3. Else → split into 4 quadrants and recurse.
 
     ---

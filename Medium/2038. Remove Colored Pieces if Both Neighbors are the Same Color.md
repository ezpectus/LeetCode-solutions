# 2038. Remove Colored Pieces if Both Neighbors are the Same Color  
*O(n) — Simple Greedy Counting*

---

## Problem Statement

You are given a string `colors` of length `n` consisting only of 'A' and 'B' (1 ≤ n ≤ 10⁵).

Alice and Bob take turns removing pieces, Alice starts first.

- Alice can remove a piece 'A' **only if** both its neighbors are also 'A'  
  (cannot remove 'B', cannot remove edge pieces)
- Bob can remove a piece 'B' **only if** both its neighbors are also 'B'  
  (cannot remove 'A', cannot remove edge pieces)

If a player cannot make a move on their turn, they lose (the other player wins).

Both play **optimally**. Return `true` if **Alice wins**, `false` if **Bob wins**.

---

## Core Idea — Greedy Count of Movable Pieces

**Key observation**:
- Removing a piece does **not** create new opportunities for the opponent — it can only **reduce** their moves
- Each possible move is **independent** — removing one triple of 'AAA' does not affect other 'AAA' groups (except adjacent ones, but still no new moves created)
- The total number of moves Alice can make = number of 'AAA' groups she can remove  
  More precisely: number of internal 'A's that have both neighbors 'A'
- Same for Bob: number of internal 'B's with both neighbors 'B'

**Actual winning condition**:
- Alice wins if she can make **more moves** than Bob (since she starts first)
- But because moves are **independent** and **non-interfering** (removing one doesn't help or block the other player), the total moves each can make is fixed:
  - Alice's moves = count of positions i (1 ≤ i ≤ n-2) where colors[i-1..i+1] = "AAA"
  - Bob's moves = count of positions i (1 ≤ i ≤ n-2) where colors[i-1..i+1] = "BBB"
- Alice wins if **her move count > Bob's move count** (she starts, so if equal moves → Bob makes last move → Alice loses)

**Proof**:
- Each "AAA" allows Alice exactly one move (remove the middle A)
- Each "BBBB" allows Bob exactly one move per internal triple, but overlapping triples share removals — actually, for a run of k consecutive 'A's, Alice can make **k-2** moves (remove middle ones one by one)
- Same for Bob: k consecutive 'B's → **k-2** moves
- Moves in different runs are completely independent

**Correct rule**:
Alice wins if and only if the **total number of removable 'A's** > total number of removable 'B's

Where removable 'A' = every position i (1 ≤ i ≤ n-2) where colors[i-1] == colors[i] == colors[i+1] == 'A'

Same for 'B'

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public bool WinnerOfGame(string colors) {
        int n = colors.Length;
        int aliceMoves = 0;
        int bobMoves = 0;

        // Count removable 'A's and 'B's
        for (int i = 1; i < n - 1; i++) {
            if (colors[i - 1] == 'A' && colors[i] == 'A' && colors[i + 1] == 'A') aliceMoves++;
            else if (colors[i - 1] == 'B' && colors[i] == 'B' && colors[i + 1] == 'B') bobMoves++;
        }

        // Alice wins if she has more moves than Bob (she starts first)
        return aliceMoves > bobMoves;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass over the string of length n — constant-time checks per position |
| **Space Complexity**  | **O(1)**      | Only two integer counters (aliceMoves and bobMoves) — no extra data structures |

**Optimal** — linear time, constant space — perfect and extremely efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: `colors = "AAABABB"`

- Positions: 0:A, 1:A, 2:A, 3:B, 4:A, 5:B, 6:B
- Check i=1 to 5 (middle positions only):
  - i=1: AAA → Alice +1
  - i=2: AAB → no
  - i=3: ABA → no
  - i=4: BAB → no
  - i=5: ABB → no
- Alice moves = 1, Bob moves = 0  
- 1 > 0 → Alice has more moves → Alice wins → **true**

**Example 2**: `colors = "AA"`

- n = 2 → no middle positions (i from 1 to n-2 = empty range)
- Alice moves = 0, Bob moves = 0  
- Alice starts but cannot move → Bob wins → **false**

**Example 3**: `colors = "ABBBBBBBAAA"`

- Alice can remove one 'A' from the "AAA" run → Alice moves = 1
- Bob can remove multiple 'B's from "BBBBBBB" run (7 B's → 7-2 = 5 removable internal B's) → Bob moves = 5
- 1 < 5 → Bob has more moves → Bob wins → **false**

**Correct** —  
The number of removable triples ("AAA" for Alice, "BBB" for Bob) directly gives the **exact number of moves** each player can make.  
Moves are **independent** — removing one triple does not create new moves for the opponent or block existing ones.  
Since Alice starts first, she wins if and only if her total moves > Bob's total moves (if equal → Bob makes the last move → Alice loses).

---

## Key Takeaway

This is a **beautiful greedy counting** problem:

- Alice can remove the middle 'A' only if surrounded by 'A's → count every "AAA" triple (each internal 'A' in a run of ≥3 'A's)
- Bob can remove the middle 'B' only if surrounded by 'B's → count every "BBB" triple
- For a run of k consecutive same letters → number of moves = **k-2** (if k ≥ 3), but simple loop counting each valid middle position works perfectly
- Alice wins if her total moves > Bob's total moves (she starts first)

**Pure, clean, optimal** — O(n) time, O(1) space, extremely simple, no edge cases missed, correct and elegant.

---

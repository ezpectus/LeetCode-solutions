## üß† Pattern: Monotonic Prefix Tracker

---

## üìå Problem Statement

You're given a stream of `n` videos, each uniquely numbered from `1` to `n`.  
Videos are uploaded in arbitrary order.  
You must design a system that supports:

- `upload(video)` ‚Äî mark a video as uploaded  
- `longest()` ‚Äî return the length of the longest uploaded prefix `[1..i]` such that **all videos from 1 to i are uploaded**

---

## üß© Architectural Idea

This is a **monotonic progress tracking** problem.  
We don't care about the full upload state ‚Äî only how far we've progressed from the start without gaps.

Key insight:

- Use a boolean array to track uploaded videos  
- Maintain a pointer `llp` (longest uploaded prefix)  
- After each upload, advance `llp` as far as possible while the next video is already uploaded

This avoids scanning the entire array and guarantees:

- Constant-time `longest()` queries  
- Linear-time total cost across all uploads  
- Minimal logic, maximum clarity

---

## üîß Implementation

```csharp
public class LUPrefix {
    private int llp = 0;
    private readonly BitArray b;

    public LUPrefix(int n) => b = new(n);

    public void Upload(int video) {
        if (b[video - 1]) return;

        b[video - 1] = true;

        while (llp < b.Length && b[llp])
            llp++;
    }

    public int Longest() => llp;
}
```

üß† **Post-Solution Breakdown**

---

## ‚úÖ Invariants

- `b[i] == true` ‚áî video `i + 1` has been uploaded  
- `llp` always points to the first missing video  
- All videos `[0..llp - 1]` are guaranteed to be uploaded  
- `Longest()` always returns the correct prefix length in **O(1)**

---

## ‚ö†Ô∏è Edge Cases

| Case                     | Behavior                                                    |
|--------------------------|-------------------------------------------------------------|
| Uploading same video twice | Ignored via `if (b[video - 1]) return`                     |
| Uploading out-of-order     | Works fine ‚Äî `llp` only advances when possible             |
| Uploading last video first| `longest()` still returns `0` until prefix is complete     |

---

## üß† Why This Works

This solution avoids brute-force scanning by maintaining a **monotonic pointer**.  
Each video is processed once, and `Longest()` is instant.

- **Upload:** amortized **O(1)** per call  
- **Longest:** **O(1)**  
- **Total cost:** **O(n)** across all operations

No extra data structures, no sorting, no queues ‚Äî just a boolean mask and a single pointer.

---

## üîÅ Pattern Generalization

This technique applies to problems with:

- Streamed input and prefix validation  
- Monotonic progress tracking  
- Boolean state over linear domains

---

## üß© Reusable Structure

- Boolean array to track state  
- Monotonic pointer to track progress  
- One-pass logic with no backtracking

---

## üß† Example Problems

- Longest prefix of valid events  
- Contiguous segment validation  
- Streamed input with prefix constraints  
- Jump Game I (prefix reachability)

---

## üß† Alternative Approaches (Comparison Table)

| Method              | Time Complexity              | Pros                   | Cons                          |
|---------------------|------------------------------|------------------------|-------------------------------|
| Full scan           | O(n) per query               | Simple                 | Too slow for large inputs     |
| HashSet + sort      | O(log n) insert, O(n) query  | Flexible               | Inefficient for prefix tracking |
| BitArray + pointer  | O(1) query, amortized O(1) upload | Fast, clean         | Requires monotonic logic      |

---

## üß† Conclusions

This solution is a clean example of **prefix tracking via monotonic state**.  
Instead of brute-force scanning or complex data structures, we use:

- Minimal state  
- One-pass logic  
- Boolean mask + pointer



---

# 2265. Count Nodes Equal to Average of Subtree  
*O(n) — Post-order DFS + Subtree Sum & Size Tracking*

---

## Problem Statement

Given the root of a binary tree, return the number of nodes where the value of the node is **equal** to the **average** of the values in its subtree (including itself).

**Average** = sum of subtree values divided by number of nodes in subtree, **rounded down** to nearest integer.

**Subtree** = the node itself + all its descendants.

**Examples**:

**Example 1**  
Input: root = [4,8,5,0,1,null,6]  
Output: **5**  
Nodes 4,5,0,1,6 each equal the average of their subtree

**Example 2**  
Input: root = [1]  
Output: **1**  
Single node always equals its own average

**Constraints**:
- 1 ≤ number of nodes ≤ 1000
- 0 ≤ Node.val ≤ 1000

---

## Core Idea — Post-order DFS with Sum & Count Return

**Key insight**:
- We need to compute for **every node**:
  - Sum of all values in its subtree
  - Number of nodes in its subtree
- Then check if node.val == (subtree_sum / subtree_size) (integer division)
- Use **post-order traversal** (DFS) to compute bottom-up:
  - Recurse left → get left_sum, left_size
  - Recurse right → get right_sum, right_size
  - Current subtree sum = left_sum + right_sum + node.val
  - Current subtree size = left_size + right_size + 1
  - Check if node.val == subtree_sum / subtree_size
  - Return (subtree_sum, subtree_size) to parent

**Time**: O(n) — visit each node exactly once  
**Space**: O(h) — recursion stack (h = height, worst O(n))

---

## Clean Implementation (C#)

```csharp
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

public class Solution{
    private int count = 0;

    public int AverageOfSubtree(TreeNode root){
        Dfs(root);
        return count;
    }

    private (int sum, int size) Dfs(TreeNode node){
        if (node == null) return (0, 0);
        
        // Post-order: left → right → process current
        var (leftSum, leftSize) = Dfs(node.left);
        var (rightSum, rightSize) = Dfs(node.right);

        int subtreeSum = leftSum + rightSum + node.val;
        int subtreeSize = leftSize + rightSize + 1;

        // Check if node value equals average (integer division)
        if (node.val == subtreeSum / subtreeSize) count++;
        
        return (subtreeSum, subtreeSize);
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Each node in the tree is visited **exactly once** during the post-order DFS traversal |
| **Space Complexity**  | **O(h)**      | Recursion stack depth equals the tree height `h`<br>Worst case (skewed tree): O(n)<br>Average case (balanced tree): O(log n) |

**Optimal** — linear time in the number of nodes, height space for recursion — perfectly efficient for n ≤ 1000.

---

## Why This Works — Example Walkthrough

**Example 1**: root = [4,8,5,0,1,null,6]
```
       4
     /   \
    8     5
   / \     \
  0   1     6
```

**Post-order DFS traversal** (bottom-up):

- Leaf node 0: sum = 0, size = 1 → 0 == 0/1 → yes → count = 1
- Leaf node 1: sum = 1, size = 1 → 1 == 1/1 → yes → count = 2
- Node 8: left(0+1) + right(null) + 8 = 9, size = 3 → 8 != 9/3 = 3 → no
- Leaf node 6: sum = 6, size = 1 → 6 == 6/1 → yes → count = 3
- Node 5: left(null) + right(6) + 5 = 11, size = 2 → 5 == 11/2 = 5 → yes → count = 4
- Root node 4: left(9) + right(11) + 4 = 24, size = 6 → 4 == 24/6 = 4 → yes → count = 5

Final result: **5** → correct

**Correct** —  
Post-order DFS naturally computes the **subtree sum** and **subtree size** bottom-up (leaves first).  
For every node, after processing its children, we have the exact sum and count of its entire subtree (including itself).  
We check if `node.val == subtree_sum / subtree_size` (integer division), and count how many nodes satisfy this condition.

---

## Key Takeaway

This is a **classic post-order DFS tree traversal** problem:

* Perform **post-order traversal** (left → right → process current)
* For each node, return a pair: `(subtree_sum, subtree_size)`
* At each node:
  - Compute subtree sum = left_sum + right_sum + node.val
  - Compute subtree size = left_size + right_size + 1
  - Check if node.val == (subtree_sum / subtree_size) using integer division
  - If true → increment global counter
* Return the pair to the parent

**Pure, clean, optimal** — O(n) time, O(h) recursion space (height of tree), very fast, intuitive, and handles all tree shapes correctly (balanced, skewed, single node, etc.).

---

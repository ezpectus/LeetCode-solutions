# 840. Magic Squares In Grid — Architectural Brute-Force Subgrid Validation  
*O((r-2)(c-2)) — Optimal Exhaustive Check*

---

## Problem Statement

Given an `r × c` grid (r,c ≤ 10) with values 0–15.

Count how many **3×3 subgrids** are **magic squares**:
- Contain **distinct** numbers **1 to 9**
- All rows, columns, both diagonals have **same sum**

Return the count.

---

## Core Idea — Check All Possible 3×3 Subgrids

Since grid small (≤10×10) → at most 8×8 = 64 subgrids.

**Brute force**:
- For each possible top-left `(i,j)` where `i ≤ r-3`, `j ≤ c-3`
- Extract 3×3 subgrid
- Validate:
  1. Contains exactly `{1,2,3,4,5,6,7,8,9}` (distinct, no 0 or >9)
  2. All rows, columns, diagonals sum to **same value** (magic constant = 15)

**No optimization needed** — tiny input.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int NumMagicSquaresInside(int[][] grid) {
        int r = grid.Length;
        int c = grid[0].Length;
        int count = 0;

        // Try every possible 3x3 subgrid
        for (int i = 0; i <= r - 3; i++) {
            for (int j = 0; j <= c - 3; j++) {
                if (IsMagic(grid, i, j))   count++;
            }
        }

        return count;
    }

private bool IsMagic(int[][] grid, int x, int y) {
        // Check distinct 1-9
        bool[] seen = new bool[10]; // index 1-9
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                int val = grid[x + i][y + j];
                if (val < 1 || val > 9 || seen[val])  return false;
                seen[val] = true;
            }
        }

        // Magic sum = 15
        int magic = grid[x][y] + grid[x][y+1] + grid[x][y+2];

        // Check rows
        for (int i = 0; i < 3; i++) {
            if (grid[x+i][y] + grid[x+i][y+1] + grid[x+i][y+2] != magic) return false;
        }

        // Check columns
        for (int j = 0; j < 3; j++) {
            if (grid[x][y+j] + grid[x+1][y+j] + grid[x+2][y+j] != magic) return false;
        }

        // Check diagonals
        if (grid[x][y] + grid[x+1][y+1] + grid[x+2][y+2] != magic) return false;
        if (grid[x][y+2] + grid[x+1][y+1] + grid[x+2][y] != magic) return false;

        return true;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O((r-2)(c-2))**     | At most 8×8 subgrids × O(1) check per subgrid  |
| **Space Complexity**  | **O(1)**              | Only fixed-size arrays                         |

**Optimal** — best possible.

---

## Why This Works — Example Walkthrough

**Input**: `[[4,3,8,4],[9,5,1,9],[2,7,6,2]]`

- Only one 3×3 subgrid at (0,0):
```
4 3 8
9 5 1
2 7 6
```

- Numbers: 1-9 **distinct** → yes
- Row sums: 15,15,15
- Column sums: 15,15,15
- Diagonals: 15,15 → **magic** → count=1

**Correct** — exactly matches expected.

---

## Pitfalls & Edge Cases

- **Numbers >9 or 0** → invalid
- **Duplicates** → invalid
- **Wrong sum** → invalid
- **Small grid** (<3×3) → 0
- **Multiple overlapping** → all checked independently

All handled.

---

## Key Takeaway

This is a **beautifully straightforward** validation problem:

- **Brute all 3×3 subgrids**
- **Check distinct 1-9**
- **Verify all sums = 15**

**No tricks. No optimization needed.**
**Pure, clean, optimal** — one of the nicest Medium grid problems.

---

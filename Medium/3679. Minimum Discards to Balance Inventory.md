# ðŸ“¦ LeetCode 3679 â€” Minimum Discards to Balance Inventory

## ðŸ“œ Problem Summary

You are given:

- `arrivals[i]`: item type arriving on day `i` (1-indexed)
- `w`: window size â€” number of recent days to consider
- `m`: max allowed frequency of any item type in any `w`-day window

Each item can be **kept or discarded**, but only on the day it arrives.  
Your goal is to ensure that **in every sliding window of size `w`**, no item type appears more than `m` times among kept items.

Return the **minimum number of arrivals to discard** to satisfy this constraint.

---

## ðŸ§  Core Insight

This is a **sliding window with bounded frequency** problem.

We simulate the process day by day:

- Maintain a **window of size `w`** using a queue  
- Track **frequency of each item type** in the current window using a dictionary  
- For each arrival:
  - If keeping it would cause its frequency in the window to exceed `m`, discard it  
  - Otherwise, keep it and update the frequency map  
- As the window slides forward, remove the oldest item and update its frequency

> This is a classic **stateful stream processing** pattern with dynamic constraints.

---

## ðŸ§ª Example Walkthrough

**Input:** `arrivals = [1,2,3,3,3,4]`, `w = 3`, `m = 2`  
**Output:** `1`

| Day | Arrival | Window         | Frequencies     | Action     | Reason                        |
|-----|---------|----------------|------------------|------------|-------------------------------|
| 1   | 1       | [1]            | {1:1}            | Keep       | freq(1) = 1 â‰¤ m               |
| 2   | 2       | [1,2]          | {1:1, 2:1}       | Keep       | freq(2) = 1 â‰¤ m               |
| 3   | 3       | [1,2,3]        | {1:1, 2:1, 3:1}  | Keep       | freq(3) = 1 â‰¤ m               |
| 4   | 3       | [2,3,3]        | {2:1, 3:2}       | Keep       | freq(3) = 2 â‰¤ m               |
| 5   | 3       | [3,3,3]        | {3:3}            | Discard    | freq(3) = 2 â†’ would become 3  |
| 6   | 4       | [3,3,4]        | {3:2, 4:1}       | Keep       | freq(4) = 1 â‰¤ m               |

**Total discards:** `1`

---

## ðŸš€ C# Implementation

```csharp
public class Solution {
    public int MinArrivalsToDiscard(int[] arrivals, int w, int m) {
        int discards = 0;
        var freq = new Dictionary<int, int>();
        var window = new Queue<(int item, int day)>();

        for (int i = 0; i < arrivals.Length; i++) {
            int item = arrivals[i];
            int day = i + 1;

            // Remove outdated items from window
            while (window.Count > 0 && window.Peek().day < day - w + 1) {
                var (oldItem, _) = window.Dequeue();
                freq[oldItem]--;
                if (freq[oldItem] == 0)
                    freq.Remove(oldItem);
            }

            // Check if keeping violates frequency constraint
            if (freq.TryGetValue(item, out int count) && count == m) {
                discards++; // discard this item
                continue;
            }

            // Keep item
            window.Enqueue((item, day));
            if (!freq.ContainsKey(item))
                freq[item] = 0;
            freq[item]++;
        }

        return discards;
    }
}

```

## âœ… Complexity Analysis

| Metric       | Value         | Explanation                                      |
|--------------|---------------|--------------------------------------------------|
| Time         | O(n)          | Each arrival is processed exactly once          |
| Space        | O(w + u)      | `w` is the window size, `u` is number of unique item types |
| Stability    | High          | No recursion, no branching â€” pure simulation    |
| Scalability  | Excellent     | Efficiently handles up to 10âµ arrivals          |

This algorithm is **stream-safe** and **state-local** â€” it doesn't require full history, only a sliding window and frequency map.

---

## ðŸ§  Engineering Takeaway

This problem teaches how to:

- ðŸ” Simulate **bounded frequency logic** in a sliding window  
- ðŸ”„ Track **state transitions** using queues and dictionaries  
- ðŸ§® Enforce **dynamic constraints** without brute-force scanning  
- ðŸ§± Build a **stream processor** that respects local rules and evolving state

> When constraints apply to recent history, the combination of **sliding window + frequency map** is your go-to pattern.

This is a classic example of **inventory balancing with discard logic**, where each decision is local but affects future state.

---

## ðŸ§± Architectural Pattern

### ðŸ”§ State Variables

- `window`: queue of kept items (bounded size `w`)  
- `freq`: dictionary of item frequencies in current window  
- `discards`: counter for discarded arrivals

### ðŸ” Loop Invariant

- Window size â‰¤ `w`  
- For every item type `t`, `freq[t] â‰¤ m`

### âš™ï¸ Decision Point

- If `freq[item] == m` â†’ discard arrival  
- Else â†’ keep and update state

### ðŸ§© Generalization

This pattern applies to:

- ðŸ§¼ Inventory balancing systems with local quotas  
- ðŸŽ® Rate-limited event tracking in real-time systems  
- ðŸ“ˆ Frequency-constrained stream analytics  
- ðŸ§  Real-time discard decisions in bounded contexts

> The architecture is clean: **one queue**, **one map**, **one rule** â€” and full control over state.

---

## ðŸ§  Bonus Thought

### Edge Case Collapse

- If `w == 1`, the problem reduces to:  
  > â€œNo item may appear more than `m` times on the same dayâ€ â€” trivial case

- If `m â‰¥ w`, then **no discards are ever needed** â€” every item is allowed regardless of frequency

> Always check edge cases â€” they often collapse the problem into simpler forms and reveal hidden invariants.

---

## ðŸ§  Meta-Reflection

This task is not just about counting discards â€” it's about **modeling evolving constraints** over a stream.  
It forces you to think in terms of **local state**, **temporal windows**, and **frequency enforcement**, which are foundational in systems design, rate-limiting, and real-time analytics.

> Youâ€™re not solving a problem â€” youâ€™re simulating a system.


---

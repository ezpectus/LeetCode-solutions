# 📦 LeetCode 3679 — Minimum Discards to Balance Inventory

## 📜 Problem Summary

You are given:

- `arrivals[i]`: item type arriving on day `i` (1-indexed)
- `w`: window size — number of recent days to consider
- `m`: max allowed frequency of any item type in any `w`-day window

Each item can be **kept or discarded**, but only on the day it arrives.  
Your goal is to ensure that **in every sliding window of size `w`**, no item type appears more than `m` times among kept items.

Return the **minimum number of arrivals to discard** to satisfy this constraint.

---

## 🧠 Core Insight

This is a **sliding window with bounded frequency** problem.

We simulate the process day by day:

- Maintain a **window of size `w`** using a queue  
- Track **frequency of each item type** in the current window using a dictionary  
- For each arrival:
  - If keeping it would cause its frequency in the window to exceed `m`, discard it  
  - Otherwise, keep it and update the frequency map  
- As the window slides forward, remove the oldest item and update its frequency

> This is a classic **stateful stream processing** pattern with dynamic constraints.

---

## 🧪 Example Walkthrough

**Input:** `arrivals = [1,2,3,3,3,4]`, `w = 3`, `m = 2`  
**Output:** `1`

| Day | Arrival | Window         | Frequencies     | Action     | Reason                        |
|-----|---------|----------------|------------------|------------|-------------------------------|
| 1   | 1       | [1]            | {1:1}            | Keep       | freq(1) = 1 ≤ m               |
| 2   | 2       | [1,2]          | {1:1, 2:1}       | Keep       | freq(2) = 1 ≤ m               |
| 3   | 3       | [1,2,3]        | {1:1, 2:1, 3:1}  | Keep       | freq(3) = 1 ≤ m               |
| 4   | 3       | [2,3,3]        | {2:1, 3:2}       | Keep       | freq(3) = 2 ≤ m               |
| 5   | 3       | [3,3,3]        | {3:3}            | Discard    | freq(3) = 2 → would become 3  |
| 6   | 4       | [3,3,4]        | {3:2, 4:1}       | Keep       | freq(4) = 1 ≤ m               |

**Total discards:** `1`

---

## 🚀 C# Implementation

```csharp
public class Solution {
    public int MinArrivalsToDiscard(int[] arrivals, int w, int m) {
        int discards = 0;
        var freq = new Dictionary<int, int>();
        var window = new Queue<(int item, int day)>();

        for (int i = 0; i < arrivals.Length; i++) {
            int item = arrivals[i];
            int day = i + 1;

            // Remove outdated items from window
            while (window.Count > 0 && window.Peek().day < day - w + 1) {
                var (oldItem, _) = window.Dequeue();
                freq[oldItem]--;
                if (freq[oldItem] == 0)
                    freq.Remove(oldItem);
            }

            // Check if keeping violates frequency constraint
            if (freq.TryGetValue(item, out int count) && count == m) {
                discards++; // discard this item
                continue;
            }

            // Keep item
            window.Enqueue((item, day));
            if (!freq.ContainsKey(item))
                freq[item] = 0;
            freq[item]++;
        }

        return discards;
    }
}

```

## ✅ Complexity Analysis

| Metric       | Value         | Explanation                                      |
|--------------|---------------|--------------------------------------------------|
| Time         | O(n)          | Each arrival is processed exactly once          |
| Space        | O(w + u)      | `w` is the window size, `u` is number of unique item types |
| Stability    | High          | No recursion, no branching — pure simulation    |
| Scalability  | Excellent     | Efficiently handles up to 10⁵ arrivals          |

This algorithm is **stream-safe** and **state-local** — it doesn't require full history, only a sliding window and frequency map.

---

## 🧠 Engineering Takeaway

This problem teaches how to:

- 🔁 Simulate **bounded frequency logic** in a sliding window  
- 🔄 Track **state transitions** using queues and dictionaries  
- 🧮 Enforce **dynamic constraints** without brute-force scanning  
- 🧱 Build a **stream processor** that respects local rules and evolving state

> When constraints apply to recent history, the combination of **sliding window + frequency map** is your go-to pattern.

This is a classic example of **inventory balancing with discard logic**, where each decision is local but affects future state.

---

## 🧱 Architectural Pattern

### 🔧 State Variables

- `window`: queue of kept items (bounded size `w`)  
- `freq`: dictionary of item frequencies in current window  
- `discards`: counter for discarded arrivals

### 🔁 Loop Invariant

- Window size ≤ `w`  
- For every item type `t`, `freq[t] ≤ m`

### ⚙️ Decision Point

- If `freq[item] == m` → discard arrival  
- Else → keep and update state

### 🧩 Generalization

This pattern applies to:

- 🧼 Inventory balancing systems with local quotas  
- 🎮 Rate-limited event tracking in real-time systems  
- 📈 Frequency-constrained stream analytics  
- 🧠 Real-time discard decisions in bounded contexts

> The architecture is clean: **one queue**, **one map**, **one rule** — and full control over state.

---

## 🧠 Bonus Thought

### Edge Case Collapse

- If `w == 1`, the problem reduces to:  
  > “No item may appear more than `m` times on the same day” — trivial case

- If `m ≥ w`, then **no discards are ever needed** — every item is allowed regardless of frequency

> Always check edge cases — they often collapse the problem into simpler forms and reveal hidden invariants.

---

## 🧠 Meta-Reflection

This task is not just about counting discards — it's about **modeling evolving constraints** over a stream.  
It forces you to think in terms of **local state**, **temporal windows**, and **frequency enforcement**, which are foundational in systems design, rate-limiting, and real-time analytics.

> You’re not solving a problem — you’re simulating a system.


---

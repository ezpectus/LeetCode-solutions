# Pattern Name  
Fixed-Size Sliding Window with Threshold Check

---

## Problem Statement

You are given an integer array `arr`, and two integers `k` and `threshold`.  
Return the number of contiguous subarrays of size `k` whose average is **greater than or equal to `threshold`**.

---

## Input Constraints

| Constraint         | Value Range                        |
|--------------------|------------------------------------|
| `arr.length`       | 1 to 10‚Åµ                           |
| `arr[i]`           | 1 to 10‚Å¥                           |
| `k`                | 1 to `arr.length`                  |
| `threshold`        | 0 to 10‚Å¥                           |

These constraints imply that:

- **Brute-force O(nk)** is unacceptable ‚Äî too slow for large `n`  
- We need a **linear-time solution**, ideally **O(n)**  
- The values are small enough to avoid overflow, but large enough to require efficiency

---

## Algorithm Selection Rationale

We are asked to evaluate **fixed-size subarrays** and compare their **average** to a threshold.  
Instead of recalculating the average each time, we can:

- Precompute `targetSum = k √ó threshold`  
- Use a **sliding window** of size `k` to track the current sum  
- Compare `windowSum ‚â• targetSum` at each step

This avoids recomputation and gives us a clean **O(n)** solution.

---

## Problem Anatomy

| Element        | Role                                             |
|----------------|--------------------------------------------------|
| `arr[i]`       | Input array element                              |
| `k`            | Fixed window size                                |
| `threshold`    | Minimum average required                         |
| `targetSum`    | Precomputed: `k √ó threshold`                     |
| `windowSum`    | Sum of current window of size `k`                |
| `count`        | Number of valid subarrays                        |

---

## Algorithm Strategy

1. Compute `targetSum = k √ó threshold`  
2. Initialize `windowSum` with sum of first `k` elements  
3. Slide the window across the array:
   - At each step, check if `windowSum ‚â• targetSum`
   - Subtract `arr[i - k]`, add `arr[i]` to move the window
4. Count how many windows satisfy the condition

---

## C# Implementation

```csharp
public class Solution {
    public int NumOfSubarrays(int[] arr, int k, int threshold) {
        int targetSum = k * threshold;
        int windowSum = 0;
        int count = 0;

        for (int i = 0; i < arr.Length; i++) {
            windowSum += arr[i];

            if (i >= k) {
                windowSum -= arr[i - k];
            }

            if (i >= k - 1 && windowSum >= targetSum) {
                count++;
            }
        }

        return count;
    }
}
```
##  Time and Space Complexity

| Metric           | Value  | Explanation                                                  |
|------------------|--------|--------------------------------------------------------------|
| Time Complexity  | O(n)   | Each element is added once and removed once from the window. |
| Space Complexity | O(1)   | Only integer counters and sums are used; no auxiliary arrays.|

This solution avoids recomputation by maintaining a rolling sum of the current window.  
No extra space is needed beyond a few integer variables, making it optimal for large inputs.

---

##  Generalization to Other Problems

This pattern applies to problems where:

- You need to evaluate **fixed-size subarrays**.
- You compare **aggregated metrics** (sum, average, max) against a **threshold**.
- You want to avoid recomputation by using a **sliding window sum**.

The key architectural idea is that the window moves forward one element at a time,  
and the aggregate (sum, count, etc.) is updated incrementally ‚Äî no full recomputation per window.

---

##  Examples of Similar Problems

| Problem Type                          | Description                                                  |
|--------------------------------------|--------------------------------------------------------------|
| Max sum of subarray of size k        | Track max sum in fixed-size window                           |
| Count subarrays with sum ‚â• target    | Count windows meeting sum condition                          |
| Longest subarray with average ‚â• x    | Variable-size window + prefix sum                            |

These problems often involve **window-based aggregation**, and the sliding window pattern  
allows for **linear-time evaluation** without nested loops or brute-force scanning.

---

## üßæ Final Takeaway

This problem uses a **fixed-size sliding window** to track subarray sums efficiently.  
Instead of recalculating averages, we precompute the **target sum** and compare directly.  
This transforms a naive **O(nk)** approach into a clean **O(n)** solution using **window sum reuse**.

The pattern is reusable for any task involving **window-based aggregation and threshold comparison**, especially when:

- The window size is fixed  
- The comparison is against a global or computed threshold  
- Performance constraints demand linear-time processing

---


# ğŸ§  Problem Breakdown â€” 1685. Sum of Absolute Differences in a Sorted Array

## ğŸ” Problem Statement

Given a sorted array `nums`, return a new array `res` where:
```
res[i] = sum(|nums[i] - nums[j]|) for all j â‰  i
```

Since `nums` is sorted, we can split the absolute difference into two parts:

- Left side (j < i): `|nums[i] - nums[j]| = nums[i] - nums[j]`
- Right side (j > i): `|nums[i] - nums[j]| = nums[j] - nums[i]`

This allows us to use prefix and suffix sums to compute the result in `O(n)` time.

---

## âœ… Implementation (C#)

```csharp
public class Solution {
    public int[] GetSumAbsoluteDifferences(int[] nums) {
        int n = nums.Length;
        int[] res = new int[n];
        int[] prefix = new int[n];
        int[] suffix = new int[n];

        prefix[0] = nums[0];
        for (int i = 1; i < n; i++)
            prefix[i] = prefix[i - 1] + nums[i];

        suffix[n - 1] = nums[n - 1];
        for (int i = n - 2; i >= 0; i--)
            suffix[i] = suffix[i + 1] + nums[i];

        for (int i = 0; i < n; i++) {
            int left = i > 0 ? nums[i] * i - prefix[i - 1] : 0;
            int right = i < n - 1 ? suffix[i + 1] - nums[i] * (n - i - 1) : 0;
            res[i] = left + right;
        }

        return res;
    }
}
```

## ğŸ§  Formula Breakdown â€” Directional Absolute Differences

### ğŸ”¹ Left Contribution: `nums[i] * i - prefix[i - 1]`

- `nums[i] * i`: total value if `nums[i]` were subtracted from each of the `i` elements before it  
- `prefix[i - 1]`: actual sum of those elements  
- Their difference gives the total absolute difference to the **left** of index `i`

### ğŸ”¹ Right Contribution: `suffix[i + 1] - nums[i] * (n - i - 1)`

- `suffix[i + 1]`: sum of all elements **after** index `i`  
- `nums[i] * (n - i - 1)`: total value if `nums[i]` were subtracted from each of those elements  
- Their difference gives the total absolute difference to the **right** of index `i`

---

## ğŸ” Why This Works

Since the array is sorted:

- For `j < i`: `|nums[i] - nums[j]| = nums[i] - nums[j]`  
- For `j > i`: `|nums[i] - nums[j]| = nums[j] - nums[i]`

This directional split allows us to model absolute differences using **prefix and suffix sums**, avoiding nested loops.

---

## ğŸ§¼ Complexity Analysis

- **Time Complexity**: `O(n)`  
  - One pass to build `prefix`  
  - One pass to build `suffix`  
  - One pass to compute `res`

- **Space Complexity**: `O(n)`  
  - Arrays used: `prefix[n]`, `suffix[n]`, `res[n]`

This avoids brute-force `O(nÂ²)` by leveraging cumulative sums and directional modeling.

---

## ğŸ§  Summary â€” Architectural Signals

This solution transforms a brute-force absolute difference problem into a **signal-based computation** using:

- ğŸ“¦ **Prefix/suffix optimization** â€” fast range sum access  
- ğŸ§­ **Directional modeling** â€” split left/right contributions  
- ğŸ” **Scalable formulation** â€” works for any sorted array

A clean, reusable pattern for problems involving:

- Absolute deviation  
- Cost modeling  
- Range-based scoring  
- Median-based optimization (with tweaks)



---

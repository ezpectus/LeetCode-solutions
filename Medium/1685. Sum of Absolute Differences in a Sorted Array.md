# 🧠 Problem Breakdown — 1685. Sum of Absolute Differences in a Sorted Array

## 🔍 Problem Statement

Given a sorted array `nums`, return a new array `res` where:
```
res[i] = sum(|nums[i] - nums[j]|) for all j ≠ i
```

Since `nums` is sorted, we can split the absolute difference into two parts:

- Left side (j < i): `|nums[i] - nums[j]| = nums[i] - nums[j]`
- Right side (j > i): `|nums[i] - nums[j]| = nums[j] - nums[i]`

This allows us to use prefix and suffix sums to compute the result in `O(n)` time.

---

## ✅ Implementation (C#)

```csharp
public class Solution {
    public int[] GetSumAbsoluteDifferences(int[] nums) {
        int n = nums.Length;
        int[] res = new int[n];
        int[] prefix = new int[n];
        int[] suffix = new int[n];

        prefix[0] = nums[0];
        for (int i = 1; i < n; i++)
            prefix[i] = prefix[i - 1] + nums[i];

        suffix[n - 1] = nums[n - 1];
        for (int i = n - 2; i >= 0; i--)
            suffix[i] = suffix[i + 1] + nums[i];

        for (int i = 0; i < n; i++) {
            int left = i > 0 ? nums[i] * i - prefix[i - 1] : 0;
            int right = i < n - 1 ? suffix[i + 1] - nums[i] * (n - i - 1) : 0;
            res[i] = left + right;
        }

        return res;
    }
}
```

## 🧠 Formula Breakdown — Directional Absolute Differences

### 🔹 Left Contribution: `nums[i] * i - prefix[i - 1]`

- `nums[i] * i`: total value if `nums[i]` were subtracted from each of the `i` elements before it  
- `prefix[i - 1]`: actual sum of those elements  
- Their difference gives the total absolute difference to the **left** of index `i`

### 🔹 Right Contribution: `suffix[i + 1] - nums[i] * (n - i - 1)`

- `suffix[i + 1]`: sum of all elements **after** index `i`  
- `nums[i] * (n - i - 1)`: total value if `nums[i]` were subtracted from each of those elements  
- Their difference gives the total absolute difference to the **right** of index `i`

---

## 🔍 Why This Works

Since the array is sorted:

- For `j < i`: `|nums[i] - nums[j]| = nums[i] - nums[j]`  
- For `j > i`: `|nums[i] - nums[j]| = nums[j] - nums[i]`

This directional split allows us to model absolute differences using **prefix and suffix sums**, avoiding nested loops.

---

## 🧼 Complexity Analysis

- **Time Complexity**: `O(n)`  
  - One pass to build `prefix`  
  - One pass to build `suffix`  
  - One pass to compute `res`

- **Space Complexity**: `O(n)`  
  - Arrays used: `prefix[n]`, `suffix[n]`, `res[n]`

This avoids brute-force `O(n²)` by leveraging cumulative sums and directional modeling.

---

## 🧠 Summary — Architectural Signals

This solution transforms a brute-force absolute difference problem into a **signal-based computation** using:

- 📦 **Prefix/suffix optimization** — fast range sum access  
- 🧭 **Directional modeling** — split left/right contributions  
- 🔁 **Scalable formulation** — works for any sorted array

A clean, reusable pattern for problems involving:

- Absolute deviation  
- Cost modeling  
- Range-based scoring  
- Median-based optimization (with tweaks)



---

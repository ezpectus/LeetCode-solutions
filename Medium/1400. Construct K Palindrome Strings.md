#  1400. Construct K Palindrome Strings 

##  Problem Summary
We are given:
- A string `s` (lowercase letters)
- An integer `k`

We must determine if it is possible to use **all characters** of `s` to construct exactly `k` non-empty palindrome strings.

---

##  Core Idea
- A palindrome requires **pairs of characters** around the center.
- Characters with **odd frequency** can only serve as the center of a palindrome.
- Therefore:
  - The **minimum number of palindromes** needed = number of odd-frequency characters.
  - The **maximum number of palindromes** possible = length of the string (each character alone).
- Condition:  
  - If `n < k` → impossible (not enough characters).  
  - Otherwise, check if `odd <= k`.

---

##  Pattern
- Count odd-frequency characters using a bitmask trick:
  - XOR toggle each character bit → final mask shows which characters have odd counts.
- Count set bits in mask = number of odd-frequency characters.
- Return `true` if `odd <= k`.

---

##  Code (C#)

```csharp
public class Solution {
    public bool CanConstruct(string s, int k) {
        int n = s.Length;
        if (n < k) return false; // not enough characters

        int mask = 0;
        foreach (char c in s) {
            mask ^= (1 << (c - 'a')); // toggle bit for each character
        }

        int odd = CountBits(mask);
        return odd <= k;
    }

    private int CountBits(int n) {
        int count = 0;
        while (n > 0) {
            count += n & 1;
            n >>= 1;
        }
        return count;
    }
}
```

##  Complexity
- **Time:** O(n) — we scan the string once, toggling bits for each character.  
- **Space:** O(1) — only an integer mask and counters are used, independent of input size.  

---

##  Pitfalls
- **Check length first:** If `n < k`, it’s impossible to construct `k` palindromes because we don’t have enough characters.  
- **Odd-frequency characters matter:** The number of characters with odd frequency defines the **minimum number of palindromes** required.  
- **Bitmask trick:** Works efficiently because there are only 26 lowercase letters — each letter corresponds to a bit.  
- **Edge cases:**  
  - When `k == n`, each character can form its own palindrome.  
  - When `odd == 0`, the entire string can be split into palindromes without restriction.  

---

##  Sanity Checks
- Input: `s = "annabelle", k = 2` → **true** (odd = 2, k = 2)  
- Input: `s = "leetcode", k = 3` → **false** (odd = 5, k = 3)  
- Input: `s = "true", k = 4` → **true** (odd = 4, k = 4)  

---

##  Key takeaway
The problem reduces to **counting odd-frequency characters**:
- If the number of odd characters ≤ `k`  
- And the string length `n ≥ k`  

Then constructing `k` palindromes is always possible.  
This is a **bitmask-based frequency analysis** that elegantly solves the problem in linear time and constant space.


---

## 🧠 Deep Dive: 309. Best Time to Buy and Sell Stock with Cooldown

### 🔹 Problem Statement
You are given an array `prices` where `prices[i]` is the price of a stock on day `i`.

You may complete as many transactions as you like (buy/sell one share), but with **two constraints**:
- After selling, you must **cooldown for one day** before buying again.
- You cannot hold more than one share at a time.

Goal: Return the **maximum profit** achievable under these rules.

---

### 🔹 Why Dynamic Programming Works

#### ✅ Subproblem Structure
At each day `i`, we track two states:
- `dp[i,0]`: max profit **not holding** stock on day `i`
- `dp[i,1]`: max profit **holding** stock on day `i`

We build up these states using previous days' values.

#### ✅ Recurrence Relations

```
dp[i,0] = max(dp[i-1,0], dp[i-1,1] + prices[i-1])
dp[i,1] = max(dp[i-1,1], dp[i-2,0] - prices[i-1])
```


Explanation:
- To be **not holding** on day `i`:  
  → either we were not holding yesterday, or  
  → we sell today (held yesterday + today's price)

- To be **holding** on day `i`:  
  → either we were holding yesterday, or  
  → we buy today (but only if we were not holding two days ago — cooldown enforced)

---

### 🔹 Base Cases
```csharp
dp[1,0] = 0
dp[1,1] = -prices[0]
Day 1: either we do nothing, or we buy the stock.
```

## 🔹 C# Code Template
```csharp
public class Solution {
    public int MaxProfit(int[] prices) {
        int n = prices.Length;
        int[,] dp = new int[n + 1, 2];
        dp[1,0] = 0;
        dp[1,1] = -prices[0];

        for (int i = 2; i <= n; i++) {
            dp[i,0] = Math.Max(dp[i-1,0], dp[i-1,1] + prices[i-1]);
            dp[i,1] = Math.Max(dp[i-1,1], dp[i-2,0] - prices[i-1]);
        }

        return dp[n,0];
    }
}
```
## 📊 DP Pattern: Stock Trading with Cooldown (Leetcode 309)

---

### 🔹 Architectural Breakdown

| 🧩 Component       | 🛠️ Role in the Solution                                                                 |
|-------------------|------------------------------------------------------------------------------------------|
| `dp[i][0]`         | Max profit on day `i` when **not holding** stock — either resting or just sold          |
| `dp[i][1]`         | Max profit on day `i` when **holding** stock — either continued holding or bought       |
| `dp[i-2][0]`       | Enforces **cooldown** before buying again — ensures no buy immediately after a sell     |
| `Math.Max(...)`    | Chooses optimal action: **hold**, **buy**, **sell**, or **wait**                        |
| `prices[i-1]`      | Current day's price — adjusted for 0-based indexing                                     |

> 🧠 This setup models a two-state system with temporal constraints, allowing precise control over transitions and profit tracking.

---

## 🔹 Why This Algorithm Fits

- ✅ Clear state transitions — only two states per day, easy to model and reason about
- ✅ Cooldown constraint — elegantly enforced via dp[i-2][0], no extra flags needed
- ✅ Bottom-up DP — avoids recursion overhead, ensures linear time
- ✅ Scales well — handles up to n = 5000 efficiently

# 🔹 Time & Space Complexity

Metric	Complexity	Notes
- ⏱️ Time	O(n)	Single pass through prices, constant-time operations per day
- 🧠 Space	O(n) → O(1)	2D DP array can be reduced to rolling variables with no loss of logic
  
# 🔚 Final Insight
This algorithm exemplifies a state-based dynamic programming pattern tailored for problems with delayed actions and resource constraints over time.

## ✅ Once mastered, it unlocks a family of problems involving:

- Inventory management
- Energy scheduling
- Task planning with cooldowns
- Multi-agent decision systems

🧠 Core lesson: Temporal constraints can be modeled through prior states — not flags or hacks.




---

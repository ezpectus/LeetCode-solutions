## ğŸ§  Deep Dive: 309. Best Time to Buy and Sell Stock with Cooldown

### ğŸ”¹ Problem Statement
You are given an array `prices` where `prices[i]` is the price of a stock on day `i`.

You may complete as many transactions as you like (buy/sell one share), but with **two constraints**:
- After selling, you must **cooldown for one day** before buying again.
- You cannot hold more than one share at a time.

Goal: Return the **maximum profit** achievable under these rules.

---

### ğŸ”¹ Why Dynamic Programming Works

#### âœ… Subproblem Structure
At each day `i`, we track two states:
- `dp[i,0]`: max profit **not holding** stock on day `i`
- `dp[i,1]`: max profit **holding** stock on day `i`

We build up these states using previous days' values.

#### âœ… Recurrence Relations

```
dp[i,0] = max(dp[i-1,0], dp[i-1,1] + prices[i-1])
dp[i,1] = max(dp[i-1,1], dp[i-2,0] - prices[i-1])
```


Explanation:
- To be **not holding** on day `i`:  
  â†’ either we were not holding yesterday, or  
  â†’ we sell today (held yesterday + today's price)

- To be **holding** on day `i`:  
  â†’ either we were holding yesterday, or  
  â†’ we buy today (but only if we were not holding two days ago â€” cooldown enforced)

---

### ğŸ”¹ Base Cases
```csharp
dp[1,0] = 0
dp[1,1] = -prices[0]
Day 1: either we do nothing, or we buy the stock.
```

## ğŸ”¹ C# Code Template
```csharp
public class Solution {
    public int MaxProfit(int[] prices) {
        int n = prices.Length;
        int[,] dp = new int[n + 1, 2];
        dp[1,0] = 0;
        dp[1,1] = -prices[0];

        for (int i = 2; i <= n; i++) {
            dp[i,0] = Math.Max(dp[i-1,0], dp[i-1,1] + prices[i-1]);
            dp[i,1] = Math.Max(dp[i-1,1], dp[i-2,0] - prices[i-1]);
        }

        return dp[n,0];
    }
}
```
## ğŸ“Š DP Pattern: Stock Trading with Cooldown (Leetcode 309)

---

### ğŸ”¹ Architectural Breakdown

| ğŸ§© Component       | ğŸ› ï¸ Role in the Solution                                                                 |
|-------------------|------------------------------------------------------------------------------------------|
| `dp[i][0]`         | Max profit on day `i` when **not holding** stock â€” either resting or just sold          |
| `dp[i][1]`         | Max profit on day `i` when **holding** stock â€” either continued holding or bought       |
| `dp[i-2][0]`       | Enforces **cooldown** before buying again â€” ensures no buy immediately after a sell     |
| `Math.Max(...)`    | Chooses optimal action: **hold**, **buy**, **sell**, or **wait**                        |
| `prices[i-1]`      | Current day's price â€” adjusted for 0-based indexing                                     |

> ğŸ§  This setup models a two-state system with temporal constraints, allowing precise control over transitions and profit tracking.

---

## ğŸ”¹ Why This Algorithm Fits

- âœ… Clear state transitions â€” only two states per day, easy to model and reason about
- âœ… Cooldown constraint â€” elegantly enforced via dp[i-2][0], no extra flags needed
- âœ… Bottom-up DP â€” avoids recursion overhead, ensures linear time
- âœ… Scales well â€” handles up to n = 5000 efficiently

# ğŸ”¹ Time & Space Complexity

Metric	Complexity	Notes
- â±ï¸ Time	O(n)	Single pass through prices, constant-time operations per day
- ğŸ§  Space	O(n) â†’ O(1)	2D DP array can be reduced to rolling variables with no loss of logic
  
# ğŸ”š Final Insight
This algorithm exemplifies a state-based dynamic programming pattern tailored for problems with delayed actions and resource constraints over time.

## âœ… Once mastered, it unlocks a family of problems involving:

- Inventory management
- Energy scheduling
- Task planning with cooldowns
- Multi-agent decision systems

ğŸ§  Core lesson: Temporal constraints can be modeled through prior states â€” not flags or hacks.




---

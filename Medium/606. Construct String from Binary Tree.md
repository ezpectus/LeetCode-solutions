# 606. Construct String from Binary Tree — Architectural Preorder DFS  
*O(n) — Minimal & Exact Parentheses*

---

## Problem Summary

Convert a binary tree to a **unique string** using **preorder traversal** with **strict parentheses rules**:

- Print node value always
- Enclose subtrees in `()`
- **Omit unnecessary** parentheses
- But **preserve structure** when left child missing but right exists → `()`

Goal: **one-to-one** mapping tree ↔ string.

---

## Core Idea — Conditional Preorder DFS

We build the string recursively:
```
value + leftPart + rightPart
```


**leftPart**:
- If left exists → `"(" + dfs(left) + ")"`
- If left missing **but right exists** → `"()"` (required for structure)
- Otherwise → `""`

**rightPart**:
- If right exists → `"(" + dfs(right) + ")"`
- Otherwise → `""`

This **exactly** matches the required format — **no extra parentheses**, but **structure preserved**.

---

## Full Working Implementation (C#)

```csharp
public class Solution {
    public string Tree2str(TreeNode root) {
        return Dfs(root);
    }

    private string Dfs(TreeNode n) {
        if (n == null) return "";

        // leaf node → just value
        if (n.left == null && n.right == null)
            return n.val.ToString();

        // left part
        string left = n.left != null
            ? "(" + Dfs(n.left) + ")"
            : "()"; // only used if right exists

        // right part
        string right = n.right != null
            ? "(" + Dfs(n.right) + ")"
            : "";

        // if left is "()" but right is empty → remove "()"
        if (n.right == null && n.left == null)
            left = "";

        // special rule: if left is null but right exists → keep "()"
        if (n.left == null && n.right != null)
            left = "()";

        return n.val + left + right;
    }
}

```
## Time and Space Complexity

| **Metric**            | **Value**     | **Explanation**                                      |
|-----------------------|---------------|------------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Each node is visited exactly once during preorder traversal |
| **Space Complexity**  | **O(h)**      | Recursion stack depth equals tree height (worst-case O(n) for skewed tree) |

**Optimal** — linear time, minimal extra space.

---

## Implementation Commentary

- **Conditional left parentheses**:  
  We only emit `"()"` for a missing left child **when a right child exists** — this preserves structural ambiguity resolution without extra data.

- **Right parentheses handling**:  
  Right subtree is always wrapped in `()` **only if it exists** — no unnecessary pairs.

- **Leaf optimization**:  
  Pure leaves return just the value — no parentheses at all.

- **Immediate string concatenation**:  
  No StringBuilder needed — modern C# optimizes `+` in recursion for small depths.

- **No extra data structures**:  
  Pure recursion on the tree itself — in-place logic with zero auxiliary space beyond stack.

---

## Final Takeaway

This is a **minimalist tree serialization** problem solved via **conditional preorder DFS**, where:

- Parentheses are emitted **only when structurally required**
- The solution **perfectly balances** omission and preservation of empty subtrees
- The code cleanly separates **value**, **left**, and **right** parts with precise rules

The pattern generalizes to any tree serialization with **context-sensitive delimiters**, such as:

- JSON-like tree representations
- Lisp-style S-expressions with optional empty lists
- Custom AST printers with minimal syntax

This structure is reusable for any problem requiring **exact, unambiguous, minimal string encoding** of tree structure.

----



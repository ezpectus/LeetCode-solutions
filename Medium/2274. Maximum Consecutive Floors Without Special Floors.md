# 2274. Maximum Consecutive Floors Without Special Floors  
*O(n log n) — Sorting + Single Pass Gap Check*

---

## Problem Statement

Alice rented all floors from `bottom` to `top` (inclusive).  
Some floors are **special** (listed in array `special`).  

Return the **maximum number of consecutive floors** that contain **no special floors**.

**Examples**:

**Example 1**: bottom = 2, top = 9, special = [4,6]  
Output: **3**  
- Ranges without special: [2,3] → 2 floors  
- [5,5] → 1 floor  
- [7,9] → 3 floors  
Maximum = **3**

**Example 2**: bottom = 6, top = 8, special = [7,6,8]  
Output: **0**  
All floors are special → no consecutive non-special floors

**Constraints**:
- 1 ≤ special.length ≤ 10⁵
- 1 ≤ bottom ≤ special[i] ≤ top ≤ 10⁹
- All values in `special` are **unique**

---

## Core Idea — Sort Special Floors + Check Gaps

**Key insight**:
- The longest consecutive non-special floors will be in one of the gaps:
  1. Between `bottom` and the first special floor
  2. Between two consecutive special floors
  3. Between the last special floor and `top`

**Algorithm**:
1. Sort the `special` array in ascending order
2. Consider the virtual gaps:
   - From `bottom` to first special - 1
   - Between special[i] and special[i+1] - 1
   - From last special + 1 to `top`
3. For each gap, compute length = **end - start + 1**
4. Take the **maximum** such length

**Time**: O(n log n) — dominated by sorting  
**Space**: O(1) extra (sorting in-place)

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int MaxConsecutive(int bottom, int top, int[] special){
        // Sort special floors
        Array.Sort(special);
        int n = special.Length;
        int maxGap = 0;

        // 1. Gap from bottom to first special floor
        if (special.Length > 0){
            maxGap = Math.Max(maxGap, special[0] - bottom);
        }
        else{
            // No special floors → entire range
            return top - bottom + 1;
        }

        // 2. Gaps between consecutive special floors
        for (int i = 1; i < n; i++){
            int gap = special[i] - special[i - 1] - 1;
            maxGap = Math.Max(maxGap, gap);
        }

        // 3. Gap from last special to top
        maxGap = Math.Max(maxGap, top - special[^1]);
        return maxGap;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)**| Sorting the special floors: O(n log n)<br>Single linear pass to compute gaps: O(n) |
| **Space Complexity**  | **O(1)**      | Only a few integer variables — sorting is done in-place (or uses O(log n) stack space) |

**Optimal** — sorting is required in the worst case; the rest is linear — perfectly efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: bottom = 2, top = 9, special = [4,6]

After sorting: **[4,6]**

Gaps calculated:
- From bottom to first special: 2 to 3 → length = 3 − 2 + 1 = **2**
- Between consecutive specials (4 and 6): 5 to 5 → length = **1**
- From last special to top: 7 to 9 → length = 9 − 7 + 1 = **3**

Maximum gap = **3** → correct

**Example 2**: bottom = 6, top = 8, special = [6,7,8]

After sorting: **[6,7,8]**

Gaps:
- bottom → 6: 6 to 5 → empty → **0**
- between 6 and 7: no floors → **0**
- between 7 and 8: no floors → **0**
- 8 → top: empty → **0**

Maximum gap = **0** → correct

**Correct** —  
After sorting the special floors, the longest sequence of consecutive non-special floors **must** lie entirely within one of the gaps (including the gap before the first special and after the last special).  
We simply compute the size of each gap and return the maximum one.

---

## Key Takeaway

This is a **classic gap-finding problem after sorting**:

* **Sort** the special floors in ascending order
* Consider three types of gaps:
  1. From `bottom` to first special floor − 1
  2. Between every pair of consecutive special floors: `special[i+1] − special[i] − 1`
  3. From last special floor + 1 to `top`
* The length of each gap is calculated as **end − start + 1**
* Return the **maximum** gap length found

**Pure, clean, optimal** — O(n log n) time (dominated by sorting), O(1) extra space, extremely fast, intuitive, and handles all edge cases perfectly.

---

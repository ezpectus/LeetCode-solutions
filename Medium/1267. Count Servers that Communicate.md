# Pattern Name
**Server Communication via Row/Column Aggregation**

## Problem Summary
- **Input**:  
  A 2D grid `m × n` where `grid[i][j] == 1` means there's a **server** at cell `(i, j)`, and `0` means **empty**.
- **Goal**:  
  Count how many servers can **communicate** with at least **one other server** in the **same row or column**.
- **Constraints**:
  - `1 ≤ m, n ≤ 250`
  - `grid[i][j] ∈ {0, 1}`

## Core Idea
- Servers **communicate** if they share a **row or column** with another server.
- Count servers **per row** and **per column**.
- A server is **communicative** if its **row or column has more than one server**.

## Solution
- Traverse the grid **once** to count servers in each **row** and **column**.
- Traverse **again** to count servers that lie in **rows or columns with count > 1**.

## Strategy Summary
- **First pass**:  
  - Count servers in each row → `rows[i]`  
  - Count servers in each column → `cols[j]`
- **Second pass**:  
  - For each cell `(i, j)` with server:  
    - If `rows[i] > 1 || cols[j] > 1` → **count it**

## C# Implementation
```csharp
public class Solution {
    public int CountServers(int[][] grid) {
        int m = grid.Length;
        int n = grid[0].Length;
        int[] rows = new int[m];
        int[] cols = new int[n];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                rows[i] += grid[i][j];
                cols[j] += grid[i][j];
            }
        }

        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1 && (rows[i] > 1 || cols[j] > 1)) {
                    res++;
                }
            }
        }

        return res;
    }
}
```

## Architectural Breakdown
| Component               | Role                                      |
|-------------------------|-------------------------------------------|
| `rows[]`                | Counts servers per row                    |
| `cols[]`                | Counts servers per column                 |
| **Double traversal**    | First for counting, second for filtering  |
| **Communication rule**  | `rows[i] > 1 || cols[j] > 1`              |

## Why This Approach Is Superior
| Aspect              | **Row/Column Aggregation** | Naive Pairwise Check     |
|---------------------|-----------------------------|---------------------------|
| Time Complexity     | **O(m × n)**                | O((m × n)²)               |
| Space Complexity    | **O(m + n)**                | O(1)                      |
| Performance         | Scales to 250×250 grid      | Breaks on large input     |
| Clarity             | Simple and readable         | Nested loops, hard to trace |

## Final Takeaway
- **This pattern is about aggregating row/column statistics to avoid pairwise comparisons.**
- **It generalizes to**:
  - Grid-based communication
  - Row/column influence problems
  - Efficient filtering via precomputed aggregates
 
---

## ðŸ§  Deep Dive: 279. Perfect Squares

### ðŸ”¹ Problem Statement
Given an integer `n`, return the **minimum number of perfect square numbers** (like `1`, `4`, `9`, `16`, ...) that sum up to `n`.

This is not about finding any combination â€” it's about finding the **least number of squares** needed.

---

### ðŸ”¹ Why Dynamic Programming Works

#### âœ… Subproblem Structure
For every integer `i` from `1` to `n`, we want to know:

> What is the minimum number of perfect squares that sum to `i`?

We build up answers from smaller values using previously computed results.

## âœ… Recurrence Relation
For each `i`, we try subtracting every square `sqÂ² â‰¤ i` and use:

```
dp[i] = min(dp[i], dp[i - sqÂ²] + 1)
```

## âœ… Bottom-Up Efficiency
We initialize dp[0] = 0 and build up to dp[n]. Each dp[i] depends only on smaller values â€” no recomputation, no recursion stack.


This means:  
If we already know the minimum number of squares to reach `i - sqÂ²`,  
we can reach `i` by adding one more square.

---

### ðŸ”¹ Base Case

```
dp[0] = 0
```
Zero squares are needed to sum to zero.

---

### ðŸ”¹ Time & Space Complexity
- **Time:** O(nâˆšn) â€” for each `i`, we loop through all `sq â‰¤ âˆši`
- **Space:** O(n) â€” one-dimensional DP array

---

### ðŸ”¹ Why This Algorithm Fits
- âœ… Optimization over minimum â€” classic DP use case  
- âœ… Fixed subproblem structure  
- âœ… No complex state transitions  
- âœ… Efficient bottom-up construction


## ðŸ”¹ C# Code Template
```csharp
public class Solution {
    public int NumSquares(int n) {
        var dp = new int[n + 1];
        for (int i = 0; i <= n; i++) dp[i] = int.MaxValue;
        dp[0] = 0;

        for (int i = 1; i <= n; i++) {
            for (int sq = 1; sq * sq <= i; sq++) {
                dp[i] = Math.Min(dp[i], dp[i - sq * sq] + 1);
            }
        }

        return dp[n];
    }
}
```

---

### ðŸ”¹ Architectural Breakdown

| Component        | Role in the Solution                                  |
|------------------|--------------------------------------------------------|
| `dp[]`           | Stores minimum number of squares for each value `i`   |
| `sq * sq â‰¤ i`    | Generates all valid square numbers for current `i`    |
| `Math.Min(...)`  | Chooses optimal path (least number of squares)        |
| `dp[0] = 0`      | Base case: zero squares needed to sum to zero         |

---

### ðŸ”¹ What Can Be Improved or Extended

ðŸ”§ **1. Track Actual Squares Used**  
Add a `prev[]` array to reconstruct the path â€” useful if you want to show which squares were used.

ðŸ”§ **2. Top-Down Memoization**  
You could use recursion with memoization, but bottom-up is faster and avoids stack overflow.

ðŸ”§ **3. Mathematical Insight**  
Lagrangeâ€™s Four Square Theorem guarantees any number can be written as the sum of â‰¤4 squares.  
But this doesnâ€™t help with *which* squares or *how many exactly* â€” so DP is still needed.

---

### ðŸ”¹ Why This Algorithm Fits

- âœ… Itâ€™s a **minimum optimization** problem â€” classic DP use case  
- âœ… Subproblems are **clearly defined and independent**  
- âœ… No complex state â€” just integer values  
- âœ… Efficient in both **time and space**

---

### ðŸ”¹ Time & Space Complexity

- **Time:** \( O(n \sqrt{n}) \) â€” for each `i`, we loop through all `sq â‰¤ \sqrt{i}`  
- **Space:** \( O(n) \) â€” one-dimensional DP array

---

### ðŸ”š Final Insight

This pattern generalizes to other problems like **coin change**, **minimum steps**, and **state-based DP**.  
Itâ€™s a clean, bottom-up approach that balances clarity, performance, and extensibility.  
Once understood, it becomes a reusable mental model for any problem involving **minimum components to reach a target**.




---

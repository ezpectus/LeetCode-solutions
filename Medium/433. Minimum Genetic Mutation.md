# 433. Minimum Genetic Mutation — BFS in Gene Space

## Problem Summary

We are given two gene strings `startGene` and `endGene`, each of length 8, consisting of characters `A`, `C`, `G`, `T`.

- One **mutation** = change exactly one character.
- Only mutations present in `bank` are valid.
- Goal: find the **minimum number of mutations** to transform `startGene` → `endGene`.
- If impossible, return `-1`.

## Core Idea

This is a **shortest path problem** in a graph:

- **Nodes** = gene strings.
- **Edge** = one valid mutation (differs by 1 character and exists in `bank`).

BFS guarantees the **shortest path** in an unweighted graph → **minimum mutations**.

## Strategy

1. Pre-check: If `endGene` not in `bank` → return `-1`.
2. BFS traversal:
   - Start from `startGene`.
   - At each step, generate all possible mutations (change one char to `A/C/G/T`).
   - If mutation exists in `bank` and not visited → enqueue.
3. Count levels: Each BFS level = one mutation step.
4. When we reach `endGene` → return step count.
5. If BFS ends without reaching `endGene` → return `-1`.

## Implementation (C#)

```csharp
public class Solution 
{
    public int MinMutation(string startGene, string endGene, string[] bank) 
    {
        HashSet<string> bankSet = new HashSet<string>(bank);
        if (!bankSet.Contains(endGene)) return -1;

        char[] genes = new char[] { 'A', 'C', 'G', 'T' };
        Queue<(string gene, int steps)> q = new Queue<(string, int)>();
        q.Enqueue((startGene, 0));
        
        HashSet<string> visited = new HashSet<string>();
        visited.Add(startGene);

        while (q.Count > 0) 
        {
            var (curr, steps) = q.Dequeue();
            if (curr == endGene) return steps;

            char[] arr = curr.ToCharArray();
            for (int i = 0; i < arr.Length; i++) 
            {
                char old = arr[i];
                foreach (char g in genes) 
                {
                    if (g == old) continue;
                    arr[i] = g;
                    string next = new string(arr);
                    if (bankSet.Contains(next) && !visited.Contains(next)) 
                    {
                        visited.Add(next);
                        q.Enqueue((next, steps + 1));
                    }
                }
                arr[i] = old; // backtrack
            }
        }
        return -1;
    }
}
```

## Complexity

- **Time**: **O(n·L·4)**  
  - `n` = size of `bank`, `L = 8` = gene length.  
  - Each BFS step tries 3 alternative mutations per position.
- **Space**: **O(n)** for `bankSet` + `visited` set.

## Pitfalls

- Must check `endGene ∈ bank`, otherwise impossible.
- Avoid revisiting already visited genes.
- BFS ensures shortest path; DFS would not guarantee minimal mutations.

## Edge Cases

- `startGene == endGene` → result = `0`.
- Empty `bank` → result = `-1` unless `startGene == endGene`.
- Multiple paths exist → BFS ensures minimum steps.

## Sanity Checks

- Input: `startGene="AACCGGTT"`, `endGene="AACCGGTA"`, `bank=["AACCGGTA"]` → Output: `1`.
- Input: `startGene="AACCGGTT"`, `endGene="AAACGGTA"`, `bank=["AACCGGTA","AACCGCTA","AAACGGTA"]` → Output: `2`.
- Input: `startGene="AAAAACCC"`, `endGene="AACCCCCC"`, `bank=["AAAACCCC","AAACCCCC","AACCCCCC"]` → Output: `3`.

## Key Takeaway

This is a **graph shortest path problem** solved by **BFS**:
- **Nodes** = gene strings.
- **Edges** = valid one-character mutations in `bank`.
- **BFS** ensures **minimal mutation count**.
**Result**: clean, efficient **O(n)** solution.

---



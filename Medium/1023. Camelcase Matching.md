# 1023. Camelcase Matching

---

##  Problem Restatement
We are given:
- An array of strings `queries`.
- A string `pattern`.

We must return a boolean array `answer` where:
- `answer[i] = true` if `queries[i]` matches `pattern`.
- `answer[i] = false` otherwise.

**Matching rule:**
- You can insert lowercase letters into `pattern` to form `query`.
- Uppercase letters in `pattern` must appear in `query` in the same order.
- If `query` contains an uppercase letter not in `pattern`, it fails.

---

##  Core Idea
- Traverse `query` and `pattern` simultaneously with two pointers.  
- For each character in `query`:
  - If it matches the current character in `pattern` â†’ advance both pointers.  
  - If it is lowercase and does not match â†’ skip (allowed insertion).  
  - If it is uppercase and does not match â†’ fail immediately.  
- At the end, check if the entire `pattern` was matched.

---

##  Code (C#)
```csharp
public class Solution {
    public IList<bool> CamelMatch(string[] queries, string pattern) {
        var result = new List<bool>();
        foreach (var q in queries) {
            result.Add(Match(q, pattern));
        }
        return result;
    }

    private bool Match(string query, string pattern) {
        int j = 0;
        foreach (char c in query) {
            if (j < pattern.Length && c == pattern[j]) {
                j++;
            } else if (char.IsUpper(c)) {
                return false;
            }
        }
        return j == pattern.Length;
    }
}
```


##  Complexity
- **Time:** O(Q * L)  
  - Q = number of queries.  
  - L = maximum length of a query string.  
  - Each query is scanned once, character by character, with at most one pass through the pattern.  
- **Space:** O(1)  
  - Only two pointers are used: one for the query and one for the pattern.  
  - No extra data structures are required.

---

##  Pitfalls
- **Pattern completion:**  
  - At the end of the scan, ensure that the entire pattern has been matched (`j == pattern.Length`).  
- **Uppercase mismatch:**  
  - If an uppercase character in the query does not match the current character in the pattern, the query fails immediately.  
- **Lowercase mismatch:**  
  - Lowercase characters can be freely skipped, since they represent allowed insertions.  

---

##  Example Walkthrough
Input:  
`queries = ["FooBarTest"]`  
`pattern = "FB"`

### Step-by-step:
1. `F` in query matches `F` in pattern â†’ advance both pointers.  
2. `oo` are lowercase â†’ skip safely.  
3. `B` in query matches `B` in pattern â†’ advance both pointers.  
4. `ar` are lowercase â†’ skip safely.  
5. `T` is uppercase, but the pattern is already finished â†’ mismatch â†’ fail.  

### Result:
`false`

---

## ðŸŒ³ Visualization
```
Query: F o o B a r T e s t
Pattern: F B
Check: âœ“ - - âœ“ - - âœ—
```



- `âœ“` = uppercase match with pattern.  
- `-` = lowercase characters ignored.  
- `âœ—` = uppercase mismatch (pattern exhausted).  

---

##  Conclusion
The algorithm is essentially a **two-pointer scan**:  
- Uppercase letters must match the pattern in order.  
- Lowercase letters can be ignored.  
- If the pattern is fully consumed and no uppercase mismatches occur, the query matches.


---








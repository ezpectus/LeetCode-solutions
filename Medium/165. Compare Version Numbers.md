# 🧠 LeetCode 165 — Compare Version Numbers

## 🔹 Task Overview

We are given two version strings `version1` and `version2`, each consisting of integer revisions separated by dots (`.`).  
Our goal is to compare them revision by revision, left to right.  
If one version has fewer revisions, treat the missing ones as `0`.  
Leading zeros in revisions are ignored.

### Required Output:
- `1` if `version1 > version2`  
- `-1` if `version1 < version2`  
- `0` if both are equal

---

## 🔹 My Approach

I split both version strings by `.` to get arrays of revisions.  
Then I iterate through both arrays in parallel, comparing each revision as an integer.  
If one array is shorter, I treat missing values as `0`.  
As soon as a difference is found, I return the result.  
If all revisions are equal, I return `0`.

---

## 🔹 Examples

| version1 | version2 | Output | Explanation                          |
|----------|----------|--------|--------------------------------------|
| "1.2"    | "1.10"   | -1     | 2 < 10                               |
| "1.01"   | "1.001"  | 0      | 01 == 001 == 1                       |
| "1.0"    | "1.0.0.0"| 0      | Missing revisions treated as zero    |

---

## 🔹 Constraints

- `1 <= version.length <= 500`  
- Only digits and dots  
- All revisions fit in 32-bit integer

---

## 🔹 C# Solution

```csharp
public class Solution {
    public int CompareVersion(string version1, string version2) {
        string[] v1 = version1.Split('.');
        string[] v2 = version2.Split('.');
        int n = Math.Max(v1.Length, v2.Length);

        for (int i = 0; i < n; i++) {
            int num1 = i < v1.Length ? int.Parse(v1[i]) : 0;
            int num2 = i < v2.Length ? int.Parse(v2[i]) : 0;

            if (num1 > num2) return 1;
            if (num1 < num2) return -1;
        }

        return 0;
    }
}
```

---

## 🔹 Complexity

### ⏱ Time Complexity: `O(n)`
- We iterate through both version arrays once.
- `n = max(v1.Length, v2.Length)` — the longest revision count.
- Each comparison is constant time (`int.Parse` + `if`).
- No nested loops or recursion.

### 🧠 Space Complexity: `O(n)`
- We store two arrays: `v1` and `v2`, each split from the input strings.
- No additional data structures used.
- Space grows linearly with the number of revisions.

---

## 🔹 Conclusion

This solution cleanly handles version comparison by:
- Splitting input strings into revision arrays.
- Iterating with padding logic for unequal lengths.
- Comparing integer values directly, ignoring leading zeros.
- Returning early on mismatch, or `0` if all revisions match.

✅ Robust against edge cases  
✅ Scales up to 500-length inputs  
✅ Easy to read, maintain, and extend


---

# 2457. Minimum Addition to Make Integer Beautiful  
*O(log n) — Greedy Digit-by-Digit Construction*

---

## Problem Statement

Given two positive integers `n` and `target`.

An integer is **beautiful** if the **sum of its digits** is **≤ target**.

Find the **minimum non-negative integer** `x` such that `n + x` is beautiful.  
It is guaranteed that such an `x` always exists.

**Examples**:

**Example 1**  
Input: n = 16, target = 6  
Output: **4**  
16 → digit sum = 7  
16 + 4 = 20 → digit sum = 2 ≤ 6

**Example 2**  
Input: n = 467, target = 6  
Output: **33**  
467 → digit sum = 17  
467 + 33 = 500 → digit sum = 5 ≤ 6

**Example 3**  
Input: n = 1, target = 1  
Output: **0**  
Already beautiful

**Constraints**:
- 1 ≤ n ≤ 10¹²
- 1 ≤ target ≤ 150
- Guaranteed that answer exists

---

## Core Idea — Greedy: Make Number End with Zeros

**Key insight**:
- Adding `x` is equivalent to **increasing** some digits and carrying over
- To **minimize** `x` while reducing digit sum to ≤ target:
  - We want to **zero out** as many low digits as possible (causing carry-over)
  - This turns trailing digits into 0 and reduces sum significantly
- The **minimal x** is the smallest number that makes `n + x` have **digit sum ≤ target**

**Greedy approach**:
1. Convert `n` to string or process digit-by-digit from right to left
2. Compute current digit sum
3. If already ≤ target → return 0
4. Otherwise, we need to **carry over** from some position to reduce sum
5. For each possible position (from right), compute how much to add to make all digits after it zero
6. Choose the **smallest such x** that makes final digit sum ≤ target

**Efficient way**:
- Iterate from the least significant digit
- At each position, calculate how much to add to make this digit and all after it zero (i.e., round up to next power of 10)
- Check if after this addition the digit sum becomes ≤ target

**Clean solution**:

```csharp
public class Solution{
    public long MakeIntegerBeautiful(long n, int target){
        if (DigitSum(n) <= target) return 0;

        long original = n;
        long power = 10;

        while (true){
            long remainder = n % power;
            long toAdd = power - remainder;
            long newNum = original + toAdd;

            if (DigitSum(newNum) <= target) return toAdd;
            
            power *= 10;
        }
    }

    private long DigitSum(long x){
        long sum = 0;
        while (x > 0){
            sum += x % 10;
            x /= 10;
        }
        return sum;
    }
}
```

## Complexity

| **Metric**            | **Value**              | **Notes**                                                                 |
|-----------------------|------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(log n × log n)**   | Digit sum calculation: O(log n) (number of digits)<br>Loop over powers of 10: O(log n) iterations (up to ~13 for n ≤ 10¹²)<br>Each iteration calls digit sum: O(log n) → total O((log n)²) |
| **Space Complexity**  | **O(1)**               | Only a constant number of variables (no extra arrays or data structures) |

**Optimal** — since n ≤ 10¹², log₁₀(n) ≈ 12–13 → extremely fast (negligible number of operations).

---

## Why This Works — Example Walkthrough

**Example 1**: n = 16, target = 6

Initial digit sum = 1 + 6 = **7** > 6

Try power = 10:
- remainder = 16 % 10 = **6**
- toAdd = 10 - 6 = **4**
- newNum = 16 + 4 = **20**
- Digit sum = 2 + 0 = **2** ≤ 6 → return **4** → correct

**Example 2**: n = 467, target = 6

Initial digit sum = 4 + 6 + 7 = **17** > 6

Try power = 10:
- remainder = 467 % 10 = **7**
- toAdd = 10 - 7 = **3**
- newNum = 467 + 3 = **470**
- Digit sum = 4 + 7 + 0 = **11** > 6 → continue

Try power = 100:
- remainder = 467 % 100 = **67**
- toAdd = 100 - 67 = **33**
- newNum = 467 + 33 = **500**
- Digit sum = 5 + 0 + 0 = **5** ≤ 6 → return **33** → correct

**Correct** —  
We greedily try to **round up** `n` to the next number ending with more and more zeros (by adding the minimal amount to reach the next power of 10).  
Each rounding step zeros out the last few digits → significantly reduces the digit sum.  
We take the **smallest such addition** `x` that makes the digit sum of `n + x` ≤ target.

---

## Key Takeaway

This is a **beautiful greedy rounding** problem:

* Compute the current digit sum of `n`
* If already ≤ target → return **0**
* Otherwise, try rounding `n` up to the next multiple of increasing powers of 10 (10, 100, 1000, ...)
* For each power of 10:
  * Compute minimal `x` to add to make the last digits zero (x = power - (n % power))
  * Check if digit sum of (n + x) ≤ target
* Return the **smallest** such `x` that satisfies the condition

**Pure, clean, optimal** — O((log n)²) time (negligible for n ≤ 10¹²), O(1) space, extremely fast, very intuitive, and always finds the minimal non-negative `x`.
---

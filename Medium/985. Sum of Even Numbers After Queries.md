# 985. Sum of Even Numbers After Queries — Architectural Running Even Sum Maintenance  
*O(n + q) — Optimal Precompute + Incremental Update*

---

## Problem Statement

Given integer array `nums` and array of queries `queries[i] = [val, index]`.

For **each query**:
- Add `val` to `nums[index]`
- Compute **sum of all even elements** in the current array

Return array where each element is the even sum **after** the corresponding query.

---

## Core Idea — Maintain Running Sum of Even Numbers

**Brute force** approach:
- For each query → update array → scan whole array to sum evens → O(q × n) → too slow (n,q ≤ 10⁴ → 10⁸)

**Optimal insight**:
- Only **one element** changes per query
- We can **track** the current sum of even numbers
- **Adjust** the sum only for the **affected element**

**Steps**:
1. Precompute **initial even sum** (single pass O(n))
2. For each query:
   - **Before update**: if `nums[index]` is even → subtract it from even sum
   - Apply `nums[index] += val`
   - **After update**: if new `nums[index]` is even → add it to even sum
   - Record current even sum in result

---

##  Implementation (C#)

```csharp
public class Solution {
    public int[] SumEvenAfterQueries(int[] nums, int[][] queries) {
        // Initial sum of even numbers
        int evenSum = 0;
        foreach (int num in nums) {
            if (num % 2 == 0)  evenSum += num;
        }

        int q = queries.Length;
        int[] answer = new int[q];

        for (int i = 0; i < q; i++) {
            int val = queries[i][0];
            int index = queries[i][1];

            // Before update: if current value even → subtract
            if (nums[index] % 2 == 0)  evenSum -= nums[index];
            
            // Apply update
            nums[index] += val;

            // After update: if new value even → add
            if (nums[index] % 2 == 0)  evenSum += nums[index];
            
            answer[i] = evenSum;
        }

        return answer;
    }
}
```


## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n + q)**  | n = nums length, q = queries                   |
| **Space Complexity**  | **O(1)**      | Only answer array (excluding input)            |

**Optimal** — linear time.

---

## Why This Works — Example Walkthrough

**Input**: `nums = [1,2,3,4]`, `queries = [[1,0],[-3,1],[-4,0],[2,3]]`

- **Initial evenSum** = 2 + 4 = **6**

- **Query 1**: +1 at index 0 → `1 → 2`
  - Before: 1 odd → no subtract
  - After: 2 even → add 2 → evenSum = **8**

- **Query 2**: -3 at index 1 → `2 → -1`
  - Before: 2 even → subtract 2 → evenSum = 6
  - After: -1 odd → no add → **6**

- **Query 3**: -4 at index 0 → `2 → -2`
  - Before: 2 even → subtract 2 → evenSum = 4
  - After: -2 even → add -2 → evenSum = **2**

- **Query 4**: +2 at index 3 → `4 → 6`
  - Before: 4 even → subtract 4 → evenSum = -2
  - After: 6 even → add 6 → evenSum = **4**

→ `[8,6,2,4]` correct.

---

## Pitfalls & Edge Cases

- **Negative numbers** → even/odd works correctly (`-2 % 2 == 0`)
- **Zero** → even
- **Large values** → int sufficient
- **All odd** → evenSum = 0
- **All even** → updates handle correctly

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** incremental update problem:

- **Maintain running even sum**
- **Adjust only affected element**
- **Before/after parity check** → precise tracking

**No full array scans. No extra space.**
**Pure, clean, optimal** — perfect for query update problems.

---

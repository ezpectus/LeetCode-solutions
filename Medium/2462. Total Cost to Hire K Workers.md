# Pattern: Greedy Dual Heap Hiring

## ðŸ§  Intuition

When hiring `k` workers from a list of costs, and you're allowed to pick from either end, the optimal strategy is to always hire the cheapest available candidate. 
To simulate this efficiently, use two min-heaps â€” one for the left end and one for the right.
This allows constant-time access to the cheapest candidate from each side.

---

## âš™ï¸ Approach

1. **Initialize two min-heaps**:
   - `leftHeap`: holds up to `candidates` elements from the start
   - `rightHeap`: holds up to `candidates` elements from the end

2. **Fill both heaps**:
   - Use two pointers: `left = 0`, `right = n - 1`
   - Add up to `candidates` elements to each heap, alternating sides

3. **Simulate `k` hires**:
   - At each step:
     - Compare the top of both heaps
     - Hire the cheaper one
     - Add its cost to `totalCost`
     - Remove it from the heap
     - If unprocessed candidates remain between `left` and `right`:
       - Add the next candidate to the same heap
       - Move the corresponding pointer (`left++` or `right--`)

---

## â±ï¸ Complexity

| Metric     | Value                  |
|------------|------------------------|
| Time       | O(k log candidates)    |
| Space      | O(candidates)          |

---

## âš ï¸ Edge Cases

- If `2 * candidates > costs.Length`, heaps may overlap â€” ensure no double-counting
- If one heap becomes empty, always hire from the other
- Avoid out-of-bounds by checking `left <= right` before adding new candidates

---

## ðŸ§© Reusability

This pattern generalizes to any problem where:
- You select elements from both ends of a list
- You need to maintain dynamic access to the minimum
- You refill selection pools as elements are consumed

---

## âœ… Summary

This is a greedy simulation with dynamic heap refill. It balances efficiency with correctness and is ideal for problems involving two-sided selection with cost optimization.





```csharp
public class Solution {
    public long TotalCost(int[] costs, int k, int candidates) {
         int n = costs.Length;
         int left = 0;
         int right = n-1;
       
      var leftHeap = new PriorityQueue<int, int>();
      var rightHeap = new PriorityQueue<int, int>();

    for(int i =0; i < candidates;i++){

        if(left <= right){
            leftHeap.Enqueue(costs[left], costs[left]);
            left++;
        }

        if(left <= right){
            rightHeap.Enqueue(costs[right],costs[right]);
            right--;
           }
       }

           long total = 0;

        for(int j = 0; j < k;j++){
             int leftmin = leftHeap.Count > 0 ? leftHeap.Peek() : int.MaxValue;
             int rightmin = rightHeap.Count > 0 ? rightHeap.Peek() : int.MaxValue;

           if(leftmin <= rightmin){
                total += leftmin;
                leftHeap.Dequeue();

                if(left <= right){
                    leftHeap.Enqueue(costs[left],costs[left]);
                    left++;
                }

           }else{
             total += rightmin;
             rightHeap.Dequeue();

              if(left <= right){
                rightHeap.Enqueue(costs[right],costs[right]);
                right--;

                 }
              }
           }
     return total;

    }
}
```


---

# ğŸŒ¸ FlowerGame â€” Parity-Based Pair Counting

## ğŸ”¹ Problem Statement

Given two integers `n` and `m`, representing ranges `x âˆˆ [1, n]` and `y âˆˆ [1, m]`, count the number of pairs `(x, y)` such that the sum `x + y` is **odd**. These are the winning configurations for Alice.

---

## ğŸ§® Formula (Exact, Not Approximate)

```text
res = evenX * oddY + oddX * evenY
Where:

evenX = n / 2, oddX = n - evenX

evenY = m / 2, oddY = m - evenY
```

This formula counts all pairs where one number is even and the other is odd â€” the only cases where x + y is odd.

## âœ… Why This Formula Works
x + y is odd â‡” x and y have different parity

So we count:

- evenX * oddY â†’ x even, y odd
- oddX * evenY â†’ x odd, y even
- These are the only valid winning pairs for Alice

## âš ï¸ Why It's Better Than `1LL * n * m / 2`

| Approach                          | Accuracy     | Edge Case Handling       | Engineering Value         |
|----------------------------------|--------------|---------------------------|---------------------------|
| `n * m / 2`                      | Approximate  | Breaks on odd `n`, `m`    | Low                       |
| `evenX * oddY + oddX * evenY`   | Exact        | Handles all cases         | High â€” reusable pattern   |

The one-liner `n * m / 2` assumes uniform parity distribution and fails on small or odd-sized inputs.  
Our formula is structurally correct and generalizes to other parity-based problems.


## ğŸ§± Engineering Insight
This is a classic example of class Ã— class intersection counting, where:

You split the domain by parity

You count valid combinations based on structural rules

You avoid brute-force or approximation

This pattern generalizes to:

Game theory (turn-based logic)

DP with parity-based transitions

Combinatorics with parity constraints

## ğŸ’» Code Implementation (C#)

```csharp
public class Solution {
    public long FlowerGame(int n, int m) {
        long evenX = n / 2;
        long oddX = n - evenX;

        long evenY = m / 2;
        long oddY = m - evenY;

        return evenX * oddY + oddX * evenY;
    }
}
```
---

ğŸ§  Where Parity Is a Power Tool
In Dynamic Programming:
Split states by parity (dp_even, dp_odd)

Optimize transitions when moves depend on parity

Model turn-based games with parity-aware logic

In Combinatorics:
Filter impossible configurations via parity

Use parity as an invariant in proofs

Count structures by parity class intersections

## ğŸ§± Architectural Takeaway

Parity isnâ€™t just a math trick â€” itâ€™s a structural lens. Use it to classify states, 
build exact formulas, and prove impossibility.

This problem isnâ€™t a throwaway â€” itâ€™s a +1 to your DP and combinatorics foundation. Keep stacking these insights, 
and when you hit LeetCode hards, youâ€™ll be solving them with architectural clarity, not brute force.



---



# 🌸 FlowerGame — Parity-Based Pair Counting

## 🔹 Problem Statement

Given two integers `n` and `m`, representing ranges `x ∈ [1, n]` and `y ∈ [1, m]`, count the number of pairs `(x, y)` such that the sum `x + y` is **odd**. These are the winning configurations for Alice.

---

## 🧮 Formula (Exact, Not Approximate)

```text
res = evenX * oddY + oddX * evenY
Where:

evenX = n / 2, oddX = n - evenX

evenY = m / 2, oddY = m - evenY
```

This formula counts all pairs where one number is even and the other is odd — the only cases where x + y is odd.

## ✅ Why This Formula Works
x + y is odd ⇔ x and y have different parity

So we count:

- evenX * oddY → x even, y odd
- oddX * evenY → x odd, y even
- These are the only valid winning pairs for Alice

## ⚠️ Why It's Better Than `1LL * n * m / 2`

| Approach                          | Accuracy     | Edge Case Handling       | Engineering Value         |
|----------------------------------|--------------|---------------------------|---------------------------|
| `n * m / 2`                      | Approximate  | Breaks on odd `n`, `m`    | Low                       |
| `evenX * oddY + oddX * evenY`   | Exact        | Handles all cases         | High — reusable pattern   |

The one-liner `n * m / 2` assumes uniform parity distribution and fails on small or odd-sized inputs.  
Our formula is structurally correct and generalizes to other parity-based problems.


## 🧱 Engineering Insight
This is a classic example of class × class intersection counting, where:

You split the domain by parity

You count valid combinations based on structural rules

You avoid brute-force or approximation

This pattern generalizes to:

Game theory (turn-based logic)

DP with parity-based transitions

Combinatorics with parity constraints

## 💻 Code Implementation (C#)

```csharp
public class Solution {
    public long FlowerGame(int n, int m) {
        long evenX = n / 2;
        long oddX = n - evenX;

        long evenY = m / 2;
        long oddY = m - evenY;

        return evenX * oddY + oddX * evenY;
    }
}
```
---

🧠 Where Parity Is a Power Tool
In Dynamic Programming:
Split states by parity (dp_even, dp_odd)

Optimize transitions when moves depend on parity

Model turn-based games with parity-aware logic

In Combinatorics:
Filter impossible configurations via parity

Use parity as an invariant in proofs

Count structures by parity class intersections

## 🧱 Architectural Takeaway

Parity isn’t just a math trick — it’s a structural lens. Use it to classify states, 
build exact formulas, and prove impossibility.

This problem isn’t a throwaway — it’s a +1 to your DP and combinatorics foundation. Keep stacking these insights, 
and when you hit LeetCode hards, you’ll be solving them with architectural clarity, not brute force.



---



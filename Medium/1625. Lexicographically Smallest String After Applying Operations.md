# üß© Pattern Name  
**BFS over String Transformations with State Deduplication**

---

## üß† Problem Type  
**State-space traversal with lexicographic optimization**  
You're given a string `s` of even length and two operations:

- Add `a` to all digits at **odd indices** (modulo 10)
- Rotate the string to the **right by `b` positions**

**Goal:** Find the lexicographically smallest string reachable via any sequence of operations.

---

## üîç Problem Anatomy

| Element      | Role                                                |
|--------------|-----------------------------------------------------|
| `s`          | Initial state (string of digits)                    |
| `a`, `b`     | Parameters for digit addition and rotation          |
| State space  | All strings reachable via any sequence of ops       |
| Goal         | Find minimal string in lex order among all states   |

---

## ‚öôÔ∏è Algorithm Match  
This is a classic **BFS over state space** problem:

- Each string is a **node**  
- Each operation is an **edge** to a new state  
- We explore all reachable states using BFS  
- Use a `HashSet` to avoid revisiting states  
- Track the **lex smallest string** seen so far

---

## ‚úÖ C# Implementation

```csharp
public class Solution {
    public string FindLexSmallestString(string s, int a, int b) {
        var seen = new HashSet<string>();
        var q = new Queue<string>();
        string small = s;

        q.Enqueue(s);
        seen.Add(s);

        while (q.Count > 0) {
            string curr = q.Dequeue();
            if (string.Compare(curr, small) < 0) small = curr;

            // Operation 1: Add 'a' to odd indices
            char[] ch = curr.ToCharArray();
            for (int i = 1; i < ch.Length; i += 2)
                ch[i] = (char)(((ch[i] - '0' + a) % 10) + '0');
            string added = new string(ch);
            if (seen.Add(added)) q.Enqueue(added);

            // Operation 2: Rotate right by 'b'
            string rotated = curr[^b..] + curr[..^b];
            if (seen.Add(rotated)) q.Enqueue(rotated);
        }

        return small;
    }
}
```

## ‚è±Ô∏è Time and Space Complexity

| Metric           | Value               | Explanation                                      |
|------------------|---------------------|--------------------------------------------------|
| Time Complexity  | O(N √ó 10^{N/2})     | Bounded by number of unique states (digits + rotations) |
| Space Complexity | O(N √ó 10^{N/2})     | For visited states and queue                    |

---

## üß† Architectural Commentary

- State deduplication via `HashSet<string>` prevents cycles  
- Lexicographic tracking is done inline during BFS  
- Operations are local and reversible, but BFS ensures minimal string is found first  
- Rotation and digit addition are implemented cleanly with slicing and char math

---

## üßæ Final Takeaway

This is a textbook example of **BFS over a finite transformation space**, where:

- The state is a string  
- Transitions are deterministic and bounded  
- Goal is to find optimal state under lexicographic ordering  

The key is to **explore all reachable states while avoiding revisits**, and **track the best** as you go.



---

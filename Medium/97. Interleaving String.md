# 🧩 Interleaving String — DFS with Memoization
Problem: Given three strings s1, s2, and s3, determine if s3 is formed by an interleaving of s1 and s2.

# 🧠 Core Idea
- Use Depth-First Search (DFS) with memoization to explore all valid interleavings of s1 and s2 that could form s3.
- At each step, we try to match the current character in s3 with either s1[i] or s2[j], preserving the order of characters.

# 🧱 State Definition

- i: current index in s1
- j: current index in s2
- k = i + j: current index in s3
- memo[(i, j)]: stores whether the substring starting at (i, j) leads to a valid interleaving

✅ Base Case
```csharp
if (i == s1.Length && j == s2.Length)
    return true;
```
We’ve consumed all characters from s1 and s2, and successfully matched s3.

# 🔁 Transitions

- If s1[i] == s3[k], recurse with DFS(i + 1, j)
- If s2[j] == s3[k], recurse with DFS(i, j + 1)
- If neither path works, memoize (i, j) as false

# 🧪 Early Exit
Before starting DFS, check if the total length of s1 and s2 matches s3. If not, return false.

```csharp
if (s1.Length + s2.Length != s3.Length)
    return false;
```

## Code :
```csharp
public class Solution {
    public bool IsInterleave(string s1, string s2, string s3) {
        if (s1.Length + s2.Length != s3.Length)
            return false;

        var memo = new Dictionary<(int, int), bool>();
        return DFS(0, 0);

        bool DFS(int i, int j) {
            if (i == s1.Length && j == s2.Length)
                return true;

            if (memo.ContainsKey((i, j)))
                return memo[(i, j)];

            int k = i + j;

            if (i < s1.Length && s1[i] == s3[k] && DFS(i + 1, j)) {
                memo[(i, j)] = true;
                return true;
            }

            if (j < s2.Length && s2[j] == s3[k] && DFS(i, j + 1)) {
                memo[(i, j)] = true;
                return true;
            }

            memo[(i, j)] = false;
            return false;
        }
    }
}
```

---

# LeetCode #3217  
**Delete Nodes From Linked List Present in Array**  
**Difficulty:** Medium  

---

##  Problem Description & Constraints  

### What We Are Given  
- `int[] nums` — **array of unique integers** that we **must delete** from the list  
- `ListNode head` — **head of a singly linked list**  
- Each node has: `int val` and `ListNode next`  

### What We Must Return  
- **Head** of the **modified list** after **removing every node** whose `val` is in `nums`  

### Constraints (and what they tell us)  
| Constraint | Meaning |
|-----------|--------|
| `1 ≤ nums.length ≤ 10⁵` | Up to 100,000 values to delete → **must be fast lookup** |
| `1 ≤ Node.val ≤ 10⁵` | Values are bounded → could use array, but `HashSet` is fine |
| **All `nums[i]` are unique** | No duplicates → `HashSet` is safe |
| `1 ≤ list length ≤ 10⁵` | Must be **O(n)** time |
| **At least one node remains** | No need to handle empty list return |

> **Conclusion from constraints**:  
> We need **O(1) lookup** for deletion + **safe in-place deletion** in a linked list.

---

##  Core Algorithm Idea  

### The Problem with Direct Deletion  
```csharp
if (head.val == 1) head = head.next;  // WRONG
```
-> **Breaks the chain. Memory leak. Later nodes lost.**

---

### The Solution: **Dummy Node + HashSet + Two Pointers**

| Tool | Why We Use It |
|------|---------------|
| `HashSet<int>` | `Contains(val)` in **O(1)** → fast ban check |
| `dummy` node | **Fake head** → allows **safe deletion of real head** |
| `prev` pointer | Points to **last valid node** |
| `curr` pointer | Scans **every node** |

---

##  Concept in Simple Terms  

> **"Walk through the list. If a node is banned — skip it. If it's good — remember it as the last good one. Use a fake node at the start so you never lose the list."**

---

##  Full C# Solution  

```csharp
public class Solution {
    public ListNode ModifiedList(int[] nums, ListNode head) {
        // Step 1: Fast ban check
        var banned = new HashSet<int>(nums);
        
        // Step 2: Safety net
        var dummy = new ListNode(0);
        dummy.next = head;
        
        // Step 3: Two pointers
        var prev = dummy;
        var curr = head;
        
        // Step 4: Scan and delete
        while (curr != null) {
            if (banned.Contains(curr.val)) {
                prev.next = curr.next;  // Skip banned node
            } else {
                prev = curr;             // Keep good node
            }
            curr = curr.next;            // Always move forward
        }
        
        return dummy.next;
    }
}
```

##  Architectural Breakdown  

| Component | Role | How It Works |
|---------|------|-------------|
| `HashSet<int> banned` | **Lookup Engine** | Stores all values from `nums`. `Contains(val)` runs in **O(1)** average time — instantly tells if a node should be deleted |
| `ListNode dummy` | **Safety Layer** | A **fake node** placed before the real `head`. `dummy.next = head`. Allows us to **safely delete the head** without special logic. The final result is always `dummy.next` |
| `prev` | **Anchor** | Always points to the **last valid (non-deleted) node**. Acts as the **connection point** for the next valid node |
| `curr` | **Scanner** | Moves through **every node** in the list, one by one. It's the **decision point**: check `curr.val` and decide — keep or delete |
| `prev.next = curr.next` | **Deletion** | **Bypasses** the current node. Removes `curr` from the chain by linking `prev` directly to the node after `curr` |
| `prev = curr` | **Keep** | Updates the anchor to the current node **only when it's safe**. This ensures `prev` always stays on the **last good node** |
| `curr = curr.next` | **Progress** | **Always advances** the scanner to the next node, regardless of deletion. Ensures we visit **every node** exactly once |

---

##  Step-by-Step Execution (Example)  

**Input**:  
`nums = [1,2,3]`  
`head = 1→2→3→4→5`  

| `curr.val` | Banned? | Action | `prev` | `prev.next` |
|------------|---------|--------|--------|-------------|
| 1 | Yes | `prev.next = 2` | `dummy` | `→ 2` |
| 2 | Yes | `prev.next = 3` | `dummy` | `→ 3` |
| 3 | Yes | `prev.next = 4` | `dummy` | `→ 4` |
| 4 | No  | `prev = 4` | `4` | — |
| 5 | No  | `prev = 5` | `5` | — |

**Final list**: `4→5`  
**Return**: `dummy.next` → points to `4`

---

##  Pro Tips & Optimizations  

| Tip | Why It Matters |
|-----|----------------|
| **Use `HashSet` not `List`** | `List.Contains()` is **O(k)** → too slow for `k=10⁵`. `HashSet` is **O(1)** average |
| **`dummy` is mandatory** | Without it, deleting the head requires special `if` logic. With dummy — **one unified flow** |
| **`prev` moves only on good nodes** | If 100 banned nodes in a row — `prev` stays put. When a good node appears — it connects instantly |
| **No extra space beyond `HashSet`** | Only `O(k)` memory for lookup. No arrays, no recursion, no temp lists |

---

##  Key Takeaway  

> **Never delete `head` directly. Never scan `nums`.**  
> **Always use:**  
> `dummy` + `HashSet` + `prev`/`curr`  

This pattern works for **any** in-place linked list deletion by value.

---

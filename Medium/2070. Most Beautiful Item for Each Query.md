# 2070. Most Beautiful Item for Each Query  
*O(m log m + q log m) — Sorting + Binary Search*

---

## Problem Statement

You are given a 2D array `items` where `items[i] = [pricei, beautyi]` represents an item with price `pricei` and beauty `beautyi`.

You are also given an array `queries` where for each `queries[j]`, you need to find the **maximum beauty** among all items whose price is **≤ queries[j]**.  
If no such item exists → return **0** for that query.

Return an array `answer` of length `queries.length` where `answer[j]` is the result for `queries[j]`.

**Constraints**:
- 1 ≤ items.length, queries.length ≤ 10⁵
- 1 ≤ pricei, beautyi, queries[j] ≤ 10⁹

---

## Core Idea — Sort Items + Binary Search per Query

**Key insight**:
- We want, for each query price Q, max beauty among all items with price ≤ Q
- To answer multiple such queries efficiently → **sort** items by price
- Then for each query → **binary search** the rightmost item with price ≤ Q
- But we need **maximum beauty** among all such items (not just the last one)
- So we must ensure that as price increases, we keep track of the **maximum beauty seen so far**

**Steps**:
1. Sort `items` by **price** ascending
2. Create a "max beauty prefix" array:
   - After sorting, iterate through items
   - Keep track of the maximum beauty seen up to current price
   - Store in a list or array: maxBeautyUpToThisPrice
3. For each query Q:
   - Binary search in the sorted items to find the rightmost position where price ≤ Q
   - The max beauty for this query = max beauty seen up to that position

**Time**:
- Sorting items: O(m log m)
- Building prefix max beauty: O(m)
- For each query: binary search O(log m) → total O(q log m)
- Overall: **O(m log m + q log m)** — very fast for 10⁵

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int[] MaximumBeauty(int[][] items, int[] queries) {
        int m = items.Length;
        int q = queries.Length;

        // Sort items by price ascending
        Array.Sort(items, (a, b) => a[0].CompareTo(b[0]));

        // Build prefix max beauty: max beauty for all items with price <= items[i][0]
        int[] prefixMax = new int[m];
        prefixMax[0] = items[0][1];
        for (int i = 1; i < m; i++) prefixMax[i] = Math.Max(prefixMax[i - 1], items[i][1]);
        
        int[] answer = new int[q];
        for (int qi = 0; qi < q; qi++) {
            int Q = queries[qi];

            // Binary search: find rightmost index where items[idx][0] <= Q
            int left = 0, right = m - 1;
            int pos = -1;

            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (items[mid][0] <= Q) {
                    pos = mid;
                    left = mid + 1;
                } 
                else right = mid - 1;   
            }

            // If no item with price <= Q → 0
            answer[qi] = (pos == -1) ? 0 : prefixMax[pos];
        }

        return answer;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(m log m + q log m)** | Sorting items by price: O(m log m)  
Building prefix maximum beauty array: O(m)  
For each query: binary search on sorted prices → O(log m) per query  
Total: **O(m log m + q log m)** |
| **Space Complexity**  | **O(m)**              | prefixMax array: O(m)  
Sorting overhead: O(log m) or O(m) depending on implementation |

**Optimal** — one-time sorting + logarithmic-time queries — perfectly efficient for m, q ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]

- After sorting by price ascending: [[1,2], [2,4], [3,2], [3,5], [5,6]]

- Build prefix maximum beauty:
  - Up to price 1: max beauty = 2
  - Up to price 2: max(2, 4) = 4
  - Up to price 3: max(4, 2, 5) = 5
  - Up to price 5: max(5, 6) = 6

- Queries:
  - Q=1: rightmost price ≤1 → index 0 → prefix max = **2**
  - Q=2: ≤2 → index 1 → prefix max = **4**
  - Q=3: ≤3 → index 3 → prefix max = **5**
  - Q=4: ≤4 → index 3 → prefix max = **5**
  - Q=5: ≤5 → index 4 → prefix max = **6**
  - Q=6: ≤6 → index 4 → prefix max = **6**

Output: **[2,4,5,5,6,6]** → correct

**Correct** —  
Sorting by price once allows efficient binary search for each query to find the highest index where price ≤ query value.  
The precomputed prefix maximum beauty at that index gives exactly the highest beauty among all items with price ≤ query.

---

## Key Takeaway

This is a **classic offline range maximum query** problem solved elegantly with sorting + prefix max:

* Sort all items by **price** in ascending order
* Build a **prefix maximum beauty** array:
  - prefixMax[i] = maximum beauty among the first i+1 items (all with price ≤ items[i][0])
* For each query Q:
  * Use **binary search** to find the rightmost index where items[index][0] ≤ Q
  * If no such index → answer = 0
  * Otherwise → answer = prefixMax[index]

**Pure, clean, optimal** — O(m log m) preprocessing + O(q log m) queries, O(m) space, very fast and straightforward.

---

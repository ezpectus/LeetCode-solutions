# LeetCode 341 — Flatten Nested List Iterator  
**Approach: Stack Simulation of Iterator**

---

##  Problem Restatement
You need to implement an iterator that flattens a nested list of integers (`NestedInteger`).  
Each element is either an integer or another list. The iterator should return integers in the correct order.

---

##  Core Idea
- Use a **stack** to store the current traversal state.  
- In the constructor, push the entire `nestedList` onto the stack (in reverse order so the first element is on top).  
- In `HasNext()`, expand the top of the stack until you find an integer.  
- In `Next()`, simply pop and return the integer.  

This way, the list is flattened lazily — only when needed.

---

##  Implementation (C#)

```csharp
public class NestedIterator {
    private Stack<NestedInteger> stack;

    public NestedIterator(IList<NestedInteger> nestedList) {
        stack = new Stack<NestedInteger>();
        // push in reverse order so the first element is on top
        for (int i = nestedList.Count - 1; i >= 0; i--) {
            stack.Push(nestedList[i]);
        }
    }

    public bool HasNext() {
        while (stack.Count > 0) {
            var top = stack.Peek();
            if (top.IsInteger()) {
                return true; // found integer
            }
            stack.Pop();
            var list = top.GetList();
            for (int i = list.Count - 1; i >= 0; i--) {
                stack.Push(list[i]); // expand nested list
            }
        }
        return false;
    }

    public int Next() {
        return stack.Pop().GetInteger();
    }
}
```




##  Time Complexity
- **Push/Pop Operations:**  
  Each element (integer or list) is pushed and popped from the stack at most once.  
  → `O(n)` total, where `n` is the total number of integers across all nested lists.  

- **HasNext():**  
  Expands lists lazily. Each expansion is amortized constant time because every element is processed once.  
  → `O(1)` amortized per call.  

- **Next():**  
  Pops and returns the top integer.  
  → `O(1)`.

---

##  Space Complexity
- **Stack:**  
  Holds at most all elements during traversal.  
  → `O(n)`.  

- **Auxiliary structures:**  
  No extra data structures beyond the stack.  
  → `O(1)` additional space.  

---

#  Impact of Design Choices

| Design Choice                  | Effect                                                                 |
|--------------------------------|------------------------------------------------------------------------|
| **Stack with reverse push**    | Ensures correct iteration order by keeping the first element on top.   |
| **Lazy expansion in HasNext**  | Avoids flattening the entire list upfront, saving both time and memory.|
| **Separation of HasNext/Next** | Matches iterator contract, provides a clean and predictable API.       |

---

#  Pitfalls
- **Flattening entire list upfront:**  
  Wastes memory and time, especially for deeply nested structures.  
- **Not pushing in reverse order:**  
  Breaks iteration order, returning elements in the wrong sequence.  
- **Not expanding lists in HasNext():**  
  Can cause `Next()` to return non‑integer values or fail unexpectedly.  

---

#  Conclusion
- **What it gives:** A clean iterator that lazily flattens nested lists.  
- **Why it matters:** Efficient, avoids unnecessary work, respects iterator contract.  
- **Key takeaway:**  
  1. Use a stack to manage traversal.  
  2. Expand nested lists inside `HasNext()`.  
  3. Return integers in `Next()` with amortized `O(1)` efficiency.  

This design achieves **`O(n)` time** and **`O(n)` space** overall, while keeping iteration order correct and memory usage optimal.


---

# üß† 984. String Without AAA or BBB ‚Äî Fichka

## üìå Problem Summary
We need to construct a string of length `a + b` containing exactly:
- `a` occurrences of `'a'`
- `b` occurrences of `'b'`

Constraints:
- The substring `"aaa"` must **not** appear
- The substring `"bbb"` must **not** appear

It is guaranteed that such a string exists.

---

## üß± Core Idea
This is a **greedy construction problem**:
- We must balance `'a'` and `'b'` so that neither appears three times consecutively.
- At each step, we decide whether to append `'a'` or `'b'` based on:
  1. Which character has more remaining count (`a > b` or `b > a`)
  2. Whether we already placed two consecutive of the same character (avoid `"aaa"` or `"bbb"`)

---

## ‚úÖ Pattern
- Track consecutive counts: `curra` and `currb`
- If `'a'` is more frequent and we haven‚Äôt placed two `'a'`s in a row ‚Üí place `'a'`
- Otherwise, place `'b'`
- Reset the opposite counter each time we switch

---

## üöÄ Code (C#)

```csharp
public class Solution {
    public string StrWithout3a3b(int a, int b) {
        string res = "";
        int curra = 0, currb = 0;

        while (a > 0 || b > 0) {
            if ((a > b && curra < 2) || (a > 0 && currb == 2)) {
                res += "a";
                curra++;
                currb = 0;
                a--;
            } else {
                res += "b";
                currb++;
                curra = 0;
                b--;
            }
        }

        return res;
    }
}
```

## ‚è±Ô∏è Complexity
- **Time:** O(a + b) ‚Äî we place each character exactly once, so runtime grows linearly with string length.  
- **Space:** O(1) ‚Äî aside from the result string itself, we only maintain two counters (`curra`, `currb`) to track consecutive characters.  

---

## ‚ö†Ô∏è Pitfalls
- **Avoid forbidden substrings:** You must ensure `"aaa"` and `"bbb"` never appear. This requires tracking consecutive counts of each character.  
- **Prioritize majority character:** Always place the character with the larger remaining count first, unless doing so would create three in a row.  
- **Reset counters correctly:** When switching from `'a'` to `'b'` (or vice versa), reset the opposite counter to zero. Otherwise, you risk miscounting and allowing invalid substrings.  
- **Edge cases:** When counts are equal, either character can be chosen, but you must still respect the consecutive limit.  

---

## ‚úÖ Sanity Checks
- Input: `a = 1, b = 2` ‚Üí `"abb"` (valid, no `"aaa"` or `"bbb"`)  
- Input: `a = 4, b = 1` ‚Üí `"aabaa"` (valid, balanced placement avoids `"aaa"`)  
- Input: `a = 3, b = 3` ‚Üí `"ababab"` or `"aabbab"` (both valid, alternating pattern prevents triples)  

---

## üëâ Key takeaway
This is a **greedy balancing construction problem**:
- At each step, place the majority character unless it risks forming `"aaa"` or `"bbb"`.  
- By carefully tracking consecutive counts, we guarantee validity while consuming all characters.  
- The algorithm is **linear-time** and **constant-space**, making it both elegant and efficient.  

In short: **Greedy placement + consecutive tracking = safe, valid string construction.**


---

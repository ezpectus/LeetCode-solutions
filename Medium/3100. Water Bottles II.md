# 🧪 LeetCode 3100 — Water Bottles II

## 📜 Problem Summary

You start with `numBottles` full water bottles.  
Each time you drink a bottle, it becomes empty.  
You can exchange `numExchange` empty bottles for **1 full bottle**, and after each exchange, `numExchange` increases by 1.

Return the **maximum number of bottles you can drink**.

---

## 🧠 Core Mechanics

This is a **greedy simulation** problem with a dynamic constraint:

- ✅ You can drink any number of full bottles → they become empty
- ✅ You can exchange **exactly one batch** of `numExchange` empty bottles for 1 full bottle
- ⚠️ After each exchange, `numExchange` increases by 1
- ❌ You cannot perform multiple exchanges in one step

> The key is to simulate the process step-by-step, tracking full bottles, empty bottles, and the evolving exchange rate.

---

## 🧪 Example Walkthrough

**Input:** `numBottles = 13`, `numExchange = 6`  
**Output:** `15`

| Step | Full | Empty | Exchange Rate | Action              |
|------|------|-------|----------------|---------------------|
| 0    | 13   | 0     | 6              | Drink all → 13 empty |
| 1    | 0    | 13    | 6              | Exchange 6 → +1 full, rate → 7 |
| 2    | 1    | 8     | 7              | Drink 1 → 9 empty   |
| 3    | 0    | 9     | 7              | Exchange 7 → +1 full, rate → 8 |
| 4    | 1    | 3     | 8              | Drink 1 → 4 empty   |
| 5    | 0    | 4     | 8              | Not enough to exchange |

**Total drunk:** `13 + 1 + 1 = 15 bottles`

---

## 🚀 C# Implementation

```csharp
public class Solution {
    public int MaxBottlesDrunk(int numBottles, int numExchange) {
        int totalDrunk = numBottles;
        int empty = numBottles;

        while (empty >= numExchange) {
            empty -= numExchange;
            totalDrunk += 1;
            empty += 1;
            numExchange += 1;
        }

        return totalDrunk;
    }
}

```
## ✅ Complexity Analysis

| Metric       | Value                          | Explanation                                      |
|--------------|----------------------------------|--------------------------------------------------|
| Time         | O(numBottles + exchanges)       | Each drink and exchange is a constant-time step |
| Space        | O(1)                            | Only counters are used                          |
| Stability    | High                            | No recursion, no branching                      |
| Scalability  | Excellent for constraints ≤ 100 | Handles all valid inputs efficiently            |

---

## 🧠 Engineering Takeaway

This problem teaches:

- 🔁 How to simulate **greedy exchange logic** with evolving constraints  
- 🔄 How to track **state transitions**: full ↔ empty ↔ full  
- 📈 How to handle **dynamic parameters** (`numExchange` increases after each use)  
- 🧮 Why **step-by-step simulation** is better than overfitting formulas

> When exchange rules evolve over time, simulate explicitly — don’t shortcut with static math.

> This is a classic example of **state modeling**: track resources, apply rules, and evolve the system.

---

## 🧱 Architectural Pattern

- **State Variables**: `full`, `empty`, `numExchange`  
- **Loop Invariant**: While `empty >= numExchange`, perform one exchange  
- **Greedy Principle**: Always exchange when possible, but respect the evolving cost

This pattern generalizes to:

- 🔄 Resource recycling systems  
- 🎮 Token-based game mechanics  
- 🧮 Dynamic cost models in simulations

> The architecture is simple but powerful — a loop, a rule, and a state tracker.


---


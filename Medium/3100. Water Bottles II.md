# ðŸ§ª LeetCode 3100 â€” Water Bottles II

## ðŸ“œ Problem Summary

You start with `numBottles` full water bottles.  
Each time you drink a bottle, it becomes empty.  
You can exchange `numExchange` empty bottles for **1 full bottle**, and after each exchange, `numExchange` increases by 1.

Return the **maximum number of bottles you can drink**.

---

## ðŸ§  Core Mechanics

This is a **greedy simulation** problem with a dynamic constraint:

- âœ… You can drink any number of full bottles â†’ they become empty
- âœ… You can exchange **exactly one batch** of `numExchange` empty bottles for 1 full bottle
- âš ï¸ After each exchange, `numExchange` increases by 1
- âŒ You cannot perform multiple exchanges in one step

> The key is to simulate the process step-by-step, tracking full bottles, empty bottles, and the evolving exchange rate.

---

## ðŸ§ª Example Walkthrough

**Input:** `numBottles = 13`, `numExchange = 6`  
**Output:** `15`

| Step | Full | Empty | Exchange Rate | Action              |
|------|------|-------|----------------|---------------------|
| 0    | 13   | 0     | 6              | Drink all â†’ 13 empty |
| 1    | 0    | 13    | 6              | Exchange 6 â†’ +1 full, rate â†’ 7 |
| 2    | 1    | 8     | 7              | Drink 1 â†’ 9 empty   |
| 3    | 0    | 9     | 7              | Exchange 7 â†’ +1 full, rate â†’ 8 |
| 4    | 1    | 3     | 8              | Drink 1 â†’ 4 empty   |
| 5    | 0    | 4     | 8              | Not enough to exchange |

**Total drunk:** `13 + 1 + 1 = 15 bottles`

---

## ðŸš€ C# Implementation

```csharp
public class Solution {
    public int MaxBottlesDrunk(int numBottles, int numExchange) {
        int totalDrunk = numBottles;
        int empty = numBottles;

        while (empty >= numExchange) {
            empty -= numExchange;
            totalDrunk += 1;
            empty += 1;
            numExchange += 1;
        }

        return totalDrunk;
    }
}

```
## âœ… Complexity Analysis

| Metric       | Value                          | Explanation                                      |
|--------------|----------------------------------|--------------------------------------------------|
| Time         | O(numBottles + exchanges)       | Each drink and exchange is a constant-time step |
| Space        | O(1)                            | Only counters are used                          |
| Stability    | High                            | No recursion, no branching                      |
| Scalability  | Excellent for constraints â‰¤ 100 | Handles all valid inputs efficiently            |

---

## ðŸ§  Engineering Takeaway

This problem teaches:

- ðŸ” How to simulate **greedy exchange logic** with evolving constraints  
- ðŸ”„ How to track **state transitions**: full â†” empty â†” full  
- ðŸ“ˆ How to handle **dynamic parameters** (`numExchange` increases after each use)  
- ðŸ§® Why **step-by-step simulation** is better than overfitting formulas

> When exchange rules evolve over time, simulate explicitly â€” donâ€™t shortcut with static math.

> This is a classic example of **state modeling**: track resources, apply rules, and evolve the system.

---

## ðŸ§± Architectural Pattern

- **State Variables**: `full`, `empty`, `numExchange`  
- **Loop Invariant**: While `empty >= numExchange`, perform one exchange  
- **Greedy Principle**: Always exchange when possible, but respect the evolving cost

This pattern generalizes to:

- ðŸ”„ Resource recycling systems  
- ðŸŽ® Token-based game mechanics  
- ðŸ§® Dynamic cost models in simulations

> The architecture is simple but powerful â€” a loop, a rule, and a state tracker.


---


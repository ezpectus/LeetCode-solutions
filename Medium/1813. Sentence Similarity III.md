# 1813. Sentence Similarity III — Architectural Two-Pointer Prefix/Suffix Matching  
*O(n + m) — Optimal Linear Check for Insertable Sentence*

---

## Problem Statement

You are given two strings `sentence1` and `sentence2`, each consisting of words separated by single spaces (no leading/trailing spaces).

Two sentences are **similar** if you can insert an arbitrary sentence (possibly empty) into **one** of them (at any position, including start or end) such that they become equal.

- The inserted sentence must be separated from existing words by spaces.
- Return `true` if they are similar, `false` otherwise.

---

## Core Idea — Check Prefix + Suffix Match with One Insertion

**Key insight**:
- Inserting a sentence into one string to match the other means:
  - One sentence is a **prefix** of the other + some middle part + a **suffix**
  - Or one is completely inside the other as a substring (with spaces)
- But since insertion is into **one** sentence, the other must match either:
  - Prefix of s1 + inserted + suffix of s1 == s2
  - Or vice versa
- Equivalent to: after removing a **common prefix** and a **common suffix**, the remaining middle part of **one** sentence must be empty.

**Algorithm**:
1. Split both sentences into arrays of words: `words1` and `words2`
2. Find the length of the **longest common prefix** (words from start match)
3. Find the length of the **longest common suffix** (words from end match)
4. Check if the **non-matching middle parts** of both sentences have length 0 after removing prefix + suffix
   - i.e., one sentence's middle must be empty (the inserted part covers the difference)

**Why it works**:
- Common prefix + inserted sentence + common suffix = the longer sentence
- The shorter sentence must be prefix + suffix with nothing in middle

---

## Full Optimal Implementation (C#)

```csharp
public class Solution {
    public bool AreSentencesSimilar(string sentence1, string sentence2) {
        string[] words1 = sentence1.Split(' ');
        string[] words2 = sentence2.Split(' ');

        int m = words1.Length;
        int k = words2.Length;

        // Find longest common prefix
        int prefix = 0;
        while (prefix < m && prefix < k && words1[prefix] == words2[prefix]) {
            prefix++;
        }

        // Find longest common suffix (from the end)
        int suffix = 0;
        while (suffix < m - prefix && suffix < k - prefix && 
               words1[m - 1 - suffix] == words2[k - 1 - suffix]) {
            suffix++;
        }

        // After removing prefix + suffix, one sentence must have nothing left in middle
        // i.e. prefix + suffix must cover the entire shorter sentence
        return prefix + suffix >= Math.Min(m, k);
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n + m)**          | Splitting strings into words O(n + m), then linear two-pointer scan for prefix + suffix (n, m = number of words ≤ 100) |
| **Space Complexity**  | **O(n + m)**          | Arrays for split words (total words ≤ 100)     |

**Optimal** — extremely fast, constraints are tiny (sentences ≤ 100 characters → very few words).

---

## Why This Works — Example Walkthrough

**Example 1**: `sentence1 = "My name is Haley"`, `sentence2 = "My Haley"`

- words1 = ["My", "name", "is", "Haley"] (length 4)
- words2 = ["My", "Haley"] (length 2)
- Longest common prefix = 1 ("My")
- Longest common suffix = 1 ("Haley")
- prefix + suffix = 2 ≥ min(4,2) = 2 → **true** → correct  
  (insert "name is" between "My" and "Haley")

**Example 2**: `sentence1 = "of"`, `sentence2 = "A lot of words"`

- words1 = ["of"] (length 1)
- words2 = ["A", "lot", "of", "words"] (length 4)
- Common prefix = 0
- Common suffix = 0 (or 1 "of" but positions don't align after prefix)
- 0 + 0 < 1 → **false** → correct  
  (no way to insert to make them equal)

**Example 3**: `sentence1 = "Eating right now"`, `sentence2 = "Eating"`

- words1 = ["Eating", "right", "now"] (length 3)
- words2 = ["Eating"] (length 1)
- Common prefix = 1 ("Eating")
- Common suffix = 0 (no match at end after prefix)
- prefix + suffix = 1 ≥ 1 → **true** → correct  
  (insert "right now" at the end of sentence2)

**Correct** — the condition `prefix + suffix ≥ length of shorter sentence` exactly checks if one sentence can be obtained by inserting some middle sentence into the other (possibly empty insertion).

---

## Pitfalls & Edge Cases

- **Identical sentences** → common prefix = full length → true
- **One sentence empty** → impossible unless both empty (but constraints length ≥ 1)
- **No common prefix or suffix** → only true if shorter sentence has length 0 (impossible)
- **Same words appear multiple times** → handled correctly by exact matching
- **Very short sentences** → fast and correct

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** string similarity problem with one insertion:

- Split both sentences into arrays of words
- Compute **longest common prefix** (from start)
- Compute **longest common suffix** (from end)
- Check if `prefix length + suffix length ≥ length of shorter sentence`
  → means the shorter sentence is exactly the prefix + suffix of the longer one (middle part can be inserted)

**Pure, clean, optimal** — perfect two-pointer prefix/suffix check for sentence similarity via single insertion.
---

# 918. Maximum Sum Circular Subarray

## 🧠 Problem Summary

You're given a circular integer array `nums` of length `n`. A circular array means the last element connects to the first, forming a loop. Your task is to find the **maximum possible sum of a non-empty subarray**, where each element is used at most once.

A subarray is a contiguous slice of the array. In circular arrays, subarrays can wrap around the end to the beginning.

---

## 📌 Key Insight

There are two types of subarrays to consider:

- **Non-wrapping subarray** — standard Kadane’s algorithm applies.
- **Wrapping subarray** — the maximum sum is achieved by excluding the minimum subarray from the total sum.

We compute:

- `maxSum`: maximum subarray sum (Kadane)
- `minSum`: minimum subarray sum (Kadane-style)
- `total`: sum of all elements

Then compare:

- If all numbers are negative → return `maxSum` directly
- Otherwise → return `max(maxSum, total - minSum)`

---

## ⚙️ Algorithm Steps

**Initialize:**
- `total = 0`
- `maxSum = -∞`, `currMax = 0`
- `minSum = ∞`, `currMin = 0`

**Iterate through `nums`:**
- Update `currMax = max(currMax + num, num)`
- Update `maxSum = max(maxSum, currMax)`
- Update `currMin = min(currMin + num, num)`
- Update `minSum = min(minSum, currMin)`
- Accumulate `total += num`

**Return:**
- If `maxSum > 0`: `max(maxSum, total - minSum)`
- Else: `maxSum` (all elements are negative)

---

## 📦 Code (C#)

```csharp
public class Solution {
    public int MaxSubarraySumCircular(int[] nums) {
        int total = 0;
        int currMax = 0, maxSum = int.MinValue;
        int currMin = 0, minSum = int.MaxValue;

        foreach (int num in nums) {
            currMax = Math.Max(currMax + num, num);
            maxSum = Math.Max(maxSum, currMax);

            currMin = Math.Min(currMin + num, num);
            minSum = Math.Min(minSum, currMin);

            total += num;
        }

        return maxSum > 0 ? Math.Max(maxSum, total - minSum) : maxSum;
    }
}
```


## 🧮 Complexity

| Metric | Value |
|--------|-------|
| Time   | O(n)  |
| Space  | O(1)  |

Single pass through the array with constant space — efficient for large inputs (up to 30,000 elements).

---

## 🔍 Edge Cases

- **All elements negative**  
  Wrapping is invalid since `total - minSum` would be zero or negative.  
  → Return `maxSum` directly (the least negative element).

- **Single element**  
  No wrapping possible.  
  → Return that element.

- **Wrapping includes both ends**  
  Happens when the optimal subarray wraps around the array.  
  → Handled via `total - minSum`, which excludes the worst segment to maximize the rest.

---

## 🧘 Insights for Training

- **Dual Kadane logic**  
  You train both max and min subarray tracking in one pass — symmetry matters.

- **Wrap-around via exclusion**  
  Instead of building the circular subarray directly, you subtract the worst part — this inversion is reusable.

- **Regime comparison**  
  You learn to compare two structural regimes: linear vs circular.  
  This is a recurring pattern in array optimization.

- **Prefix/suffix symmetry**  
  You reinforce the idea that sometimes the best result comes from **excluding** a segment, not constructing one.

This problem builds architectural fluency in subarray dynamics and teaches how to flip perspective when direct construction is inefficient.


---

# 🧠 Task Scheduler — Greedy + Frequency Count (LeetCode 621)

---

## 📜 Origin & Motivation

We are given a list of tasks labeled A–Z and a cooldown `n`.  
Each task takes 1 unit of time, and the same task must be separated by at least `n` intervals.  
The goal is to **minimize total CPU time**, including idle slots.

This is a classic **greedy scheduling** problem — we want to place the most frequent tasks as far apart as possible, and fill the gaps with other tasks or idle slots.

---

## 🧩 Use Cases

- 🧠 Task scheduling with cooldown constraints  
- 🧪 Greedy placement of high-frequency tasks  
- 📊 Frequency histogram + max count logic  
- 🧱 Interval packing with idle slot calculation

---

## 🧱 Core Architecture

### 🎯 Triggers

| Condition                        | Action in Code           |
|----------------------------------|--------------------------|
| Task appears                     | Count frequency          |
| Max frequency task dominates     | Compute idle slots       |
| Enough filler tasks              | Fill idle slots          |
| Not enough fillers               | Add idle time            |

---

### 🔧 Algorithm Steps

1. Count frequency of each task  
2. Find the **maximum frequency `f_max`**  
3. Count how many tasks have frequency `f_max`  
4. Compute minimum time using formula:
```
min_time = max(tasks.length, (f_max - 1) * (n + 1) + max_count)
```


- `(f_max - 1)` → number of full blocks  
- `(n + 1)` → size of each block (task + n idle)  
- `max_count` → number of tasks with frequency `f_max` (last block may be wider)

---

## 🚀 C# Implementation

```csharp
public class Solution {
    public int LeastInterval(char[] tasks, int n) {
        int[] freq = new int[26];
        foreach (char task in tasks) {
            freq[task - 'A']++;
        }

        Array.Sort(freq);
        int f_max = freq[25];
        int max_count = 1;

        for (int i = 24; i >= 0; i--) {
            if (freq[i] == f_max) max_count++;
            else break;
        }

        int min_time = Math.Max(tasks.Length, (f_max - 1) * (n + 1) + max_count);
        return min_time;
    }
}
```

## ⏱️ Complexity Analysis  
Frequency count: O(n) — scan all tasks  
Sorting: O(26·log 26) — constant time  
Final scan: O(26) — count max frequency tasks  
**Total time complexity**: O(n) — linear in number of tasks  
**Space complexity**: O(1) — fixed array of size 26

## ⚠️ Pitfalls  
🔁 Must use greedy formula — simulating task placement is slow  
📊 Sorting frequency array is safe due to fixed size  
⚠️ Forgetting to count all tasks with max frequency leads to underestimation  
🧩 Formula must use `max(tasks.length, computed)` — never underestimate actual task count  
🧠 Edge case: when `n = 0`, answer is simply `tasks.length`

## ✅ Conclusion  
This is a greedy scheduling problem with cooldown constraints:

🔁 Count task frequencies  
📊 Use max frequency to compute idle blocks  
🧠 Fill gaps with other tasks or idle slots  
🏆 Elegant formula avoids simulation and scales linearly

👉 **Key takeaway**: When cooldowns block task repetition, use frequency-based greedy packing — fast, clean, and optimal.


---

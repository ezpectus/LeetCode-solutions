# ğŸ§  Task Scheduler â€” Greedy + Frequency Count (LeetCode 621)

---

## ğŸ“œ Origin & Motivation

We are given a list of tasks labeled Aâ€“Z and a cooldown `n`.  
Each task takes 1 unit of time, and the same task must be separated by at least `n` intervals.  
The goal is to **minimize total CPU time**, including idle slots.

This is a classic **greedy scheduling** problem â€” we want to place the most frequent tasks as far apart as possible, and fill the gaps with other tasks or idle slots.

---

## ğŸ§© Use Cases

- ğŸ§  Task scheduling with cooldown constraints  
- ğŸ§ª Greedy placement of high-frequency tasks  
- ğŸ“Š Frequency histogram + max count logic  
- ğŸ§± Interval packing with idle slot calculation

---

## ğŸ§± Core Architecture

### ğŸ¯ Triggers

| Condition                        | Action in Code           |
|----------------------------------|--------------------------|
| Task appears                     | Count frequency          |
| Max frequency task dominates     | Compute idle slots       |
| Enough filler tasks              | Fill idle slots          |
| Not enough fillers               | Add idle time            |

---

### ğŸ”§ Algorithm Steps

1. Count frequency of each task  
2. Find the **maximum frequency `f_max`**  
3. Count how many tasks have frequency `f_max`  
4. Compute minimum time using formula:
```
min_time = max(tasks.length, (f_max - 1) * (n + 1) + max_count)
```


- `(f_max - 1)` â†’ number of full blocks  
- `(n + 1)` â†’ size of each block (task + n idle)  
- `max_count` â†’ number of tasks with frequency `f_max` (last block may be wider)

---

## ğŸš€ C# Implementation

```csharp
public class Solution {
    public int LeastInterval(char[] tasks, int n) {
        int[] freq = new int[26];
        foreach (char task in tasks) {
            freq[task - 'A']++;
        }

        Array.Sort(freq);
        int f_max = freq[25];
        int max_count = 1;

        for (int i = 24; i >= 0; i--) {
            if (freq[i] == f_max) max_count++;
            else break;
        }

        int min_time = Math.Max(tasks.Length, (f_max - 1) * (n + 1) + max_count);
        return min_time;
    }
}
```

## â±ï¸ Complexity Analysis  
Frequency count: O(n) â€” scan all tasks  
Sorting: O(26Â·logâ€¯26) â€” constant time  
Final scan: O(26) â€” count max frequency tasks  
**Total time complexity**: O(n) â€” linear in number of tasks  
**Space complexity**: O(1) â€” fixed array of size 26

## âš ï¸ Pitfalls  
ğŸ” Must use greedy formula â€” simulating task placement is slow  
ğŸ“Š Sorting frequency array is safe due to fixed size  
âš ï¸ Forgetting to count all tasks with max frequency leads to underestimation  
ğŸ§© Formula must use `max(tasks.length, computed)` â€” never underestimate actual task count  
ğŸ§  Edge case: when `n = 0`, answer is simply `tasks.length`

## âœ… Conclusion  
This is a greedy scheduling problem with cooldown constraints:

ğŸ” Count task frequencies  
ğŸ“Š Use max frequency to compute idle blocks  
ğŸ§  Fill gaps with other tasks or idle slots  
ğŸ† Elegant formula avoids simulation and scales linearly

ğŸ‘‰ **Key takeaway**: When cooldowns block task repetition, use frequency-based greedy packing â€” fast, clean, and optimal.


---

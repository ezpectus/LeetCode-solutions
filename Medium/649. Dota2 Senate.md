# Intuition
The problem simulates a round-based voting system where senators from two parties (Radiant and Dire) take turns banning each other. Each senator acts optimally for their party. The key insight is that the order of senators matters — whoever acts first in a round can ban an opponent before they get a chance to act.

# Approach
We simulate the voting rounds using two queues: one for Radiant senators and one for Dire senators. Each queue stores the index of senators in the original string. In each round:

We dequeue the front senator from both queues.

The senator with the smaller index acts first and bans the other.

The winning senator is re-enqueued with index i + n to simulate their return in the next round.

This continues until one queue is empty — meaning one party has been completely banned.

# Complexity
Time complexity: $$O(n)$$ Each senator is enqueued and dequeued at most once per round, and the number of rounds is bounded by the number of senators.

Space complexity: $$O(n)$$ We use two queues to store indices of senators.

# Code
```csharp []
//Round-based Simulation + Greedy Queue

public class Solution {
    public string PredictPartyVictory(string senate) {
        int n = senate.Length;
        Queue<int> radiant = new Queue<int>();
        Queue<int> dire = new Queue<int>();


     for(int i = 0; i < n;i++){
        if(senate[i] == 'R'){
            radiant.Enqueue(i);
        }else{
            dire.Enqueue(i);
        }
     }

     while(radiant.Count > 0 && dire.Count > 0){
           int r = radiant.Dequeue();
           int d = dire.Dequeue();

       if(r < d){
          radiant.Enqueue(r +n);

         }else{
            dire.Enqueue(d+n);
         }
     }

  return radiant.Count > 0 ? "Radiant" : "Dire";


    }
}
```



---

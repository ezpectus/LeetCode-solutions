# 1219. Path with Maximum Gold — Architectural DFS with Backtracking  
*O(4^{gold cells}) — Optimal Exhaustive Search with Pruning*

---

## Problem Statement

Given `m × n` grid (m,n ≤15) where:
- Cells contain **gold** (0–100) or **empty** (0)

Rules:
- Start from **any cell with gold**
- Move **up/down/left/right** (4 directions)
- **Collect all gold** in visited cell
- **Cannot visit** same cell twice
- **Cannot visit** cells with 0 gold
- Can **stop** anytime

Return **maximum gold** collectible.

At most **25 cells** contain gold.

---

## Core Idea — DFS with Backtracking from Every Gold Cell

**Key insight**:
- Gold cells ≤25 → total paths manageable
- **Start DFS** from **every cell with gold >0**
- **Backtracking** → visit neighbors, collect gold, recurse, undo visit
- Track **current sum** → update global max

**Pruning**:
- Skip cells with 0 gold
- Mark visited → avoid cycles

**No need** memo — paths unique per start.

---

##  Implementation (C#)

```csharp
public class Solution {
    private int m, n;
    private int[][] grid;
    private bool[][] visited;
    private int maxGold = 0;

    private readonly int[][] dirs = {
        new int[] {-1, 0}, new int[] {1, 0},
        new int[] {0, -1}, new int[] {0, 1}
    };

    public int GetMaximumGold(int[][] grid) {
        this.grid = grid;
        m = grid.Length;
        n = grid[0].Length;
        visited = new bool[m][];

        for (int i = 0; i < m; i++)  visited[i] = new bool[n];
        

        // Try starting from every cell with gold
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] > 0)  Dfs(i, j, 0);  
            }
        }

        return maxGold;
    }

private void Dfs(int r, int c, int curr)  {
        if (r < 0 || r >= m || c < 0 || c >= n || 
            grid[r][c] == 0 || visited[r][c]) {
            maxGold = Math.Max(maxGold, curr);
            return;
        }

        visited[r][c] = true;
        curr += grid[r][c];

        // Explore 4 directions
        foreach (var d in dirs)  Dfs(r + d[0], c + d[1], curr);
        visited[r][c] = false; // backtrack
    }
}
```



## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(4^g)**                    | g ≤ 25 gold cells → theoretical worst ~10⁹, practical much faster due to pruning |
| **Space Complexity**  | **O(m × n + g)**              | Visited array + recursion depth (g ≤ 25)       |

**Optimal** — exhaustive search necessary, constraints make it feasible.

---

## Why This Works — Example Walkthrough

**Input**: `[[0,6,0],[5,8,7],[0,9,0]]`

- Gold cells: (0,1)=6, (1,0)=5, (1,1)=8, (1,2)=7, (2,1)=9
- DFS tries all starting points:
  - Start at 9 → 9 → 8 → 7 → **24**
  - Start at 6 → 6 → 8 → 7 → 9 → **30**? Wait — no: from 6 to 9 not adjacent
  - Valid max path: 9 → 8 → 7 = **24** (or 7 → 8 → 9)
- DFS explores all connected paths → finds **24**

**Correct**.

**Larger grid**:
- Explores all valid connected paths from every starting gold cell
- Backtracking ensures no cell reused
- Finds global maximum

**Correct**.

---

## Pitfalls & Edge Cases

- **Isolated gold cell** → returns its value
- **No connected path** → max is largest single cell
- **Cycles in grid** → `visited` prevents infinite loops
- **All zero** → 0 (though problem implies at least one gold)
- **Multiple paths with same max** → finds one (any is fine)

All handled perfectly.

---

## Key Takeaway

This is a **classic backtracking** exploration:

- **Start from every cell with gold**
- **DFS + backtracking** → try all valid paths, collect sum
- **Visited array** → prevent revisiting cells
- **Global max update** → track best sum

**Pure, clean, optimal** — perfect grid path collection with no revisits.

---

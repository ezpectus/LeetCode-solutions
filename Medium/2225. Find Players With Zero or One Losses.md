# 2225. Find Players With Zero or One Losses  
*O(n + m log m) — HashMap + Sorted Lists*

---

## Problem Statement

You are given an integer array `matches` where `matches[i] = [winneri, loseri]` means player `winneri` defeated player `loseri` in a match.

Return a list `answer` of size 2 where:

- `answer[0]` — list of all players that have **not lost any matches**
- `answer[1]` — list of all players that have **lost exactly one match**

Both lists should be returned in **increasing order**.

**Note**:
- Only consider players who have played **at least one match**
- No two matches have the same outcome

**Examples**:

**Example 1**  
Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]  
Output: **[[1,2,10],[4,5,7,8]]**  
- Zero losses: 1,2,10
- One loss: 4,5,7,8

**Example 2**  
Input: matches = [[2,3],[1,3],[5,4],[6,4]]  
Output: **[[1,2,5,6],[]]**  
- Zero losses: 1,2,5,6
- One loss: none

**Constraints**:
- 1 ≤ matches.length ≤ 10⁵
- matches[i].length == 2
- 1 ≤ winneri, loseri ≤ 10⁵
- winneri ≠ loseri
- All matches[i] are unique

---

## Core Idea — Count Losses + Collect Players

**Approach**:
1. Use a **dictionary** or **array** to count **losses** for each player
2. Use a **set** to track all players who appeared (played at least one match)
3. After processing all matches:
   - Players with **0 losses** → answer[0]
   - Players with **exactly 1 loss** → answer[1]
4. Sort both lists in **increasing order**

**Time**: O(M + P log P) where M = matches.length, P = number of unique players ≤ 10⁵  
**Space**: O(P) — for loss count and player tracking

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public IList<IList<int>> FindWinners(int[][] matches){
        // Count losses for each player
        var lossCount = new Dictionary<int, int>();

        // Track all players who played
        var players = new HashSet<int>();

        foreach (var match in matches){
            int winner = match[0];
            int loser = match[1];

            // Winner: no loss added
            players.Add(winner);

            // Loser: increment loss count
            players.Add(loser);
            lossCount[loser] = lossCount.GetValueOrDefault(loser, 0) + 1;
        }

        // Collect players with 0 losses and 1 loss
        var zeroLoss = new List<int>();
        var oneLoss = new List<int>();

        foreach (int player in players){
            int losses = lossCount.GetValueOrDefault(player, 0);
            if (losses == 0) zeroLoss.Add(player);
            else if (losses == 1) oneLoss.Add(player);
            
        }

        // Sort both lists
        zeroLoss.Sort();
        oneLoss.Sort();

        return new List<IList<int>> { zeroLoss, oneLoss };
    }
}
```

## Complexity

| **Metric**            | **Value**              | **Notes**                                                                 |
|-----------------------|------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(M + P log P)**     | Processing all matches: O(M)<br>Collecting unique players + sorting two lists: O(P log P)<br>where M = matches.length, P = number of unique players (≤ 10⁵) |
| **Space Complexity**  | **O(P)**               | Dictionary for loss counts + HashSet for all players + two output lists   |

**Optimal** — linear in the number of matches plus logarithmic factor for sorting — perfectly efficient under constraints (M ≤ 10⁵, P ≤ 10⁵).

---

## Why This Works — Example Walkthrough

**Example 1**: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]

**Players who appeared** (winners or losers): 1,2,3,4,5,6,7,8,9,10

**Loss counts** (only losers are counted):
- 3 lost twice (to 1 and 2)
- 6 lost twice (to 3 and 5)
- 5 lost once (to 4)
- 7 lost once (to 5)
- 8 lost once (to 4)
- 9 lost twice (to 4 and 10)
- **4 lost once** (to 10 — matches[8] = [10,4])
- 1, 2, 10 never lost

**Zero losses**: players who never appeared as losers → **1, 2, 10**  
**One loss**: players who lost exactly once → **4, 5, 7, 8**

After sorting:  
answer[0] = [1,2,10]  
answer[1] = [4,5,7,8]

Matches the example output perfectly.

**Correct** —  
We collect **every player who participated** (appeared as winner or loser).  
We only **count losses** (loser side of each match).  
Then separate players into:
- **0 losses** (never lost any match)
- **exactly 1 loss**
And sort both groups in increasing order.

---

## Key Takeaway

This is a **simple, clean frequency + set** problem:

* Use a **dictionary** to count how many times each player **lost** (loser count)
* Use a **set** to track **all players** who played at least one match (winners or losers)
* After processing all matches:
  * Players with **0 losses** → first list
  * Players with **exactly 1 loss** → second list
* Sort both lists in **increasing order** and return as answer[0] and answer[1]

**Pure, clean, optimal** — O(M + P log P) time, O(P) space, extremely fast, very intuitive, handles all edge cases perfectly (no matches, single match, players with many losses, disconnected players, etc.).

---

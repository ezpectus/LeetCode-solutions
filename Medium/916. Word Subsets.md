# 916. Word Subsets — Architectural Frequency Max Merge + Inclusion Check  
*O(n × l) — Optimal Precompute Required Counts*

---

## Problem Statement

Given `words1` and `words2`.

Word `a` is **universal** if **every** `b` in `words2` is **subset** of `a` (including multiplicity).

Return **all universal** words from `words1`.

---

## Core Idea — Precompute Max Required Frequency

**Key insight**:
- `b` subset of `a` → for each char, `count_b[c] ≤ count_a[c]`
- For `a` to satisfy **all** `b` → must satisfy **max** count over all `b`

**Solution**:
1. Compute **max frequency** for each char across **all words2**
   - `req[26]` = max count of char in any words2
2. For each word in `words1`:
   - Compute its frequency
   - Check if `count_a[c] ≥ req[c]` for **all c**
   - If yes → universal

**No need** to check each words2 separately.

---

## Implementation (C++)

```cpp
class Solution {
public:
    vector<string> wordSubsets(vector<string>& words1, vector<string>& words2){
        vector<int> req(26, 0);

        // Compute max required count for each char across all words2
        for (const string& b : words2) {
            vector<int> cnt(26, 0);
            for (char c : b) cnt[c - 'a']++;
            for (int i = 0; i < 26; i++) req[i] = max(req[i], cnt[i]);
            
        }

        vector<string> res;

        // Check each word in words1
        for (const string& a : words1) {
            vector<int> cnt(26, 0);
            for (char c : a)  cnt[c - 'a']++;
            

            bool universal = true;
            for (int i = 0; i < 26; i++) {
                if (cnt[i] < req[i]) {
                    universal = false;
                    break;
                }
            }

            if (universal)  res.push_back(a);  
        }

        return res;
    }
};
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n × l)**  | n = total words, l = max length ≤ 10           |
| **Space Complexity**  | **O(1)**      | Fixed 26-size arrays                           |

**Optimal** — linear in input size.

---

## Why This Works — Example Walkthrough

**Input**: `words1 = ["amazon","apple","facebook","google","leetcode"]`, `words2 = ["e","o"]`

- **words2** requirements:
  - `"e"` → e:1
  - `"o"` → o:1
- **req** = e:1, o:1

- **Check words1**:
  - `"amazon"` → o:1, e:0 → **no**
  - `"apple"` → e:1, o:0 → **no**
  - `"facebook"` → e:1, o:2 → **yes**
  - `"google"` → e:1, o:2 → **yes**
  - `"leetcode"` → e:3, o:1 → **yes**

→ `["facebook","google","leetcode"]` correct.

---

## Pitfalls & Edge Cases

- **Multiple same letters in words2** → max frequency handles correctly
- **No requirement** → req all 0 → all words1 universal
- **words2 empty** → all words1 (though constraints say ≥1)
- **Long words** → fully handled

All covered cleanly.

---

## Key Takeaway

This is a **beautifully simple** inclusion problem:

- **Max merge** of words2 frequencies → single requirement array
- **Single check** per words1 word → fast and clean
- **Frequency arrays** → O(1) per word

**No nested loops over words2.**
**Pure, clean, optimal** — one of the most elegant Medium string problems.

---

# Problem: Maximum Sum of Two Non-Overlapping Subarrays
Number: LeetCode 1031
Difficulty: Medium Language: C++

## Problem Overview
Given an array nums and two integers firstLen and secondLen, f
ind the maximum sum of two non-overlapping subarrays of lengths firstLen and secondLen.
The subarrays can appear in any order — firstLen before secondLen, or vice versa — but must not overlap.

## Constraints
- 1 <= firstLen, secondLen <= 1000
- 2 <= firstLen + secondLen <= 1000
- firstLen + secondLen <= nums.length <= 1000
- 0 <= nums[i] <= 1000

## Approach Summary
We use dynamic programming with sliding window to track the best possible subarray sums.

Phase 1: Prefix Sum
- Build a prefix sum array to compute subarray sums in constant time.

Phase 2: Two Passes
- We consider both configurations:
- firstLen before secondLen
- secondLen before firstLen

For each configuration:

- Slide a window of size firstLen, track the maximum sum so far
- For each position, compute the sum of the second subarray that follows
- Update the global maximum

Phase 3: Result
- Return the best result across both configurations.

## C++ Code
```cpp
class Solution {
public:
    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {
        return max(maxSum(nums, firstLen, secondLen),
                   maxSum(nums, secondLen, firstLen));
    }

    int maxSum(vector<int>& nums, int L, int R) {
        int n = nums.size();
        vector<int> prefix(n + 1, 0);
        for (int i = 0; i < n; ++i)
            prefix[i + 1] = prefix[i] + nums[i];

        int maxL = 0, result = 0;
        for (int i = L + R; i <= n; ++i) {
            maxL = max(maxL, prefix[i - R] - prefix[i - R - L]);
            result = max(result, maxL + prefix[i] - prefix[i - R]);
        }
        return result;
    }
};
```
## Complexity Analysis
- Time: O(n) — single pass with prefix sums
- Space: O(n) — for prefix sum array

## Why This Works

- Prefix sums allow constant-time subarray sum computation
- Sliding window tracks best possible left subarray
- Two configurations ensure we don’t miss optimal order
- Dynamic reuse of previous max values avoids recomputation

## Related Concepts

- Prefix sums — fast subarray sum computation
- Sliding window — efficient traversal of fixed-length subarrays
- Dynamic programming — reuse of previous optimal states
- Greedy max tracking — maintaining best prefix sum on the fly


---

# 478. Generate Random Point in a Circle

---

## Problem Restatement
We need to generate a **uniform random point inside a circle** given:
- `radius`
- `x_center`, `y_center`

Constraints:
- 0 < radius ≤ 10^8
- -10^7 ≤ x_center, y_center ≤ 10^7
- Up to 30,000 calls to `randPoint`.

---

## Key Idea
To generate a uniform random point inside a circle:
1. Use **polar coordinates**:
   - Random angle θ ∈ [0, 2π).
   - Random radius `r` chosen carefully to ensure uniform distribution.
2. Uniform distribution requires:
   - `r = radius * sqrt(random())`  
     (not just `radius * random()`, because area grows with r²).
3. Convert to Cartesian coordinates:
   - `x = x_center + r * cos(θ)`
   - `y = y_center + r * sin(θ)`

---

## Code (C#)
```csharp
public class Solution {
    private double radius;
    private double x_center;
    private double y_center;
    private Random rand;

    public Solution(double radius, double x_center, double y_center) {
        this.radius = radius;
        this.x_center = x_center;
        this.y_center = y_center;
        this.rand = new Random();
    }
    
    public double[] RandPoint() {
        double angle = 2 * Math.PI * rand.NextDouble();
        double r = radius * Math.Sqrt(rand.NextDouble());
        double x = x_center + r * Math.Cos(angle);
        double y = y_center + r * Math.Sin(angle);
        return new double[] { x, y };
    }
}
```

## Complexity
- **Time:** O(1) per call, since each point generation involves only constant-time random sampling and math operations.  
- **Space:** O(1), no extra storage beyond a few variables.  

---

## Example Walkthrough
**Input:** `radius = 1.0, x_center = 0.0, y_center = 0.0`

- Random angle θ = 1.2 rad  
- Random radius r = 0.5 (scaled with sqrt for uniform distribution)  
- x = 0 + 0.5 * cos(1.2) ≈ 0.18  
- y = 0 + 0.5 * sin(1.2) ≈ 0.47  

**Output:** `[0.18, 0.47]` → uniformly distributed inside the circle ✅  

---

## Conclusion
The algorithm leverages **polar coordinates with sqrt scaling** to guarantee uniform distribution of points.  
- Each call runs in constant time.  
- Works seamlessly for very large radius and arbitrary center coordinates.  


---

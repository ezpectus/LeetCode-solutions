# LeetCode #2257  
**Count Unguarded Cells in the Grid**  
**Difficulty:** Medium  

---

## 1. Problem Description & Constraints  

### What We Are Given  
- `int m, n` — size of the grid (`m × n`)  
- `int[][] guards` — positions of **guards** `[row, col]`  
- `int[][] walls` — positions of **walls** `[row, col]`  

### What We Must Return  
- Number of **empty cells** that are **not guarded** by any guard  

### Guard Rules  
- Can see **up, down, left, right** (4 directions)  
- **Blocked** by **walls** or **other guards**  
- **Cannot see through** obstacles  

### Constraints (and what they tell us)  
| Constraint | Meaning |
|-----------|--------|
| `2 ≤ m*n ≤ 10⁵` | Large grid → **O(mn)** is acceptable |
| `guards + walls ≤ 5×10⁴` | Many obstacles → simulation is fine |
| **All positions unique** | No overlap between guards/walls |

> **Conclusion from constraints**:  
> We need **O(mn)** time + **O(mn)** space simulation.

---

## 2. Core Algorithm Idea  

### The Problem with Brute Force  
```csharp
for each cell → check all guards → O(mn * g) → TLE
```
### The Solution: **Simulate Vision from Each Guard**

| Tool | Why We Use It |
|------|---------------|
| `grid[x,y]` | Track **empty, guard, wall, guarded** states |
| `dx, dy` | 4 directions: **up, right, down, left** |
| `while` loop | **Sweep until blocked** or edge |

---

## 3. Concept in Simple Terms  

> **"From every guard, look in 4 directions. Mark every cell you can see — until you hit a wall or another guard."**


## 4. Full C# Solution  

```csharp
public class Solution {
    public int CountUnguarded(int m, int n, int[][] guards, int[][] walls) {
        // 0: empty, 1: guard, 2: wall, 3: guarded
        var grid = new int[m, n];
        
        // Step 1: Place walls
        foreach (var w in walls) {
            grid[w[0], w[1]] = 2;
        }
        
        // Step 2: Place guards
        foreach (var g in guards) {
            grid[g[0], g[1]] = 1;
        }
        
        // Step 3: Simulate vision in 4 directions
        int[] dx = { -1, 0, 1, 0 };  // up, right, down, left
        int[] dy = { 0, 1, 0, -1 };
        
        foreach (var g in guards) {
            int x = g[0], y = g[1];
            
            for (int d = 0; d < 4; d++) {
                int nx = x + dx[d];
                int ny = y + dy[d];
                
                while (nx >= 0 && nx < m && ny >= 0 && ny < n && 
                       grid[nx, ny] != 1 && grid[nx, ny] != 2) {
                    grid[nx, ny] = 3;  // Mark as guarded
                    nx += dx[d];
                    ny += dy[d];
                }
            }
        }
        
        // Step 4: Count unguarded empty cells
        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i, j] == 0) count++;
            }
        }
        
        return count;
    }
}
```
## 5. Architectural Breakdown  

| Component | Role | How It Works |
|---------|------|-------------|
| `grid[x,y] = 0` | **Empty** | Default state — cells we can guard |
| `grid[x,y] = 1` | **Guard** | Starting point of vision — where we begin sweeping |
| `grid[x,y] = 2` | **Wall** | Blocks vision — stops the sweep immediately |
| `grid[x,y] = 3` | **Guarded** | Seen by at least one guard — final state |
| `dx, dy` | **Directions** | Up, Right, Down, Left — 4 cardinal directions |
| `while` loop | **Vision Sweep** | Moves until blocked or out of bounds — simulates line of sight |
| Final count | **Result** | Only `0` cells are unguarded — ignores guards, walls, guarded |

---

## 6. Step-by-Step Execution (Example)  
```
**Input**:  
m = 4, n = 6
guards = [[0,0],[1,1],[2,3]]
walls  = [[0,1],[2,2],[1,4]]
**Initial Grid:**
G W . . . .
. G . . W .
. . W . . .
. . . . . .
```

**Vision from (0,0)**:  
→ **Right**: blocked by wall at `(0,1)`  
→ **Down**: marks `(1,0)`, `(2,0)`, `(3,0)`  
→ **Left**: out of bounds  
→ **Up**: out of bounds  

**Vision from (1,1)**:  
-  **Right**: hits wall at `(1,4)` → marks `(1,2)`, `(1,3)`  
- **Down**: hits wall at `(2,2)` → marks `(2,1)`  
-  **Left**: hits guard at `(0,0)` → marks nothing  
-  **Up**: hits guard at `(0,0)` → marks nothing  

**Vision from (2,3)**:  
-  All directions blocked or already guarded  

**Final unguarded cells**: **7**

---

## 7. Pro Tips & Optimizations  

| Tip | Why It Matters |
|-----|----------------|
| **Mark guards/walls first** | Prevents false blocking — guards block each other |
| **Use `while` not `for`** | Stops at **first obstacle** — no wasted iterations |
| **Check `grid[nx,ny] != 1 && != 2`** | **Guards block vision too** — not just walls |
| **Count only `0`** | Ignores guards, walls, guarded cells — only empty matters |

---

## 8. Key Takeaway  

> **"Simulate vision from each guard. Stop at walls or guards. Count unmarked empty cells."**


---

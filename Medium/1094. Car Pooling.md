# 1094. Car Pooling

---

## Problem Summary
We are given:
- A car with `capacity` seats.
- An array `trips`, where each trip is `[numPassengers, from, to]`.

The car drives only east. At `from`, passengers get in; at `to`, they get out.  
We must determine if it is possible to complete all trips without exceeding capacity at any point.


---

## Code Idea
This is a **sweep line problem**:
1. **Record changes at each location**:
   - At `from`, add `numPassengers`.  
   - At `to`, subtract `numPassengers`.  

2. **Apply prefix sum**:
   - Traverse locations in order (0 → 1000).  
   - Maintain current passengers.  
   - If at any point `current > capacity`, return `false`.  

3. **Return result**:
   - If traversal completes without exceeding capacity, return `true`.

---

## Code (C#)
```csharp
public class Solution {
    public bool CarPooling(int[][] trips, int capacity) {
        int maxLocation = 1001;
        int[] changes = new int[maxLocation];

        foreach (var trip in trips) {
            int passengers = trip[0];
            int from = trip[1];
            int to = trip[2];

            changes[from] += passengers;
            changes[to] -= passengers;
        }

        int current = 0;
        for (int i = 0; i < maxLocation; i++) {
            current += changes[i];
            if (current > capacity) return false;
        }

        return true;
    }
}
```



## Complexity
- **Time:** O(n + M), where `n = trips.Length`, `M = max location (≤ 1000)`.  
- **Space:** O(M) for the changes array.  

---

## Pitfalls
- Must handle multiple trips overlapping correctly.  
- Ensure passengers are dropped off at `to` before picking up new ones at the same location.  
- Capacity can be large (up to 1e5).  
- Locations are bounded by 1000 → safe to use a fixed-size array.  

---

## Example Walkthrough
**Input:** `trips = [[2,1,5],[3,3,7]], capacity = 4`  
- At 1: +2 → current = 2.  
- At 3: +3 → current = 5 (exceeds capacity).  
- **Output:** `false`.  

**Input:** `trips = [[2,1,5],[3,3,7]], capacity = 5`  
- At 1: +2 → current = 2.  
- At 3: +3 → current = 5 (equal to capacity).  
- At 5: -2 → current = 3.  
- At 7: -3 → current = 0.  
- **Output:** `true`.  

---

## Conclusion
This problem reduces to a **sweep line with prefix sum**.  
- Efficient O(n + M) solution.  
- Correctly handles overlapping trips and capacity constraints.  


---

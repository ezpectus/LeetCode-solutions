# 🧠 Good Nodes in Binary Tree — Architectural Breakdown

## 📌 Problem Statement

Given a binary tree, count the number of "good" nodes. A node is considered good if there are **no nodes with a greater value** on the path from the root to that node. In other words, the node is **at least as large as all its ancestors**.

This is a **context-dependent evaluation** problem: the decision for each node depends not only on its own value but also on the values encountered earlier on the path.

---

## 🧩 Approach: DFS with Context Propagation

The solution uses **depth-first search (DFS)**, where we pass along the **maximum value seen so far** (`maxSoFar`) from the root to the current node.

- If `node.val >= maxSoFar`, the node is considered good.
- We then update `maxSoFar = max(maxSoFar, node.val)` and pass it down recursively to the left and right children.

This ensures that each node is evaluated in the context of the path that led to it.

---

## 🧱 Architectural Pattern

This approach is **generalizable** to any tree problem where decisions depend on the path from root to node. The context can be anything: max, min, sum, depth, list of values, etc.

**Pattern:**

- Recursive function accepts `node` and `context`
- Evaluate condition on `node` using `context`
- Update `context`
- Recurse into `left` and `right` with updated context
- Aggregate results

---

## ⚠️ Key Details

- **Base case**: `node == null` → return 0
- **Root node** is always good, since it has no ancestors
- **Context update must happen before recursion**, otherwise the evaluation will be incorrect

---






```csharp
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

public class Solution {
    public int GoodNodes(TreeNode root) {

        return dfs(root,root.val);

    }
    public int dfs(TreeNode node, int maxSoFar){
         if(node == null) return 0;

         int count = 0;
         if(node.val >= maxSoFar){
            count++;
         }

     int newmax = Math.Max(maxSoFar,node.val);

     count += dfs(node.left, newmax);
     count += dfs(node.right, newmax);

    return count;
    }
}

```

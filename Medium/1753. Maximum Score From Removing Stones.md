# 1753. Maximum Score From Removing Stones — Architectural Greedy Sorting + Math Formula  
*O(1) — Optimal Closed-Form Solution*

---

## Problem Statement

You have three piles of stones with sizes `a`, `b`, `c` (1 ≤ a,b,c ≤ 10⁵).

Each turn:
- Choose **two different non-empty piles**
- Remove **one stone** from each
- Add **1** to your score

Game ends when fewer than **two non-empty piles** remain.

Return the **maximum score** you can achieve.

---

## Core Idea — Greedy: Always Reduce the Two Largest Piles

**Key insight**:
- Each move reduces **two piles** by 1 → total stones decrease by 2
- Score = number of moves = (total stones - remaining stones) / 2
- Game ends when at most **one pile** has stones left
- To maximize moves → **minimize remaining stones** → ideally leave **0 or 1** stone

**Optimal strategy**:
- Sort the three numbers: let x ≤ y ≤ z
- The maximum score is **min(x + y, z)**
  - If z ≤ x + y → can reduce all to zero → score = (x + y + z) / 2
  - If z > x + y → can reduce x and y to zero, z remains z - (x + y) → score = x + y

**Simplified formula** (after sorting):
```text
score = min(x + y, z)
```

## Full Optimal Implementation (C#)
```cpp
public class Solution {
    public int MaximumScore(int a, int b, int c) {
        // Sort the three numbers: x ≤ y ≤ z
        int[] nums = { a, b, c };
        Array.Sort(nums);
        int x = nums[0], y = nums[1], z = nums[2];

        // Maximum score
        if (x + y >= z)  return (x + y + z) / 2;
        else  return x + y;
        
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(1)**      | Fixed operations (sort 3 elements + arithmetic) |
| **Space Complexity**  | **O(1)**      | No extra space needed                          |

**Optimal** — constant time and space.

---

## Why This Works — Example Walkthrough

**Example 1**: `a=2`, `b=4`, `c=6`

- Sorted: 2, 4, 6
- Check: 2 + 4 = 6 == 6
- Total stones = 12 → moves = 12 / 2 = **6**

**Correct**.

**Example 2**: `4, 4, 6`

- Sorted: 4, 4, 6
- 4 + 4 = 8 > 6
- Total stones = 14 → moves = 14 / 2 = **7**

**Correct**.

**Example 3**: `1, 8, 8`

- Sorted: 1, 8, 8
- 1 + 8 = 9 > 8
- Total stones = 17 → moves = 17 / 2 = **8** (integer division)

**Correct**.

The formula always computes the maximum number of moves possible while ensuring at most one pile remains (game end condition).

---

## Pitfalls & Edge Cases

- **One pile is zero** → score = min of the other two (game ends when only one non-empty pile left)
- **All piles equal** → score = total // 2 (even distribution)
- **Very unbalanced** (one pile much larger) → score = sum of two smaller piles
- **Minimum values** → each pile ≥1 (constraints) → no zero-pile issues
- **Large numbers** → int sufficient (max score ≤ 3×10⁵ / 2 < 2³¹)

All handled perfectly.

---

## Key Takeaway

This is a **beautifully elegant** greedy insight:

- Sort the three pile sizes: **x ≤ y ≤ z**
- Maximum moves = **min(x + y, (x + y + z) // 2)**
- Equivalent to: **always reduce the two largest piles** until only one pile (or none) remains

**Pure, clean, optimal** — perfect maximum score from removing stones.

---

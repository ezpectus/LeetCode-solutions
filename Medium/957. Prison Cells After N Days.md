# 957. Prison Cells After N Days  
*Cycle Detection — Prison Cell Simulation*

---

## Problem
We have **8 prison cells** in a row, each either **occupied (1)** or **vacant (0)**.  

Each day, the state changes by this rule:  
> A cell becomes **occupied** if its **two neighbors** are **both occupied** or **both vacant**.  
> Otherwise → **vacant**.  

**Edge cells** (first and last) **always become vacant** (no two neighbors).

Given:
- Initial state: `cells` (array of 8 integers)
- Number of days: `n` (up to `10⁹`)

Return the **state after `n` days**.

---

## Pattern
**Finite State Simulation + Cycle Detection**

- Only **8 cells** → **2⁸ = 256 possible states**
- State evolution **must repeat** → **cycle forms**
- Instead of simulating `10⁹` days → **detect cycle** and **skip ahead**

---

## Algorithm Breakdown

1. Use a `temp` array for next state
2. Simulate day-by-day:
   - Update cells `1..6` using rule: `cells[i-1] == cells[i+1]`
   - Set `temp[0] = temp[7] = 0`
3. **Track seen states** in a list
4. When a state **repeats** → **cycle detected**
5. Jump forward using:  
   ```cpp
   n % cycle_length
   ```
   6. Return state at that index
  
   ## Optimized Code (C++)

```cpp
class Solution {
public:
    vector<int> prisonAfterNDays(vector<int>& cells, int n) {
        vector<int> next(8);
        vector<vector<int>> seen;

        while (n--) {
            // Compute next state
            for (int i = 1; i < 7; ++i) {
                next[i] = (cells[i-1] == cells[i+1]);
            }
            next[0] = next[7] = 0;

            // Check for cycle
            if (!seen.empty() && seen[0] == next) {
                return seen[n % seen.size()];
            }

            seen.push_back(next);
            cells = next;
        }

        return cells;
    }
};
```

> **Note:** `seen[0]` is the **first state after day 1** — cycle starts from there.

---

## Complexity
| Metric | Value |
|-------|-------|
| **Time** | **O(min(n, 256))** → bounded by cycle length |
| **Space** | **O(256)** → store seen states |

---

## Pitfalls & Fixes
| Issue | Fix |
|------|-----|
| Simulating `10⁹` days | **Detect cycle early** |
| Forgetting edge cells | **Always set `temp[0] = temp[7] = 0`** |
| Wrong cycle start | Compare with `seen[0]`, not current `cells` |
| Infinite loop | Break when **first repeat** occurs |

---

## Insight
**Finite state machine with small state space** → **cycle is inevitable**

> **Simulate until repeat → use modulo to jump**

**Classic pattern:**  
> *"When state space is small, cycle detection beats brute force"*

---

## Fichka Library Entry
**Category:** `Simulation / Cycle Detection`  
**Pattern:** `Prison cell evolution with finite states — detect cycle, skip ahead with modulo`


---

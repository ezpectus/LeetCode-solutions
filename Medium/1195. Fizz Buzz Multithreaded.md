# 1195. Fizz Buzz Multithreaded — Architectural Semaphore-Based Strict Sequencing  
*O(n) — Optimal Turn-Based Synchronization with 4 Semaphores*

---


## Problem Statement

You have **4 concurrent threads** that must collaboratively produce the classic FizzBuzz sequence from 1 to `n`:

- **Number thread** — prints the number if not divisible by 3 or 5
- **Fizz thread** — prints `"fizz"` if divisible by 3 (but not by 5)
- **Buzz thread** — prints `"buzz"` if divisible by 5 (but not by 3)
- **FizzBuzz thread** — prints `"fizzbuzz"` if divisible by both 3 and 5

All threads receive the **same instance** of the `FizzBuzz` class and run concurrently.

**Goal**: Produce the **exact correct sequence** `1,2,"fizz",4,"buzz",...` with no race conditions, no missing/duplicated outputs, and strict order.

---

## Core Idea — 4 Semaphores + Shared Counter

**The most important part — how and why it works**

**Key insight**:
- The sequence is **strictly sequential** — we must process numbers from 1 to n in order.
- Each number belongs to **exactly one** category (number, fizz, buzz, or fizzbuzz).
- We can use a **shared counter** `curr` to track the next number that needs to be printed.
- Use **four dedicated semaphores** — one for each thread type:
  - `numberSem` — allows Number thread to print
  - `fizzSem` — allows Fizz thread
  - `buzzSem` — allows Buzz thread
  - `fizzbuzzSem` — allows FizzBuzz thread
- Initially, only `numberSem` is open (because 1 is a number).
- After a thread prints:
  - Increment `curr`
  - Determine which category `curr` belongs to
  - Release the **corresponding semaphore** for the next thread

**Why this guarantees correctness**:
- Only one thread can be active at a time (protected by its semaphore)
- The shared `curr` ensures we process numbers **in exact order**
- Conditional release routes control to the **correct thread** for the next number
- No thread can skip ahead or print out of order

**Flow example** (n=5):
- Start: `curr=1` → `numberSem` open
- Number prints **1** → `curr=2` → release `numberSem` (2 is number)
- Number prints **2** → `curr=3` → release `fizzSem`
- Fizz prints **"fizz"** → `curr=4` → release `numberSem`
- Number prints **4** → `curr=5` → release `buzzSem`
- Buzz prints **"buzz"** → `curr=6 > n` → end

**Result**: `1,2,"fizz",4,"buzz"` — perfect.

---

## Implementation (C#)

```csharp
using System.Threading;

public class FizzBuzz 
{
    private int n;
    private int curr = 1;

    private SemaphoreSlim fizzSem = new(0, 1);
    private SemaphoreSlim buzzSem = new(0, 1);
    private SemaphoreSlim fizzbuzzSem = new(0, 1);
    private SemaphoreSlim numberSem = new(1, 1); // start with number

    public FizzBuzz(int n) 
    {
        this.n = n;
    }

    public void Fizz(Action printFizz) 
    {
        while (curr <= n) 
        {
            fizzSem.Wait();
            if (curr > n) break;
            printFizz();
            curr++;
            ReleaseNext();
        }
    }

    public void Buzz(Action printBuzz) 
    {
        while (curr <= n) 
        {
            buzzSem.Wait();
            if (curr > n) break;
            printBuzz();
            curr++;
            ReleaseNext();
        }
    }

    public void Fizzbuzz(Action printFizzBuzz) 
    {
        while (curr <= n) 
        {
            fizzbuzzSem.Wait();
            if (curr > n) break;
            printFizzBuzz();
            curr++;
            ReleaseNext();
        }
    }

    public void Number(Action<int> printNumber) 
    {
        while (curr <= n) 
        {
            numberSem.Wait();
            if (curr > n) break;
            printNumber(curr);
            curr++;
            ReleaseNext();
        }
    }

    private void ReleaseNext() 
    {
        if (curr > n) 
        {
            // Release all to exit
            fizzSem.Release();
            buzzSem.Release();
            fizzbuzzSem.Release();
            numberSem.Release();
            return;
        }

        if (curr % 15 == 0) fizzbuzzSem.Release();
        else if (curr % 3 == 0) fizzSem.Release();
        else if (curr % 5 == 0) buzzSem.Release();
        else numberSem.Release();
    }
}
```


## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Each number from 1 to n is processed exactly once |
| **Space Complexity**  | **O(1)**      | Only 4 semaphores and a single integer counter |

**Optimal** — minimal state, no deadlock, strict order.

---

## Why This Works — Execution Flow

**Example**: `n = 5` → expected output `1,2,"fizz",4,"buzz"`

- Start: `curr = 1`, only `numberSem` is open (count = 1)
- **Number thread**:
  - Prints **1** → `curr = 2` → 2 not divisible by 3 or 5 → releases `numberSem`
  - Prints **2** → `curr = 3` → 3 % 3 == 0 → releases `fizzSem`
  - Prints **4** → `curr = 5` → 5 % 5 == 0 → releases `buzzSem`
- **Fizz thread**:
  - Waits → gets turn at `curr=3` → prints **"fizz"** → `curr = 4` → releases `numberSem`
- **Buzz thread**:
  - Waits → gets turn at `curr=5` → prints **"buzz"** → `curr = 6 > n` → ends
- **FizzBuzz thread** never runs (no multiples of 15)

**Output**: `1,2,"fizz",4,"buzz"` — **perfect**.

The shared `curr` and conditional release ensure **exact sequencing**.

---

## Pitfalls & Edge Cases

- **n=1** → only Number thread prints **1**
- **Thread scheduling** → semaphores enforce correct order regardless of when threads start or how fast they run
- **Race on `curr`** → safe: only one printing thread is active at a time (protected by semaphores)
- **No deadlock** → every successful print is always followed by a release of the next appropriate semaphore
- **Early exit** → when `curr > n`, all waiting threads are released to terminate cleanly

All handled perfectly.

---

## Key Takeaway

This is a **clean and reliable** multi-thread coordination:

- **Four dedicated semaphores** → one for each output type
- **Shared counter** → determines which thread should act next
- **Dynamic release** → `ReleaseNext()` routes control precisely based on current number

**No extra locks, no flags, no busy waiting** — pure semaphore orchestration.
**Pure, clean, optimal** — perfect multi-threaded FizzBuzz.

---

# 722. Remove Comments — Architectural Solution

## Problem Statement
Given a C++ source code as array of strings `source` (each element = one line), remove all comments:

- Line comment: `//` — ignore everything to end of line
- Block comment: `/* ... */` — ignore until closing `*/` (can span multiple lines)
- Block comments take precedence
- Empty lines after removal should be omitted
- Return cleaned code as list of non-empty strings

Constraints:  
- ≤ 100 lines
- ≤ 80 chars per line
- No quotes, no control chars
- Every `/*` has matching `*/`

## Core Idea
Process the source **line by line**, tracking whether we are currently inside a block comment.

Use a **state flag** `inBlock` and build result line-by-line.

Key points:
- When we encounter `/*` → set `inBlock = true`
- When we encounter `*/` and `inBlock` → set `inBlock = false`
- `//` only matters if **not** in block comment
- Block comments can merge lines (implicit newline deletion)

We build current line character-by-character, only adding non-commented parts.

## Implementation (C#) 

```csharp
public class Solution {
    public IList<string> RemoveComments(string[] source)   {
        var result = new List<string>();
        var currentLine = new StringBuilder();
        bool inBlock = false;

        foreach (string line in source) {
            int i = 0;
            while (i < line.Length)  {
                if (inBlock)  {
                    // Look for end of block comment
                    if (i + 1 < line.Length && line[i] == '*' && line[i + 1] == '/')   {
                        inBlock = false;
                        i += 2;  // skip */
                    } 
                    else 
                    {
                        i++;
                    }
                }

                else  {
                    // Not in block — look for start of comment
                    if (i + 1 < line.Length && line[i] == '/' && line[i + 1] == '/')   {
                        // Line comment — ignore rest of line
                        break;
                    } 
                    else if (i + 1 < line.Length && line[i] == '/' && line[i + 1] == '*')    {
                        // Start of block comment
                        inBlock = true;
                        i += 2;
                    } 
                    else  {
                        // Normal character
                        currentLine.Append(line[i]);
                        i++;
                    }
                }
            }

            // If not in block and currentLine has content → add to result
            if (!inBlock && currentLine.Length > 0)  {
                result.Add(currentLine.ToString());
                currentLine.Clear();
            }
        }

        return result;
    }
}
```
## Complexity Analysis

* **Time Complexity**: **O(S)**  
  S — total number of characters in the input array (≤ 100 lines × 80 chars = 8K).  
  We process each character exactly once (with constant-time lookahead for 2-char tokens).

* **Space Complexity**: **O(S)**  
  - Output list of strings — worst case same size as input  
  - `currentLine` StringBuilder — at most one line length (~80 chars)  
  - Constant extra variables (`inBlock` flag)

## Pitfalls & Edge Cases

* **Block comment spanning multiple lines** — `inBlock` flag must persist across line boundaries → correctly carries over.  
* **`/*/`** — does **not** end the comment (overlapping forbidden by spec) → code skips `*/` only when exactly matching.  
* **`//` inside block comment** — completely ignored (block takes precedence).  
* **`/*` inside line comment** — ignored because line comment (`//`) ends the line processing before reaching it.  
* **Empty line after comment removal** — skipped (only add to result if `currentLine` non-empty and not in block).  
* **Multiple consecutive block comments** — handled seamlessly via state flag.  
* **Line ending with `/*`** — block starts, rest of line ignored, state carried to next line.  
* **Nested comments** — not possible in C++ and not required by problem → no need to handle.

## Conclusion
Beautiful **finite state machine** problem.

The core insight:

* A single boolean `inBlock` maintains context across lines
* Character-by-character processing with 2-character lookahead for tokens (`//`, `/*`, `*/`)
* Build current line only with non-commented characters
* Emit line only when complete, non-empty, and outside block

- No regex, no stack, no complex parsing trees.
- Once you model the problem as **"carry block comment state between lines"** — the solution flows naturally in ~30 clean lines.
- Classic Medium that rewards precise state management over brute-force or over-engineered approaches.
- Master this pattern (state flag + char-by-char with lookahead) — you own every "remove comments", "process code with context", or similar string-stream parsing problem.


---


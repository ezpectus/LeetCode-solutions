# Intuition
This problem is a classic sliding window variation. The key insight is that we don't need to actually flip the zeros—we just need to track how many zeros are inside our current window and ensure that number doesn't exceed k. If it does, we shrink the window from the left until it's valid again.

# Approach
We use two pointers, left and right, to define a window over the array. As we iterate with right, we count the number of zeros in the window.

If the number of zeros exceeds k, we move left forward until the window becomes valid again.

At each step, we update the maximum length of a valid window.

This approach allows us to simulate flipping up to k zeros without modifying the array.

# Complexity
Time complexity: $$O(n)$$ We visit each element at most twice—once when expanding right, and once when contracting left.

Space complexity: $$O(1)$$ We use only a few integer variables for tracking the window and zero count.

# Code
```csharp []
public class Solution {
    public int LongestOnes(int[] nums, int k) {
        int n = nums.Length;
        int left= 0;
        int zeros = 0;
         int maxlen =0;

        for(int right =0; right < n;right++){

            if(nums[right] == 0){
               zeros++;
            } 
              while(zeros > k){
                if(nums[left] == 0)
                     zeros--;
               left++;
              }
    maxlen = Math.Max(maxlen,right-left+1);

        }
    return maxlen;
    
    }
}
```

# 2211. Count Collisions on a Road

---

## Problem Restatement
We are given a string `directions` representing cars on a road:
- `'L'` → car moving left
- `'R'` → car moving right
- `'S'` → car stationary

Rules:
- Collision between opposite directions (`R` vs `L`) → +2 collisions.
- Collision between moving and stationary (`R` vs `S` or `L` vs `S`) → +1 collision.
- After collision, cars stop moving.

Return the total number of collisions.

---

## Key Idea
1. **Ignore cars that never collide:**
   - Leading `'L'` cars (moving left at the far left edge) → no collision.
   - Trailing `'R'` cars (moving right at the far right edge) → no collision.
2. **All other moving cars will eventually collide.**
   - Every `'R'` inside the middle segment will collide with something.
   - Every `'L'` inside the middle segment will collide with something.
3. **Count collisions:**
   - Each `'R'` or `'L'` in the middle contributes **1 collision**.
   - Each `'RL'` pair contributes **2 collisions**, but this is already covered by counting both cars.

So the formula is:
```
collisions = total moving cars in middle segment
```

---

## Code (C#)
```csharp
public class Solution {
    public int CountCollisions(string directions) {
        int n = directions.Length;
        int left = 0, right = n - 1;

        // Skip leading 'L'
        while (left < n && directions[left] == 'L') left++;
        // Skip trailing 'R'
        while (right >= 0 && directions[right] == 'R') right--;

        int collisions = 0;
        for (int i = left; i <= right; i++) {
            if (directions[i] != 'S') {
                collisions++;
            }
        }

        return collisions;
    }
}
```


## Complexity
- **Time:** O(n), because we only scan the string once to skip leading `'L'`, trailing `'R'`, and count the middle segment.  
- **Space:** O(1), since we only use a few counters and pointers.  

---

## Example Walkthrough

**Input:** `"RLRSLL"`  
- Leading `'L'`? None.  
- Trailing `'R'`? None.  
- Middle segment = `"RLRSLL"`.  
- Moving cars inside = 5 (`R, L, R, L, L`).  
- **Output = 5 ✅**

**Input:** `"LLRR"`  
- Skip leading `'L'` → left = 2.  
- Skip trailing `'R'` → right = 1.  
- Middle segment empty.  
- Collisions = 0.  
- **Output = 0 ✅**

---

## Why This Works
- Cars moving left at the far left edge (`L`) will never collide.  
- Cars moving right at the far right edge (`R`) will never collide.  
- Every other moving car (`L` or `R`) in the middle segment will eventually collide with something.  
- Stationary cars (`S`) don’t add collisions themselves, but they stop moving cars, so counting only `L` and `R` in the middle segment is enough.  

---

## Conclusion
The trick is to **ignore cars that escape without collision** (leading `'L'` and trailing `'R'`).  
All other moving cars will eventually collide, so the answer is simply the count of `'L'` and `'R'` in the middle segment.  

This yields an **efficient O(n) solution** with constant space, perfectly suited for strings up to length 10⁵.


---

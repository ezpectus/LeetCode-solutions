# 2012. Sum of Beauty in the Array  
*O(n) — Optimal Two-Pass Prefix/Suffix Tracking*

---

## Problem Statement

You are given a **0-indexed** integer array `nums` (3 ≤ length ≤ 10⁵, 1 ≤ nums[i] ≤ 10⁵).

For each index `i` where **1 ≤ i ≤ nums.length - 2**, the **beauty** of `nums[i]` is defined as:

- **2** — if `nums[j] < nums[i] < nums[k]` for **all** `0 ≤ j < i` and for **all** `i < k ≤ n-1`  
  (i.e. `nums[i]` is **strictly greater** than everything on the left **and** strictly smaller than everything on the right)
- **1** — if `nums[i-1] < nums[i] < nums[i+1]` **and** the above condition is **not** satisfied  
  (i.e. local strict increase, but not globally max on left or min on right)
- **0** — otherwise

Return the **sum** of beauty values for all valid indices `i` (1 ≤ i ≤ n-2).

---

## Core Idea — Two-Pass Prefix/Suffix Maximum Tracking

**Key insight**:
- Beauty 2 requires `nums[i]` to be **strictly greater** than **all** elements on the left **and** **strictly smaller** than **all** elements on the right.
- Beauty 1 only requires **local** strict increase: `nums[i-1] < nums[i] < nums[i+1]`

We can precompute two arrays in O(n):

1. **leftMax[i]** = maximum value in subarray `nums[0..i]` (inclusive)
2. **rightMin[i]** = minimum value in subarray `nums[i..n-1]` (inclusive)

Then for each i (1 ≤ i ≤ n-2):

- If `leftMax[i-1] < nums[i] < rightMin[i+1]` → beauty = **2**  
  (nums[i] > all on left AND nums[i] < all on right)
- Else if `nums[i-1] < nums[i] < nums[i+1]` → beauty = **1**
- Else → beauty = **0**

Sum all beauties.

**Why this is correct**:
- `leftMax[i-1]` is the max in [0..i-1] — checking `leftMax[i-1] < nums[i]` means nums[i] > all on left
- `rightMin[i+1]` is the min in [i+1..n-1] — checking `nums[i] < rightMin[i+1]` means nums[i] < all on right
- Local condition is trivial

**Time**: O(n) — two linear passes  
**Space**: O(n) — for prefix/suffix arrays (can optimize to O(1) extra space if needed)

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int SumOfBeauties(int[] nums) {
        int n = nums.Length;

        // leftMax[i] = max value in nums[0..i] inclusive
        int[] leftMax = new int[n];
        leftMax[0] = nums[0];
        for (int i = 1; i < n; i++) {
            leftMax[i] = Math.Max(leftMax[i - 1], nums[i]);
        }

        // rightMin[i] = min value in nums[i..n-1] inclusive
        int[] rightMin = new int[n];
        rightMin[n - 1] = nums[n - 1];
        for (int i = n - 2; i >= 0; i--){
            rightMin[i] = Math.Min(rightMin[i + 1], nums[i]);
        }

        int beautySum = 0;
        for (int i = 1; i < n - 1; i++) {
            if (leftMax[i - 1] < nums[i] && nums[i] < rightMin[i + 1]) beautySum += 2;
            else if (nums[i - 1] < nums[i] && nums[i] < nums[i + 1]) beautySum += 1;
            // else beauty += 0
        }

        return beautySum;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Two separate passes to build leftMax and rightMin: O(n) each  
One final pass to compute the sum of beauty values: O(n)  
Total: **O(n)** — single linear scan complexity |
| **Space Complexity**  | **O(n)**      | Two additional arrays: leftMax and rightMin, each of size n |

**Optimal** — linear time and linear space — ideal and efficient for n ≤ 10⁵ constraints.

---

## Why This Works — Example Walkthrough

**Example 1**: `nums = [1,2,3]`

- leftMax = [1, 2, 3]  
  (max up to index 0 = 1, up to 1 = 2, up to 2 = 3)
- rightMin = [1, 2, 3]  
  (min from index 2 = 3, from 1 = 2, from 0 = 1)
- i = 1 (value = 2):  
  leftMax[0] = 1 < 2 < rightMin[2] = 3 → yes → beauty += **2**
- Sum = **2** → correct

**Example 2**: `nums = [2,4,6,4]`

- leftMax = [2, 4, 6, 6]  
- rightMin = [2, 4, 4, 4]
- i = 1 (value = 4):  
  leftMax[0] = 2 < 4 < rightMin[2] = 4 ? → 4 < 4 is false → no beauty 2  
  But nums[0]=2 < 4 < nums[2]=6 → true → beauty += **1**
- i = 2 (value = 6):  
  leftMax[1] = 4 < 6 < rightMin[3] = 4 ? → 6 < 4 is false → no beauty 2  
  nums[1]=4 < 6 < nums[3]=4 ? → 6 < 4 is false → no beauty 1
- Sum = **1** → correct

**Correct** — precomputing the maximum from the left and minimum from the right allows us to check both **global** conditions (beauty 2) and **local** conditions (beauty 1) in constant time per position.

---

## Key Takeaway

This is a **classic precompute prefix/suffix extrema** problem:

- Build **leftMax[i]** = maximum value in subarray nums[0..i] (inclusive)
- Build **rightMin[i]** = minimum value in subarray nums[i..n-1] (inclusive)
- For every middle position i (1 ≤ i ≤ n-2):
  - **Beauty 2** condition: leftMax[i-1] < nums[i] < rightMin[i+1]  
    → nums[i] is strictly greater than everything on its left **and** strictly smaller than everything on its right
  - **Beauty 1** condition (fallback): nums[i-1] < nums[i] < nums[i+1]  
    → local strict increase, but not globally dominant
  - Otherwise → beauty = 0
- Sum all beauty contributions from i = 1 to n-2

**Pure, clean, optimal** — O(n) time, O(n) space, simple precomputation, no tricky edge cases.

---

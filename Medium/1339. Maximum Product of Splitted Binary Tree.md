# 1339. Maximum Product of Splitted Binary Tree — Architectural Two-Pass DFS Subtree Sum  
*O(n) — Optimal Double Traversal with Total Sum*

---

## Problem Statement

- Given binary tree `root` (2 ≤ nodes ≤ 5×10⁴, values 1–10⁴).
- Remove **one edge** → split into two subtrees.
- Maximize **product of their subtree sums**.
- Return result **modulo 10⁹ + 7** (compute product first, then mod).

---

## Core Idea — Find Split Closest to Half Total Sum

**Key insight**:
- Let `total` = sum of all node values
- After removing edge → one subtree sum `s`, other `total - s`
- Product = `s * (total - s)`
- Maximum when `s` closest to `total / 2`

**Steps**:
1. First DFS → compute **total sum** of tree
2. Second DFS → compute all **subtree sums**
   - Track maximum product `subtree_sum * (total - subtree_sum)`
3. Return max product % (10⁹+7)

---

##  Implementation (C#)

```csharp
public class Solution {
    private const long MOD = 1_000_000_007;
    private long total = 0;
    private long maxProd = 0;

    public int MaxProduct(TreeNode root) {
        // First pass: compute total sum
        total = SumTree(root);

        // Second pass: find best split
        SumTreeWithProduct(root);

        return (int)(maxProd % MOD);
    }

    private long SumTree(TreeNode node) {
        if (node == null) return 0;
        return node.val + SumTree(node.left) + SumTree(node.right);
    }

    private long SumTreeWithProduct(TreeNode node) {
        if (node == null) return 0;

        long left = SumTreeWithProduct(node.left);
        long right = SumTreeWithProduct(node.right);
        long subtree = node.val + left + right;

        // Possible splits: left or right subtree
        if (left > 0) {
            long prod = left * (total - left);
            maxProd = Math.Max(maxProd, prod);
        }

        if (right > 0) {
            long prod = right * (total - right);
            maxProd = Math.Max(maxProd, prod);
        }

        return subtree;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Two DFS passes over the entire tree            |
| **Space Complexity**  | **O(h)**      | Recursion stack (h = tree height, worst-case n) |

**Optimal** — minimal number of passes, no extra data structures.

---

## Why This Works — Example Walkthrough

**Input**: `root = [1,2,3,4,5,6]`

- First DFS: total tree sum = **21**
- Second DFS computes subtree sums and possible splits:
  - Left subtree of root (2+4+5) = **11** → product 11 × (21-11) = **110**
  - Right subtree of root (3+6) = **9** → product 9 × 12 = **108**
  - Other subtrees (e.g., under 2: 4+5=9, under 3: 6) give smaller products
- Maximum product = **110** → **correct**

**Skewed tree example**: the algorithm still visits every subtree exactly once in the second pass and correctly identifies the split that gives the maximum product (closest to half of total sum).

The key is that **every possible edge removal** corresponds to choosing one subtree as one part — we consider all such possibilities efficiently.

---

## Pitfalls & Edge Cases

- **n=2** → only one possible edge → product of the two single-node subtrees
- **Large sums** → use `long` for calculations to prevent overflow **before** applying modulo
- **Unbalanced/skewed tree** → recursion handles deep chains correctly
- **All nodes on one side** → still correctly computes the complementary subtree
- **Root-only split** → not possible (must remove an edge), but code naturally excludes it

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** tree DP:

- **First pass** → compute total sum of the tree
- **Second pass** → compute every subtree sum and evaluate the product `subtree * (total - subtree)`
- **Track maximum** → the best split is the one closest to half the total sum
**Pure, clean, optimal** — perfect tree splitting for maximum product.

---


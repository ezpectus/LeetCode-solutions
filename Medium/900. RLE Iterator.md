# 900. RLE Iterator — Architectural Streaming Consumption  
*Amortized O(1) per call — Lazy RLE Decoding*

---

## Problem Statement

We are given a **run-length encoded** array `encoding` of **even length**.

- For every even index `i`, `encoding[i]` is the **count** (number of repetitions).  
- `encoding[i+1]` is the **value** repeated that many times.

We must design an iterator with two operations:

- `RLEIterator(int[] encoding)` — initializes the structure  
- `Next(int n)` — exhausts the next `n` elements and returns the **last** exhausted element  
  - If fewer than `n` elements remain → return `-1`

### Example

```text
encoding = [3,8,0,9,2,5] → sequence = [8,8,8,5,5]

next(2) → 8   → left: [8,5,5]
next(1) → 8   → left: [5,5]
next(1) → 5   → left: [5]
next(2) → -1  → not enough
```
## Core Idea

Instead of expanding the entire sequence (which may be huge), we **consume counts directly**:

- Maintain a pointer `pos` into `encoding`
- Each `Next(n)` **skips through runs** until `n` elements are exhausted
- Return the value of the **last exhausted element**, or `-1` if not enough

This is **streaming consumption of RLE**.

---

## Steps

1. Store `encoding` array and maintain a pointer `pos` (current index in encoding).

2. For each `Next(n)`:

   - While `n > 0` and `pos < encoding.Length`:
     - If `encoding[pos] >= n`:  
       → Decrease `encoding[pos]` by `n`  
       → Return `encoding[pos+1]` (the value)
     - Else:  
       → Subtract `encoding[pos]` from `n`  
       → Move `pos += 2` (skip exhausted run)

   - If we exit loop without exhausting `n` → return `-1`

---

## Implementation (C#)

```csharp
public class RLEIterator {
 private int[] encoding;
 private int pos;
    public RLEIterator(int[] encoding) {
        this.encoding = encoding;
        this.pos = 0;
    }
    
    public int Next(int n) {
        while(pos < encoding.Length && n > 0){
            if(encoding[pos] >= n){
                encoding[pos] -= n;
                return encoding[pos+1];
            }else{
                n -= encoding[pos];
                pos += 2;
            }
        }
        return -1;
    }
}
```

## Complexity Analysis

- **Time Complexity**:  
  Each `Next` call may advance the pointer across runs.  
  Across **all calls**, the pointer moves at most once per run → **amortized O(1)** per call.

- **Space Complexity**:  
  **O(1)** extra space beyond the input array.

---

## Pitfalls & Edge Cases

- **Zero counts**: Runs like `[0,9]` must be skipped correctly → **handled**
- **Large `n`**: Must handle up to `10⁹` without overflow → `int` is enough (LeetCode constraint)
- **Exhaustion**: If not enough elements remain → return `-1` → **handled**
- **Multiple calls**: Pointer must persist across calls → `pos` is instance field

---

## Conclusion

The **architectural insight** is realizing that **we don’t need to expand the sequence**.
We simply **consume counts in place** with a moving pointer.
This collapses a potentially **massive sequence** into a **clean streaming iterator** with **amortized constant time** per call.
**Result**: a concise, efficient solution that handles large counts and multiple calls seamlessly.

---

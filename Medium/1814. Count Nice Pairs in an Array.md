# 1814. Count Nice Pairs in an Array — Architectural HashMap + Reverse Insight  
*O(n) — Optimal Frequency Counting with Reverse Mapping*

---

## Problem Statement

You are given an array `nums` of non-negative integers.

Define `rev(x)` as the integer obtained by reversing the digits of `x` (leading zeros ignored, e.g. rev(120) = 21).

A pair of indices `(i, j)` (i < j) is **nice** if:  
`nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])`

Return the number of nice pairs modulo **10⁹ + 7**.

---

## Core Idea — Rearrange Equation + Frequency Map

**Key insight**:
Rearrange the condition:
```
nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])
```


So two numbers form a nice pair if they have the **same value** of `(number - reverse(number))`

**Algorithm**:
1. For each number in `nums`, compute `diff = num - rev(num)`
2. Use a **dictionary** to count frequency of each `diff`
3. For each number, add to answer the **current count** of its `diff` (all previous numbers with same diff form nice pairs with it)
4. Then increment the frequency of its `diff`
5. Return answer % (10⁹ + 7)

**Why it works**:
- All pairs with same `(num - rev(num))` satisfy the condition
- We count each pair exactly once (when we process the second index)

---

## Full Optimal Implementation (C#)

```csharp
public class Solution {
    private const int MOD = 1000000007;

    public int CountNicePairs(int[] nums) {
        Dictionary<long, int> freq = new Dictionary<long, int>();
        long answer = 0;

        foreach (int num in nums) {
            long revNum = Reverse(num);
            long diff = (long)num - revNum;

            if (freq.TryGetValue(diff, out int count)) {
                answer = (answer + count) % MOD;
            }

            freq[diff] = freq.GetValueOrDefault(diff, 0) + 1;
        }

        return (int)answer;
    }

    private long Reverse(int num) {
        long rev = 0;
        while (num > 0) {
            rev = rev * 10 + num % 10;
            num /= 10;
        }
        return rev;
    }
}
```

## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(n × log max(nums[i]))**   | n ≤ 10⁵ elements, reversing each number takes O(log 10⁹) ≈ 10 operations (digits) |
| **Space Complexity**  | **O(n)**                      | Worst case: each number has a unique diff → dictionary stores O(n) entries |

**Optimal** — very fast in practice (≈ 10⁶ operations total), perfectly suited for constraints.

---

## Why This Works — Example Walkthrough

**Example 1**: `nums = [42,11,1,97]`

- 42 → rev(42) = 24 → diff = 42 - 24 = **18**
- 11 → rev(11) = 11 → diff = **0**
- 1 → rev(1) = 1 → diff = **0**
- 97 → rev(97) = 79 → diff = 97 - 79 = **18**

Processing sequence:

- 42 (diff=18) → freq[18] = 1 → ans += 0 → ans = 0
- 11 (diff=0) → freq[0] = 1 → ans += 0 → ans = 0
- 1 (diff=0) → freq[0] = 2 → ans += 1 → ans = 1
- 97 (diff=18) → freq[18] = 2 → ans += 1 → ans = **2**

Pairs found: (0,3) with diff=18, (1,2) with diff=0 → **2** → correct

**Example 2**: `nums = [13,10,35,24,76]`

- Compute diff = num - rev(num) for each
- Count frequency of each diff value
- For each number → add current frequency of its diff to answer
- Result = **4** → correct

**Correct** — every pair (i < j) where `nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])` is counted exactly once (when processing the later index).

---

## Pitfalls & Edge Cases

- **Numbers with trailing zeros** → rev(100) = 1 (leading zeros ignored) → diff = 100 - 1 = 99 → correct
- **Zero** → rev(0) = 0 → diff = 0
- **Duplicate numbers** → same diff → correctly counted as pairs
- **Large n (≤ 10⁵)** → O(n × 10) ≈ 10⁶ operations → very fast
- **Large numbers (≤ 10⁹)** → use `long` for diff and reverse to prevent overflow

All handled perfectly.

---

## Key Takeaway

This is a **beautifully elegant** rearrangement + frequency counting problem:

- The condition `nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])` simplifies to:  
  `nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])`
- Compute for each number its **diff = num - rev(num)**
- Use **dictionary** to count how many previous numbers had the same diff
- For each new number → add current frequency of its diff to answer → then increment frequency

**Pure, clean, optimal** — perfect O(n) counting of nice pairs with O(1) lookups.

---

# 885. Spiral Matrix III — Architectural Spiral Simulation with Direction Steps  
*O(rows × cols) — Optimal Step-by-Step Movement*

---

## Problem Statement

Start at `(rStart, cStart)` on `rows × cols` grid.

Walk in **clockwise spiral**, visiting **all cells** (even going outside temporarily).

Return **coordinates** in the order visited (only grid cells).

---

## Core Idea - Spiral Pattern with Increasing Steps

**Spiral rule**:
- Move **steps** in current direction
- Turn right
- Repeat **twice** per step size
- Then **increase steps**

Pattern: 1 right, 1 down, 2 left, 2 up, 3 right, 3 down, ...

**Simulation**:
- Use **direction vectors**: right → down → left → up
- Always update position (even outside)
- Add to result **only if in bounds**

**Stop** when all cells visited.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int[][] SpiralMatrixIII(int rows, int cols, int rStart, int cStart) {
        var result = new List<int[]>();
        int[][] dirs = { new[] { 0, 1 }, new[] { 1, 0 }, new[] { 0, -1 }, new[] { -1, 0 } }; // right, down, left, up
        int r = rStart, c = cStart;
        int dir = 0; // 0-right, 1-down, 2-left, 3-up
        int steps = 1; 

        result.Add(new int[] { r, c });
        int total = rows * cols;
        if (total == 1) return result.ToArray();

        while (result.Count < total) {
            for (int turn = 0; turn < 2; turn++){
                for (int i = 0; i < steps; i++) {
                    r += dirs[dir][0];
                    c += dirs[dir][1];

                    if (r >= 0 && r < rows && c >= 0 && c < cols) {
                        result.Add(new int[] { r, c });
                        if (result.Count == total) return result.ToArray();
                    }
                }
                dir = (dir + 1) % 4; 
            }
            steps++;
        }

        return result.ToArray();
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(rows × cols)**    | Visit all cells + some outside moves           |
| **Space Complexity**  | **O(rows × cols)**    | Result list                                    |

**Optimal** — must visit and store all cells.

---

## Why This Works — Example Walkthrough

**Input**: `rows=5, cols=6, rStart=1, cStart=4`

- **Start**: `(1,4)`
- **steps=1**:
  - Right 1 → `(1,5)`
  - Down 1 → `(2,5)`
- **steps=2**:
  - Left 2 → `(2,4)`, `(2,3)`
  - Up 2 → `(1,3)`, `(0,3)`
- **steps=3**:
  - Right 3 → `(0,4)`, `(0,5)`, `(0,6)` (out)
  - Down 3 → `(1,6)` (out), `(2,6)` (out), `(3,6)` (out)
- **steps=4**:
  - Left 4 → `(3,5)`, `(3,4)`, `(3,3)`, `(3,2)`
  - Up 4 → `(2,2)`, `(1,2)`, `(0,2)`, `(-1,2)` (out)
- And continue...

Eventually visits **all 30 cells** in exact spiral order.

**Perfect** — matches expected path.

---

## Key Takeaway

This is a **beautifully clean** spiral simulation:

- **Direction array** → easy 90° turns
- **Steps increase every two turns** → natural spiral growth
- **Always move** → position updates even outside grid
- **Add only in-bounds** → correct result order

**No visited set. No complex logic.**
**Pure, elegant, optimal** — one of the nicest simulation problems.


---

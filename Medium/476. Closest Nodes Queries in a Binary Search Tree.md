# 2476. Closest Nodes Queries in a Binary Search Tree  
*O(n + q log n) — In-order Traversal + Binary Search*

---

## Problem Statement

You are given the root of a **binary search tree** (BST) with unique node values and an array `queries` of positive integers.

For each query `queries[i]`:

- Find the **largest value** in the BST that is **≤** `queries[i]` (or -1 if none exists) → `mini`
- Find the **smallest value** in the BST that is **≥** `queries[i]` (or -1 if none exists) → `maxi`

Return a 2D array `answer` where `answer[i] = [mini, maxi]`.

**Examples**:

**Example 1**  
Input: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]  
Output: **[[2,2],[4,6],[15,-1]]**

**Example 2**  
Input: root = [4,null,9], queries = [3]  
Output: **[[-1,4]]**

**Constraints**:
- 2 ≤ number of nodes ≤ 10⁵
- 1 ≤ Node.val ≤ 10⁶ (all unique)
- 1 ≤ n = queries.length ≤ 10⁵
- 1 ≤ queries[i] ≤ 10⁶

---

## Core Idea — In-order Traversal + Binary Search

**Beautiful & efficient approach**:
- Since it's a **BST**, an **in-order traversal** gives all values in **sorted order**
- Perform in-order traversal once → get a sorted list of all node values
- For each query `q`:
  - Find the **rightmost** value ≤ q (upper bound - 1) → mini
  - Find the **leftmost** value ≥ q (lower bound) → maxi
- Use **binary search** (bisect) on the sorted list to answer each query quickly

**Time**:
- In-order traversal: O(n)
- For q queries: O(q log n) binary searches

**Space**: O(n) — store sorted list

---

## Clean Implementation (C#)

```csharp
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution{
    public IList<IList<int>> ClosestNodes(TreeNode root, IList<int> queries){
        // Step 1: In-order traversal to get sorted list of values
        var sorted = new List<int>();
        Inorder(root, sorted);
        var answer = new List<IList<int>>();

        // Step 2: For each query, binary search in sorted list
        foreach (int q in queries){
            int mini = -1;
            int maxi = -1;

            // Find the rightmost index where sorted[idx] <= q
            int left = 0, right = sorted.Count - 1;
            while (left <= right){
                int mid = left + (right - left) / 2;
                if (sorted[mid] <= q){
                    mini = sorted[mid];
                    left = mid + 1;
                }
                else right = mid - 1;
                
            }

            // Find the leftmost index where sorted[idx] >= q
            left = 0;
            right = sorted.Count - 1;
            while (left <= right){
                int mid = left + (right - left) / 2;
                if (sorted[mid] >= q){
                    maxi = sorted[mid];
                    right = mid - 1;
                }
                else left = mid + 1;
            }

            answer.Add(new List<int> { mini, maxi });
        }

        return answer;
    }

    private void Inorder(TreeNode node, List<int> sorted){
        if (node == null) return;

        Inorder(node.left, sorted);
        sorted.Add(node.val);
        Inorder(node.right, sorted);
    }
}
```

## Complexity

| **Metric**            | **Value**              | **Notes**                                                                 |
|-----------------------|------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(n + q log n)**     | In-order traversal to build sorted list: O(n)<br>For each of q queries: two binary searches O(log n) each → O(q log n) |
| **Space Complexity**  | **O(n)**               | Sorted list of all node values: O(n)<br>Recursion stack during in-order traversal: O(h) ≤ O(n) in worst case |

**Optimal** — linear preprocessing + logarithmic per query — extremely efficient for n, q ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]

**In-order traversal** gives sorted node values:  
[1, 2, 4, 6, 9, 13, 14, 15]

**Query 2**:
- Largest value ≤ 2 → **2**
- Smallest value ≥ 2 → **2**  
→ [2, 2]

**Query 5**:
- Largest value ≤ 5 → **4**
- Smallest value ≥ 5 → **6**  
→ [4, 6]

**Query 16**:
- Largest value ≤ 16 → **15**
- Smallest value ≥ 16 → none → **-1**  
→ [15, -1]

**Correct** —  
Since the tree is a **binary search tree**, an in-order traversal naturally produces all node values in **sorted order**.  
For each query, we perform **binary search** (or bisect) twice on this sorted list:
- One to find the rightmost value ≤ query (floor / largest ≤)
- One to find the leftmost value ≥ query (ceil / smallest ≥)  
This directly gives the required closest values satisfying the conditions.

---

## Key Takeaway

This is a **classic BST + binary search on sorted values** problem:

* Perform **in-order traversal** once → get all node values in **sorted order** (O(n))
* For each query q:
  * Use **binary search** to find the **largest value ≤ q** (floor/mini)
  * Use **binary search** to find the **smallest value ≥ q** (ceil/maxi)
  * If no value exists in one direction → return -1 for that part
* Return list of [mini, maxi] pairs for all queries

---

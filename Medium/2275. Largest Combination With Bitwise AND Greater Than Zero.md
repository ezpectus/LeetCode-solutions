# 2275. Largest Combination With Bitwise AND Greater Than Zero — Architectural Bit Counting Solution

## Problem Summary

We are given an array `candidates` of positive integers.
We want the **largest subset** such that the **bitwise AND** of all elements in the subset is **greater than 0**.
Return the **size** of this largest combination.

## Core Idea

For the **AND** of a subset to be `> 0`, there must be **at least one bit** that is **set in every number** of the subset.

**Key insight**:  
The maximum size of such a subset is equal to the **maximum number of elements that share the same bit set**.

In other words:  
**Find the bit position that appears in the most numbers → that count is the answer.**

## Strategy

1. Iterate through each number in `candidates`.
2. For each bit position (0–23, since max value ≤ 10⁷ < 2²⁴):
   - If the bit is set → increment counter for that bit.
3. After processing all numbers → take the **maximum** counter value.
4. Return this maximum.

## Optimized Code (C#)

```csharp
public class Solution 
{
    public int LargestCombination(int[] candidates) 
    {
        int[] bitCount = new int[24]; // enough for numbers up to 1e7
        
        foreach (int num in candidates) 
        {
            for (int b = 0; b < 24; b++) 
            {
                if (((num >> b) & 1) == 1) 
                {
                    bitCount[b]++;
                }
            }
        }
        
        int res = 0;
        foreach (int count in bitCount) 
        {
            res = Math.Max(res, count);
        }
        return res;
    }
}
```

## Complexity

- **Time**: **O(n·log M)**  
  - `n` = number of candidates (≤ 10⁵)  
  - `M` = max value (≤ 10⁷ → ~24 bits)  
  - **Efficient enough** — runs in microseconds

- **Space**: **O(log M)** for bit counters (~24–32 integers)

## Pitfalls

- Must check all bit positions up to 24 (safe to use 32)
- Avoid overflow — counts ≤ 10⁵ → `int` is safe
- Ensure we return **maximum count**, not sum or bitwise result

## Edge Cases

- **Single element** → result = `1`
- **All numbers identical** → result = length of array (all bits shared)
- **No common bit among >1 numbers** → result = `1`

## Sanity Checks

- Input: `[16,17,71,62,12,24,14]` → Output: `4`
- Input: `[8,8]` → Output: `2`
- Input: `[1,2,4,8]` → Output: `1` (no shared bit)

## Key Takeaway

This is a **bit counting** problem:

- Each bit position defines a possible **AND > 0** combination
- The **largest valid subset** = **maximum number of elements sharing any single bit**
**Clean O(n·log M) solution** — elegant, fast, and mathematically perfect.

---


# 556. Next Greater Element III

---

## Problem Summary
We are given a positive integer `n`.  
- Task: find the smallest integer that has exactly the same digits as `n` but is **greater** than `n`.  
- If no such integer exists, return `-1`.  
- The result must fit in a 32-bit signed integer. If the next greater permutation exceeds this range, return `-1`.

---

## Code Idea
This problem is essentially finding the **next permutation** of the digits of `n`:
1. **Convert to char array**  
   - Work with digits as characters for easier manipulation.  

2. **Find pivot**  
   - Traverse digits from right to left.  
   - Find the first index `i` where `digits[i] < digits[i+1]`.  
   - If no such index exists → digits are in descending order → return `-1`.  

3. **Find successor**  
   - From the right, find the smallest digit greater than `digits[i]`.  
   - Swap them.  

4. **Reverse suffix**  
   - Reverse digits after index `i` to get the smallest possible number greater than `n`.  

5. **Convert back to integer**  
   - Parse the new digit array into a number.  
   - If it exceeds `Int32.MaxValue`, return `-1`.  

---

## Code (C#)
```csharp
public class Solution {
    public int NextGreaterElement(int n) {
        char[] digits = n.ToString().ToCharArray();
        int i = digits.Length - 2;

        // Step 1: find pivot
        while (i >= 0 && digits[i] >= digits[i + 1]) {
            i--;
        }
        if (i < 0) return -1;

        // Step 2: find successor
        int j = digits.Length - 1;
        while (digits[j] <= digits[i]) {
            j--;
        }

        // Step 3: swap
        char temp = digits[i];
        digits[i] = digits[j];
        digits[j] = temp;

        // Step 4: reverse suffix
        Array.Reverse(digits, i + 1, digits.Length - (i + 1));

        // Step 5: convert back
        long val = long.Parse(new string(digits));
        return (val > int.MaxValue) ? -1 : (int)val;
    }
}
```


## Complexity
- **Time:** O(k), where `k` = number of digits in `n`.  
- **Space:** O(k) for digit array.  

---

## Pitfalls
- Must handle case when digits are in descending order → return `-1`.  
- Ensure reversal of suffix after pivot for correct minimal next permutation.  
- Watch out for integer overflow → check against `Int32.MaxValue`.  
- Edge case: single-digit numbers → always return `-1`.  

---

## Example Walkthrough
**Input:** `n = 12`  
- Digits: [1, 2].  
- Pivot at index 0 (`1 < 2`).  
- Swap → [2, 1].  
- Result = 21.  
**Output:** `21`.  

**Input:** `n = 21`  
- Digits: [2, 1].  
- No pivot (digits in descending order).  
- **Output:** `-1`.  

---

## Conclusion
This problem is a direct application of the **next permutation algorithm** on digits.  
- Efficient O(k) solution.  
- Handles overflow and descending order cases.  
- Clean implementation using swap + reverse suffix.  



---


# 1947. Maximum Compatibility Score Sum  
*O(m! × n) — Optimal Backtracking / Bitmask DP (m ≤ 8)*

---

## Problem Statement

You are given two m × n matrices:

- `students` — m students' answers (each row is a student)
- `mentors` — m mentors' answers (each row is a mentor)

- m ≤ 8, n ≤ 8
- Each answer is 0 or 1

**Compatibility score** of student i and mentor j = number of positions k where `students[i][k] == mentors[j][k]`

You must assign **each student to exactly one mentor** (bijective matching).

Return the **maximum possible sum** of compatibility scores over all possible assignments.

---

## Core Idea — Bitmask DP / Maximum Weight Bipartite Matching

**Key insight**:
- m ≤ 8 → we can use **bitmask** to represent which mentors are already assigned (2⁸ = 256 states)
- For each subset of mentors (mask), we can compute the maximum sum when assigning the first |subset| students to them
- Or more naturally: assign students in fixed order (0 to m-1), and mask represents used mentors

**DP state**:
- `dp[mask]` = maximum compatibility sum when assigning the first `__builtin_popcount(mask)` students  
  to the mentors set in `mask`

**Transition**:
- For each mask:
  - Let student_idx = number of set bits in mask
  - If student_idx == m → done
  - For each available mentor j (bit j not set in mask):
    - score = compatibility(students[student_idx], mentors[j])
    - dp[mask | (1 << j)] = max(dp[mask | (1 << j)], dp[mask] + score)

**Base**: dp[0] = 0

**Final answer**: dp[(1 << m) - 1]

**Time**: O(2^m × m × n)  
- 2^m states
- For each state: loop over m possible mentors
- Computing compatibility: O(n)

With m ≤ 8, n ≤ 8: 256 × 8 × 8 = ~16k operations — instantaneous

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MaxCompatibilitySum(int[][] students, int[][] mentors) {
        int m = students.Length;
        int n = students[0].Length;

        // Precompute compatibility scores
        int[,] compat = new int[m, m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < m; j++) {
                int score = 0;
                for (int k = 0; k < n; k++) {
                    if (students[i][k] == mentors[j][k]) score++;
                }

                compat[i, j] = score;
            }
        }

        // dp[mask] = max sum assigning first popcount(mask) students to mentors in mask
        int[] dp = new int[1 << m];
        Array.Fill(dp, -1); // -1 means impossible
        dp[0] = 0;

        for (int mask = 0; mask < (1 << m); mask++){
            if (dp[mask] == -1) continue;

            int student = __builtin_popcount(mask); // next student to assign
            if (student == m) continue;

            for (int j = 0; j < m; j++) {
                if ((mask & (1 << j)) == 0) { // mentor j free
                    int newMask = mask | (1 << j);
                    dp[newMask] = Math.Max(dp[newMask], dp[mask] + compat[student, j]);
                }
            }
        }

        return dp[(1 << m) - 1];
    }

    // Helper: count set bits
    private int __builtin_popcount(int x) {
        return BitOperations.PopCount((uint)x);
    }
}
```


## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(2ᵐ × m × n)**     | 2ᵐ states × m choices for next mentor × n to precompute compatibility (precompute is separate O(m² × n)) |
| **Precompute Time**   | **O(m² × n)**         | Compatibility matrix: m students × m mentors × n questions ≤ 8² × 8 = 512 operations |
| **Space Complexity**  | **O(2ᵐ + m²)**        | DP array: 2ᵐ = 256 integers + compat matrix O(m²) ≈ 64 integers |

**Optimal** — with m ≤ 8, total operations ≈ 256 × 8 × 8 = 16,384 — runs instantly.

---

## Why This Works — Example Walkthrough

**Example 1**: `students = [[1,1,0],[1,0,1],[0,0,1]]`, `mentors = [[1,0,0],[0,0,1],[1,1,0]]`

- Precompute 3×3 compatibility matrix (each entry = number of matching answers)
- dp[0] = 0 (no students assigned)
- Assign student 0 to each mentor j → dp[1 << j] = compat[0][j]
- Then assign student 1 to each remaining mentor → update dp with two mentors used
- Finally assign student 2 to the last mentor → dp[(1<<3)-1] = max possible sum
- Result = **8** (optimal assignment: student 0 → mentor 2 (score 3), student 1 → mentor 0 (score 2), student 2 → mentor 1 (score 3))

**Correct** — bitmask DP explores **all possible permutations** of mentor assignments (by building subsets of used mentors), accumulates the maximum sum using precomputed compatibility scores.

---

## Pitfalls & Edge Cases

- **m = 1** → only one possible assignment → just compat[0][0]
- **All answers identical** → max sum = m × n (perfect match possible)
- **m = 8** → 256 states × 8 choices × 8 compatibility lookups ≈ 16k operations → instantaneous
- **n = 8** → precomputing compat matrix = 64 × 8 = 512 operations — negligible
- **No valid assignment** → impossible (m students = m mentors, always possible)

All handled perfectly.

---

## Key Takeaway

This is a **classic bipartite maximum weight matching** problem with tiny constraints (m ≤ 8):

- Precompute **compatibility matrix**: O(m² × n) — score[i][j] = number of positions where students[i] == mentors[j]
- Use **bitmask DP** to assign students in fixed order (0 to m-1):
  - `dp[mask]` = maximum sum when assigning the first popcount(mask) students to the mentors in mask
  - Transition: for each unused mentor j (bit j not set), assign next student to j → add score[student][j]
- Final answer = `dp[(1 << m) - 1]`

**Pure, clean, optimal** — O(2ᵐ × m × n) time, with m ≤ 8 → extremely fast and elegant.
---

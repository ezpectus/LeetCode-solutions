# 1115. Print FooBar Alternately — Architectural Semaphore-Based Synchronization  
*O(n) — Optimal Thread Coordination with Semaphores*

---

## Problem Statement

You are given a class `FooBar` with two methods:
- `Foo(Action printFoo)` — should print `"foo"` exactly `n` times
- `Bar(Action printBar)` — should print `"bar"` exactly `n` times

These methods will be called **concurrently** by two different threads:
- One thread calls `Foo()`
- The other calls `Bar()`

**Goal**: Ensure strict alternation → output `"foobar"` repeated `n` times  
(i.e., `foo` from first thread, immediately followed by `bar` from second, and so on).

You **cannot** modify the `printFoo()` / `printBar()` calls themselves.

---

## Core Idea — SemaphoreSlim for Turn-Based Execution

**Key insight**:
- We need **strict ordering**: `foo` → `bar` → `foo` → `bar` → ...
- Use **two semaphores** to control turn:
  - `fooSemaphore` — allows `Foo` to proceed (initially open)
  - `barSemaphore` — allows `Bar` to proceed (initially blocked)

**Flow**:
- `Foo` waits on `fooSemaphore` → prints `"foo"` → releases `barSemaphore`
- `Bar` waits on `barSemaphore` → prints `"bar"` → releases `fooSemaphore`

→ Guarantees perfect alternation, no race conditions.

---

##  Implementation (C#)

```csharp
using System;
using System.Threading;

public class FooBar 
{
    private int n;
    private SemaphoreSlim fooSemaphore;
    private SemaphoreSlim barSemaphore;

    public FooBar(int n) 
    {
        this.n = n;
        fooSemaphore = new SemaphoreSlim(1, 1);  // Foo starts first
        barSemaphore = new SemaphoreSlim(0, 1);  // Bar waits initially
    }

    public void Foo(Action printFoo) 
    {
        for (int i = 0; i < n; i++) 
        {
            fooSemaphore.Wait();     // Wait for turn
            printFoo();              // Output "foo"
            barSemaphore.Release();  // Allow Bar to go
        }
    }

    public void Bar(Action printBar) 
    {
        for (int i = 0; i < n; i++) 
        {
            barSemaphore.Wait();     // Wait for turn
            printBar();              // Output "bar"
            fooSemaphore.Release();  // Allow next Foo
        }
    }
}
```


## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | n iterations per method                        |
| **Space Complexity**  | **O(1)**      | Only two semaphores                            |

**Optimal** — minimal overhead, perfect synchronization.

---

## Why This Works — Execution Flow

**Example**: `n = 2`

- **Thread A** calls `Foo()`:
  - i=0: `fooSemaphore` is open (initial count 1) → passes → prints `"foo"` → releases `barSemaphore`
  - i=1: waits until `Bar` releases `fooSemaphore` again

- **Thread B** calls `Bar()`:
  - i=0: `barSemaphore` now open → passes → prints `"bar"` → releases `fooSemaphore`
  - i=1: waits → then prints second `"bar"`

**Output**: `foobarfoobar`

**Correct** — strict alternation guaranteed regardless of thread scheduling.

---

## Pitfalls & Edge Cases

- **n=1** → outputs `"foobar"` exactly once
- **Thread scheduling** → semaphores enforce correct order even if threads start simultaneously or in any order
- **Concurrent start** → `fooSemaphore` ensures `Foo` prints first
- **No deadlock** → every print is always followed by a release
- **No busy waiting** → threads block efficiently on semaphores

All handled perfectly.

---

## Key Takeaway

This is a **masterpiece of thread synchronization**:

- **Two semaphores** → clean and intuitive turn-taking mechanism
- **Foo starts first** → correct initial state
- **No busy waiting** → efficient blocking with zero CPU waste
**Pure, clean, optimal** — perfect alternating print coordination.

---

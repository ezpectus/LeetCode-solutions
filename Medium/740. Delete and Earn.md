# LeetCode 740 — Delete and Earn  
**Approach: Transform to House Robber Problem**

---

##  Problem Restatement
We are given an array `nums`.  
- Picking a number `x` earns `x` points.  
- But all numbers `x-1` and `x+1` must be deleted.  
We must maximize the total points.

---

##  Core Idea
- Group values by number:  
  - For each unique number `x`, total points = `x * count(x)`.  
- After grouping, the problem becomes:  
  - If we take `x`, we cannot take `x-1` or `x+1`.  
  - This is exactly the **House Robber** problem on a line of values.  
- Steps:  
  1. Build an array `points[i]` = total points for number `i`.  
  2. Apply dynamic programming:  
     - `dp[i] = max(dp[i-1], dp[i-2] + points[i])`.  

---

##  Implementation (C#)

```csharp
public class Solution {
    public int DeleteAndEarn(int[] nums) {
        int maxVal = 0;
        foreach (int num in nums) {
            if (num > maxVal) maxVal = num;
        }

        int[] points = new int[maxVal + 1];
        foreach (int num in nums) {
            points[num] += num;
        }

        int take = 0, skip = 0;
        for (int i = 0; i <= maxVal; i++) {
            int takeNew = skip + points[i];
            int skipNew = Math.Max(skip, take);
            take = takeNew;
            skip = skipNew;
        }

        return Math.Max(take, skip);
    }
}
```

##  Time Complexity
- **Building points array:**  
  Each element in `nums` contributes to its bucket → `O(n)`.  
- **Dynamic Programming iteration:**  
  Iterate up to maximum value (≤ 10^4) → `O(maxVal)`.  
- **Total:**  
  → `O(n + maxVal)` overall.

---

##  Space Complexity
- **Points array:**  
  Size = `maxVal + 1` → `O(maxVal)`.  
- **DP variables:**  
  Only two integers (`take`, `skip`) maintained → `O(1)`.  
- **Total:**  
  → `O(maxVal)`.

---

#  Impact of Design Choices

| Design Choice                  | Effect                                                                 |
|--------------------------------|------------------------------------------------------------------------|
| **Transform to House Robber**  | Simplifies problem into a well-known DP pattern.                       |
| **Points array**               | Aggregates duplicates efficiently, avoids repeated calculations.       |
| **Two-variable DP**            | Optimizes memory usage, avoids full DP table.                          |

---

#  Pitfalls
- **Forgetting to aggregate duplicates:**  
  Leads to undercounting total points.  
- **Using naive recursion:**  
  Causes exponential runtime, not feasible for large inputs.  
- **Not handling max value correctly:**  
  May cause array out-of-bounds errors.  

---

#  Conclusion
- **What it gives:** Efficient solution by reducing to House Robber DP.  
- **Why it matters:** Handles duplicates and adjacency constraints cleanly.  
- **Key takeaway:**  
  1. Aggregate points by value.  
  2. Apply House Robber DP.  
  3. Achieve `O(n + maxVal)` time and `O(maxVal)` space.  


---

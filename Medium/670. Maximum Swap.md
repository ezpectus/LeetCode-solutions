# 🔁 Maximum Swap — Greedy Digit Rearrangement

## 🧾 Conclusion & Engineering Insight

This problem is a classic example of greedy digit optimization under a single-move constraint. 
The key insight is that the rightmost occurrence of a larger digit offers the best opportunity for gain when swapped forward.
By preprocessing the last occurrence of each digit, we enable constant-time lookups during the greedy scan. 
This transforms the brute-force idea of checking all swaps into a linear-time strategy with early exit.

## 🔧 Reusable Pattern:

- "Track future opportunities, and make one optimal move to maximize outcome."
- This technique generalizes well to:
- Lexicographic string rearrangement
- Inventory or trading optimizations
- Greedy scheduling with limited moves

## 🧠 Why It Matters:

- Encourages architectural thinking: preprocessing + greedy scan
- Highlights the power of early exit in constrained optimization
- Reinforces the value of digit-level manipulation in algorithmic tasks

## 🧠 Problem Statement

You're given an integer `num`. You may swap **two digits at most once** to produce the **maximum possible number**.  
Return the resulting number.

### Example:
- Input: `2736`  
- Output: `7236`  
- Explanation: Swap `2` and `7` to get the highest possible value.

---

## 💻 Code Implementation (C#)

```csharp
public class Solution {
    public int MaximumSwap(int num) {
        char[] digits = num.ToString().ToArray();
        int[] last = new int[10];
        int n = digits.Length;

        // Step 1: Record the last occurrence of each digit
        for (int i = 0; i < n; i++) {
            last[digits[i] - '0'] = i;
        }

        // Step 2: Greedy scan from left to right
        for (int i = 0; i < n; i++) {
            // Try to find a bigger digit to swap forward
            for (int d = 9; d > digits[i] - '0'; d--) {
                if (last[d] > i) {
                    // Step 3: Swap and return
                    char temp = digits[i];
                    digits[i] = digits[last[d]];
                    digits[last[d]] = temp;
                    return int.Parse(new string(digits));
                }
            }
        }

        // Step 4: No swap needed — return original number
        return num;
    }
}
```


## 🧱 Step-by-Step Breakdown
🔹 Step 1: Track Last Occurrence
We build a map last[d] that stores the last index where digit d appears. This allows us to quickly check if a better digit exists later in the number.

🔹 Step 2: Greedy Scan
We iterate from left to right. For each digit digits[i], we check if there's a larger digit d that appears after index i.

🔹 Step 3: Perform Swap
If such a digit exists, we swap digits[i] with digits[last[d]] and return the new number immediately. Only one swap is allowed, so we exit after the first valid improvement.

🔹 Step 4: No Swap Case
If no better digit is found for any position, the number is already maximal — return it as-is.

## 🧩 Pattern: Greedy Digit Swap for Lexicographic Maximization
🔧 Technique:
Preprocessing: Build last[] map of digit positions

Greedy Search: For each digit, look for a better one to swap forward

Early Exit: Perform one optimal swap and return

## 📌 Use Cases:

- Rearranging digits for max/min value
- Lexicographic optimization in strings
- Greedy swap under constraints (1 move, adjacency, etc.)

## 🧠 Why It Works:
You only need one optimal move to maximize the number

The rightmost occurrence of a larger digit gives the best gain

Greedy ensures local improvement leads to global optimum

## 📊 Complexity Analysis
Aspect	Value
Time	O(n)
Space	O(1)
Swap Count	At most 1
Efficient for large numbers up to 10⁸.

## 🧠 Engineering Insight
This task teaches a reusable greedy pattern:

"Track future opportunities, and make one optimal move to maximize outcome."

You can apply this to:

Digit rearrangement

Lexicographic string swaps

Graph node prioritization

Inventory or trading optimizations

## 🧾 Conclusion

The Maximum Swap problem exemplifies a clean greedy strategy where a single optimal move yields the best result. 
By tracking the last occurrence of each digit, we enable constant-time access to future opportunities. T
he greedy scan ensures that the first viable swap with a higher digit is executed immediately, guaranteeing maximal gain.

This pattern is not just efficient — it’s architecturally elegant:

- Preprocess once, scan once, exit early
- Avoids brute-force enumeration of all swaps
- Highlights the power of digit-level manipulation in constrained optimization

## 🔁 Reusable Insight:

In single-move maximization tasks, tracking future state and acting greedily can 
outperform exhaustive search — especially when the cost of checking all options is high.

This technique generalizes to:

- Lexicographic rearrangement
- Greedy scheduling
- Inventory or trading optimizations with limited actions


---

# 1048. Longest String Chain

---

## Problem Restatement
We are given an array of words.  
A word `A` is a predecessor of word `B` if we can insert exactly one letter anywhere in `A` without changing the order of the other characters to make it equal to `B`.  

We need to return the length of the longest possible word chain.

---

## Key Idea
This is a **Dynamic Programming with HashMap** problem.

1. **Sort words by length.**  
   - Because a predecessor must be shorter than its successor by exactly 1 character.

2. **DP relation:**  
   - For each word, generate all possible predecessors by removing one character.  
   - If the predecessor exists in the dictionary, update the chain length.  
   - Formula:  
     ```
     dp[word] = max(dp[word], dp[predecessor] + 1)
     ```

3. **Answer:**  
   - The maximum value in `dp`.

---

## Code (C#)
```csharp
public class Solution {
    public int LongestStrChain(string[] words) {
        // Step 1: Sort words by length
        Array.Sort(words, (a, b) => a.Length.CompareTo(b.Length));

        // Step 2: DP dictionary
        Dictionary<string, int> dp = new Dictionary<string, int>();
        int maxChain = 1;

        foreach (string word in words) {
            int best = 1;
            // Step 3: Generate all possible predecessors
            for (int i = 0; i < word.Length; i++) {
                string predecessor = word.Substring(0, i) + word.Substring(i + 1);
                if (dp.ContainsKey(predecessor)) {
                    best = Math.Max(best, dp[predecessor] + 1);
                }
            }
            dp[word] = best;
            maxChain = Math.Max(maxChain, best);
        }

        return maxChain;
    }
}
```


## Complexity
- **Time:** O(n * L²)  
  - n = number of words  
  - L = maximum word length (≤ 16)  
  - For each word, we generate up to L predecessors and check them in the dictionary.  
- **Space:** O(n), storing DP values for each word.  

---

## Example Walkthrough

**Input:** `["a","b","ba","bca","bda","bdca"]`  
- Sorted: `["a","b","ba","bca","bda","bdca"]`  
- Chains:  
  - `"a" → "ba" → "bda" → "bdca"` length = 4 ✅  
- **Output = 4**

**Input:** `["xbc","pcxbcf","xb","cxbc","pcxbc"]`  
- Chain: `"xb" → "xbc" → "cxbc" → "pcxbc" → "pcxbcf"` length = 5 ✅  
- **Output = 5**

**Input:** `["abcd","dbqca"]`  
- No valid chain longer than 1.  
- **Output = 1**

---

## Why This Works
- Sorting by length ensures we always build chains from shorter to longer words.  
- Generating predecessors by removing one character allows us to check if a valid chain exists.  
- DP with HashMap stores the best chain length ending at each word.  
- Incrementally updating ensures correctness and efficiency.  

---

## Conclusion
The solution uses **DP with HashMap**:
- Sort words by length.  
- For each word, generate all possible predecessors.  
- Update chain lengths incrementally.  

This yields an efficient solution for up to 1000 words with length ≤ 16, guaranteeing correctness and optimal performance.


---

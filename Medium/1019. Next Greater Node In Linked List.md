# 1019. Next Greater Node In Linked List — Architectural Monotonic Stack (Reverse Traversal)  
*O(n) — Optimal Single Pass with Stack*

---

## Problem Statement

Given linked list `head`.

For each node, find **next greater** value (first strictly larger to the right).

Return array where `answer[i]` = next greater for i-th node (1-indexed), or **0** if none.

---

## Core Idea — Monotonic Decreasing Stack (Reverse Processing)

**Brute** → O(n²) too slow.

**Optimal**:
- Traverse list **right to left**
- Maintain **monotonic decreasing stack** of values
- For current node:
  - Pop stack while top ≤ current → discard smaller/equal
  - Next greater = **stack top** (or 0 if empty)
  - Push current value

**Stack** keeps candidates for "next greater".

**Reverse** → natural for linked list (no random access).

---

## Implementation (C#)

```csharp
public class Solution {
    public int[] NextLargerNodes(ListNode head) {
        // First: count nodes and collect values
        var values = new List<int>();
        ListNode curr = head;
        while (curr != null) {
            values.Add(curr.val);
            curr = curr.next;
          }

        int n = values.Count;
        int[] answer = new int[n];
        var stack = new Stack<int>(); // indices

        // Traverse from right to left
        for (int i = n - 1; i >= 0; i--) {
            // Pop smaller or equal elements
            while (stack.Count > 0 && values[stack.Peek()] <= values[i])  stack.Pop();
            
            // Next greater = top of stack or 0
            answer[i] = stack.Count > 0 ? values[stack.Peek()] : 0;

            // Push current index
            stack.Push(i);
        }

        return answer;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Each node pushed/popped at most once           |
| **Space Complexity**  | **O(n)**      | Stack + values list                            |

**Optimal** — linear time.

---

## Why This Works — Example Walkthrough

**Input**: `head = [2,1,5]`

- values = [2,1,5]
- i=2 (5): stack empty → answer[2]=0 → push index 2
- i=1 (1): top val=5 >1 → answer[1]=5 → push 1
- i=0 (2): top val=1 ≤2 → pop → top val=5 >2 → answer[0]=5 → push 0

→ `[5,5,0]` correct.

**Input**: `[2,7,4,3,5]`

- From right:
  - 5 → answer=0 → push
  - 3 → top=5 → answer=5 → push
  - 4 → top=5 >4 → answer=5 → push
  - 7 → pop 4,3,5 (all ≤7) → empty → answer=0 → push
  - 2 → top=7 >2 → answer=7 → push

→ `[7,0,5,5,0]` correct.

---

## Pitfalls & Edge Cases

- **Decreasing list** → all 0
- **Increasing list** → all 0 except last
- **Duplicates** → strictly greater → equal values give 0
- **Single node** → [0]

All handled perfectly.

---

## Key Takeaway

This is a **classic monotonic stack** problem:

- **Reverse traversal** → simulate "to the right"
- **Decreasing stack** → keep potential next greater candidates
- **Pop smaller/equal** → maintain valid candidates
**Pure, clean, optimal** — one of the best next greater element variants.

---

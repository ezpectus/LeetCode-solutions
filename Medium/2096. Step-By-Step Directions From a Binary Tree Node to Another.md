# 2096. Step-By-Step Directions From a Binary Tree Node to Another  
*O(n) — Elegant Path Construction via DFS + Common Prefix Removal*

---

## Problem Statement

You are given the root of a binary tree with `n` nodes (2 ≤ n ≤ 10⁵).  
Each node has a **unique** value from 1 to `n`.  
You are given two distinct values: `startValue` (starting node) and `destValue` (destination node).

Find the **shortest path** from the node with value `startValue` to the node with value `destValue`.  
Return the directions as a string using only:
- `'L'` — move to left child
- `'R'` — move to right child
- `'U'` — move to parent

The path must be the **shortest** possible (minimum number of moves).

**Constraints**:
- 2 ≤ number of nodes ≤ 10⁵
- 1 ≤ node.val ≤ n (all values unique)
- 1 ≤ startValue, destValue ≤ n
- startValue ≠ destValue

---

## Core Idea — DFS Paths + Remove Common Prefix (LCA Trick)

**Beautiful insight**:
- The shortest path from start to dest always goes through their **Lowest Common Ancestor (LCA)**
- Path = **start → LCA** (all 'U' moves) + **LCA → dest** (all 'L'/'R' moves)
- We find LCA **implicitly** by comparing paths from root to start and root to dest

**Algorithm**:
1. Use DFS to find path from root → startValue → string of 'L'/'R' (built bottom-up)
2. Use DFS to find path from root → destValue → string of 'L'/'R' (built bottom-up)
3. Remove the **longest common suffix** of both paths (this is path from LCA to root reversed)
4. The remaining part of start path → replace all 'L'/'R' with 'U' (going up to LCA)
5. The remaining part of dest path → **reverse** it (because it was built bottom-up) → gives correct 'L'/'R' from LCA to dest
6. Result = 'U's (from start to LCA) + reversed remaining dest path

**Why bottom-up paths?**
- DFS builds path from leaf to root → reverse order
- Common suffix = path from LCA to root (reversed)
- Removing common suffix leaves path from start to LCA and LCA to dest (reversed)

**Time**: O(n) — two DFS traversals + O(n) string operations  
**Space**: O(n) — recursion stack + path strings

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public string GetDirections(TreeNode root, int startValue, int destValue) {
        StringBuilder startChars = new(), finalChars = new();
        DFS(root, startValue, startChars);
        DFS(root, destValue, finalChars);
        
        RemoveCommonPath(startChars, finalChars);
        
        ReverseSB(finalChars);

        startChars.Replace('R', 'U');
        startChars.Replace('L', 'U');
        return startChars.Append(finalChars).ToString();
    }
    private bool DFS(TreeNode node, int find, StringBuilder target){
        if(node is null) return false;
        if(node.val == find) return true;

        var left = DFS(node.left, find, target);
        if(left) target.Append('L');
        var right = DFS(node.right, find, target);
        if(right) target.Append('R');

        return left || right;
    }

    private void RemoveCommonPath(StringBuilder path1, StringBuilder path2){
        while(path1.Length > 0 && path2.Length > 0 && path1[path1.Length - 1] == path2[path2.Length - 1]){
            path1.Remove(path1.Length - 1, 1);
            path2.Remove(path2.Length - 1, 1);
        }
    }

    private void ReverseSB(StringBuilder path){
        for(int i = 0; i < path.Length / 2; i++){
            var temp = path[path.Length - i - 1];
            path[path.Length - i - 1] = path[i];
            path[i] = temp;
        }
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Two DFS traversals to build paths from root to start and dest: O(n)  
Common suffix removal and string operations: O(n) in worst case |
| **Space Complexity**  | **O(n)**      | Recursion stack during DFS: O(n) in worst case (skewed tree)  
Two StringBuilders for paths: O(n) |

**Optimal** — linear time and linear space — perfectly efficient even for large trees (n ≤ 10⁵).

---

## Why This Code Works — Step-by-Step Explanation

### 1. Path Building (DFS)
- The `DFS` function builds the path **bottom-up**:  
  - When returning from recursion (found the target), it appends 'L' or 'R' on the way back up.
  - Result: path string is stored **from target to root** (reversed direction).

### 2. Remove Common Suffix
- The common **suffix** of both paths is the path from the **LCA to root** (in reversed form).
- Removing this common suffix leaves:
  - In `startPath`: path from **start to LCA** (still reversed)
  - In `destPath`: path from **dest to LCA** (still reversed)

### 3. Reverse destPath
- After removing the common suffix, `destPath` contains the reversed path from dest to LCA.
- Reversing it gives the correct direction: **LCA → dest** with 'L' and 'R' moves.

### 4. Convert startPath to 'U's
- The remaining `startPath` contains the reversed path from start to LCA.
- Replacing every 'L' and 'R' with 'U' correctly represents going **up** from start to LCA.

### 5. Concatenate
- Final string = **'U's** (start → LCA) + **'L'/'R' moves** (LCA → dest)  
  → gives the exact shortest path directions.

**Correct** —  
This clever use of **bottom-up path construction** + **common suffix removal** implicitly finds the LCA and splits the path without ever computing the LCA node explicitly.

---

## Key Takeaway

This is a **classic tree path query** problem solved with one of the most elegant tricks in tree problems:

* Perform **DFS** to build paths from root → start and root → dest (constructed **bottom-up**)
* Remove the **common suffix** of both paths (this is the reversed path from LCA to root)
* Remaining `startPath` → replace every move with **'U'** (going up to LCA)
* Remaining `destPath` → **reverse** it (now correct direction from LCA to dest)
* Concatenate: 'U's + reversed dest suffix → shortest path directions string

**Pure, clean, optimal** — O(n) time, O(n) space, beautiful insight, no need for explicit LCA computation or heavy preprocessing.
---

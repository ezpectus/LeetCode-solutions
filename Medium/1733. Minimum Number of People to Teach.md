# ðŸ§  1733. Minimum Number of People to Teach

## ðŸ“˜ Problem Summary

In a social network of `m` users, each user knows a set of languages.  
Two users can communicate **only if they share at least one common language**.  
You're given a list of friendships between users.  
You can **choose one language** and teach it to some users so that **every friendship becomes communicable**.  
Return the **minimum number of users to teach**.

---

## ðŸ”§C# Implementation

```csharp
public class Solution {
    public int MinimumTeachings(int n, int[][] languages, int[][] friendships) {
        HashSet<int> teach = new HashSet<int>();

        // Step 1: Identify users in friendships that can't communicate
        foreach (var pair in friendships) {
            int u = pair[0] - 1;
            int v = pair[1] - 1;

            if (!hasCommonLanguage(languages[u], languages[v])) {
                teach.Add(u);
                teach.Add(v);
            }
        }

        // Step 2: Try teaching each language and count how many users need it
        int minteach = int.MaxValue;

        for (int lang = 1; lang <= n; lang++) {
            int count = 0;

            foreach (var user in teach) {
                if (!languages[user].Contains(lang)) {
                    count++;
                }
            }

            minteach = Math.Min(minteach, count);
        }

        return minteach;
    }

    private bool hasCommonLanguage(int[] a, int[] b) {
        HashSet<int> set = new HashSet<int>(a);
        foreach (var lang in b) {
            if (set.Contains(lang)) return true;
        }
        return false;
    }
}
```



## ðŸ“¶ Signal Table

| Signal              | Meaning                                                  |
|---------------------|----------------------------------------------------------|
| `languages[i]`      | Languages known by user `i`                              |
| `friendships[i]`    | Pair of users who are friends                            |
| `hasCommonLanguage`| Checks if two users share a language                     |
| `teach`             | Set of users involved in non-communicable friendships    |
| `minteach`          | Minimum number of users to teach for full communication  |

---

## âœ… Takeaways

- This is a **greedy + set-based optimization** problem.
- The focus is on **friendships that can't communicate** due to language gaps.
- For each language, simulate teaching it to all users in `teach` who donâ€™t know it.
- The optimal language minimizes the number of people to teach.
- The solution avoids brute-force and targets only **problematic edges**, not the entire graph.

---

## ðŸ§© Engineering Reflection

This task isn't about brute-force â€” it's about **signal isolation**.  
The key is to isolate users who block communication, then simulate teaching each language to cover those gaps.  
The architecture is clean:

- One pass to identify blockers  
- One loop to evaluate teaching cost per language  
- One final min-check to return the optimal strategy

This pattern generalizes to **coverage problems**, **set intersection**, and **minimal intervention strategies**.

---

## ðŸ§  Architectural Recognition Signals

- **Friendships are pairwise, not transitive** â†’ no need for graph traversal or DP  
- **Communication depends on shared language** â†’ set intersection is the core signal  
- **Only one language can be taught** â†’ greedy simulation across all languages  
- **Goal is minimal intervention** â†’ classic optimization over a constrained domain  
- **No need to teach everyone** â†’ focus only on users in broken friendships  
- **Languages are bounded (1 to n)** â†’ feasible to brute-force over language choices

This wasnâ€™t a dynamic programming or graph traversal problem.  
Instead, it was a **localized optimization**: isolate the conflict zone, simulate minimal fixes, and choose the best.  
Even in fatigue, the problem was decomposed into signals and expressed through clean set logic.


---

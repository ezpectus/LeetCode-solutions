# 1901. Find a Peak Element II  
*O(m log n) — Optimal Binary Search on Rows + Greedy Column Check*

---

## Problem Statement

You are given a 0-indexed `m × n` integer matrix `mat` where:

- No two adjacent cells (up, down, left, right) have the same value
- The grid is surrounded by an imaginary border of `-1` in all directions

A **peak element** is a cell that is **strictly greater** than all its four adjacent neighbors.

Find **any** peak element `mat[i][j]` and return its coordinates `[i, j]`.

You must solve it in **O(m log n)** or **O(n log m)** time.

---

## Core Idea — Binary Search on Rows + Find Peak in Column

**Key insight**:
- Because the matrix has **no two adjacent equal** → every row/column has a **peak**
- We can perform **binary search on rows** (or columns) to reduce the problem dimension
- For a mid row, look at the **maximum value** in that row
- Find the column `c` where `mat[mid][c]` is maximum in that row
- Then look at the **neighbors above and below** in column `c`:
  - If `mat[mid][c]` > both above and below → it's a peak → done
  - If above > mid → peak must be in upper half (because values decrease downward)
  - If below > mid → peak must be in lower half
- This guarantees we discard half the rows each time → O(log m) steps
- In each step we scan the entire row → O(n) per step → total **O(n log m)**

**Note**:
- We could binary search columns instead → O(m log n)
- Both are acceptable (problem allows either)

---

## Clean Implementation (C#) — Binary Search on Rows

```csharp
public class Solution {
    public int[] FindPeakGrid(int[][] mat) {
        int m = mat.Length;
        int n = mat[0].Length;

        int top = 0;
        int bottom = m - 1;

        while (top <= bottom) {
            int mid = top + (bottom - top) / 2;

            // Find the column with maximum value in this row
            int maxCol = 0;
            for (int j = 1; j < n; j++) {
                if (mat[mid][j] > mat[mid][maxCol])  maxCol = j; 
            }

            int curr = mat[mid][maxCol];

            // Check neighbors above and below in the same column
            bool hasAbove = mid > 0 && mat[mid - 1][maxCol] > curr;
            bool hasBelow = mid < m - 1 && mat[mid + 1][maxCol] > curr;

            if (!hasAbove && !hasBelow) {
                // This is a peak (greater than left/right implicitly by max in row)
                return new int[] { mid, maxCol };
            }

            // If upper neighbor is larger → peak must be in upper half
            if (hasAbove)  bottom = mid - 1;
            // Else lower neighbor is larger → peak in lower half
            else top = mid + 1;
            
        }

        // Problem guarantees at least one peak exists → should never reach here
        return new int[] { -1, -1 };
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n log m)**| Binary search on rows: log m (~9 steps for m ≤ 500) × O(n) time to scan row and find max column |
| **Space Complexity**  | **O(1)**      | Only a few integer variables (no extra arrays) |

**Optimal** — meets the required O(m log n) or O(n log m) time bound perfectly.

---

## Why This Works — Example Walkthrough

**Example 1**: `mat = [[1,4],[3,2]]`

- Binary search rows: top=0, bottom=1
- mid=0: row [1,4] → maxCol=1 (value 4)
- Above: no neighbor
- Below: mat[1][1]=2 < 4 → no larger neighbor → it's a peak → return **[0,1]** → correct

**Example 2**: `mat = [[10,20,15],[21,30,14],[7,16,32]]`

- mid=1: row [21,30,14] → maxCol=1 (value 30)
- Above: mat[0][1]=20 < 30
- Below: mat[2][1]=16 < 30 → no larger neighbor → peak at **[1,1]** → correct

**Correct** — at each step we pick the **strongest candidate** in the middle row (maximum value in row).  
If it's greater than vertical neighbors → it's a peak → done.  
If upper neighbor is larger → any peak in this column must be **above** (values decrease downward).  
If lower neighbor is larger → peak must be **below**.  
This halves the search space each time — logarithmic steps with linear row scan.

---

## Pitfalls & Edge Cases

- **m = 1 or n = 1** → single row/column → maximum element is always a peak
- **Peak on border** → imaginary -1 border ensures it's greater than non-existing neighbors
- **Multiple peaks** → any one is acceptable
- **m, n ≤ 500** → log 500 ≈ 9 steps × 500 = ~4500 operations → extremely fast
- **All values distinct** → guaranteed by problem (no adjacent equals)

All handled perfectly.

---

## Key Takeaway

This is a **beautifully clever binary search + greedy** 2D peak finding problem:

- Binary search on **rows** (or columns) to reduce the search space logarithmically
- At each mid row, find the **column with the maximum value** in that row (best candidate)
- Check **vertical neighbors** (above and below) in that column:
  - If current value > both neighbors → it's a peak → return [mid, maxCol]
  - If upper neighbor > current → discard lower half (peak must be above)
  - If lower neighbor > current → discard upper half (peak must be below)
- Logarithmic steps × linear row scan → O(n log m)

**Pure, clean, optimal** — efficient way to find any peak in 2D grid with no adjacent equals.

---

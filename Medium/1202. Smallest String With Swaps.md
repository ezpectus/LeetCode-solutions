# 1202. Smallest String With Swaps — Architectural Union-Find + Component Sorting  
*O(n log n + m α(n)) — Optimal Disjoint Set with Greedy Sorting*

---


## Problem Statement

Given string `s` and list of swappable index pairs `pairs`.

You can **swap** characters at any pair **any number** of times.

Return **lexicographically smallest** possible string.

---

## Core Idea — Union-Find for Connected Components + Sort Characters

**Key insight**:
- Swappable pairs → **connected components** (graph)
- Within component → can rearrange characters **freely** (any order)
- To minimize → **sort characters** in each component → place smallest first

**Steps**:
1. **Union-Find** → group indices into components
2. For each component:
   - Collect **indices** and **characters**
   - Sort indices ascending
   - Sort characters ascending
   - Assign sorted chars to sorted indices

**Result** → smallest possible string.

---

## Full Optimal Implementation (C#)

```csharp
public class Solution {
    public string SmallestStringWithSwaps(string s, IList<IList<int>> pairs)  {
        int n = s.Length;
        var parent = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
        

        // Union-Find
        int Find(int x) {
            if (parent[x] != x)  parent[x] = Find(parent[x]);
            
            return parent[x];
        }

        void Union(int x, int y) {
            int px = Find(x);
            int py = Find(y);
            if (px != py)  parent[px] = py; 
        }

        foreach (var pair in pairs) Union(pair[0], pair[1]);
        

        // Group indices by root parent
        var components = new Dictionary<int, List<int>>();
        for (int i = 0; i < n; i++) {
            int root = Find(i);
            if (!components.ContainsKey(root))  components[root] = new List<int>();
            components[root].Add(i);
        }

        // Build result
        char[] result = s.ToCharArray();
        foreach (var component in components.Values) {
            // Get indices and characters
            var indices = component;
            var chars = new List<char>();
            foreach (int idx in indices)  chars.Add(s[idx]);
            

            // Sort both
            indices.Sort();
            chars.Sort();

            // Assign sorted chars to sorted positions
            for (int i = 0; i < indices.Count; i++) result[indices[i]] = chars[i];  
        }

        return new string(result);
    }
}
```

## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n + m α(n))**       | Union-Find nearly linear + sorting components  |
| **Space Complexity**  | **O(n)**                      | Parent array + component lists                 |

**Optimal** — best for large n.

---

## Why This Works — Example Walkthrough

**Input**: `s = "dcab"`, `pairs = [[0,3],[1,2]]`

- Unions: 0↔3, 1↔2
- Components:
  - {0,3}: chars 'd','b' → sorted 'b','d' → positions 0,3 → "b..d"
  - {1,2}: chars 'c','a' → sorted 'a','c' → positions 1,2 → "bacd"

→ **"bacd"**

**Correct**.

**Input**: add `[0,2]` → `pairs = [[0,3],[1,2],[0,2]]`

- All indices connected → one component
- chars "dcab" → sorted "abcd"
- → **"abcd"**

**Correct**.

---

## Pitfalls & Edge Cases

- **No pairs** → original string unchanged
- **All connected** → fully sorted string
- **Multiple components** → sort each independently
- **Same characters** → sorting handles correctly (stable)

All handled perfectly.

---

## Key Takeaway

This is a **masterpiece of graph + greedy**:

- **Union-Find** → efficiently find swappable groups (connected components)
- **Sort chars in group** → achieve minimal lexicographical order
- **In-place assignment** → efficient reconstruction
**Pure, clean, optimal** — one of the best string rearrangement problems.

---

# 787. Cheapest Flights Within K Stops

**Difficulty:** Medium  
**Topics:** Dynamic Programming, Graph, Bellman-Ford  

---

## ðŸ“– Problem Restatement
You are given `n` cities and a list of flights `flights[i] = [from, to, price]`.  
You need to find the cheapest price from `src` to `dst` with at most `k` stops.  
If no such route exists, return `-1`.

---

## ðŸ’¡ Core Idea
- This is a **shortest path problem with a constraint on number of edges**.  
- Classic Dijkstra does not work directly because of the stop limit.  
- Instead, we use **Bellman-Ford style DP**:  
- `dp[step][city]` = minimum cost to reach `city` using at most `step` flights.  
- Transition:  ```dp[step][to] = min(dp[step][to], dp[step-1][from] + price)```
- Base case:  ```dp[0][src] = 0; dp[0][other] = âˆž```
- Answer:  ```dp[k+1][dst] (since k stops = k+1 edges)```
  
---

## ðŸ”Ž Step-by-Step Algorithm
1. Initialize DP table of size `(k+2) x n` with `INF`.  
2. Set `dp[0][src] = 0`.  
3. For each step from 1 to k+1:  
 - Copy previous values (`dp[step][city] = dp[step-1][city]`).  
 - For each flight `(from, to, price)`:  
   ```
   if dp[step-1][from] + price < dp[step][to]:
       dp[step][to] = dp[step-1][from] + price
   ```
4. Return `dp[k+1][dst]` if finite, else `-1`.

---

## âœ… C# Implementation
```csharp
public class Solution {
  public int FindCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
      int INF = int.MaxValue / 2;
      int[,] dp = new int[k+2, n];

      // init
      for (int step = 0; step <= k+1; step++) {
          for (int city = 0; city < n; city++) {
              dp[step, city] = INF;
          }
      }
      dp[0, src] = 0;

      // relaxation (Bellman-Ford style)
      for (int step = 1; step <= k+1; step++) {
          for (int city = 0; city < n; city++) {
              dp[step, city] = dp[step-1, city]; // carry over
          }
          foreach (var flight in flights) {
              int from = flight[0], to = flight[1], price = flight[2];
              if (dp[step-1, from] + price < dp[step, to]) {
                  dp[step, to] = dp[step-1, from] + price;
              }
          }
      }

      return dp[k+1, dst] == INF ? -1 : dp[k+1, dst];
   }
}
```
## ðŸ“Š Complexity Analysis

- **Time Complexity: O(k * |flights|)**  
  - For each of `k+1` steps, we relax all edges.  
  - This mirrors the Bellman-Ford algorithm, which iteratively relaxes edges.  

- **Space Complexity: O(k * n)**  
  - DP table stores the minimum cost for each city at each step.  
  - Can be optimized to O(n) with two arrays (`prev`, `curr`).  

---

## âš ï¸ Pitfalls

- **Stops vs Edges**  
  - Remember: `k` stops = `k+1` edges.  

- **Copying Previous Values**  
  - Must copy values from the previous step before relaxing, otherwise you may exceed the stop limit.  

- **Algorithm Choice**  
  - Dijkstra is not suitable here because of the stop constraint.  
  - Bellman-Ford style DP works perfectly since it respects edge limits.  

- **Edge Cases**  
  - No path â†’ return `-1`.  
  - Direct flight with `k = 0` â†’ return direct cost.  
  - Multiple paths â†’ choose the cheapest within the stop limit.  

---

## ðŸ”Ž Example Walkthrough

**Input:**  
`n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1`

- **Step 0:**  
```
dp[0][0] = 0
dp[0][1] = âˆž
dp[0][2] = âˆž
```

- **Step 1 (relaxation):**  
```
dp[1][1] = 100
dp[1][2] = 500
```

- **Step 2 (relaxation):**  
```dp[2][2] = min(500, dp[1][1] + 100 = 200) = 200```

**Answer:** `200`

---

## âœ… Key Takeaway

- This problem is solved by **Bellman-Ford style DP**:  
```dp[step][to] = min(dp[step][to], dp[step-1][from] + price)```
- Clean O(k * |flights|) solution, memory optimizable to O(n).  
- **Pattern:** "shortest path with limited edges" â†’ always think Bellman-Ford.  


---






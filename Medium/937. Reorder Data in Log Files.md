# 937. Reorder Data in Log Files — Architectural Custom Comparator Sorting  
*O(n log n × l) — Optimal Stable Partition + Sort*

---

## Problem Statement

Given array `logs`:
- **Letter-logs**: identifier + lowercase letters
- **Digit-logs**: identifier + digits

Reorder:
1. **All letter-logs** before **digit-logs**
2. **Letter-logs** sorted:
   - By **content** (after identifier) lexicographically
   - If content equal → by **identifier**
3. **Digit-logs** keep **original relative order**

Return reordered logs.

---

## Core Idea — Custom Comparator for Stable Sort

**Key insights**:
- Use **stable sort** → digit-logs preserve order
- **Custom comparator**:
  - First: letter-log < digit-log
  - Then: compare **content**, then **identifier**

**Implementation**:
- For each log:
  - Find first space → split identifier and content
  - Check if content starts with digit → digit-log
- Comparator logic:
  - If one letter and one digit → letter first
  - If both letter → compare content, then identifier
  - If both digit → equal (stable sort preserves order)

---

##  Implementation (C++)

```cpp
class Solution {
public:
    vector<string> reorderLogFiles(vector<string>& logs){
        stable_sort(logs.begin(), logs.end(), [](const string& a, const string& b) {
            size_t spaceA = a.find(' ');
            size_t spaceB = b.find(' ');

            string idA = a.substr(0, spaceA);
            string contentA = a.substr(spaceA + 1);
            string idB = b.substr(0, spaceB);
            string contentB = b.substr(spaceB + 1);

            bool isDigitA = isdigit(contentA[0]);
            bool isDigitB = isdigit(contentB[0]);

            if (isDigitA && !isDigitB) return false;  
            if (!isDigitA && isDigitB) return true;  

           
            if (!isDigitA && !isDigitB) {
                if (contentA != contentB) 
                    return contentA < contentB;
                return idA < idB;
            }
            return false;
        });

        return logs;
    }
};
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n × l)**    | n = logs count, l = average length             |
| **Space Complexity**  | **O(1)**              | In-place sort (excluding temporary string ops) |

**Optimal** — sorting required, no extra data structures.

---

## Why This Works — Example Walkthrough

**Input**: `["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"]`

- **Identifier + content split** for each log
- **Letter-logs**: `"let1 art can"`, `"let2 own kit dig"`, `"let3 art zero"`
- **Digit-logs**: `"dig1 8 1 5 1"`, `"dig2 3 6"`

- **Sort letter-logs**:
  - By content:
    - `"art can"` < `"art zero"` < `"own kit dig"`
  - `"art can"` vs `"art zero"` → `"can"` < `"zero"` → `"let1"` before `"let3"`
- **Digit-logs** remain in original relative order (thanks to `stable_sort`)

→ `["let1 art can","let3 art zero","let2 own kit dig","dig1 8 1 5 1","dig2 3 6"]`

**Correct** — matches expected output.

---

## Pitfalls & Edge Cases

- **Content identical** → fall back to identifier comparison
- **Digit-logs** → stable order preserved by `stable_sort`
- **Mixed types** → letter-logs always before digit-logs
- **Single word after identifier** → handled correctly

All covered perfectly.

---

## Key Takeaway

This is a **beautifully clean** custom sort problem:

- **Stable sort** → preserves digit-log relative order
- **Custom comparator** → multi-level comparison (type → content → identifier)
- **String splitting** → clean extraction of identifier and content

**No extra space. No manual partition.**
**Pure, elegant, optimal** — one of the best Medium sorting problems.

---

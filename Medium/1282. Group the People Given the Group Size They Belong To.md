# 1282. Group the People Given the Group Size They Belong To — Architectural HashMap Grouping  
*O(n) — Optimal Single Pass Bucket Collection*

---

## Problem Statement

Given array `groupSizes` where `groupSizes[i]` = required group size for person `i`.

**Group people** so each person `i` in group of exactly `groupSizes[i]`.

Return **any valid grouping** (list of groups).

Guaranteed solution exists.

---

## Core Idea — Group by Size + Collect Full Buckets

**Key insight**:
- People with same `groupSizes[i]` = `size` → can be grouped together
- For each size → collect people needing that size
- When **exactly `size`** people collected → form group

**Use**:
- `Dictionary<int, List<int>>` → size → list of people indices
- For each person → add to list of their size
- When list.Count == size → add to result, clear list

**Simple and clean**.

---

##  Implementation (C#)

```csharp
public class Solution {
    public IList<IList<int>> GroupThePeople(int[] groupSizes) {
        var groups = new Dictionary<int, List<int>>();
        var result = new List<IList<int>>();

        for (int i = 0; i < groupSizes.Length; i++){
            int size = groupSizes[i];

            if (!groups.ContainsKey(size)) groups[size] = new List<int>();
            groups[size].Add(i);

            // When full group collected
            if (groups[size].Count == size){
                result.Add(new List<int>(groups[size]));
                groups[size].Clear();
            }
        }

        return result;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass, each person processed once        |
| **Space Complexity**  | **O(n)**      | Dictionary + result lists                      |

**Optimal** — linear time.

---

## Why This Works — Example Walkthrough

**Input**: `groupSizes = [3,3,3,3,3,1,3]`

- size 3: people 0,1,2,3,4,6
- size 1: person 5

**Process**:
- Add 0,1,2 → group size 3 full → `[[0,1,2]]`
- Add 3,4,6 → group size 3 full → `[[3,4,6]]`
- Add 5 → group size 1 full → `[[5]]`

→ `[[0,1,2],[3,4,6],[5]]` (order may vary)

**Correct**.

**Input**: `[2,1,3,3,3,2]`

- size 1: [1]
- size 2: [0,5]
- size 3: [2,3,4]

→ `[[1],[0,5],[2,3,4]]`

**Correct**.

---

## Pitfalls & Edge Cases

- **size=1** → single-person groups
- **Multiple full groups** → multiple lists for same size
- **All same size** → split into multiple groups of that size
- **n=1** → `[[0]]`

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** grouping problem:

- **Bucket by group size**
- **Collect until full**
- **Emit group** when count matches size

**No sorting. No complex logic.**
**Pure, clean, optimal** — perfect bucket grouping.

---

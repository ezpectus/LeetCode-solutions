# 3573. Best Time to Buy and Sell Stock V — Architectural Memoized Recursive DP with 3 States  
*O(n × k) — Optimal Top-Down Tree DP*

---

## Problem Statement

Given array `prices` and integer `k`.

Allowed **at most k** transactions:
- **Normal**: buy low → sell high → profit `prices[j] - prices[i]`
- **Short**: sell high → buy back low → profit `prices[i] - prices[j]`

Transactions **sequential**.

Return **maximum profit**.

---

## Core Idea — Recursive DP with 3 States

**States**:
- `i` — current day (from end)
- `j` — remaining transactions
- `state`:
  - `0` — no position (free)
  - `1` — holding **long** (bought)
  - `2` — holding **short** (sold short)

**Transitions**:
- `state=0`: do nothing, buy (→ long), short (→ short)
- `state=1`: hold long, sell (→ free, complete normal)
- `state=2`: hold short, buy back (→ free, complete short)

**Memoization** → avoid recomputation.

---

##  Implementation (C#)

```csharp
public class Solution {
    private int[] prices;
    private long[,,] memo;

    public long MaximumProfit(int[] prices, int k) {
        this.prices = prices;
        int n = prices.Length;
        memo = new long[n, k + 1, 3];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= k; j++) {
                for (int s = 0; s < 3; s++) {
                    memo[i, j, s] = -1;
                }
            }
        }
        return Dfs(n - 1, k, 0);
    }

    private long Dfs(int i, int j, int state) {
        if (j == 0)  return 0;
        if (i == 0)  return state == 0 ? 0 : (state == 1 ? -prices[0] : prices[0]);
        

        long res = memo[i, j, state];
        if (res != -1)  return res;
        

        int p = prices[i];
        if (state == 0) {
            res = Math.Max(Dfs(i - 1, j, 0), Math.Max(Dfs(i - 1, j, 1) + p,
                                                      Dfs(i - 1, j, 2) - p));
        } else if (state == 1) {
            res = Math.Max(Dfs(i - 1, j, 1), Dfs(i - 1, j - 1, 0) - p);
        } else {
            res = Math.Max(Dfs(i - 1, j, 2), Dfs(i - 1, j - 1, 0) + p);
        }
        memo[i, j, state] = res;
        return res;
    }
}
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n × k)**          | Each state (day, transactions left, state) computed once |
| **Space Complexity**  | **O(n × k)**          | Memo table of size n × (k+1) × 3                |

**Optimal** — standard for k-transaction problems with constant states.

---

## Why This Works — Example Walkthrough

**Input**: `prices = [1,7,9,8,2]`, `k=2`

The recursion explores all possible sequences backwards from the last day:

- Day 4 (price=2): possible actions depending on previous state
- Day 3 (price=8): can **short sell** (start short position)
- Day 2 (price=9): can **sell long** (complete normal transaction)
- Day 1 (price=7): hold position
- Day 0 (price=1): can **buy long**

DP explores **all valid sequences** and finds the best one:

- Buy at 1 → sell at 9 → profit **8**
- Short at 8 → buy back at 2 → profit **6**
- Total **14**

**Perfect** — maximum possible profit with 2 transactions.

---

## Key Takeaway

This is a **clean recursive DP** for complex stock rules:

- **3 states** → perfectly handles **normal** and **short selling**
- **Top-down memoization** → easy to write, debug, and understand
- **Sequential transactions** enforced via `transLeft` counter


---


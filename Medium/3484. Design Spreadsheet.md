# üìä LeetCode 3484 ‚Äî Design Spreadsheet (C#)

## üß© Problem Overview

Implement a simplified spreadsheet system with:

- **26 columns**, labeled `'A'` to `'Z'`
- A given number of **rows**, indexed from `1` to `rows`
- Each cell holds an **integer value** between `0` and `10‚Åµ`
- All cells are initially set to `0`

### Supported Operations

| Method | Description |
|--------|-------------|
| `Spreadsheet(int rows)` | Initializes the spreadsheet with `rows` rows and 26 columns |
| `SetCell(string cell, int value)` | Sets the value of a cell like `"A1"` or `"B10"` |
| `ResetCell(string cell)` | Resets the specified cell to `0` |
| `GetValue(string formula)` | Evaluates a formula like `"=A1+B2"` or `"=5+7"` and returns the result |

---

## üß† Architectural Rationale

### ‚úÖ Why a 2D array (`int[,] grid`)
- Fixed-size grid: 26 columns √ó `rows`
- Direct access in constant time: `O(1)`
- Unset cells default to `0` ‚Äî no need to track state

### ‚úÖ Why ASCII math for cell parsing
- `"B2"` ‚Üí `col = 'B' - 'A'`, `row = int.Parse("2") - 1`
- No regex, no string splitting ‚Äî just fast, clean parsing

### ‚úÖ Why `Eval()` abstraction
- Handles both raw integers and cell references
- Token starts with a letter ‚Üí cell lookup
- Otherwise ‚Üí parse as integer

### ‚úÖ Why no caching or dependency tracking
- Each formula is independent
- No chaining, no graph traversal
- Stateless, atomic operations

---

## ‚úÖ C# Implementation

```csharp
public class Spreadsheet {
    private readonly int[,] grid;

    public Spreadsheet(int rows) {
        grid = new int[rows, 26]; // 26 columns: A-Z
    }

    public void SetCell(string cell, int value) {
        var (row, col) = ParseCell(cell);
        grid[row, col] = value;
    }

    public void ResetCell(string cell) {
        var (row, col) = ParseCell(cell);
        grid[row, col] = 0;
    }

    public int GetValue(string formula) {
        if (!formula.StartsWith("=")) return 0;
        string[] parts = formula.Substring(1).Split('+');
        return Eval(parts[0]) + Eval(parts[1]);
    }

    private int Eval(string token) {
        token = token.Trim();
        if (char.IsLetter(token[0])) {
            var (row, col) = ParseCell(token);
            return grid[row, col];
        } else {
            return int.Parse(token);
        }
    }

    private (int row, int col) ParseCell(string cell) {
        char colChar = cell[0];
        int col = colChar - 'A';
        int row = int.Parse(cell.Substring(1)) - 1;
        return (row, col);
    }
}

```

## ‚è± Time & Space Complexity

| Operation     | Time Complexity | Space Complexity | Description                                      |
|---------------|------------------|-------------------|--------------------------------------------------|
| `SetCell`     | `O(1)`           | `O(1)`            | Direct write to grid at parsed `(row, col)`      |
| `ResetCell`   | `O(1)`           | `O(1)`            | Overwrites cell with `0`                         |
| `GetValue`    | `O(1)`           | `O(1)`            | Parses and evaluates two tokens                  |
| `Eval`        | `O(1)`           | `O(1)`            | Either parses integer or accesses grid           |
| `ParseCell`   | `O(1)`           | `O(1)`            | Converts `"A1"` to `(0, 0)` using ASCII math     |

**Total space usage**:  
`O(rows √ó 26)` ‚Äî fixed-size grid for all cells.  
No dynamic allocation, no auxiliary structures.

---

## üß™ Example Execution

| Operation            | Output | Explanation                          |
|----------------------|--------|--------------------------------------|
| `GetValue("=5+7")`   | `12`   | Evaluates raw integers: `5 + 7`      |
| `SetCell("A1", 10)`  | ‚Äî      | Sets cell `A1` to `10`               |
| `GetValue("=A1+6")`  | `16`   | A1 = `10`, adds `6` ‚Üí `10 + 6`       |
| `SetCell("B2", 15)`  | ‚Äî      | Sets cell `B2` to `15`               |
| `GetValue("=A1+B2")` | `25`   | A1 = `10`, B2 = `15` ‚Üí `10 + 15`     |
| `ResetCell("A1")`    | ‚Äî      | Resets A1 to `0`                     |
| `GetValue("=A1+B2")` | `15`   | A1 = `0`, B2 = `15` ‚Üí `0 + 15`       |

All operations behave predictably and execute in constant time.

---

## ‚úÖ Final Takeaways

- **Minimalist design**  
  No maps, no graphs, no dependency tracking. Just a fixed grid.

- **Constant-time operations**  
  Every method ‚Äî from parsing to evaluation ‚Äî runs in `O(1)`.

- **Easy to extend**  
  Support for more operators (`-`, `*`, `/`) can be added by expanding `Eval()` and `GetValue()` logic.

- **Clean separation of concerns**  
  - `ParseCell()` ‚Üí coordinate translation  
  - `Eval()` ‚Üí token interpretation  
  - `GetValue()` ‚Üí formula orchestration  
  - `SetCell` / `ResetCell` ‚Üí direct state mutation


---

# 2105. Watering Plants II  
*O(n) — Two-Pointer Greedy Simulation*

---

## Problem Statement

Alice and Bob water `n` plants arranged in a row (indices 0 to n-1).  
- Alice starts from **left** (plant 0), moves right  
- Bob starts from **right** (plant n-1), moves left  
They water **simultaneously** (same speed, one plant at a time)

Each has a watering can with capacities `capacityA` and `capacityB`.  
- They must **fully water** a plant if they have enough water  
- If not enough → **refill instantly** to full capacity, then water  
- If they both reach the **same plant** at the same time:
  - The one with **more water** waters it  
  - If equal → **Alice** waters it

Return the **total number of refills** needed to water all plants.

**Examples**:

**Example 1**: plants = [2,2,3,3], capacityA = 5, capacityB = 5  
Output: **1**  
- Alice waters 0 (5→3), Bob waters 3 (5→2)  
- Alice waters 1 (3→1), Bob refills → waters 2 (5→2)  
Total refills = **1**

**Constraints**:
- 1 ≤ n ≤ 10⁵
- 1 ≤ plants[i] ≤ 10⁶
- max(plants[i]) ≤ capacityA, capacityB ≤ 10⁹

---

## Core Idea — Two-Pointer Greedy Simulation

**Approach**:
- Use **two pointers**: Alice from left, Bob from right
- Track current water in Alice's and Bob's cans
- Simulate step by step until pointers meet or cross

**Key rules**:
- Alice always tries to water leftmost remaining plant
- Bob always tries to water rightmost remaining plant
- If pointers meet at same plant:
  - Compare current water amounts
  - If Alice has more or equal → Alice waters it
  - Else → Bob waters it
- Refill only when current water < required for current plant

**Time**: O(n) — each plant watered exactly once  
**Space**: O(1) — only pointers and water counters

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MinimumRefill(int[] plants, int capacityA, int capacityB) {
        int n = plants.Length;
        int left = 0;           // Alice's pointer
        int right = n - 1;      // Bob's pointer
        int waterA = capacityA;
        int waterB = capacityB;
        int refills = 0;

        while (left <= right) {
            // If Alice and Bob meet at the same plant
            if (left == right) {
                // The one with more water (or Alice if equal) waters it
                if (waterA >= waterB) {
                    if (waterA < plants[left]) refills++;  
                } 
                else {
                    if (waterB < plants[right]) refills++;  
                }
                break;
            }

            // Alice waters left plant
            if (waterA >= plants[left]){
                waterA -= plants[left];
            } 
            else{
                refills++;
                waterA = capacityA - plants[left];
            }
            left++;

            // Bob waters right plant
            if (waterB >= plants[right]){
                waterB -= plants[right];
            } 
            else {
                refills++;
                waterB = capacityB - plants[right];
            }
            right--;
        }

        return refills;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Two pointers start from both ends and move inward → each plant is processed **exactly once** |
| **Space Complexity**  | **O(1)**      | Only a constant number of integer variables (pointers, water levels, refill counter) — no extra arrays or data structures |

**Optimal** — linear time and constant extra space — ideal and highly efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: plants = [2,2,3,3], capacityA = 5, capacityB = 5

- Initial state:  
  Alice water = 5, Bob water = 5  
  left = 0 (plant 2), right = 3 (plant 3)

**Step 1**:
- Alice waters plant 0 (5 ≥ 2) → waterA = 5 - 2 = **3**, left = 1  
- Bob waters plant 3 (5 ≥ 3) → waterB = 5 - 3 = **2**, right = 2

**Step 2**:
- Alice waters plant 1 (3 ≥ 2) → waterA = 3 - 2 = **1**, left = 2  
- Bob wants plant 2 (2 < 3) → **refill** (refills = 1), waterB = 5 - 3 = **2**, right = 1

- Pointers cross: left = 2 > right = 1 → all plants watered

Total refills = **1** → correct

**Correct** —  
We simulate Alice and Bob moving inward **simultaneously** (one plant per step each).  
When they reach the **same plant** (left == right), we decide who waters it based on:
- Whoever has **more water** left in their can waters it  
- If equal → **Alice** waters it

Refills are only counted when a person doesn't have enough water for their current plant **before** watering it.

---

## Key Takeaway

This is a **classic two-pointer greedy simulation** problem with a meeting point rule:

* Use **two pointers**: Alice starts from left (index 0), Bob from right (index n-1)
* Simulate watering step by step:
  - Alice always waters the next leftmost unwatered plant
  - Bob always waters the next rightmost unwatered plant
* If they reach the **same plant** (left == right):
  - Compare current water amounts → the one with **more** (or Alice if tie) waters it
* Refill instantly only when current water < required for the current plant
* Count every refill operation

**Pure, clean, optimal** — O(n) time, O(1) extra space, simple and intuitive simulation, very efficient and easy to understand.

---

# Pattern Name
**Prefix 2D + Binary Search on Square Size**

## Problem Summary
- **Input**:  
  `m × n` matrix `mat`, integer `threshold`
- **Goal**:  
  Return **maximum side length** of square with sum `≤ threshold`  
  → `0` if no such square
- **Constraints**:
  - `1 ≤ m, n ≤ 300`
  - `0 ≤ mat[i][j] ≤ 10⁴`
  - `0 ≤ threshold ≤ 10⁵`

## Core Idea
- **Brute force** (current code): O(mn·min(m,n)²) → **TLE**
- **Better**:  
  1. **Precompute 2D prefix sums** → O(1) square sum query  
  2. **Binary search on side length** → O(log min(m,n))  
  3. **Check existence** of valid square → O(mn)

## Solution
1. Build `prefix[i+1][j+1] = sum of submatrix [0,0] to [i,j]`
2. Binary search `side` from `1` to `min(m,n)`
3. For each `side`, check if **any** square sum `≤ threshold`
4. Return largest valid `side`

## C# Implementation (O(mn log min(m,n)))
```csharp
public class Solution {
    public int MaxSideLength(int[][] mat, int threshold) {
        int m = mat.Length, n = mat[0].Length;
        int[,] p = new int[m+1, n+1];

        // Build prefix
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                p[i+1, j+1] = p[i, j+1] + p[i+1, j] - p[i, j] + mat[i][j];

        int lo = 0, hi = Math.Min(m, n);
        while (lo < hi) {
            int mid = (lo + hi + 1) / 2;
            if (Exists(p, m, n, mid, threshold)) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }

    bool Exists(int[,] p, int m, int n, int s, int t) {
        for (int i = 0; i <= m - s; i++)
            for (int j = 0; j <= n - s; j++) {
                int sum = p[i+s, j+s] - p[i, j+s] - p[i+s, j] + p[i, j];
                if (sum <= t) return true;
            }
        return false;
    }
}
```

## Example Walkthrough
| mat | `[[1,1,3],[1,1,3],[1,1,3]]` | `threshold=4` |
|-----|-----------------------------|---------------|
| **Prefix** | Built in O(mn) |
| **Binary search** | `lo=0`, `hi=3` |
| `mid=2` → check 2×2 squares → `1+1+1+1=4 ≤ 4` → **valid** |
| `mid=3` → check 3×3 → `9 > 4` → **invalid** |
| **Result**: `2` |

## Architectural Breakdown
| Component           | Role                                      |
|---------------------|-------------------------------------------|
| `p[i+1,j+1]`        | 2D prefix sum for O(1) range query        |
| **Binary search**   | Try side lengths log(min(m,n))            |
| `Exists()`          | O(mn) check for any valid square          |
| **Inclusion-exclusion** | `p[a,b] - p[c,b] - p[a,d] + p[c,d]`   |

## Why This Approach Is Superior
| Aspect              | **Prefix + Binary Search** | Brute Force (Original)   |
|---------------------|-----------------------------|---------------------------|
| Time Complexity     | **O(mn log min(m,n))**      | O(mn·min(m,n)²) → TLE     |
| Space Complexity    | **O(mn)**                   | O(1)                      |
| Performance         | Fast on 300×300             | Too slow                  |
| Clarity             | **Clean, modular**          | Nested loops, hard to debug |

## Final Takeaway
- **This pattern generalizes to**:
  - **Max square with constraint**
  - **Submatrix sum queries**
  - **Binary search on size + prefix**
- **Key Insight**:  
  > **"Precompute sums → binary search size → check existence."**
  
  ---

# 1017. Convert to Base -2 — Architectural Negative Base Conversion with Remainder Adjustment  
*O(log n) — Optimal Iterative Division*

---

## Problem Statement

Given non-negative integer `n`.

Return its representation in **base -2** as binary string.

- No leading zeros (except "0")
- Base -2: powers `(-2)^0, (-2)^1, (-2)^2, ...`

---

## Core Idea — Division by -2 with Positive Remainder

**Normal base conversion**:
- Remainder = `n % base`
- `n /= base`

**Base -2**:
- Negative base → remainder must be **non-negative** (0 or 1)
- When `n % 2 == 1` and dividing by -2 → remainder would be negative
- **Fix**: remainder = 1, add 1 to quotient

**Rule**:
- `rem = n % 2`
- if `rem < 0` → `rem += 2`, `n = n / -2 + 1`
- else `n /= -2`

**In practice** (for positive n):
- While `n != 0`:
  - `rem = n % 2`
  - if `rem == 1` → append '1', `n = -(n // 2)`
  - else append '0', `n = -(n // 2)`

**Better**:
- `rem = n & 1`
- append digit
- `n = -(n >> 1)` if rem==1, else `n >>= 1`? No.

**Standard**:
```csharp
while (n != 0) 
{
    sb.Append(n & 1);
    n = -(n >> 1);
}
```

Why:

- n & 1 → LSB → remainder
- -(n >> 1) → equivalent to divide by -2 (for positive n)
  ##  Implementation (C#)
```cpp
public class Solution {
    public string BaseNeg2(int n) {
        if (n == 0) return "0";

        var sb = new StringBuilder();
        while (n != 0) {
            int rem = n & 1;
            sb.Append(rem);
            n = -(n >> 1);
        }

        // Reverse because we built from LSB
        char[] arr = sb.ToString().ToCharArray();
        Array.Reverse(arr);
        return new string(arr);
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(log n)**  | Number of bits in representation               |
| **Space Complexity**  | **O(log n)**  | Output string length                           |

**Optimal** — minimal operations per bit.

---

## Why This Works — Example Walkthrough

**Input**: `n = 2`

- n=2 → rem = 0 → append '0' → n = -(2 >> 1) = -1
- n=-1 → rem = 1 → append '1' → n = -(-1 >> 1) = 1
- n=1 → rem = 1 → append '1' → n = -(1 >> 1) = 0
- Built string: "011" → reverse → **"110"**

**Correct** — (-2)² + (-2)¹ + (-2)⁰ = 4 - 2 + 0 = 2

**Input**: `n = 3`

- 3 → rem=1 → append '1' → n=-1
- -1 → rem=1 → append '1' → n=1
- 1 → rem=1 → append '1' → n=0
- "111" → **"111"**

**Correct** — 4 - 2 + 1 = 3

**Input**: `n = 4`

- 4 → rem=0 → append '0' → n=-2
- -2 → rem=0 → append '0' → n=1
- 1 → rem=1 → append '1' → n=0
- "001" → reverse → **"100"**

**Correct** — (-2)² = 4

---

## Pitfalls & Edge Cases

- **n=0** → special case → "0"
- **Negative remainders** → handled automatically by bit trick
- **Leading zeros** → none (algorithm stops at n=0)
- **Large n** → O(log n) bits → efficient

All handled perfectly.

---

## Key Takeaway

This is a **beautifully clever** base conversion:

- **Negative base** → special remainder rule
- **Bit trick `-(n >> 1)`** → equivalent to division by -2
- **Build LSB first** → reverse at end

**No modulo headaches.**
**Pure, clean, optimal** — one of the most elegant base conversion problems.

---




  

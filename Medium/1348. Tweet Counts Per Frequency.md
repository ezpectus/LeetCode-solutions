# 1352. Tweet Counts Per Frequency — Architectural Per-Tweet Sorted Timestamps + Binary Search Buckets  
*O(log n) per record, O(k log n) per query — Optimal SortedList Insertion*

---

## Problem Statement

Implement `TweetCounts` class:

- `RecordTweet(tweetName, time)` — record tweet at timestamp `time`
- `GetTweetCountsPerFrequency(freq, tweetName, startTime, endTime)` — return list of tweet counts in intervals:
  - `"minute"` → every 60 seconds
  - `"hour"` → every 3600 seconds
  - `"day"` → every 86400 seconds

Timestamps **increasing**, queries in any order.

---

## Core Idea — Store Sorted Timestamps Per Tweet + Binary Search for Buckets

**Key insight**:
- For each `tweetName` → maintain **sorted list** of timestamps
- Insert with **binary search** → O(log n)
- Query → compute bucket size → use **binary search** to count tweets in each `[start, end]` bucket

**No need** discretize or tree → direct binary search on sorted list.

---

##  Implementation (C#) 

```csharp
public class TweetCounts {
    // tweetName → sorted list of timestamps
    private Dictionary<string, List<int>> tweets;

    // Interval sizes for each frequency
    private Dictionary<string, int> intervals = new(){
        { "minute", 60 },
        { "hour",   3600 },
        { "day",    86400 }
    };

    public TweetCounts() {
        tweets = new Dictionary<string, List<int>>();
    }
    

    /// Records a tweet at given time.
    /// Maintains timestamps in sorted order using binary search + insert.

    public void RecordTweet(string tweetName, int time) {
        if (!tweets.ContainsKey(tweetName)) {
            tweets[tweetName] = new List<int>();
        }

        var list = tweets[tweetName];

        // Find insertion point using binary search
        int idx = list.BinarySearch(time);
        if (idx < 0) {
            idx = ~idx; // insertion point for non-existing value
        }

        list.Insert(idx, time);
    }
    

    /// Returns tweet counts per frequency interval in [startTime, endTime].
    /// Uses binary search to efficiently count tweets in each bucket.
    public IList<int> GetTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {
        if (!tweets.ContainsKey(tweetName)) {
            return new List<int>(); // no tweets → all zeros
        }

        int delta = intervals[freq];
        int bucketCount = (endTime - startTime) / delta + 1;
        var result = new List<int>(bucketCount);
        var times = tweets[tweetName];

        for (int i = 0; i < bucketCount; i++) 
        {
            int bucketStart = startTime + i * delta;
            int bucketEnd = Math.Min(endTime, bucketStart + delta - 1);

            // Lower bound: first index >= bucketStart
            int left = times.BinarySearch(bucketStart);
            if (left < 0) left = ~left;

            // Upper bound: first index > bucketEnd
            int right = times.BinarySearch(bucketEnd + 1);
            if (right < 0) right = ~right;

            result.Add(right - left);
        }

        return result;
    }
}
```

## Complexity

| **Operation**         | **Time**                      | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **RecordTweet**       | **O(log n + n)**              | Binary search + List.Insert (amortized)        |
| **GetTweetCounts**    | **O(k log n)**                | k = number of buckets                          |
| **Space**             | **O(total tweets)**           | All timestamps stored per tweet                |

**Optimal** — best balance for online recording + queries.

---

## Why This Works — Example Walkthrough

**Records**:
- "tweetA": times **0, 10, 60, 70**

**Query**: `"minute"`, start=0, end=119

- delta = 60 → buckets **[0-59]**, **[60-119]**
- First bucket: left=0, right=2 → count = **2** (times 0,10)
- Second bucket: left=2, right=4 → count = **2** (times 60,70)

→ `[2,2]`

**Correct**.

---

## Pitfalls & Edge Cases

- **Same timestamp** → allowed (multiple tweets at same time)
- **No tweets for name** → return empty list
- **start > end** → not possible per constraints
- **Large time range** → many buckets → binary search still efficient
- **List.Insert cost** → O(n) worst-case, but amortized acceptable for constraints

All handled perfectly.

---

## Key Takeaway

This is a **beautifully efficient** online system:

- **Sorted list per tweet** → maintains order on insert
- **Binary search** → fast range counts for buckets
- **Simple bucket loop** → clean and readable query logic

**No complex trees. No pre-processing.**
**Pure, clean, optimal** — perfect for time-based frequency queries.

---

# LeetCode #954  
**Array of Doubled Pairs**  
**Difficulty:** Medium  

---

## Problem Description & Constraints  

### What We Are Given  
- `int[] arr` — array of **even length**  
- Values: `-10⁵ ≤ arr[i] ≤ 10⁵`  

### What We Must Return  
- `true` if we can **reorder** the array so that:  
  > `arr[2*i + 1] == 2 * arr[2*i]` for every `i`  
- `false` otherwise  

### Constraints (and what they tell us)  
| Constraint | Meaning |
|-----------|--------|
| `2 ≤ arr.length ≤ 3×10⁴` | Up to 30,000 elements → **O(n log n)** is fine |
| `arr.length` is **even** | Always valid pairing |
| `-10⁵ ≤ arr[i] ≤ 10⁵` | Use **offset** for negative indices |

> **Conclusion**:  
> We need **frequency counting** + **greedy pairing** from **largest to smallest**

---

##  Core Algorithm Idea  

### The Key Insight  
> Every `x` must be **paired** with `2x`  
> We **must process larger numbers first** → so `2x` is used as **double**, not half  

---

### The Solution: **Separate Positive/Negative + Reverse Greedy**

| Step | Action |
|------|--------|
| 1 | Split into **positive** and **negative** frequency arrays |
| 2 | Use **absolute value** for negatives |
| 3 | Process from **largest → smallest** |
| 4 | For each `x`, subtract its count from `x/2` |

---

---

##  Full C# Solution

```csharp
public class Solution {
    public bool CanReorderDoubled(int[] arr) {
        int s = (int)Math.Pow(10,5) + 1;
        int pMax = 0, nMax = 0;
        var pfreq = new int[s];
        var nfreq = new int[s];

        foreach (int a in arr) {
            if (a > 0) {
                pfreq[a]++;
                pMax = Math.Max(pMax, a);
            } else if (a < 0) {
                nfreq[-a]++;
                nMax = Math.Max(nMax, -a);
            }
        }

        return IsValid(pfreq, pMax) && IsValid(nfreq, nMax);
    }

    private bool IsValid(int[] freq, int uplimit) {
        for (int i = uplimit; i > 0; i--) {
            int count = freq[i];
            if (count == 0) continue;
            if (i % 2 == 1) return false;  // Odd number can't be double

            int half = i / 2;
            freq[half] -= count;
            if (freq[half] < 0) return false;
        }
        return true;
    }
}
```

##  Architectural Breakdown  

| Component | Role | How It Works |
|---------|------|-------------|
| `pfreq`, `nfreq` | **Frequency Maps** | `pfreq[x]` = count of `x` (positive), `nfreq[x]` = count of `-x` |
| `pMax`, `nMax` | **Upper Bounds** | Avoid scanning full array — only up to max value |
| `for i = uplimit → 1` | **Reverse Order** | Ensures `2x` is processed **after** `x` |
| `i % 2 == 1` | **Odd Check** | Cannot be double of anything → immediate `false` |
| `freq[half] -= count` | **Greedy Pairing** | Use `count` of `half` for `count` of `i` |
| `freq[half] < 0` | **Validation** | Not enough halves → impossible |

---

##  Step-by-Step Execution (Example)  

**Input**: `arr = [4, -2, 2, -4]`

| Value | `pfreq` | `nfreq` |
|-------|--------|--------|
| 4     | `pfreq[4] = 1` | — |
| -2    | — | `nfreq[2] = 1` |
| 2     | `pfreq[2] = 1` | — |
| -4    | — | `nfreq[4] = 1` |

**Positive (`pfreq`, max=4`)**:  
1. `i=4`: `count=1`, even → `half=2` → `pfreq[2] -= 1` → `0`  
2. `i=2`: `count=0` → skip  
→ **Valid**

**Negative (`nfreq`, max=4`)**:  
1. `i=4`: `count=1`, even → `half=2` → `nfreq[2] -= 1` → `0`  
2. `i=2`: `count=0` → skip  
→ **Valid**

**Result**: `true`

---

##  Pro Tips & Optimizations  

| Tip | Why It Matters |
|-----|----------------|
| **Separate pos/neg** | Avoids index collision |
| **Process large → small** | **Critical for correctness** |
| **Check `i % 2 == 1`** | Early fail for odds |
| **Use `uplimit`** | Faster than full array scan |

---

##  Key Takeaway  

> **"Count frequency. Process from largest absolute value. Pair each even number with its half. Fail if odd or not enough halves."**

---

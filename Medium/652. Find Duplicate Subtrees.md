# 652. Find Duplicate Subtrees

---

## Problem Summary
We are given the root of a binary tree.  
- A **duplicate subtree** is defined as a subtree that appears more than once in the tree, with the same structure and node values.  
- Task: return the root nodes of all distinct duplicate subtrees.  

---

## Core Idea
- Use **postorder traversal** to serialize each subtree (left → right → node).  
- Maintain a **hash map** from serialization string → frequency.  
- When a serialization appears for the second time, record the root node of that subtree.  
- Continue until all nodes are processed.  

This ensures we capture each duplicate subtree exactly once.  

---

## C++ Implementation
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<string,int> freq;
    vector<TreeNode*> res;

    string dfs(TreeNode* node) {
        if (!node) return "#"; // marker for null
        string serial = to_string(node->val) + "," + dfs(node->left) + "," + dfs(node->right);
        if (++freq[serial] == 2) {
            res.push_back(node);
        }
        return serial;
    }

    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```


## Complexity
- **Time:** O(n²) — worst case due to string concatenation at each node.  
  - Optimized approaches use unique IDs for subtrees to achieve O(n).  
- **Space:** O(n) — hash map stores subtree serializations, recursion stack depth up to n.  

---

## Pitfalls
- Must use **postorder traversal** to ensure full subtree serialization.  
- Avoid counting duplicates multiple times → only add when frequency == 2.  
- String concatenation may be costly; for large trees, consider hashing or ID mapping.  
- **Edge case:** single node tree → no duplicates.  

---

## Example Walkthrough
**Input:** `root = [1,2,3,4,null,2,4,null,null,4]`  

**Subtree serializations:**  
- Node(4) → `"4,#,#"`  
- Node(2) → `"2,4,#,#,#"`  
- Node(3) → `"3,2,4,#,#,#,4,#,#"`  
- Node(1) → `"1,2,4,#,#,#,3,2,4,#,#,#,4,#,#"`  

**Duplicates:**  
- `"4,#,#"` → appears multiple times → subtree `[4]`  
- `"2,4,#,#,#"` → appears multiple times → subtree `[2,4]`  

**Output:** `[[2,4],[4]]`  

---

## Conclusion
The problem reduces to **serializing subtrees via postorder DFS** and tracking frequencies.  
- Straightforward solution uses string serialization with a hash map.  
- Runs in **O(n²)** worst case, but can be optimized to **O(n)** with subtree ID mapping.  
- Clean, efficient, and captures each duplicate subtree exactly once.  



---

# 915. Partition Array into Disjoint Intervals — Architectural Two-Pass Max Tracking  
*O(n) — Optimal Linear Scan*

---

## Problem Statement

Given array `nums`.

Partition into **contiguous** `left` and `right`:
- All in `left` ≤ all in `right`
- Both **non-empty**
- `left` as **smallest** as possible

Return **length of left**.

**Guaranteed** valid partition exists.

---

## Core Idea — Track Maximum in Left Part

**Insight**:
- We need **smallest** `left` such that `max(left) ≤ min(right)`
- Equivalent: `max(nums[0..i]) ≤ min(nums[i+1..n-1])`

**Solution**:
1. **Precompute** `rightMin[i]` = minimum from `i` to end
2. **Iterate** from left:
   - Track `leftMax`
   - If `leftMax ≤ rightMin[i+1]` → valid → return `i+1`

**Single pass** possible with careful tracking.

**Optimal**:
- Keep running `leftMax`
- Keep current `maxSeen`
- When `maxSeen` updated → possible candidate
- Check if all after current position ≥ `maxSeen`

---

##  Implementation (C++)

```cpp
class Solution {
public:
    int partitionDisjoint(vector<int>& nums) {
        int n = nums.size();
        int leftMax = nums[0];
        int maxSeen = nums[0];
        int pos = 0;

        for (int i = 1; i < n; i++) {
            if (nums[i] < leftMax) {
                // Must include i in left → extend
                pos = i;
                leftMax = maxSeen; // update leftMax to current maxSeen
            } 
            else maxSeen = max(maxSeen, nums[i]);  
        }

        return pos + 1;
    }
};
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single linear pass                             |
| **Space Complexity**  | **O(1)**      | Only a few variables                           |

**Optimal** — fastest possible.

---

## Why This Works — Example Walkthrough

**Input**: `nums = [5,0,3,8,6]`

- i=0: leftMax=5, globalMax=5, partition=0
- i=1: 0 < 5 → **extend** partition=1, leftMax remains 5
- i=2: 3 < 5 → **extend** partition=2, leftMax=5
- i=3: 8 > 5 → globalMax=8
- i=4: 6 > 5 → globalMax=8

→ partition=2 → length **3** → left = `[5,0,3]`, right = `[8,6]`

**Correct**.

**Input**: `[1,1,1,0,6,12]`

- Encounter `0` → smaller than current leftMax → **extend** partition to include it
- Final partition after `0` → length **4**

**Correct**.

---

## Pitfalls & Edge Cases

- **Decreasing then increasing** → extend when smaller element found
- **All increasing** → partition=1
- **All equal** → partition=1
- **Minimum at end** → partition=n-1

All handled perfectly.

---

## Key Takeaway

This is a **beautifully clever** greedy scan:

- **Track max seen** (`globalMax`)
- **When smaller element found** → must extend left
- **Update leftMax** to current maxSeen

**No two arrays. No extra space.**
**Pure, clean, optimal** — one of the most elegant Medium array problems.

---

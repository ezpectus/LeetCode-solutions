# 1386. Cinema Seat Allocation  
*Max 4-Person Groups — Greedy Bitmask Magic*

---

## 1. Problem Statement  

We are given a cinema with `n` rows, each containing **10 seats** labeled `1` to `10`.  
Some seats are already **reserved** (given in `reservedSeats`).  

**Goal**:  
> **Maximize the number of 4-person groups** we can seat.

Each group must occupy **4 adjacent seats in one row**, with **one exception**:  
- **Aisle** between seats `5` and `6` → normally **no crossing**  
- **Allowed**: `4,5,6,7` → group **split across aisle**

---

## 2. Constraints → Algorithm Feasibility  

| Constraint | Implication |
|----------|-----------|
| `1 ≤ n ≤ 10⁹` | **Cannot simulate per row** → must avoid O(n) |
| `reservedSeats.length ≤ 10⁴` | Only **~10⁴ seats** are booked → **only few rows affected** |
| `1 ≤ seat ≤ 10` | Only **10 columns** → **bitmask is ideal** |

> **Conclusion**:  
> - **Only process rows with at least one reserved seat**  
> - **All other rows** → **2 groups each** (bulk count)

---

## 3. Core Idea — Block Compatibility & Greedy Priority  

### Valid 4-seat blocks:
| Block | Seats     | Overlap |
|-------|-----------|--------|
| **A** | `2,3,4,5` | —      |
| **B** | `6,7,8,9` | —      |
| **C** | `4,5,6,7` | A & B  |

---

### Compatibility Matrix  

| A | B | C | Can Coexist? | Groups |
|---|---|---|--------------|--------|
| Yes | Yes | — | Yes          | **2**  |
| Yes | — | — | Yes          | **1**  |
| — | Yes | — | Yes          | **1**  |
| — | — | Yes | Yes          | **1**  |
| No | No | No | No           | **0**  |

> **Key Rule**:  
> **Max 2 groups per row**  
> **C is fallback** — only used **if A and B are both blocked**

---

## 4. Full Implementation (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int maxNumberOfFamilies(int n, vector<vector<int>>& reserved) {
        unordered_map<int, int> row_mask;
        for (auto& r : reserved) {
            row_mask[r[0]] |= (1 << r[1]);  // seat k → bit k
        }

        int ans = 0;
        long long empty = n - (long long)row_mask.size();
        ans += empty * 2;  // empty row → 2 groups

        for (auto& [_, mask] : row_mask) {
            // Block A: seats 2-5
            bool A = (mask & ((1<<2)|(1<<3)|(1<<4)|(1<<5))) == 0;
            // Block B: seats 6-9
            bool B = (mask & ((1<<6)|(1<<7)|(1<<8)|(1<<9))) == 0;
            // Block C: seats 4-7 (fallback)
            bool C = (mask & ((1<<4)|(1<<5)|(1<<6)|(1<<7))) == 0;

            if (A && B) {
                ans += 2;  // Best case
            }
            else if (A || B || C) {
                ans += 1;  // Fallback
            }
        }

        return ans;
    }
};

```

## 6. Full Implementation (C#)

```csharp
public class Solution {
    public int MaxNumberOfFamilies(int n, int[][] reservedSeats) {
        var rowMask = new Dictionary<int, int>();
        foreach (var r in reservedSeats) {
            int row = r[0], seat = r[1];
            if (!rowMask.ContainsKey(row)) rowMask[row] = 0;
            rowMask[row] |= (1 << seat);
        }

        int ans = 0;
        long emptyRows = n - rowMask.Count;
        ans += (int)(emptyRows * 2);

        foreach (var mask in rowMask.Values) {
            bool A = (mask & ((1<<2)|(1<<3)|(1<<4)|(1<<5))) == 0;
            bool B = (mask & ((1<<6)|(1<<7)|(1<<8)|(1<<9))) == 0;
            bool C = (mask & ((1<<4)|(1<<5)|(1<<6)|(1<<7))) == 0;

            if (A && B) ans += 2;
            else if (A || B || C) ans += 1;
        }

        return ans;
    }
}
```

## 7. Complexity Analysis — Engineering View  

* **Time: O(R)**  
  `R ≤ 10⁴` — we make **one pass** over reserved seats. No hidden loops.  

* **Memory: O(R)**  
  Only **affected rows** are stored. Clean rows don’t exist in memory.  

* **Scalability: n ≤ 10⁹**  
  We **never touch empty rows** — this is the **core optimization**.  
  `n` can be a billion, runtime stays **constant** relative to `n`.

---

## 8. Pitfalls & Fixes — Engineering Traps  

| **Trap** | **Why it breaks** | **Fix** |
|--------|-------------------|--------|
| **Integer overflow** | `n` is up to `10⁹` → `n * 2` overflows `int` | Use `long` for `emptyRows` |
| **Bit shift error** | Seat `k` → bit `k` → `1 << k` | **Never** shift by `k-1` or `k+1` |
| **Double-counting** | Processing same row twice | Use `unordered_map` — **one entry per row** |
| **Forgetting Block C** | Lose 1 group when A/B blocked but C free | **Always check C** as fallback |

---

## 9. Insight — The Real Fichka  

**Greedy + Bitmask + Bulk Empty Rows**

### Pattern  
- **Fixed small width** (10 seats) → **bitmask is perfect**  
- **Huge `n`** → **skip clean units**, process only **"dirty" rows**  
- **Few valid configurations** → **greedy priority** is **safe and optimal**

### Generalization  
This pattern applies to:  
- Cinema, theater, airplane seating  
- Any **row-based allocation** with **small fixed width**  
- Problems where **total size is huge**, but **modified elements are few**

---

**Fichka Rule**:  
> When the space is **massive** but **only a few points are "dirty"**:  
> - **Group by key** (row)  
> - **Bulk-process clean blocks** with math  
> - **Bitmask the dirty ones** — fast, compact, O(1) checks

---

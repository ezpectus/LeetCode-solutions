# 802. Find Eventual Safe States

**Difficulty:** Medium  
**Topics:** Graph, DFS, Topological Sort  

---

##  Problem Restatement
We are given a directed graph `graph[i]` representing edges from node `i` to its neighbors.  
- A **terminal node** has no outgoing edges.  
- A **safe node** is one where every path starting from it eventually leads to a terminal node (or another safe node).  
Return all safe nodes in ascending order.

---

##  Core Idea
- Unsafe nodes are those that can reach a cycle.  
- Safe nodes are those that **cannot reach a cycle**.  
- Two main approaches:  
  1. **DFS with coloring** (detect cycles).  
  2. **Reverse graph + Topological sort** (Kahn’s algorithm).  

Here we use **DFS coloring**:  
- `0` = unvisited  
- `1` = visiting (in recursion stack)  
- `2` = safe (no cycle reachable)  

Transition:  
- If during DFS we revisit a node with state `1` → cycle → unsafe.  
- If all neighbors are safe → current node is safe.  

---

##  C# Implementation
```csharp
public class Solution {
    public IList<int> EventualSafeNodes(int[][] graph) {
        int n = graph.Length;
        int[] state = new int[n]; // 0=unvisited, 1=visiting, 2=safe
        var result = new List<int>();

        bool Dfs(int node) {
            if (state[node] != 0) return state[node] == 2;
            state[node] = 1; // mark visiting
            foreach (int nei in graph[node]) {
                if (!Dfs(nei)) return false;
            }
            state[node] = 2; // mark safe
            return true;
        }

        for (int i = 0; i < n; i++) {
            if (Dfs(i)) result.Add(i);
        }

        return result;
    }
}
```

##  Complexity Analysis

- **Time Complexity:** O(V + E) — each node and edge visited once.  
- **Space Complexity:** O(V) — recursion stack + state array.  

---

##  Pitfalls

- Must detect cycles correctly → use `state[node] == 1`.  
- Don’t forget to mark safe nodes (`state[node] = 2`).  
- Return nodes sorted ascending → DFS approach naturally iterates in order.  

---

##  Example Walkthrough

**Input:**  
`graph = [[1,2],[2,3],[5],[0],[5],[],[]]`  

- Terminal nodes: 5, 6.  
- Safe nodes: 2, 4, 5, 6.  
- **Output:** `[2,4,5,6]`  

---

**Input:**  
`graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]`  

- Only node 4 is terminal and safe.  
- **Output:** `[4]`  

---

##  Key Takeaway

- Safe nodes = nodes that cannot reach a cycle.  
- **Pattern:** DFS coloring or reverse graph topological sort.  
- Clean O(V+E) solution with simple state tracking.  


---

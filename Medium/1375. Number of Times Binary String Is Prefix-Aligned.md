# 1375. Number of Times Binary String Is Prefix-Aligned — Architectural Max Position Tracking  
*O(n) — Optimal Single Pass with Running Maximum*

---

## Problem Statement

Given permutation `flips` of `[1..n]` — order of flipping bits from `0` to `1`.

After each step `i`, the string has `1`s at positions `flips[1..i]`, rest `0`.

String is **prefix-aligned** after step `i` if:
- All positions `1` to `i` are `1`
- Positions `i+1` to `n` are `0`

Return **number of steps** where string is prefix-aligned.

---

## Core Idea — Track Maximum Flipped Position

**Key insight**:
- After step `i`, flipped positions: `flips[1..i]`
- For prefix-aligned at step `i`:
  - All `1..i` must be flipped → max(flips[1..i]) == i
  - (automatically, since only i positions flipped)

**So**:
- Count how many times `max_so_far == current_step`

**Steps**:
- Initialize `max_pos = 0`
- For each step `i=1 to n`:
  - Update `max_pos = max(max_pos, flips[i])`
  - If `max_pos == i` → count++

---

##  Implementation (C#)

```csharp
public class Solution {
    public int NumTimesAllBlue(int[] flips) {
        int n = flips.Length;
        int maxPos = 0;
        int count = 0;

        for (int i = 0; i < n; i++) {
            maxPos = Math.Max(maxPos, flips[i]);
            if (maxPos == i + 1)  count++;
        }

        return count;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass                                    |
| **Space Complexity**  | **O(1)**      | Only two variables                             |

**Optimal** — minimal operations.

---

## Why This Works — Example Walkthrough

**Input**: `flips = [3,2,4,1,5]`

- Step 1: flip 3 → max=3 ≠1 → no
- Step 2: flip 2 → max=3 ≠2 → no
- Step 3: flip 4 → max=4 ≠3 → no
- Step 4: flip 1 → max=4 ==4 → **yes**
- Step 5: flip 5 → max=5 ==5 → **yes**

**Count = 2** → **correct**

**Input**: `flips = [4,1,2,3]`

- Step 1: flip 4 → max=4 ≠1 → no
- Step 2: flip 1 → max=4 ≠2 → no
- Step 3: flip 2 → max=4 ≠3 → no
- Step 4: flip 3 → max=4 ==4 → **yes**

**Count = 1** → **correct**

The key is that after step `i`, the prefix `[1..i]` is all 1s **if and only if** the maximum flipped position so far is exactly `i`.

---

## Pitfalls & Edge Cases

- **n=1** → always 1 (max=1 after first flip)
- **Increasing order** (e.g., [1,2,3,...]) → every step satisfies → count = n
- **Decreasing order** (e.g., [n,...,1]) → only last step → count = 1
- **Early alignment** → correctly counted when max catches up to step

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** observation:

- Prefix-aligned at step `i` ⇔ **maximum flipped position** equals `i`
- Track running max → increment count when equal to current step

**Pure, clean, optimal** — perfect alignment counting with single pass.

---

## üß© Problem Context: Longest Common Subarray (Leetcode 718)

Given two integer arrays `nums1` and `nums2`, the task is to find the **maximum length of a subarray** that appears in **both arrays**. The subarray must be **contiguous** in both sequences.

### üîç Why This Is Not a Sliding Window Problem

At first glance, this might seem solvable with a sliding window ‚Äî especially since we're comparing sequences. However, sliding window assumes:
- A fixed or dynamically growing window
- One-directional traversal
- Local constraints (e.g. uniqueness, sum, frequency)

This problem violates those assumptions:
- We don‚Äôt know where the matching subarrays start
- We need to compare **all possible pairs of positions**
- The match must be **contiguous** and **simultaneous** in both arrays

Therefore, the correct approach is **Dynamic Programming**, where we track the length of matching subarrays ending at each pair of positions.

---

## üß± Architectural Pattern: Two-Sequence Positional Matching via DP

We define a DP table `dp[i][j]` where:
- `dp[i][j]` represents the length of the longest common subarray ending at `nums1[i-1]` and `nums2[j-1]`
- If `nums1[i-1] == nums2[j-1]`, then `dp[i][j] = dp[i-1][j-1] + 1`
- Otherwise, `dp[i][j] = 0`

We iterate through all pairs and track the maximum value of `dp[i][j]`.

---

## üíª Code Template (C#)

```csharp
public class Solution {
    public int FindLength(int[] nums1, int[] nums2) {
        int m = nums1.Length;
        int n = nums2.Length;
        int[,] dp = new int[m + 1, n + 1];
        int maxlen = 0;

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i, j] = dp[i - 1, j - 1] + 1;
                    maxlen = Math.Max(maxlen, dp[i, j]);
                }
            }
        }

        return maxlen;
    }
}
```


## üîß Detailed Breakdown

| Component                     | Purpose                                                                 |
|------------------------------|-------------------------------------------------------------------------|
| `dp[m+1][n+1]`               | Extra row/column to avoid out-of-bounds when accessing `dp[i-1][j-1]`   |
| `nums1[i-1], nums2[j-1]`     | Aligns with `dp[i][j]` since DP starts from index 1                    |
| `dp[i][j] = dp[i-1][j-1] + 1`| Builds up length of matching subarray if current elements match         |
| `maxlen`                     | Tracks the longest match found so far                                  |

---

## üß† Engineering Takeaways

- This is a classic **Longest Common Subarray** pattern ‚Äî not to be confused with **LCS**, which allows gaps.
- The match must be **contiguous**, so we reset to `0` when elements differ.
- The DP table captures **local state** and builds up **global insight**.
- The recurrence is **diagonal**, meaning each match depends on the previous match ending one step earlier in both arrays.

---

## üîÑ Generalizations

| Variant                    | Description                                                              |
|----------------------------|---------------------------------------------------------------------------|
| **Strings**                | Match longest common substring between two texts                         |
| **Binary Data**            | Compare byte sequences for similarity                                    |
| **Signal Matching**        | Detect overlapping patterns in time-series data                          |
| **Rolling Arrays**         | Optimize space to `O(n)` using two rows                                  |
| **Binary Search + Hashing**| For large inputs, use Rabin-Karp style hashing to compare substrings     |

---

## üß≠ Task Classification

| Task Type                   | Pattern Used                                 |
|-----------------------------|----------------------------------------------|
| Longest Common Subarray     | `dp[i][j] = dp[i-1][j-1] + 1`                |
| Longest Common Subsequence  | `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`     |
| Edit Distance / Transform   | `dp[i][j]` with cost-based transitions       |
| Matching with Gaps          | LCS-style DP                                 |
| Matching with Constraints   | DP + condition filters                       |

---

## üß© Summary & Reusability

- **Core Insight**: This pattern tracks **contiguous alignment** between two sequences using a **diagonal DP recurrence**.
- **When to Use**: Any time you need to find the longest exact match between two sequences with no gaps.
- **Reusable Template**: Can be abstracted into a `MatchMatrix<T>` utility with configurable match conditions.
- **Space Optimization**: Use rolling arrays or 1D DP if only the previous row is needed.
- **Meta-Level Note**: This pattern is a great benchmark for distinguishing **local vs global DP**,
- and for teaching how recurrence direction (diagonal vs vertical/horizontal) reflects problem constraints.



---

# 1124. Longest Well-Performing Interval

---

## Problem Summary
We are given an array `hours` representing daily work hours.  
- A day is **tiring** if `hours[i] > 8`.  
- A **well-performing interval** is a contiguous subarray where the number of tiring days > non-tiring days.  

We must return the length of the longest well-performing interval.

---

## Code Idea
1. **Transform array**  
   - Replace each day with `+1` if tiring (`hours[i] > 8`), else `-1`.  
   - Problem reduces to finding the longest subarray with positive sum.

2. **Prefix Sum + Monotonic Stack**  
   - Compute prefix sums: `prefix[i] = sum of transformed array up to i`.  
   - We want longest interval `(i, j)` such that `prefix[j] > prefix[i]`.  
   - Use a **monotonic decreasing stack** to store candidate indices.  
   - Traverse from right to left, check longest valid interval.

3. **Return maximum length**.

---

## Code (C#)
```csharp
public class Solution {
    public int LongestWPI(int[] hours) {
        int n = hours.Length;
        int[] prefix = new int[n + 1];
        
        // Step 1: build prefix sum
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + (hours[i] > 8 ? 1 : -1);
        }

        // Step 2: build monotonic decreasing stack
        Stack<int> stack = new Stack<int>();
        for (int i = 0; i <= n; i++) {
            if (stack.Count == 0 || prefix[stack.Peek()] > prefix[i]) {
                stack.Push(i);
            }
        }

        // Step 3: traverse from right to left
        int res = 0;
        for (int j = n; j >= 0; j--) {
            while (stack.Count > 0 && prefix[j] > prefix[stack.Peek()]) {
                res = Math.Max(res, j - stack.Pop());
            }
        }

        return res;
    }
}
```



## Complexity
- **Time:** O(n), single pass for prefix sum + stack + traversal.  
- **Space:** O(n) for prefix array and stack.  

---

## Pitfalls
- Must transform `hours[i]` into `+1` if `> 8`, else `-1`.  
- Stack must store indices of **decreasing prefix values**.  
- Careful with prefix array indexing (length = n+1).  
- Edge case: no tiring days â†’ result = 0.  

---

## Example Walkthrough
**Input:** `hours = [9,9,6,0,6,6,9]`  
- Transformed: `[+1, +1, -1, -1, -1, -1, +1]`.  
- Prefix: `[0,1,2,1,0,-1,-2,-1]`.  
- Longest interval with positive sum = length 3 (`[9,9,6]`).  
**Output:** `3`.  

---

**Input:** `hours = [6,6,6]`  
- Transformed: `[-1,-1,-1]`.  
- Prefix: `[0,-1,-2,-3]`.  
- No positive interval.  
**Output:** `0`.  

---

## Conclusion
This problem reduces to finding the **longest subarray with positive sum** using prefix sums and a monotonic stack.  
- Efficient O(n) solution.  
- Handles large input sizes up to 10^4.  
- Prefix sums capture balance of tiring vs non-tiring days, and the stack ensures we can quickly find the longest valid interval.  


---

# 🔺 Problem: Split Linked List in Parts (Leetcode 725)

## 📜 Problem Explanation
We are given the head of a singly linked list and an integer k. 

We need to split the linked list into k consecutive parts such that:

- The length of each part differs by at most 1.
- Earlier parts are greater or equal in size compared to later parts.
- Some parts may be null if the list is shorter than k.
- The order of nodes must remain the same.
- We must return an array of k linked list parts.

## 📏 Constraints
- 0 <= number of nodes <= 1000
- 0 <= Node.val <= 1000
- 1 <= k <= 50

 Constraints show that:

- The list is relatively small (≤ 1000 nodes).
- A direct traversal to compute length and then splitting is efficient.
- No need for advanced data structures — just careful pointer manipulation.

## ⚡️ Algorithm Choice
- First, compute the length of the linked list.
- Each part should have size len / k (integer division).
- The first len % k parts get one extra node (to balance sizes).
- Traverse the list, cutting it into parts according to these sizes.

This ensures all parts differ in size by at most one and earlier parts are not smaller than later ones.

## 🧠 Core Idea
- Count total length of the list.

Distribute nodes:

- Base size = len / k

- Extra nodes = len % k (distributed to the first parts).

Split the list:

- For each part, move forward the required number of nodes.
- Cut the link (cur.next = null) to separate the part.
- Store the head of each part in the result array.

## 💻 C# Implementation
```csharp

public class Solution {
    public ListNode[] SplitListToParts(ListNode head, int k) {
        int len = 0;
        ListNode cur = head;

        // 1) Count length
        while (cur != null) {
            len++;
            cur = cur.next;
        }

        // 2) Base size and remainder
        int subCnt = len / k;
        int[] freq = Enumerable.Repeat(subCnt, k).ToArray();
        int rest = len % k;

        for (int i = 0; i < rest; i++) freq[i]++;

        // 3) Split into parts
        ListNode newHead = head;
        ListNode[] res = new ListNode[k];
        cur = newHead;

        for (int i = 0; i < k; i++) {
            if (freq[i] == 0) {
                res[i] = null;
                continue;
            }

            // Traverse part length - 1
            for (int j = 1; j < freq[i]; j++) {
                cur = cur.next;
            }

            // Cut and move
            ListNode nextN = cur.next;
            cur.next = null;
            res[i] = newHead;
            newHead = nextN;
            cur = nextN;
        }

        return res;
    }
}
```

## 🔍 Why This Works

- Balanced distribution: Each part differs by at most one node.
- Greedy allocation: Extra nodes are given to earlier parts.
- Pointer manipulation: Cutting links ensures independent sublists.

## 🧮 Time & Space Complexity

- Time	O(n)	```One pass to count, one to split```
- Space	O(k)	```Result array of size k```
- Scalability	Strong	```Works for n ≤ 1000, k ≤ 50```

## 🧠 Engineering Takeaway
This problem is a linked list partitioning exercise:

- Compute total size.
- Distribute nodes evenly with remainder handling.
- Carefully cut the list into independent parts.
  
 It’s a clean example of mathematical distribution + pointer manipulation.


---

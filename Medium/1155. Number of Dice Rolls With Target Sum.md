# 1155. Number of Dice Rolls With Target Sum — Architectural Classic Unbounded Knapsack DP  
*O(n × target) — Optimal 2D DP with Modulo*

---


## Problem Statement

Given:
- `n` dice
- Each die has `k` faces (1 to k)
- Target sum `target`

Return **number of ways** to roll dice so sum = `target`.

Return **modulo 10⁹+7**.

---

## Core Idea - DP Counting Ways to Reach Sum

**Classic unbounded knapsack**:
- Each die → choose value 1 to k
- Order doesn't matter → count combinations

**DP**:
- `dp[i][s]` = ways to achieve sum `s` using **first i dice**
- `dp[0][0] = 1` (one way to have sum 0 with 0 dice)

**Transition**:
- `dp[i][s] = sum(dp[i-1][s - face])` for face = 1 to k (if s - face >= 0)

**Optimize**:
- Use **1D DP** → `dp[s]`
- Iterate dice → update backward (or use temp)

**Final**: `dp[target]`

---

##  Implementation (C#)

```csharp
public class Solution 
{
    private const int MOD = 1000000007;

    public int NumRollsToTarget(int n, int k, int target) 
    {
        // dp[s] = ways to make sum s with current dice
        int[] dp = new int[target + 1];
        dp[0] = 1; // base case

        for (int dice = 1; dice <= n; dice++) 
        {
            int[] newDp = new int[target + 1];

            for (int face = 1; face <= k; face++) 
            {
                for (int s = face; s <= target; s++) 
                {
                    newDp[s] = (newDp[s] + dp[s - face]) % MOD;
                }
            }

            dp = newDp;
        }

        return dp[target];
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n × target)**     | n dice × target sum ≤ 30 × 1000 = 30k operations |
| **Space Complexity**  | **O(target)**         | 1D DP array of size target+1                   |

**Optimal** — constraints are small, linear in input size.

---

## Why This Works — Example Walkthrough

**Input**: `n=2`, `k=6`, `target=7`

- After **1 die**: `dp[1..6] = 1` (one way to get each sum 1 through 6)
- After **2 dice**:
  - For sum `s=7`: we can reach it by adding a face from 1 to 6 to previous sums `6` down to `1`
  - All previous `dp[1]` to `dp[6]` are 1 → total **6 ways**

→ **6** correct (1+6, 2+5, 3+4, 4+3, 5+2, 6+1).

**Input**: `n=30`, `k=30`, `target=500`

- DP iteratively builds up from 1 die to 30 dice
- Large intermediate numbers → modulo prevents overflow
- Final `dp[500]` = **222616187**

**Correct**.

---

## Pitfalls & Edge Cases

- **target=0** → impossible unless n=0 (but n≥1) → 0 ways
- **target too large** ( > n×k ) → dp[target]=0 automatically
- **k=1** → only one way if target==n (all dice show 1)
- **Modulo** → must apply on every addition to avoid overflow

All handled perfectly.

---

## Key Takeaway

This is a **classic counting DP**:

- **Unbounded knapsack** style → each die is independent and can contribute any face 1..k
- **1D DP** → `dp[s]` = number of ways to reach sum s
- **Iterate over dice**, updating the DP array
- **Modulo** for large results
**Pure, clean, optimal** — perfect for dice sum counting problems.

---

# 2486. Append Characters to String to Make Subsequence  
*O(n + m) — Greedy Two-Pointer Matching*

---

## Problem Statement

- You are given two strings `s` and `t` consisting of lowercase English letters.
- Return the **minimum number of characters** that need to be **appended** to the **end** of `s` so that `t` becomes a **subsequence** of the resulting string.
- **Subsequence** — string that can be derived by deleting some (or no) characters without changing order.

**Examples**:

**Example 1**  
Input: s = "coaching", t = "coding"  
Output: **4**  
Append "ding" → "coachingding"  
t is subsequence → c o a c h i n **g** d **i** n **g**

**Example 2**  
Input: s = "abcde", t = "a"  
Output: **0**  
"a" is already subsequence

**Example 3**  
Input: s = "z", t = "abcde"  
Output: **5**  
Append "abcde" → "zabcde"

**Constraints**:
- 1 ≤ s.length, t.length ≤ 10⁵
- s and t consist of lowercase English letters

---

## Core Idea — Greedy Two-Pointer Matching

**Key insight**:
- We want to **match** as many characters of `t` as possible using existing characters in `s` (in order)
- Any prefix of `t` that is already a subsequence of `s` does **not** need appending
- The characters of `t` that cannot be matched in `s` must be appended at the end
- Since we can only append at the end, the unmatched part of `t` must be appended **exactly as is**

**Algorithm** (two pointers):
1. Use two pointers:
   - `i` for position in `s`
   - `j` for position in `t`
2. Iterate through `s`:
   - If `s[i] == t[j]` → match → move `j` forward
   - Always move `i` forward
3. After processing all of `s`, the remaining suffix `t[j..]` must be appended
4. Return length of remaining suffix = `t.length - j`

**Time**: O(n + m) — single pass through `s`  
**Space**: O(1) — only pointers

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int AppendCharacters(string s, string t){
        int n = s.Length;
        int m = t.Length;
        int j = 0; // pointer in t

        // Try to match as much of t as possible using s
        for (int i = 0; i < n && j < m; i++){
            if (s[i] == t[j]) j++; // matched → move to next char in t   
        }

        // Remaining characters in t must be appended
        return m - j;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n + m)**  | Single pass through string `s`: O(n)<br>Pointer `j` advances at most `m` times → total O(n + m) |
| **Space Complexity**  | **O(1)**      | Only two integer pointers (`i` and `j`) — no extra space used |

**Optimal** — linear time in total length of input strings, constant extra space — perfectly efficient for n, m ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: s = "coaching", t = "coding"

**Characters**:
- s: c o a c h i n g
- t: c o d i n g

**Two-pointer simulation**:
- i=0: s[0]='c' == t[0]='c' → match → j=1
- i=1: s[1]='o' == t[1]='o' → match → j=2
- i=2: s[2]='a' ≠ t[2]='d' → no match
- i=3: s[3]='c' ≠ 'd' → no
- i=4: s[4]='h' ≠ 'd' → no
- i=5: s[5]='i' ≠ 'd' → no
- i=6: s[6]='n' ≠ 'd' → no
- i=7: s[7]='g' ≠ 'd' → no

**Final j = 2**  
Matched prefix of t: "co"  
Remaining suffix of t: "ding" (length 4)  
Need to append **"ding"** → **4** characters → correct

**Correct** —  
We greedily match as many characters of `t` as possible using characters from `s` in order (left to right).  
The **longest prefix** of `t` that is a subsequence of `s` is found this way.  
All remaining unmatched characters of `t` (the suffix t[j..]) **must** be appended at the end of `s` to complete the subsequence.  
The length of this suffix is exactly the **minimum number of characters** needed.

---

## Key Takeaway

This is a **simple, elegant greedy two-pointer** problem:

* Use two pointers:
  - `i` — current position in `s`
  - `j` — current position in `t` (next character we need to match)
* Traverse `s` from left to right:
  - If `s[i]` matches the current needed `t[j]` → advance `j` (found match)
  - Always advance `i`
* After processing all of `s`, the number of remaining unmatched characters in `t` is `t.length - j`
* This is exactly the **minimum number** of characters to append at the end

**Pure, clean, optimal** — O(n + m) time, O(1) extra space, extremely fast, very intuitive, and correctly computes the minimal appends needed to make `t` a subsequence of the resulting string.

---

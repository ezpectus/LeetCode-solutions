# 🧠 Maximum Total Damage With Spell Casting — Sliding Window DP (LeetCode 3186)

---

## 📜 Origin & Motivation

This problem models a **conflict-aware selection**:  
Each spell has a damage value, but casting one disables nearby values (`±1`, `±2`).  
The goal is to **maximize total damage** while respecting these constraints.

This resembles the **"Delete and Earn"** pattern — a variant of **House Robber**, where values are grouped and adjacent values conflict.  
However, the conflict range is wider (`±2`), so naive DP fails — we need **sorted compression + sliding window**.

---

## 🧩 Use Cases

- 🎮 Spell selection with adjacency constraints  
- 🧠 Conflict-aware greedy aggregation  
- 📊 Frequency compression for large value ranges  
- 🧪 Dynamic programming on sparse domains

---

## 🧱 Core Architecture

### 🎯 Triggers

| Condition                        | Action in Code           |
|----------------------------------|--------------------------|
| Spell value appears              | Add to frequency map     |
| Conflict with ±1 or ±2 values    | Skip conflicting states  |
| Non-conflicting value            | Include in DP via max(mx) |

---

### 🔧 Algorithm Steps

1. Count total damage per unique spell value  
2. Sort all unique values  
3. Build compressed list `vec = (damage, count)`  
4. Initialize DP array `f[i]` and sliding pointer `j`  
5. For each `i`:
   - Advance `j` while `vec[j].damage < vec[i].damage - 2`  
   - Maintain `mx = max(f[j])` over safe states  
   - Set `f[i] = mx + vec[i].damage * vec[i].count`  
6. Return `max(f[i])`

---

## 🚀 C# Implementation

```csharp
public class Solution {
    public long MaximumTotalDamage(int[] power) {
        var count = new SortedDictionary<int, int>();
        foreach (var p in power) {
            if (!count.ContainsKey(p)) count[p] = 0;
            count[p]++;
        }

        var vec = new List<(int damage, int count)>();
        vec.Add((-1000000000, 0)); // sentinel
        foreach (var kv in count) {
            vec.Add((kv.Key, kv.Value));
        }

        int n = vec.Count;
        long[] f = new long[n];
        long mx = 0, ans = 0;
        int j = 1;

        for (int i = 1; i < n; i++) {
            while (j < i && vec[j].damage < vec[i].damage - 2) {
                mx = Math.Max(mx, f[j]);
                j++;
            }
            f[i] = mx + (long)vec[i].damage * vec[i].count;
            ans = Math.Max(ans, f[i]);
        }

        return ans;
    }
}

```
## ⏱️ Complexity Analysis  
Frequency compression: O(n) — build damage map from input  
Sorting keys: O(k·log k) — where k is number of unique values  
DP traversal: O(k) — linear scan with sliding pointer  
**Total time complexity**: O(n + k·log k) — efficient for sparse domains  
**Space complexity**: O(k) — frequency map and DP state

## ⚠️ Pitfalls  
🔁 Must compress values — direct DP over 10⁹ range is infeasible  
🧹 Sorting keys is essential for adjacency detection  
⚠️ Forgetting ±2 conflicts leads to invalid selections  
🧩 Multiple spells with same damage must be aggregated correctly  
🧠 Sliding pointer must advance only when conflict is resolved — otherwise stale mx

## ✅ Conclusion  
This is a frequency-compressed dynamic programming problem with adjacency conflict:

🔁 Aggregates damage per value  
📊 Uses sorted keys to detect conflicts  
🧠 Applies sliding window DP with safe state tracking  
🏆 A classic pattern in conflict-aware selection problems

👉 **Key takeaway**: When adjacency disables selection, compress values and apply sliding DP — elegant, scalable, and robust.


---

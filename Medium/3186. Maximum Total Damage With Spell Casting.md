# ðŸ§  Maximum Total Damage With Spell Casting â€” Sliding Window DP (LeetCode 3186)

---

## ðŸ“œ Origin & Motivation

This problem models a **conflict-aware selection**:  
Each spell has a damage value, but casting one disables nearby values (`Â±1`, `Â±2`).  
The goal is to **maximize total damage** while respecting these constraints.

This resembles the **"Delete and Earn"** pattern â€” a variant of **House Robber**, where values are grouped and adjacent values conflict.  
However, the conflict range is wider (`Â±2`), so naive DP fails â€” we need **sorted compression + sliding window**.

---

## ðŸ§© Use Cases

- ðŸŽ® Spell selection with adjacency constraints  
- ðŸ§  Conflict-aware greedy aggregation  
- ðŸ“Š Frequency compression for large value ranges  
- ðŸ§ª Dynamic programming on sparse domains

---

## ðŸ§± Core Architecture

### ðŸŽ¯ Triggers

| Condition                        | Action in Code           |
|----------------------------------|--------------------------|
| Spell value appears              | Add to frequency map     |
| Conflict with Â±1 or Â±2 values    | Skip conflicting states  |
| Non-conflicting value            | Include in DP via max(mx) |

---

### ðŸ”§ Algorithm Steps

1. Count total damage per unique spell value  
2. Sort all unique values  
3. Build compressed list `vec = (damage, count)`  
4. Initialize DP array `f[i]` and sliding pointer `j`  
5. For each `i`:
   - Advance `j` while `vec[j].damage < vec[i].damage - 2`  
   - Maintain `mx = max(f[j])` over safe states  
   - Set `f[i] = mx + vec[i].damage * vec[i].count`  
6. Return `max(f[i])`

---

## ðŸš€ C# Implementation

```csharp
public class Solution {
    public long MaximumTotalDamage(int[] power) {
        var count = new SortedDictionary<int, int>();
        foreach (var p in power) {
            if (!count.ContainsKey(p)) count[p] = 0;
            count[p]++;
        }

        var vec = new List<(int damage, int count)>();
        vec.Add((-1000000000, 0)); // sentinel
        foreach (var kv in count) {
            vec.Add((kv.Key, kv.Value));
        }

        int n = vec.Count;
        long[] f = new long[n];
        long mx = 0, ans = 0;
        int j = 1;

        for (int i = 1; i < n; i++) {
            while (j < i && vec[j].damage < vec[i].damage - 2) {
                mx = Math.Max(mx, f[j]);
                j++;
            }
            f[i] = mx + (long)vec[i].damage * vec[i].count;
            ans = Math.Max(ans, f[i]);
        }

        return ans;
    }
}

```
## â±ï¸ Complexity Analysis  
Frequency compression: O(n) â€” build damage map from input  
Sorting keys: O(kÂ·logâ€¯k) â€” where k is number of unique values  
DP traversal: O(k) â€” linear scan with sliding pointer  
**Total time complexity**: O(n + kÂ·logâ€¯k) â€” efficient for sparse domains  
**Space complexity**: O(k) â€” frequency map and DP state

## âš ï¸ Pitfalls  
ðŸ” Must compress values â€” direct DP over 10â¹ range is infeasible  
ðŸ§¹ Sorting keys is essential for adjacency detection  
âš ï¸ Forgetting Â±2 conflicts leads to invalid selections  
ðŸ§© Multiple spells with same damage must be aggregated correctly  
ðŸ§  Sliding pointer must advance only when conflict is resolved â€” otherwise stale mx

## âœ… Conclusion  
This is a frequency-compressed dynamic programming problem with adjacency conflict:

ðŸ” Aggregates damage per value  
ðŸ“Š Uses sorted keys to detect conflicts  
ðŸ§  Applies sliding window DP with safe state tracking  
ðŸ† A classic pattern in conflict-aware selection problems

ðŸ‘‰ **Key takeaway**: When adjacency disables selection, compress values and apply sliding DP â€” elegant, scalable, and robust.


---

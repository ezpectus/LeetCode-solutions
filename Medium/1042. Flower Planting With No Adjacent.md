# LeetCode 1042 — Flower Planting With No Adjacent  
**Approach: Greedy Coloring (Graph Coloring with Constraint ≤ 3 neighbors)**

---

##  Problem Restatement
We have `n` gardens (nodes) connected by bidirectional paths (edges).  
Each garden must be assigned one of **4 flower types** (colors).  
Constraint: Adjacent gardens (connected by a path) must have different flower types.  
It is guaranteed that a solution exists because each garden has at most **3 neighbors**.

---

##  Core Idea
- This is a **graph coloring problem**.  
- Since each garden has at most 3 neighbors, and we have 4 flower types, we can always assign a valid flower greedily.  
- Strategy:  
  1. Build adjacency list for all gardens.  
  2. Iterate through gardens from `1` to `n`.  
  3. For each garden, check which flower types are already used by its neighbors.  
  4. Assign the smallest available flower type (from 1 to 4).  
- No backtracking is needed because the guarantee ensures a solution always exists.

---

##  Greedy Coloring Strategy
1. **Build adjacency list:** Use `List<int>[]` to store neighbors for each garden.  
2. **Initialize answer array:** `int[] res = new int[n]`.  
3. **Assign flowers:**  
   - For each garden `i`, create a boolean array `used[5]` to mark flower types used by neighbors.  
   - Pick the first flower type not marked as used.  
   - Assign it to `res[i]`.  
4. **Return result.**

---

##  Implementation (C#)

```csharp
public class Solution {
    public int[] GardenNoAdj(int n, int[][] paths) {
        // Step 1: Build adjacency list
        List<int>[] graph = new List<int>[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new List<int>();
        }
        foreach (var path in paths) {
            int u = path[0] - 1; // convert to 0-based
            int v = path[1] - 1;
            graph[u].Add(v);
            graph[v].Add(u);
        }

        // Step 2: Initialize result array
        int[] res = new int[n];

        // Step 3: Assign flowers greedily
        for (int i = 0; i < n; i++) {
            bool[] used = new bool[5]; // flower types 1..4
            foreach (int nei in graph[i]) {
                if (res[nei] != 0) {
                    used[res[nei]] = true;
                }
            }
            for (int flower = 1; flower <= 4; flower++) {
                if (!used[flower]) {
                    res[i] = flower;
                    break;
                }
            }
        }

        return res;
    }
}
```

##  Time Complexity
- **Building adjacency list:**  
  - Each path is processed once to add both endpoints to the adjacency list.  
  - Complexity: `O(n + m)` where `m = paths.Length`.  

- **Assigning flowers:**  
  - For each garden, we check its neighbors.  
  - Since each garden has at most 3 neighbors, this step is `O(1)` per garden.  
  - For `n` gardens, total complexity is `O(n)`.  

- **Total complexity:**  
  - `O(n + m)` which is efficient for `n ≤ 10^4` and `m ≤ 2·10^4`.  
  - This is linear in the size of the input, making it scalable.

---

##  Space Complexity
- **Adjacency list:** `O(n + m)` to store all gardens and paths.  
- **Result array:** `O(n)` to store flower assignments for each garden.  
- **Temporary `used[5]` per garden:** `O(1)` constant space for checking neighbor colors.  
- **Total space:** `O(n + m)` overall, efficient and manageable for given constraints.

---

#  Impact of Design Choices

| Design Choice        | Effect                                                                 |
|----------------------|------------------------------------------------------------------------|
| **Greedy coloring**  | Works because each node has ≤ 3 neighbors and 4 colors are available. |
| **Adjacency list**   | Efficient storage and traversal of graph edges, avoids memory blowup.  |
| **Boolean used array** | Quick check of neighbor colors, ensures valid assignment in constant time. |

---

#  Pitfalls

- **Forgetting to convert indices to 0-based:** Leads to incorrect assignments since arrays in C# are 0-based.  
- **Using adjacency matrix:** Causes memory blowup for `n = 10^4` (would require `10^8` entries).  
- **Not checking neighbors before assignment:** May assign duplicate flower types to adjacent gardens, violating constraints.  
- **Overcomplicating with backtracking:** Unnecessary, since greedy always works here due to the degree ≤ 3 guarantee.  

---

#  Conclusion

- **What it gives:** A valid flower assignment for all gardens with no adjacent conflicts.  
- **Why it matters:** Demonstrates greedy graph coloring under bounded degree constraints, avoiding complex algorithms.  
- **Key takeaway:**  
  1. Build adjacency list.  
  2. Greedily assign flowers ensuring no neighbor conflict.  
  3. Guaranteed solution exists because degree ≤ 3 and colors = 4.  

This approach is simple, efficient, and leverages the problem’s guarantee to avoid complex backtracking. 
It highlights how constraints (bounded degree and fixed number of colors) can simplify graph coloring problems into straightforward greedy solutions.




---

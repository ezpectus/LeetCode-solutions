# 🧠 Matrix Block Sum — 2D Prefix Aggregation Pattern

## 🔍 Problem Overview

Given a matrix `mat` of size `m x n` and an integer `k`, return a matrix `result` where each `result[i][j]` is the sum of all elements within a square block of radius `k` centered at `(i, j)`.

Block boundaries:

```
i - k ≤ r ≤ i + k
 j - k ≤ c ≤ j + k
(r, c) must be within matrix bounds
```

---

## 💡 Core Idea

Instead of recalculating the sum for every block, **precompute a 2D prefix sum matrix**.  
This allows constant-time access to any rectangular submatrix using **inclusion-exclusion**.

---

## 📐 Formula

To compute the sum of a block from `(r1, c1)` to `(r2, c2)`:
```
blockSum = prefix[r2+1][c2+1] - prefix[r1][c2+1] - prefix[r2+1][c1] + prefix[r1][c1]
```

To build the prefix matrix:
```
prefix[i+1][j+1] = mat[i][j] + prefix[i][j+1] + prefix[i+1][j] - prefix[i][j]
```

---

## 🧩 C# Implementation

```csharp
public class Solution {
    public int[][] MatrixBlockSum(int[][] mat, int k) {
        int m = mat.Length;
        int n = mat[0].Length;

        int[][] prefix = new int[m + 1][];
        for (int i = 0; i <= m; i++) prefix[i] = new int[n + 1];

        // Build prefix sum matrix
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                prefix[i + 1][j + 1] = mat[i][j]
                                     + prefix[i][j + 1]
                                     + prefix[i + 1][j]
                                     - prefix[i][j];
            }
        }

        // Build result matrix
        int[][] result = new int[m][];
        for (int i = 0; i < m; i++) {
            result[i] = new int[n];
            for (int j = 0; j < n; j++) {
                int r1 = Math.Max(0, i - k);
                int c1 = Math.Max(0, j - k);
                int r2 = Math.Min(m - 1, i + k);
                int c2 = Math.Min(n - 1, j + k);

                result[i][j] = prefix[r2 + 1][c2 + 1]
                             - prefix[r1][c2 + 1]
                             - prefix[r2 + 1][c1]
                             + prefix[r1][c1];
            }
        }

        return result;
    }
}
```
## 🔍 Signal Recognition Table

| Signal Type         | Insight                                                             |
|---------------------|----------------------------------------------------------------------|
| Matrix structure     | 2D grid → prefix sum is viable                                       |
| Block sum logic      | Fixed-size window → no need for DP                                   |
| Query frequency      | Repeated queries → preprocessing is optimal                          |
| Aggregation pattern  | Inclusion-exclusion → classic 2D submatrix sum                       |
| Index control        | Requires careful boundary handling with `Math.Max` / `Math.Min`      |
| Formula structure    | Clean, scalable, and reusable across grid-based problems             |

---

## 🧠 How I Saw It

I didn’t just want to “solve” — I wanted to understand the logic per cell.  
Once I saw that each `result[i][j]` depends on a rectangular region, I knew I needed:

- A way to aggregate fast  
- A structure that lets me query any submatrix instantly  
- A formula that’s clean and scalable  

That’s when the prefix sum pattern clicked, and the formula built itself.

---

## ✅ Summary of Internalization

- Understood matrix logic and how aggregation works  
- Built prefix sum manually and verified correctness  
- Applied inclusion-exclusion with clean index control  
- Converted the solution into a reusable architectural pattern  
- Ready to apply this logic in future grid-based or image-like problems



---

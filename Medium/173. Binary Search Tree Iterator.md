# 🧠 LeetCode 173 — Binary Search Tree Iterator  
**Category:** Design / Tree Traversal  
**Difficulty:** Medium  
**Language:** C#  
**Pattern:** Lazy In-order Traversal using Stack

---

## 💡 Problem Summary

Implement a class `BSTIterator` that allows in-order traversal of a Binary Search Tree (BST) using two methods:

- `Next()` — returns the next smallest number in the BST  
- `HasNext()` — returns true if there are more nodes to visit

The traversal must be **lazy**, meaning we don’t precompute the entire in-order list. We aim for:

- **O(h)** space complexity (where `h` is the height of the tree)  
- **Amortized O(1)** time complexity for both `Next()` and `HasNext()`

---

## 🧠 Why I Chose a Stack

From the start, I knew this was a **stateful traversal** problem.  
Flattening the tree into a list would violate both space and time constraints — it’s wasteful and eager.

Instead, I chose a `Stack<TreeNode>` because:

- It lets me **simulate recursion manually**  
- I can **push left children lazily**, only when needed  
- It gives me **control over traversal state**, which is key in design tasks

I initially considered using a list, but that would require full traversal upfront.  
The stack gives me **on-demand traversal**, which is exactly what the problem wants.

---

## 🔧 C# Implementation

```csharp
public class BSTIterator {
    private Stack<TreeNode> stack;

    public BSTIterator(TreeNode root) {
        stack = new Stack<TreeNode>();
        PushLeft(root);
    }

    private void PushLeft(TreeNode node) {
        while (node != null) {
            stack.Push(node);
            node = node.left;
        }
    }

    public int Next() {
        TreeNode node = stack.Pop();
        if (node.right != null) {
            PushLeft(node.right);
        }
        return node.val;
    }

    public bool HasNext() {
        return stack.Count > 0;
    }
}
```

## 🔍 Architectural Breakdown

| Component   | Purpose                                                                 |
|------------|-------------------------------------------------------------------------|
| `stack`     | Maintains traversal state — simulates call stack for in-order traversal |
| `PushLeft()`| Lazily pushes all left descendants — prepares the next smallest node    |
| `Next()`    | Pops current node, then processes right subtree via `PushLeft()`        |
| `HasNext()` | Checks if traversal can continue — i.e., stack is not empty             |

---

## 🧩 Time & Space Complexity

- **Time Complexity:**  
  - `Next()` and `HasNext()` → Amortized **O(1)**  
  - Each node is pushed and popped exactly once

- **Space Complexity:**  
  - **O(h)** — where `h` is the height of the tree  
  - Stack holds at most one path from root to leaf

---

## 🧠 Summary

This problem shifted my thinking from algorithmic recursion to **stateful class design**.  
It’s not just about retrieving the next node — it’s about **building an iterator-like structure** that manages traversal state efficiently.

Design problems like this are fundamentally different: they require **control, encapsulation, and architectural clarity**.  
This task marked my entry into **thinking like a system builder**, not just a coder.

---

# 1845. Seat Reservation Manager  
*O(log n) per operation — Optimal Min-Heap / SortedSet Solution*

---

## Problem Statement

Design a system `SeatManager` to manage `n` seats numbered from **1 to n** (all initially available).

Implement:

- `SeatManager(int n)` — initialize with `n` seats
- `int reserve()` — return the **smallest-numbered** unreserved seat and reserve it
- `void unreserve(int seatNumber)` — unreserve the given seat

**Constraints**:
- 1 ≤ n ≤ 10⁵
- 1 ≤ seatNumber ≤ n
- At most 10⁵ calls total to `reserve` + `unreserve`
- `reserve` always has at least one seat available
- `unreserve` called only on reserved seats

---

## Core Idea — Min-Heap (Priority Queue) for Available Seats

**Key insight**:
- We always need the **smallest** available seat
- Seats are reserved and unreserved dynamically
- Use a **min-heap** (PriorityQueue) to always get the smallest available seat in O(log n)
- Initially all seats 1 to n are available → but we don't want to push all 10⁵ at once (too slow)
- **Lazy approach**:
  - Keep a variable `nextSeat = 1` — next seat that hasn't been considered yet
  - When `reserve()` called:
    - If heap not empty → take smallest from heap (previously unreserved)
    - Else → take `nextSeat++` (new seat)
  - When `unreserve(seat)` → push seat back to heap

This way we only push seats that were reserved and then unreserved → heap size stays small.

---

## Clean Implementation (C#)

```csharp
public class SeatManager {
    private PriorityQueue<int, int> pq;   // min-heap of available seats
    private int nextSeat;                 // next unused seat (1-based)

    public SeatManager(int n) {
        pq = new PriorityQueue<int, int>();
        nextSeat = 1;
    }
    
    public int Reserve() {
        // If there are previously unreserved seats — take smallest
        if (pq.Count > 0)  return pq.Dequeue();
        // Otherwise take next unused seat
        return nextSeat++;
    }
    
    public void Unreserve(int seatNumber) {
        // Push back to available seats
        pq.Enqueue(seatNumber, seatNumber);
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **reserve()**         | **O(log n)**  | Heap dequeue O(log n) or O(1) nextSeat increment |
| **unreserve()**       | **O(log n)**  | Heap enqueue O(log n)                          |
| **Space Complexity**  | **O(n)**      | Heap worst-case stores up to n seats (if all reserved then unreserved) |

**Optimal** — logarithmic time per operation, perfectly suited for up to 10⁵ calls total.

---

## Why This Works — Example Walkthrough

**Example 1**: `n = 5`

- Init: `nextSeat = 1`, `pq` empty
- reserve() → pq empty → return **1**, `nextSeat = 2`
- reserve() → pq empty → return **2**, `nextSeat = 3`
- unreserve(2) → push 2 into pq → pq = {2}
- reserve() → pq not empty → return **2**, pq empty
- reserve() → pq empty → return **3**, `nextSeat = 4`
- reserve() → pq empty → return **4**, `nextSeat = 5`
- reserve() → pq empty → return **5**, `nextSeat = 6`
- unreserve(5) → push 5 into pq → pq = {5}

Output sequence: **[1,2,2,3,4,5]** → matches example behavior

**Correct** — always returns the **smallest** available seat.  
Lazy initialization with `nextSeat` avoids pushing all 10⁵ seats upfront (would be O(n log n) init time).  
Heap only contains previously reserved and unreserved seats — size stays small in practice.

---

## Pitfalls & Edge Cases

- **n = 1** → reserve() → 1, unreserve(1) → pq has 1
- **reserve() when pq empty** → safely take nextSeat and increment
- **unreserve seat > nextSeat** → possible (previously reserved) → correctly pushed to heap
- **unreserve same seat multiple times** → problem guarantees only reserved seats are unreserved
- **Large n (10⁵)** → heap operations log(10⁵) ≈ 17 → very fast even if heap grows to n

All handled perfectly.

---

## Key Takeaway

This is a **beautifully efficient** seat reservation problem with lazy loading:

- Use **PriorityQueue** (min-heap) to always fetch the smallest available seat
- **Lazy loading** with `nextSeat` — only push seats that were reserved and then unreserved
- `reserve()` → take from heap if available, else take next unused seat (`nextSeat++`)
- `unreserve()` → push seat back to heap

**Pure, clean, optimal** — log n per operation, no unnecessary initial heap population.

---

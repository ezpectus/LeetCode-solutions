# 2034. Stock Price Fluctuation  
*O(log n) amortized per Update — Priority Queue + Dictionary Cleanup*

---

## Problem Statement

Design a `StockPrice` class to process a stream of stock price records (timestamp + price).  
Records may arrive out of order and may correct previous prices for the same timestamp.

Operations:
- `StockPrice()` — initialize empty structure
- `Update(timestamp, price)` — set or correct price at given timestamp
- `Current()` — return price at the **latest** timestamp
- `Maximum()` — return **highest** price among all current records
- `Minimum()` — return **lowest** price among all current records

**Constraints**:
- 1 ≤ timestamp, price ≤ 10⁹
- At most 10⁵ total calls
- `current`, `maximum`, `minimum` called only after at least one `update`

---

## Implementation C#

```csharp
public class StockPrice {
    private PriorityQueue<(int time, int price), int> minPQ;
    private PriorityQueue<(int time, int price), int> maxPQ;
    private Dictionary<int, int> tp = new(); // timestamp → current price
    private (int latestTime, int value) currentStk;

    public StockPrice() {
        minPQ = new PriorityQueue<(int time, int price), int>();
        maxPQ = new PriorityQueue<(int time, int price), int>(
            Comparer<int>.Create((a, b) => b.CompareTo(a))); // max-heap
        currentStk = (-1, -1);
    }
    
    public void Update(int timestamp, int price) {
        if (!tp.ContainsKey(timestamp)) tp.Add(timestamp, price);
        else tp[timestamp] = price;

        // Update current (latest) if this timestamp is newer
        if (timestamp >= currentStk.latestTime) 
            currentStk = (timestamp, price);

        // Add to both min-heap and max-heap
        minPQ.Enqueue((timestamp, price), price);
        maxPQ.Enqueue((timestamp, price), price);
    }
    
    public int Current() {
        return currentStk.value;
    }
    
    public int Maximum() {
        while (maxPQ.Count > 0) {
            var (time, price) = maxPQ.Peek();
            if (tp.ContainsKey(time) && tp[time] == price) return price;
            maxPQ.Dequeue();
        }

        return -1; // should never reach here after at least one update
    }
    
    public int Minimum() {
        while (minPQ.Count > 0) {
            var (time, price) = minPQ.Peek();
            if (tp.ContainsKey(time) && tp[time] == price) return price;
            minPQ.Dequeue();
        }

        return -1; // should never reach here after at least one update
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time per Update**   | **O(log n)**          | Two heap enqueues — each O(log n)              |
| **Time per Current**  | **O(1)**              | Direct access to tracked current value         |
| **Time per Maximum**  | **O(log n) amortized**| Worst-case O(n) if many invalid entries, but amortized low due to lazy cleanup |
| **Time per Minimum**  | **O(log n) amortized**| Same as Maximum — lazy deletion of outdated entries |
| **Total Time**        | **O(q log n) amortized** | q ≤ 10⁵ total calls → very fast in practice    |
| **Space Complexity**  | **O(n)**              | Dictionary O(n) + two heaps O(n) worst-case    |

**Note**:  
The `Maximum` and `Minimum` methods use **lazy deletion** — they clean invalid (outdated) entries only when peeked.  
This makes queries **amortized O(log n)** — in practice very fast, though worst-case can be O(n) per query if many outdated entries accumulate.

---

## How This Code Works — Step-by-Step Explanation

### 1. Data Structures

- `tp` (Dictionary): timestamp → current (latest) price for that timestamp  
  → used to validate whether a price in heap is still valid

- `minPQ` (min-heap): stores (time, price) pairs, ordered by price ascending

- `maxPQ` (max-heap): stores (time, price) pairs, ordered by price descending  
  → achieved with custom comparer `(a,b) => b.CompareTo(a)`

- `currentStk` — tuple tracking the **latest timestamp** and its price (for fast `Current()`)

### 2. Update(timestamp, price)

- Update or add to `tp[timestamp] = price`

- If this timestamp is newer than current latest → update `currentStk`

- Push the (timestamp, price) pair into **both** min-heap and max-heap  
  → heaps keep all historical updates (even outdated ones)

### 3. Current()

- Simply returns the price from `currentStk.value`  
  → O(1), always correct because updated in `Update`

### 4. Maximum()

- Peek from max-heap (largest price)

- If that price is still current for its timestamp (`tp[time] == price`) → return it

- Otherwise → pop invalid entry and repeat  
  → lazy deletion of outdated records

### 5. Minimum()

- Same logic but on min-heap (smallest price)

- Peek → validate → pop if invalid → repeat

### Correctness Guarantees

- `Current()` always uses the latest tracked timestamp

- `Maximum`/`Minimum` eventually find valid prices by cleaning outdated ones

- Corrections properly override in `tp` → old entries in heaps become invalid and get cleaned

---

## Key Takeaway

This is a **clever lazy-deletion heap + dictionary** solution:

- **Dictionary** tracks current price per timestamp
- **Two heaps** (min + max) store all updates (even outdated)
- **Lazy deletion** in `Maximum`/`Minimum` — clean invalid entries only when peeked
- `Current` uses simple tracked latest value — O(1)

**Pure, clean, practical** — O(log n) updates, amortized O(log n) queries, handles corrections perfectly.

---

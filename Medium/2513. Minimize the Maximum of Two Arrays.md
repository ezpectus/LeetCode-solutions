# 2513. Minimize the Maximum of Two Arrays  
*O(log (uniqueCnt1 + uniqueCnt2)) — Binary Search on Answer + Inclusion-Exclusion*

---

## Problem Statement

We need to fill two arrays `arr1` and `arr2` (initially empty) with **positive integers** satisfying:

- `arr1` has **exactly** `uniqueCnt1` **distinct** positive integers, **none** divisible by `divisor1`
- `arr2` has **exactly** `uniqueCnt2` **distinct** positive integers, **none** divisible by `divisor2`
- No integer appears in both arrays

Return the **minimum possible maximum** integer that appears in either array.

**Examples**:

**Example 1**  
Input: divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3  
Output: **4**  
arr1 = [1], arr2 = [2,3,4] → max = 4

**Example 2**  
Input: divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1  
Output: **3**  
arr1 = [1,2], arr2 = [3] → max = 3

**Example 3**  
Input: divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2  
Output: **15**  
arr1 = [1,3,5,7,9,11,13,15], arr2 = [2,6] → max = 15

**Constraints**:
- 2 ≤ divisor1, divisor2 ≤ 10⁵
- 1 ≤ uniqueCnt1, uniqueCnt2 < 10⁹
- 2 ≤ uniqueCnt1 + uniqueCnt2 ≤ 10⁹

---

## Core Idea — Binary Search on Maximum Value + Counting Valid Numbers

**Key insight**:
- We want the **smallest possible** maximum value M such that we can assign at least `uniqueCnt1 + uniqueCnt2` distinct positive integers ≤ M, satisfying the divisibility constraints and no overlap.
- Binary search on M (the maximum number used) from 1 to some large enough value (e.g., 2×10⁹ or higher).
- For a candidate M, check if we can select enough numbers ≤ M:
  - Total numbers ≤ M: M
  - Numbers divisible by divisor1: floor(M / divisor1)
  - Numbers divisible by divisor2: floor(M / divisor2)
  - Numbers divisible by lcm(divisor1, divisor2): floor(M / lcm)
- Numbers forbidden for arr1: divisible by divisor1
- Numbers forbidden for arr2: divisible by divisor2
- Numbers available for arr1: total - divisible by divisor1
- Numbers available for arr2: total - divisible by divisor2
- But numbers divisible by both (lcm) are forbidden for both → overcounted

**Inclusion-Exclusion**:
- Numbers usable only for arr1: not divisible by divisor1 → M - floor(M / divisor1)
- Numbers usable only for arr2: not divisible by divisor2 → M - floor(M / divisor2)
- Numbers usable for both: not divisible by divisor1 and not by divisor2  
  = M - floor(M/div1) - floor(M/div2) + floor(M/lcm)

We need:
- usable_for_arr1 ≥ uniqueCnt1
- usable_for_arr2 ≥ uniqueCnt2
- usable_for_both ≥ uniqueCnt1 + uniqueCnt2 - usable_for_arr1 - usable_for_arr2 (the overlap needed)

But simpler check:
- Total usable numbers (not forbidden for arr1 or arr2) ≥ uniqueCnt1 + uniqueCnt2
- usable_for_arr1 ≥ uniqueCnt1
- usable_for_arr2 ≥ uniqueCnt2

Since we can assign overlap to either, the tightest condition is usually the total usable.

**Correct check**:
- Total numbers ≤ M not divisible by div1 → can go to arr1
- Total not divisible by div2 → can go to arr2
- We need to assign uniqueCnt1 to arr1 and uniqueCnt2 to arr2 without overlap

So:
- Let A = numbers ≤ M not div by div1 (can go to arr1)
- Let B = numbers ≤ M not div by div2 (can go to arr2)
- We need |A| ≥ uniqueCnt1 and |B| ≥ uniqueCnt2
- And total distinct numbers we can use = |A ∪ B| ≥ uniqueCnt1 + uniqueCnt2

Where |A ∪ B| = |A| + |B| - |A ∩ B|

A ∩ B = numbers ≤ M not div by div1 and not div by div2 = M - floor(M/div1) - floor(M/div2) + floor(M/lcm)

So check:
- |A| ≥ uniqueCnt1
- |B| ≥ uniqueCnt2
- |A| + |B| - |A ∩ B| ≥ uniqueCnt1 + uniqueCnt2

If all three hold → possible with max = M

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int MinimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2){
        long left = 1;
        long right = 2L * 1000000000; // safe upper bound
        long lcm = LCM(divisor1, divisor2);

        while (left < right){
            long mid = left + (right - left) / 2;

            long countA = mid - mid / divisor1;                // usable for arr1
            long countB = mid - mid / divisor2;                // usable for arr2
            long countBoth = mid - mid / divisor1 - mid / divisor2 + mid / lcm; // usable for both

            if (countA >= uniqueCnt1 && countB >= uniqueCnt2 && countA + countB - countBoth >= uniqueCnt1 + uniqueCnt2){
                right = mid;
            }
            else left = mid + 1;
            
        }

        return (int)left;
    }

    private long GCD(long a, long b){
        while (b != 0){
            long t = b;
            b = a % b;
            a = t;
        }
        return a;
    }

    private long LCM(long a, long b){
        return a / GCD(a, b) * b;
    }
}
```

## Complexity

| **Metric**            | **Value**              | **Notes**                                                                 |
|-----------------------|------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(log MAX)**         | Binary search on the answer (maximum value M): range [1, ~2×10⁹]<br>Number of iterations ≈ log₂(2×10⁹) ≈ 30–31<br>Each check performs only O(1) arithmetic operations (floor divisions + LCM) |
| **Space Complexity**  | **O(1)**               | Only a constant number of integer variables — no arrays or extra data structures |

**Optimal** — logarithmic time and constant space — extremely fast even under maximum constraints (uniqueCnt1 + uniqueCnt2 ≤ 10⁹).

---

## Why This Works — Example Walkthrough

**Example 1**: divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3

**Goal**:
- Need ≥ 1 number not divisible by 2
- Need ≥ 3 numbers not divisible by 7
- Total distinct usable numbers ≥ 1 + 3 = 4

**Try M = 4**:
- countA = numbers ≤ 4 not ÷ by 2 = 4 - floor(4/2) = 4 - 2 = **2** ≥ 1 ✓
- countB = numbers ≤ 4 not ÷ by 7 = 4 - floor(4/7) = 4 - 0 = **4** ≥ 3 ✓
- countBoth = numbers ≤ 4 not ÷ by 2 and not ÷ by 7 = 4 - 2 - 0 + floor(4/lcm(2,7)) = 4 - 2 - 0 + 0 = **2**
- Total usable = countA + countB - countBoth = 2 + 4 - 2 = **4** ≥ 4 ✓

→ Possible with max = 4

**Try M = 3**:
- countA = 3 - 1 = **2** ≥ 1 ✓
- countB = 3 - 0 = **3** ≥ 3 ✓
- countBoth = 3 - 1 - 0 + 0 = **2**
- Total usable = 2 + 3 - 2 = **3** < 4 → impossible

**Minimum M** = **4** → correct

**Correct** —  
We perform **binary search** on the smallest possible maximum value M such that there are enough numbers ≤ M satisfying the divisibility constraints for both arrays (with possible overlap between the two sets).  
Inclusion-exclusion is used to accurately compute the size of the union of usable numbers.

---

## Key Takeaway

This is a **classic binary search on answer + inclusion-exclusion** problem:

* Binary search for the **smallest maximum value M** (the answer we want to minimize)
* For each candidate M, check if it's possible to assign:
  * At least `uniqueCnt1` numbers ≤ M **not divisible** by `divisor1` (usable for arr1)
  * At least `uniqueCnt2` numbers ≤ M **not divisible** by `divisor2` (usable for arr2)
  * Total **distinct** usable numbers (union of the two sets) ≥ `uniqueCnt1 + uniqueCnt2`
* Use **inclusion-exclusion** to compute:
  * Usable for arr1: M - floor(M / divisor1)
  * Usable for arr2: M - floor(M / divisor2)
  * Usable for both: M - floor(M/div1) - floor(M/div2) + floor(M / lcm(div1,div2))
* If all three conditions hold → M is possible → try smaller value
* Return the smallest M that satisfies the conditions

**Pure, clean, optimal** — O(log MAX) time (≈30 iterations), O(1) space, blazing fast, elegant use of math (inclusion-exclusion + binary search), and correctly solves the problem under huge constraints.

---

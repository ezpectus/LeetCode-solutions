# LeetCode 1006 — Clumsy Factorial  
**Approach: Simulation with Operator Rotation**


---

##  Problem Restatement
We define a "clumsy factorial" of `n` by applying operations in a fixed cycle:  
`*`, `/`, `+`, `-` in order, on decreasing integers from `n` down to `1`.  
- Multiplication and division are evaluated before addition and subtraction.  
- Division is floor division.  
Return the result of this clumsy factorial.

---

##  Core Idea
- Iterate numbers from `n` down to `1`.  
- Apply operations in repeating cycle: `*`, `/`, `+`, `-`.  
- Use a stack or simulation to respect operator precedence:  
  - Handle `*` and `/` immediately.  
  - Push `+` and `-` results onto stack.  
- Sum stack at the end.

---

## Implementation (C#)

```csharp
public class Solution {
    public int Clumsy(int n) {
        Stack<int> stack = new Stack<int>();
        stack.Push(n);
        n--;
        int index = 0; // 0:*, 1:/, 2:+, 3:-

        while (n > 0) {
            if (index % 4 == 0) {
                stack.Push(stack.Pop() * n);
            } else if (index % 4 == 1) {
                stack.Push(stack.Pop() / n);
            } else if (index % 4 == 2) {
                stack.Push(n);
            } else {
                stack.Push(-n);
            }
            index++;
            n--;
        }

        int res = 0;
        foreach (int num in stack) {
            res += num;
        }
        return res;
    }
}
```

##  Time Complexity
- **Processing loop:**  
  Each number from `n` down to `1` is processed exactly once.  
  → `O(n)` overall.  

---

##  Space Complexity
- **Stack usage:**  
  Intermediate results are stored in a stack during simulation.  
  → `O(n)` space.  

---

#  Impact of Design Choices

| Design Choice          | Effect                                                                 |
|------------------------|------------------------------------------------------------------------|
| **Stack simulation**   | Ensures correct operator precedence for `*` and `/`.                   |
| **Operator cycle index** | Cleanly rotates through `*`, `/`, `+`, `-` in fixed order.             |
| **Final summation**    | Collects results after precedence is handled correctly.                |

---

#  Pitfalls
- Forgetting floor division → produces incorrect results.  
- Not respecting operator precedence → wrong evaluation order.  
- Handling subtraction incorrectly (must push negative value).  

---

#  Conclusion
- **What it gives:** Correct clumsy factorial result for any `n`.  
- **Why it matters:** Demonstrates operator precedence handling with cyclic operations.  
- **Key takeaway:**  
  1. Use stack to enforce precedence.  
  2. Rotate operations with index.  
  3. Sum stack at the end.  


---

# 🧩 Problem: Minimum Score Triangulation of Polygon  
## 🔢 Number: LeetCode 1039  
**Difficulty**: Medium  
**Language**: C#  
**Status**: ✅ Solved via bottom-up dynamic programming  

---

## 📜 Problem Overview

We are given a convex polygon with `n` vertices, each labeled with an integer value.  
The polygon is represented by an array `values[]`, where `values[i]` is the value of the `i-th` vertex in clockwise order.

We must triangulate the polygon into `n - 2` triangles.  
Each triangle has a score equal to the product of its three vertex values.  
The total score of the triangulation is the sum of all triangle scores.

Our goal is to **minimize** the total score across all valid triangulations.

---

### 🔢 Constraints
- `n == values.length`  
- `3 ≤ n ≤ 50`  
- `1 ≤ values[i] ≤ 100`  
- Polygon is convex and vertices are ordered clockwise  
- Only triangles are allowed — no other shapes

---

### 🎁 What’s Given
- An integer array `values[]` representing the polygon’s vertices  
- We must compute the **minimum total score** from any valid triangulation  
- Each triangle’s score is `values[i] * values[j] * values[k]` for its three vertices

---

### 👀 What We Observe
- This is a classic **polygon triangulation** problem  
- The number of triangles is always `n - 2`  
- The triangle score depends on vertex values — not geometry  
- We must explore multiple triangulation paths to find the minimum score  
- Brute-force recursion is possible but inefficient  
- **Bottom-up DP** is optimal for `n ≤ 50`

---

## 🧠 Explanation

We use **bottom-up dynamic programming** to solve this problem efficiently.

Let `dp[i][j]` represent the **minimum score** to triangulate the subpolygon from vertex `i` to vertex `j`.  
We initialize `dp[i][j] = 0` for all adjacent pairs (`j - i < 2`) since no triangle can be formed.

For each subpolygon of length ≥ 3, we try all possible third vertices `k` between `i` and `j` to form a triangle `(i, k, j)` and compute:

```csharp
dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + values[i] * values[k] * values[j])
```

This recurrence captures the cost of forming triangle (i, k, j) plus the cost of triangulating the two resulting subpolygons.
We build the solution bottom-up, increasing the gap between i and j from 2 to n - 1.

## ⚙️ Algorithm Choice

- Approach: Bottom-up dynamic programming
- Why: Avoids recursion and memoization overhead
- Efficiency: O(n³) time is acceptable for n ≤ 50
- Memory: O(n²) DP table

## 💡 Idea Summary
- Use a 2D DP table dp[i][j] to store minimum triangulation scores
- For each subpolygon (i, j), try all possible third vertices k
- Update dp[i][j] with the minimum score from all valid splits
- Final answer is dp[0][n - 1]

## 🧾 Code
```cpp
public class Solution {
    public int MinScoreTriangulation(int[] values) {
        int n = values.Length;
        int[,] dp = new int[n, n];

        for (int gap = 2; gap < n; gap++) {
            for (int i = 0; i + gap < n; i++) {
                int j = i + gap;
                dp[i, j] = int.MaxValue;

                for (int k = i + 1; k < j; k++) {
                    int score = dp[i, k] + dp[k, j] + values[i] * values[k] * values[j];
                    dp[i, j] = Math.Min(dp[i, j], score);
                }
            }
        }

        return dp[0, n - 1];
    }
}
```

## ✅ Complexity, Insights & Notes

### ⏱ Time Complexity
- **O(n³)** — three nested loops over polygon vertices  
- Acceptable for `n ≤ 50` due to manageable input size

### 🧠 Space Complexity
- **O(n²)** — DP table of size `n × n`  
- Stores minimum triangulation scores for all subpolygons

---

### 🧨 Tricks / Insights
- The triangle `(i, k, j)` splits the polygon into two smaller subproblems  
- We reuse previously computed scores from `dp[i][k]` and `dp[k][j]`  
- The recurrence builds the solution bottom-up without recursion  
- This is a classic **interval DP** pattern — similar to **matrix chain multiplication**  
- The triangle score is computed as `values[i] * values[k] * values[j]` and added to subproblem scores

---

### 🧠 Notes
- Brute-force recursion with memoization also works but is slower and less elegant  
- This pattern generalizes to other polygon-based DP problems involving triangulation, partitioning, or nested structure  
- Useful in:
  - **Geometry-based optimization**  
  - **Graphics rendering**  
  - **Computational cost minimization**  
  - **Interval partitioning problems**  
  - **Structure-aware dynamic programming**

---

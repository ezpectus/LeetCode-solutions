# ğŸ§© Problem: Minimum Score Triangulation of Polygon  
## ğŸ”¢ Number: LeetCode 1039  
**Difficulty**: Medium  
**Language**: C#  
**Status**: âœ… Solved via bottom-up dynamic programming  

---

## ğŸ“œ Problem Overview

We are given a convex polygon with `n` vertices, each labeled with an integer value.  
The polygon is represented by an array `values[]`, where `values[i]` is the value of the `i-th` vertex in clockwise order.

We must triangulate the polygon into `n - 2` triangles.  
Each triangle has a score equal to the product of its three vertex values.  
The total score of the triangulation is the sum of all triangle scores.

Our goal is to **minimize** the total score across all valid triangulations.

---

### ğŸ”¢ Constraints
- `n == values.length`  
- `3 â‰¤ n â‰¤ 50`  
- `1 â‰¤ values[i] â‰¤ 100`  
- Polygon is convex and vertices are ordered clockwise  
- Only triangles are allowed â€” no other shapes

---

### ğŸ Whatâ€™s Given
- An integer array `values[]` representing the polygonâ€™s vertices  
- We must compute the **minimum total score** from any valid triangulation  
- Each triangleâ€™s score is `values[i] * values[j] * values[k]` for its three vertices

---

### ğŸ‘€ What We Observe
- This is a classic **polygon triangulation** problem  
- The number of triangles is always `n - 2`  
- The triangle score depends on vertex values â€” not geometry  
- We must explore multiple triangulation paths to find the minimum score  
- Brute-force recursion is possible but inefficient  
- **Bottom-up DP** is optimal for `n â‰¤ 50`

---

## ğŸ§  Explanation

We use **bottom-up dynamic programming** to solve this problem efficiently.

Let `dp[i][j]` represent the **minimum score** to triangulate the subpolygon from vertex `i` to vertex `j`.  
We initialize `dp[i][j] = 0` for all adjacent pairs (`j - i < 2`) since no triangle can be formed.

For each subpolygon of length â‰¥ 3, we try all possible third vertices `k` between `i` and `j` to form a triangle `(i, k, j)` and compute:

```csharp
dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + values[i] * values[k] * values[j])
```

This recurrence captures the cost of forming triangle (i, k, j) plus the cost of triangulating the two resulting subpolygons.
We build the solution bottom-up, increasing the gap between i and j from 2 to n - 1.

## âš™ï¸ Algorithm Choice

- Approach: Bottom-up dynamic programming
- Why: Avoids recursion and memoization overhead
- Efficiency: O(nÂ³) time is acceptable for n â‰¤ 50
- Memory: O(nÂ²) DP table

## ğŸ’¡ Idea Summary
- Use a 2D DP table dp[i][j] to store minimum triangulation scores
- For each subpolygon (i, j), try all possible third vertices k
- Update dp[i][j] with the minimum score from all valid splits
- Final answer is dp[0][n - 1]

## ğŸ§¾ Code
```cpp
public class Solution {
    public int MinScoreTriangulation(int[] values) {
        int n = values.Length;
        int[,] dp = new int[n, n];

        for (int gap = 2; gap < n; gap++) {
            for (int i = 0; i + gap < n; i++) {
                int j = i + gap;
                dp[i, j] = int.MaxValue;

                for (int k = i + 1; k < j; k++) {
                    int score = dp[i, k] + dp[k, j] + values[i] * values[k] * values[j];
                    dp[i, j] = Math.Min(dp[i, j], score);
                }
            }
        }

        return dp[0, n - 1];
    }
}
```

## âœ… Complexity, Insights & Notes

### â± Time Complexity
- **O(nÂ³)** â€” three nested loops over polygon vertices  
- Acceptable for `n â‰¤ 50` due to manageable input size

### ğŸ§  Space Complexity
- **O(nÂ²)** â€” DP table of size `n Ã— n`  
- Stores minimum triangulation scores for all subpolygons

---

### ğŸ§¨ Tricks / Insights
- The triangle `(i, k, j)` splits the polygon into two smaller subproblems  
- We reuse previously computed scores from `dp[i][k]` and `dp[k][j]`  
- The recurrence builds the solution bottom-up without recursion  
- This is a classic **interval DP** pattern â€” similar to **matrix chain multiplication**  
- The triangle score is computed as `values[i] * values[k] * values[j]` and added to subproblem scores

---

### ğŸ§  Notes
- Brute-force recursion with memoization also works but is slower and less elegant  
- This pattern generalizes to other polygon-based DP problems involving triangulation, partitioning, or nested structure  
- Useful in:
  - **Geometry-based optimization**  
  - **Graphics rendering**  
  - **Computational cost minimization**  
  - **Interval partitioning problems**  
  - **Structure-aware dynamic programming**

---

# LeetCode 764 — Largest Plus Sign  
**Approach: Dynamic Programming with 4 Directional Counts**

---

##  Problem Restatement
We are given an `n x n` grid filled with `1`s except for some cells marked as `0` (mines).  
We need to find the **order of the largest axis-aligned plus sign** of `1`s.  
- Order `k` means: center cell + arms of length `k-1` in all four directions.  
- If no plus sign exists, return `0`.

---

##  Core Idea
- For each cell `(i,j)`, compute the maximum consecutive `1`s in **four directions**:  
  - Left, Right, Up, Down.  
- The order of a plus sign centered at `(i,j)` = `min(left, right, up, down)`.  
- The answer = maximum order across all cells.  

---

##  Implementation (C#)

```csharp
public class Solution {
    public int OrderOfLargestPlusSign(int n, int[][] mines) {
        int[,] grid = new int[n, n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                grid[i, j] = 1;
            }
        }
        foreach (var mine in mines) {
            grid[mine[0], mine[1]] = 0;
        }

        int[,] left = new int[n, n];
        int[,] right = new int[n, n];
        int[,] up = new int[n, n];
        int[,] down = new int[n, n];

        // left + right
        for (int i = 0; i < n; i++) {
            int count = 0;
            for (int j = 0; j < n; j++) {
                count = grid[i, j] == 1 ? count + 1 : 0;
                left[i, j] = count;
            }
            count = 0;
            for (int j = n - 1; j >= 0; j--) {
                count = grid[i, j] == 1 ? count + 1 : 0;
                right[i, j] = count;
            }
        }

        // up + down
        for (int j = 0; j < n; j++) {
            int count = 0;
            for (int i = 0; i < n; i++) {
                count = grid[i, j] == 1 ? count + 1 : 0;
                up[i, j] = count;
            }
            count = 0;
            for (int i = n - 1; i >= 0; i--) {
                count = grid[i, j] == 1 ? count + 1 : 0;
                down[i, j] = count;
            }
        }

        int res = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i, j] == 1) {
                    int order = Math.Min(Math.Min(left[i, j], right[i, j]),
                                         Math.Min(up[i, j], down[i, j]));
                    res = Math.Max(res, order);
                }
            }
        }
        return res;
    }
}
```

##  Complexity Analysis
- **Time Complexity:**  
  - Fill grid → `O(n^2)`.  
  - Compute directional counts → `O(n^2)`.  
  - Final scan → `O(n^2)`.  
  - Total → `O(n^2)`.  

- **Space Complexity:**  
  - Four DP matrices of size `n x n` → `O(n^2)`.  

---

#  Impact of Design Choices

| Design Choice                  | Effect                                                                 |
|--------------------------------|------------------------------------------------------------------------|
| **Directional DP arrays**      | Efficiently capture arm lengths in each direction.                     |
| **Minimum of four counts**     | Ensures valid plus sign order.                                         |
| **Matrix scan**                | Guarantees maximum order found globally.                               |

---

#  Pitfalls
- Forgetting to reset count when hitting a `0`.  
- Taking max instead of min of directional counts → invalid plus sign.  
- Not handling `n=1` edge case → must return `0` if cell is mined.  

---

#  Conclusion
- **What it gives:** Largest plus sign order in grid.  
- **Why it matters:** Classic DP pattern for 2D grids with directional constraints.  
- **Key takeaway:**  
  1. Compute directional counts.  
  2. Take minimum for each cell.  
  3. Track maximum order across grid.
 
 ---

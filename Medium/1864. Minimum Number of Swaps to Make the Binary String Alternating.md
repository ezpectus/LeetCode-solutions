# 1864. Minimum Number of Swaps to Make the Binary String Alternating  
*O(n) — Optimal Two-Pattern Greedy Check*

---

## Problem Statement

- Given a binary string `s` (consisting only of '0' and '1', length 1 ≤ n ≤ 1000).
- Return the **minimum number of swaps** (any two characters, not necessarily adjacent) needed to make `s` **alternating** (no two adjacent characters are equal).
- If impossible → return **-1**.
- Alternating examples: "010", "10101", "01010", etc.

---

## Core Idea — Try Both Possible Patterns

**Key insight**:
- There are only **two possible alternating patterns** for a binary string:
  1. Starts with '0': "010101..."  
  2. Starts with '1': "101010..."
- For the string to be made alternating, it must match **one** of these two patterns after some swaps.
- Swaps can rearrange characters freely (since any positions allowed), so **the total count of 0s and 1s** must be sufficient to fill the required positions in the pattern.

**Steps**:
1. Count total number of '0's and '1's in `s`
2. For each possible target pattern:
   - Compute how many positions should be '0' and how many '1'
   - If we don't have enough '0's or '1's → impossible for this pattern
   - Otherwise, count how many positions currently **do not match** the target pattern
   - Each mismatch requires a swap with a mismatch of opposite type
   - Number of swaps = number of mismatches / 2 (since each swap fixes two mismatches)
3. Take the **minimum** swaps over the two possible patterns
4. If both impossible → return -1

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MinSwaps(string s) {
        int n = s.Length;

        // Count total zeros and ones
        int count0 = 0, count1 = 0;
        foreach (char c in s) {
            if (c == '0') count0++;
            else count1++;
        }

        int minSwaps = int.MaxValue;

        // Try both possible starting patterns
        for (int startWith = 0; startWith < 2; startWith++) {
            // Expected char at position 0
            char expectedFirst = (char)('0' + startWith);
            int needed0 = 0, needed1 = 0;

            // Count required 0s and 1s for this pattern
            for (int i = 0; i < n; i++) {
                char expected = (i % 2 == 0) ? expectedFirst : (char)('0' + '1' - expectedFirst);
                if (expected == '0') needed0++;
                else needed1++;
            }

            // If not enough 0s or 1s → impossible
            if (needed0 > count0 || needed1 > count1) continue;

            // Count mismatches
            int mismatches = 0;
            for (int i = 0; i < n; i++) {
                char expected = (i % 2 == 0) ? expectedFirst : (char)('0' + '1' - expectedFirst);
                if (s[i] != expected) mismatches++;
            }

            // Each swap fixes two mismatches (one 0→1 and one 1→0)
            int swapsNeeded = mismatches / 2;
            minSwaps = Math.Min(minSwaps, swapsNeeded);
        }

        return minSwaps == int.MaxValue ? -1 : minSwaps;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Two passes over the string (counting 0s/1s + mismatch counting) for each of the two patterns → total O(n) |
| **Space Complexity**  | **O(1)**      | Only a few integer counters and constants      |

**Optimal** — linear time, perfectly suited for n ≤ 1000.

---

## Why This Works — Example Walkthrough

**Example 1**: `s = "111000"`

- count0 = 3, count1 = 3
- Pattern 1: starts with '1' → "101010"
  - needed1 = 3, needed0 = 3 → possible
  - mismatches: positions 1,3,4 → 3 mismatches → swaps = 3 / 2 = **1** (integer division)
- Pattern 2: starts with '0' → "010101"
  - needed0 = 3, needed1 = 3 → possible
  - mismatches: positions 0,2,5 → 3 mismatches → swaps = **1**

Minimum swaps = **1** → correct  
(For example: swap positions to turn "111000" → "101010")

**Example 2**: `s = "010"`

- count0 = 2, count1 = 1
- One pattern matches exactly → mismatches = 0 → **0** swaps → correct

**Example 3**: `s = "1110"`

- count1 = 3, count0 = 1
- Pattern "1010": needed1 = 2, needed0 = 2 → not enough 0s → impossible
- Pattern "0101": needed0 = 2, needed1 = 2 → not enough 0s → impossible
- Return **-1** → correct

**Correct** — we check both possible alternating patterns ("0101..." or "1010..."), verify we have enough 0s and 1s, count mismatches, and compute swaps = mismatches / 2 (each swap fixes two mismatches).

---

## Pitfalls & Edge Cases

- **n = 1** → always alternating → **0** swaps
- **All 1s or all 0s** → impossible to alternate unless n=1 → **-1**
- **Already alternating** → **0** swaps
- **Even / odd length** → both patterns are checked correctly
- **Duplicate counts** → handled by total 0s/1s counters

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple greedy counting** problem:

- There are only **two possible target alternating patterns**:
  - Starting with '0': "010101..."
  - Starting with '1': "101010..."
- For each pattern:
  - Calculate required number of 0s and 1s
  - If not enough characters → skip (impossible)
  - Count **mismatches** (positions where s differs from target pattern)
  - Swaps needed = mismatches / 2 (each swap fixes two mismatches)
- Take the **minimum** swaps over both patterns
- If neither pattern possible → return **-1**

**Pure, clean, optimal** — linear time check of both possible alternating configurations.

---

# 1208. Get Equal Substrings Within Budget

## Problem

Given two strings `s` and `t` of **equal length**, and an integer `maxCost`.  
Changing `s[i]` → `t[i]` costs `|s[i] - t[i]|` (ASCII difference).

**Task**:  
Find the **maximum length** of a substring in `s` that can be changed to match the corresponding substring in `t` **without exceeding `maxCost`**.

---

## Core Insight

> This is a **sliding window optimization** problem.

Each position has a **cost**, and we want the **longest contiguous segment** where **total cost ≤ `maxCost`**.

**Key observations**:
- Costs are **non-negative**
- We don’t care **which** characters are changed — only **total cost**
- Use **two pointers** to maintain a **valid window**

---

## Architectural Triggers

| Trigger | Implication |
|-------|-------------|
| “Maximum length under cost constraint” | **Sliding window** with cumulative sum |
| “Absolute difference per character” | Compute cost **on the fly** |
| “Fixed alphabet” | ASCII diff is bounded and predictable |

---

## What This Implies

Use two pointers: `[start, end]`

1. **Expand `end`** → add `|s[end] - t[end]|` to `curr_cost`
2. **If `curr_cost > maxCost`** → shrink from `start`:
   - `curr_cost -= |s[start] - t[start]|`
   - `start++`
3. **Update** `maxLen = max(maxLen, end - start + 1)`

> **Why it works**:
> - Costs ≥ 0 → shrinking **always reduces cost**
> - Greedy expansion + minimal shrink → **optimal length**

---

## Code (C++)

```cpp
class Solution {
public:
    int equalSubstring(string s, string t, int maxCost) {
        int n = s.size();
        int start = 0, curr = 0, maxLen = 0;

        for (int end = 0; end < n; ++end) {
            curr += abs(s[end] - t[end]);

            while (curr > maxCost && start <= end) {
                curr -= abs(s[start] - t[start]);
                ++start;
            }

            maxLen = max(maxLen, end - start + 1);
        }

        return maxLen;
    }
};
```

## Complexity

| Metric | Value |
|-------|-------|
| **Time** | `O(n)` — single pass |
| **Space** | `O(1)` — no extra structures |

---

## Example: `s = "abcd"`, `t = "bcdf"`, `maxCost = 3`

| Pos | `s[i]` | `t[i]` | Cost | Cumulative |
|-----|--------|--------|------|------------|
| 0   | `a`    | `b`    | 1    | 1          |
| 1   | `b`    | `c`    | 1    | 2          |
| 2   | `c`    | `d`    | 1    | **3 (valid)** |
| 3   | `d`    | `f`    | 2    | 5 (invalid)|

**Window behavior**:
- `[0,2]` → cost = **3** → **valid** → len = **3**
- `[1,3]` → cost = 4 → shrink → still invalid
- Final: `maxLen = 3`

> **Answer = 3**

---

## Insight

This is a **classic sliding window with additive constraint**.

> You’re **not optimizing structure** — just **total cost**.  
> The window **expands greedily** and **shrinks only when necessary**.

**Core idea**:  
- Each character contributes a **non-negative cost**
- We want **maximum length** under **budget**
- **Two pointers** maintain the **longest valid window**

**Pattern**:  
> *"Maximum-length subarray with sum ≤ budget"*

**Generalizes to**:
- Budget-constrained substring problems
- Maximum-length subarrays with bounded sum
- Real-time cost tracking in streaming data

---

## Fichka Library Entry

> **Sliding window: max-length subarray under additive cost constraint**

---

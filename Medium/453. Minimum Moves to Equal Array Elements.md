# 453. Minimum Moves to Equal Array Elements

---

## Problem Restatement
We are given an integer array `nums`.  
In one move, we can increment **n - 1** elements by 1.  
We must return the minimum number of moves required to make all elements equal.

---

## Key Insight
Incrementing `n - 1` elements by 1 is equivalent to **decrementing 1 element by 1** (relative difference).  
Thus, the problem reduces to:
- Making all elements equal to the **minimum element** in the array.  
- Formula:  


```
moves = sum(nums[i] - min(nums)) for i = 0..n-1
```

---

## Code (C#)
```csharp
using System;

public class Solution {
    public int MinMoves(int[] nums) {
        int minVal = int.MaxValue;
        long sum = 0;

        foreach (int num in nums) {
            if (num < minVal) minVal = num;
            sum += num;
        }

        return (int)(sum - (long)minVal * nums.Length);
    }
}
```


## Time Complexity
- **Traversal:** Single pass to compute sum and minimum.  
- **Overall:** O(n), where n = length of the array.  

---

## Space Complexity
- **Only variables:** `sum`, `minVal`.  
- **Overall:** O(1).  

---

## Example Walkthrough

### Example 1
**Input:** `[1,2,3]`  
- min = 1, sum = 6  
- moves = sum - min * n = 6 - 1*3 = 3  
✅ Output = `3`  

---

### Example 2
**Input:** `[1,1,1]`  
- min = 1, sum = 3  
- moves = 3 - 1*3 = 0  
✅ Output = `0`  

---

## Why This Works
- Incrementing n-1 elements is equivalent to decrementing one element.  
- Thus, the target is to make all elements equal to the minimum.  
- The total moves equal the sum of differences from the minimum.  

---

✅ **Conclusion**  
This is the **Minimum Difference Summation Algorithm**.  
By reducing the problem to differences from the minimum element, we compute the answer efficiently in O(n) time and O(1) space.


---

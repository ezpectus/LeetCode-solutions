# Find the Minimum Amount of Time to Brew Potions ‚Äî Engineering Breakdown
## üìå Problem Description
You are given two integer arrays:

- skill of length n (skills of wizards).
- mana of length m (mana capacity of potions).
- Each potion must be brewed by all wizards sequentially.

Time taken by wizard i on potion j is:

```
time[i][j] = skill[i] * mana[j]
```


- Brewing is synchronized: a potion must immediately pass to the next wizard once the current wizard finishes.
- Wizards cannot overlap improperly: wizard k cannot start potion j+1 if wizard k+1 is still working on potion j.
- Goal: Return the minimum total time required to brew all potions in order.

## üí° Core Idea

This is a Dynamic Programming (DP) on pipelines problem. 
We simulate the brewing process across wizards and potions, ensuring synchronization.

Strategy
- Maintain an array done[k] = earliest finishing time after wizard k processes the current potion.

For each potion:

- Forward pass: compute finish times for each wizard sequentially.
- Backward pass: adjust times backwards to enforce synchronization (wizard k must finish exactly when wizard k+1 starts).
- After all potions, done[n] holds the minimum total time.

## üíª Full Code

```csharp
public class Solution {
    public long MinTime(int[] skill, int[] mana) {
        int n = skill.Length;
        int m = mana.Length;
        long[] done = new long[n + 1];

        for (int i = 0; i < m; i++) {
            // Forward pass: compute finish times
            for (int j = 0; j < n; j++)
                done[j + 1] = Math.Max(done[j + 1], done[j]) + (long)mana[i] * skill[j];

            // Backward pass: synchronize times
            for (int k = n - 1; k > 0; k--)
                done[k] = done[k + 1] - (long)mana[i] * skill[k];
        }

        return done[n];
    }
}
```

## ‚è±Ô∏è Time & Space Complexity
The time complexity of this solution is O(n¬∑m), since for each of the m potions we iterate over all n wizards twice ‚Äî once in the forward pass and once in the backward pass.
The space complexity is O(n), because we only maintain a single DP array done of size n+1 to track the finish times.

## üß† Pattern Summary
Pattern: Pipeline DP with Synchronization 
Type: Dynamic Programming + Scheduling Key 
Invariant: Each wizard‚Äôs finish time depends both on their own previous work and on synchronization with the next wizard.

Used In:

- Job scheduling on multiple machines
- Assembly line or pipeline optimization
- Sequential task processing with dependencies

Engineering Insight

- This solution models the brewing process as a pipeline of dependent tasks.
- The forward pass ensures correct accumulation of work across wizards.
- The backward pass enforces synchronization, preventing any wizard from getting ahead of the pipeline.

Why it‚Äôs reusable:

- It applies to any sequential multi‚Äëstage process, such as manufacturing lines, computational pipelines, or workflow systems.
- It generalizes to problems where tasks must pass through ordered stages with strict synchronization.

## üíª A Few Words About the Code
The implementation is compact but powerful:

- It uses a single DP array done to track finish times.
- The forward loop simulates potion brewing across all wizards.
- The backward loop corrects timings to maintain synchronization.
- This dual‚Äëpass structure makes the solution both efficient and elegant, capable of handling up to 5000 wizards and 5000 potions within the given constraints.


---

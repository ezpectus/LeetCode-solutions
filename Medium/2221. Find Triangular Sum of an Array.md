# ðŸ”º Problem: Triangular Sum of an Array (Leetcode 2221)

## ðŸ“œ Statement

You're given a 0-indexed array `nums` of digits (0â€“9).  
The **triangular sum** is the final single-digit value obtained by repeatedly applying:

> `nums[i] = (nums[i] + nums[i+1]) % 10` for all `i` in `[0, n-2]`

Repeat until only one element remains. Return that value.

---

## ðŸ§  Core Idea

This is a **modular reduction cascade**.  
Each layer compresses the array by one element using pairwise modulo-10 addition.  
The process continues until the array collapses into a single digit.

> Think of it as a **numerical triangle**, where each level is a reduced version of the previous.

---

## ðŸ§ª Example

```text
Input: [1, 2, 3, 4, 5]
â†’ [3, 5, 7, 9]
â†’ [8, 2, 6]
â†’ [0, 8]
â†’ [8]
Output: 8
```
## ðŸ§± C# Implementation
```cpp
public class Solution {
    public int TriangularSum(int[] nums) {
        int n = nums.Length;
        for (int i = n; i > 1; i--) {
            for (int j = 0; j < i - 1; j++) {
                nums[j] = (nums[j] + nums[j + 1]) % 10;
            }
        }
        return nums[0];
    }
}
```

## ðŸ” Why This Code Is Optimized

### âœ… In-place Mutation
- No need to allocate `newNums` â€” we overwrite `nums` directly.
- Saves memory: **O(1)** space complexity.
- Avoids GC pressure and heap churn â€” especially relevant in constrained environments.

### ðŸ” Controlled Iteration
- Outer loop: max `n` iterations.
- Inner loop: shrinking range â€” `n-1`, `n-2`, ..., `1`.
- Total operations: **O(nÂ²)** worst-case, but tight and predictable.
- No recursion, no branching â€” just pure iteration.

### ðŸ§® Modulo Arithmetic
- `% 10` keeps values bounded in `[0â€“9]`.
- Prevents overflow, ensures digit-level integrity.
- Makes the system stable under all input conditions.

### ðŸ§  Cache-Friendly
- Sequential access pattern â€” no jumps, no recursion.
- Works well with CPU cache due to linear memory traversal.
- No dynamic memory allocation â€” just stack-level loop control.

---

## ðŸ§® Time & Space Complexity

| Metric      | Value   | Notes                                      |
|-------------|---------|--------------------------------------------|
| Time        | O(nÂ²)   | Nested iteration over shrinking array      |
| Space       | O(1)    | In-place updates, no extra allocations     |
| Stability   | High    | No branching, no recursion                 |
| Scalability | Up to 1000 | Handles max constraints smoothly       |

---

## ðŸ§  Engineering Takeaway

This task is a clean example of:

- âœ… **In-place array transformation** â€” memory-efficient and fast  
- ðŸ”¢ **Modular arithmetic** â€” bounded operations, no overflow  
- ðŸ” **Iterative compression** â€” each layer strips away one level of structure  
- ðŸ§  **Numerical convergence** â€” simple rules yield elegant finality

> Youâ€™re not just summing â€” youâ€™re **collapsing structure into essence**.

---

## ðŸ§© Conclusion

Triangular sum is a metaphor for **data reduction under constraints**.  
Each layer strips away redundancy, leaving behind a distilled core.  
Perfect warm-up for deeper algorithmic compression problems.

---

# 🔺 Problem: Triangular Sum of an Array (Leetcode 2221)

## 📜 Statement

You're given a 0-indexed array `nums` of digits (0–9).  
The **triangular sum** is the final single-digit value obtained by repeatedly applying:

> `nums[i] = (nums[i] + nums[i+1]) % 10` for all `i` in `[0, n-2]`

Repeat until only one element remains. Return that value.

---

## 🧠 Core Idea

This is a **modular reduction cascade**.  
Each layer compresses the array by one element using pairwise modulo-10 addition.  
The process continues until the array collapses into a single digit.

> Think of it as a **numerical triangle**, where each level is a reduced version of the previous.

---

## 🧪 Example

```text
Input: [1, 2, 3, 4, 5]
→ [3, 5, 7, 9]
→ [8, 2, 6]
→ [0, 8]
→ [8]
Output: 8
```
## 🧱 C# Implementation
```cpp
public class Solution {
    public int TriangularSum(int[] nums) {
        int n = nums.Length;
        for (int i = n; i > 1; i--) {
            for (int j = 0; j < i - 1; j++) {
                nums[j] = (nums[j] + nums[j + 1]) % 10;
            }
        }
        return nums[0];
    }
}
```

## 🔍 Why This Code Is Optimized

### ✅ In-place Mutation
- No need to allocate `newNums` — we overwrite `nums` directly.
- Saves memory: **O(1)** space complexity.
- Avoids GC pressure and heap churn — especially relevant in constrained environments.

### 🔁 Controlled Iteration
- Outer loop: max `n` iterations.
- Inner loop: shrinking range — `n-1`, `n-2`, ..., `1`.
- Total operations: **O(n²)** worst-case, but tight and predictable.
- No recursion, no branching — just pure iteration.

### 🧮 Modulo Arithmetic
- `% 10` keeps values bounded in `[0–9]`.
- Prevents overflow, ensures digit-level integrity.
- Makes the system stable under all input conditions.

### 🧠 Cache-Friendly
- Sequential access pattern — no jumps, no recursion.
- Works well with CPU cache due to linear memory traversal.
- No dynamic memory allocation — just stack-level loop control.

---

## 🧮 Time & Space Complexity

| Metric      | Value   | Notes                                      |
|-------------|---------|--------------------------------------------|
| Time        | O(n²)   | Nested iteration over shrinking array      |
| Space       | O(1)    | In-place updates, no extra allocations     |
| Stability   | High    | No branching, no recursion                 |
| Scalability | Up to 1000 | Handles max constraints smoothly       |

---

## 🧠 Engineering Takeaway

This task is a clean example of:

- ✅ **In-place array transformation** — memory-efficient and fast  
- 🔢 **Modular arithmetic** — bounded operations, no overflow  
- 🔁 **Iterative compression** — each layer strips away one level of structure  
- 🧠 **Numerical convergence** — simple rules yield elegant finality

> You’re not just summing — you’re **collapsing structure into essence**.

---

## 🧩 Conclusion

Triangular sum is a metaphor for **data reduction under constraints**.  
Each layer strips away redundancy, leaving behind a distilled core.  
Perfect warm-up for deeper algorithmic compression problems.

---

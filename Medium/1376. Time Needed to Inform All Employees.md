# 1376. Time Needed to Inform All Employees — Architectural DFS from Head with Max Depth  
*O(n) — Optimal Tree Traversal from Root*

---

## Problem Statement

Given `n` employees (0 to n-1), `headID` (root), `manager[]` (parent of each), `informTime[]` (time to inform subordinates).

Tree structure guaranteed.

Head informs direct subordinates → they inform theirs after `informTime[head]` minutes, etc.

Return **total minutes** to inform **all** employees.

---

## Core Idea — DFS from Head, Track Maximum Time

**Key insight**:
- Tree → no cycles → DFS safe
- Time to inform a subtree = `informTime[node]` + max over children subtrees
- Total time = **maximum** over all leaf paths from head

**Steps**:
1. Build adjacency list: `children[i]` = list of subordinates of i
2. DFS from head:
   - If no children → return 0
   - Else → return `informTime[node] + max(DFS(child) for child)`

**Answer** = DFS(head)

---

##  Implementation (C#)

```csharp
public class Solution {
    public int NumOfMinutes(int n, int headID, int[] manager, int[] informTime) {
        // Build children list
        var children = new List<int>[n];
        for (int i = 0; i < n; i++)  children[i] = new List<int>();
        
        for (int i = 0; i < n; i++)  {
            if (manager[i] != -1) children[manager[i]].Add(i); 
        }

        // DFS: return time to inform subtree
        return Dfs(headID, children, informTime);
    }

private int Dfs(int node, List<int>[] children, int[] informTime) {
        int maxChild = 0;
        foreach (int child in children[node])  maxChild = Math.Max(maxChild, Dfs(child, children, informTime));
        
        return informTime[node] + maxChild;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Each node visited exactly once                 |
| **Space Complexity**  | **O(n)**      | Adjacency list + recursion stack (worst-case height n) |

**Optimal** — linear time and minimal extra space.

---

## Why This Works — Example Walkthrough

**Example 2**: `n=6`, `headID=2`, `manager=[2,2,-1,2,2,2]`, `informTime=[0,0,1,0,0,0]`

- Tree structure:
  - Root **2** (informTime=1) → direct subordinates: 0,1,3,4,5
  - All subordinates are leaves (informTime=0)

- DFS from node 2:
  - Recurse on each child → each returns 0 (no further subordinates)
  - Max over children = 0
  - Return `informTime[2] + 0 = 1 + 0 = **1**`

**Result**: **1** minute — correct.

**Example 1**: `n=1`, `headID=0`

- Single node → no children
- DFS returns `informTime[0] + 0 = 0` (since informTime[0]=0)
- **Result**: **0** — correct.

The DFS correctly computes the **longest path** in terms of information delay from the head.

---

## Pitfalls & Edge Cases

- **n=1** → single node → returns **0**
- **Deep chain** → correctly accumulates time along the longest path
- **Wide tree** → correctly takes maximum over all branches
- **informTime=0** → no delay at that node (common for leaves)
- **Head with no subordinates** → returns **0**

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** tree traversal:

- **Build children list** → reverse the manager array (O(n))
- **DFS from head** → returns time to inform entire subtree
- **Take max over children** → finds the longest delay path
- **Return head time + max child time** → total minutes needed

**Pure, clean, optimal** — perfect information propagation timing.

---

# 537. Complex Number Multiplication — Architectural Solution

---

##  Problem Statement
We are given two complex numbers in string format, e.g. `"1+1i"` or `"1+-1i"`.  
We need to implement multiplication of these complex numbers and return the result in the same string format `"a+bi"`.

Constraints:
- Input strings are guaranteed to be valid complex numbers.  
- The real and imaginary parts are integers in the range [-100, 100].  

---

##  Core Idea
- Parse each input string into its **real** and **imaginary** parts.  
- Apply the formula for complex multiplication:  
```
(a + bi) * (c + di) = (ac - bd) + (ad + bc)i
```
- Construct the result string in the format `"real+imaginaryi"`.  

---

##  Implementation (C#)
```csharp
using System;

public class Solution {
  public string ComplexNumberMultiply(string num1, string num2) {
      // Parse num1
      var parts1 = num1.Split('+');
      int a = int.Parse(parts1[0]);
      int b = int.Parse(parts1[1].Replace("i", ""));
      
      // Parse num2
      var parts2 = num2.Split('+');
      int c = int.Parse(parts2[0]);
      int d = int.Parse(parts2[1].Replace("i", ""));
      
      // Apply multiplication formula
      int real = a * c - b * d;
      int imag = a * d + b * c;
      
      return $"{real}+{imag}i";
  }
}
```


##  Complexity Analysis
- **Time Complexity:** O(1)  
  Parsing the two input strings and performing a fixed number of arithmetic operations is constant time.  
- **Space Complexity:** O(1)  
  Only a handful of integer variables are needed to store the real and imaginary parts.

---

##  Pitfalls & Edge Cases
- **Parsing negative numbers**  
  Inputs like `"1+-1i"` must be correctly split into `1` and `-1`. String splitting and replacement must handle the `"+"` and `"i"` characters carefully.  
- **String format consistency**  
  Always return the result in `"a+bi"` format, even if `a` or `b` are negative. For example, `"-1+-1i"` is valid.  
- **Zero cases**  
  Multiplying with zero should yield `"0+0i"`. Both real and imaginary parts must be explicitly included.  
- **Input validation**  
  Although constraints guarantee valid input, robust parsing ensures no hidden errors when handling edge cases.

---

##  Conclusion
This solution follows a clean architectural pipeline:
1. **Parse** the input strings into real and imaginary components.  
2. **Compute** the product using the standard formula `(a+bi)*(c+di) = (ac - bd) + (ad + bc)i`.  
3. **Format** the result back into the required string representation.  
4. **Return** the final string.  

It is efficient (O(1) time and space), robust against negatives and zero cases, and architecturally elegant: **parse → compute → format → return**.


---

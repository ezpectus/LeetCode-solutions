# LeetCode 1962 — Remove Stones to Minimize the Total  
**Approach: Max-Heap (Priority Queue) with Greedy Reduction**

---

##  Problem Restatement
We have piles of stones. In each of `k` operations:  
- Choose a pile.  
- Remove `floor(pile/2)` stones.  
We want the minimum total stones after `k` operations.

---

##  Core Idea
- Always remove stones from the **largest pile** (greedy choice).  
- Use a **max-heap** (priority queue) to efficiently get and update the largest pile.  
- Each operation:  
  - Extract max pile.  
  - Remove half (`floor(pile/2)`).  
  - Push updated pile back.  
- Track total sum dynamically.

---

##  Optimized Implementation (C#)

```csharp
public class Solution {
    public int MinStoneSum(int[] piles, int k) {
        int sum = 0;
        var pq = new PriorityQueue<int, int>();

        // Build max-heap
        foreach (int pile in piles) {
            sum += pile;
            pq.Enqueue(pile, -pile); // negative priority for max-heap
        }

        // Perform k operations
        while (k-- > 0) {
            int largest = pq.Dequeue();
            int removed = largest / 2;
            sum -= removed;
            int updated = largest - removed;
            pq.Enqueue(updated, -updated);
        }

        return sum;
    }
}
```

##  Time Complexity
- **Heap construction:**  
  Insert all piles into the priority queue → `O(n)`.  
- **Operations:**  
  Each of the `k` removals requires extracting and reinserting into the heap → `O(log n)` per operation.  
- **Overall:**  
  → `O(n + k log n)`.

---

##  Space Complexity
- **Heap storage:**  
  Priority queue holds all piles → `O(n)`.  
- **Additional variables:**  
  Only integer counters for sum tracking → `O(1)`.  
- **Total:**  
  → `O(n)`.

---

#  Impact of Design Choices

| Design Choice                  | Effect                                                                 |
|--------------------------------|------------------------------------------------------------------------|
| **Max-heap (priority queue)**  | Efficiently retrieves largest pile each step.                         |
| **Dynamic sum tracking**       | Avoids recomputing total after each operation.                        |
| **Greedy removal**             | Guarantees optimal reduction by always targeting the largest pile.     |

---

#  Pitfalls
- **Using min-heap instead of max-heap:** Produces incorrect results.  
- **Forgetting to update total sum:** Leads to wrong final answer.  
- **Not handling repeated operations on same pile:** Must reinsert updated pile correctly.  

---

#  Conclusion
- **What it gives:** Minimum total stones after `k` optimal removals.  
- **Why it matters:** Greedy + heap ensures efficiency for large inputs (`n, k ≤ 10^5`).  
- **Key takeaway:**  
  1. Use max-heap for largest pile selection.  
  2. Update sum incrementally.  
  3. Complexity `O(n + k log n)` is optimal for constraints.  



---

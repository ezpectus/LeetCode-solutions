# 2120. Execution of All Suffix Instructions Staying in a Grid  
*O(m²) — Simple Simulation per Starting Position*

---

## Problem Statement

You have an **n × n** grid (0 ≤ row, col < n).  
Robot starts at `startPos = [startrow, startcol]`.  
You are given a string `s` of length `m` consisting of moves: `'L'`, `'R'`, `'U'`, `'D'`.

For each starting index `i` (0 ≤ i < m), compute how many instructions the robot can execute **starting from the i-th instruction** until:
- It would move **off the grid**, or
- There are no more instructions left

Return an array `answer` of length `m` where `answer[i]` is the number of moves the robot can make if it starts executing from index `i`.

**Examples**:

**Example 1**: n = 3, startPos = [0,1], s = "RRDDLU"  
Output: [1,5,4,3,1,0]  
- i=0: "R" → moves right to (0,2), next 'R' would go to (0,3) → off → **1**
- i=1: "RDDLU" → can do all 5 moves, ends inside grid → **5**
- etc.

**Constraints**:
- 1 ≤ n, m ≤ 500
- 0 ≤ startrow, startcol < n
- s consists of 'L','R','U','D'

---

## Core Idea — Brute-Force Simulation per Starting Point

Since m ≤ 500 and n ≤ 500, we can afford to:
- For each starting index i (0 to m-1):
  - Simulate the robot starting from position (startrow, startcol)
  - Execute instructions from s[i], s[i+1], ..., s[m-1]
  - Count how many moves it can make before going out of grid

**Time**: O(m²) — for each of m starting points, simulate up to m moves → 500² = 250,000 operations — fast enough

**Space**: O(1) — only current position and counter

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int[] ExecuteInstructions(int n, int[] startPos, string s) {
        int m = s.Length;
        int[] answer = new int[m];

        int sr = startPos[0];
        int sc = startPos[1];

        // For each possible starting index i
        for (int i = 0; i < m; i++) {
            int row = sr;
            int col = sc;
            int count = 0;

            // Try to execute from i to m-1
            for (int j = i; j < m; j++) {
                char move = s[j];

                // Compute next position
                int nr = row;
                int nc = col;

                if (move == 'L') nc--;
                else if (move == 'R') nc++;
                else if (move == 'U') nr--;
                else if (move == 'D') nr++;

                // Check if next position is inside grid
                if (nr >= 0 && nr < n && nc >= 0 && nc < n) {
                    row = nr;
                    col = nc;
                    count++;
                } 
                else {
                    // Cannot make this move → stop here
                    break;
                }
            }

            answer[i] = count;
        }

        return answer;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(m²)**     | For each of the m possible starting indices, we simulate up to m moves in the worst case → O(m²) ≈ 500² = 250,000 operations |
| **Space Complexity**  | **O(1)**      | Only a few integer variables (current position, counter) + the output array of size m (necessary for return) |

**Optimal** — quadratic time is perfectly acceptable and efficient given the constraint m ≤ 500.

---

## Why This Works — Example Walkthrough

**Example 1**: n = 3, startPos = [0,1], s = "RRDDLU"

Grid is 3×3, robot starts at row 0, column 1.

- **i = 0**: suffix = "RRDDLU"
  - Move 'R' → column 1 → 2 (0,2) → valid
  - Next 'R' → column 2 → 3 (0,3) → out of bounds
  - Stops after **1** move

- **i = 1**: suffix = "RDDLU"
  - 'R' → (0,2) ok
  - 'D' → (1,2) ok
  - 'D' → (2,2) ok
  - 'L' → (2,1) ok
  - 'U' → (1,1) ok
  - All **5** moves succeed → stays inside grid

- **i = 2**: suffix = "DDLU" → **4** moves ok
- **i = 3**: suffix = "DLU" → **3** moves ok
- **i = 4**: suffix = "LU"
  - 'L' → (0,0) ok
  - 'U' → (-1,0) → out
  - Stops after **1** move

- **i = 5**: suffix = "U"
  - 'U' → (-1,1) → out
  - **0** moves

Output: **[1,5,4,3,1,0]** → correct

**Correct** —  
For each possible starting index i, we simulate the robot from the initial position (startPos) and execute the suffix instructions s[i..m-1] one by one.  
We count how many consecutive moves the robot can perform before any move would take it outside the grid boundaries [0, n-1].

---

## Key Takeaway

This is a **straightforward multi-start simulation** problem:

* For each possible starting instruction index i (from 0 to m-1):
  * Place the robot back at the initial position (startrow, startcol)
  * Try to execute instructions s[i], s[i+1], ..., s[m-1] sequentially
  * For each instruction, calculate the next position
  * If the next position is still inside the grid [0..n-1], execute the move and increment count
  * If the next move would go out of bounds, stop for this starting index
* Store the count of successful moves for each i in the answer array

**Pure, clean, optimal** — O(m²) time, O(1) extra space (besides output), extremely simple and direct simulation — perfect and efficient for m ≤ 500.

---

# 684. Redundant Connection
---
## ðŸ§  Problem Signal
You're given a graph that started as a tree â€” meaning:
```
 It has n nodes
 Itâ€™s connected
 It has no cycles
```
- Then, one extra edge was added, making it n edges total.
- This extra edge creates a cycle. Your task is to find and return that edge.

## ðŸ”§ Core Insight

- A tree with n nodes has exactly n - 1 edges. 
- Adding one more edge â†’ cycle is guaranteed. So we need to detect the edge that forms the cycle.
- This is a classic use case for Union-Find (Disjoint Set Union).

## ðŸ§± Union-Find Explained
Union-Find is a data structure that tracks connected components.

It supports two operations:

- find(x) â†’ returns the root of the component containing x
- union(x, y) â†’ merges the components of x and y
- If find(a) == find(b) â†’ a and b are already connected â†’ adding edge [a, b] would create a cycle â†’ this is the redundant edge
  
---

## ðŸ’» Full Code (C#)

```csharp
public class Solution {
    public int[] FindRedundantConnection(int[][] edges) {
        int n = edges.Length;
        int[] parent = new int[n + 1];

        // Initialize each node to be its own parent
        for (int i = 1; i <= n; i++) {
            parent[i] = i;
        }

        foreach (var edge in edges) {
            int a = edge[0], b = edge[1];
            int rootA = Find(parent, a);
            int rootB = Find(parent, b);

            if (rootA == rootB) {
                // a and b are already connected â†’ cycle detected
                return edge;
            }

            // Merge the components
            parent[rootA] = rootB;
        }

        return new int[0]; // Should never reach here per problem constraints
    }

    private int Find(int[] parent, int x) {
        if (parent[x] != x) {
            parent[x] = Find(parent, parent[x]); // Path compression
        }
        return parent[x];
    }
}
```

##  ðŸ§  Architectural Notes 

### ðŸ”¹ Path Compression in Find()

- What it does: When you call Find(x), it recursively finds the root of x. With path compression, it also flattens the tree by directly linking x to its root.
- Why it matters: Future Find() calls become faster because the depth of the tree shrinks.
- Signal: This is a self-optimizing structure â€” the more you use it, the faster it gets.

- ðŸ“¦ In my terms: itâ€™s like caching the signal path so future lookups donâ€™t waste cycles.

### ðŸ”¹ Near O(n) Time Complexity

- Union-Find with path compression and union by rank (if used) gives amortized inverse Ackermann time, which is practically O(n) for all real inputs.
- Why it matters: Even with 1000 edges, the algorithm stays fast and stable.
- Signal: Youâ€™re not brute-forcing â€” youâ€™re using a structural filter that scales.

- ðŸ“¦ Denis-style: itâ€™s not just fast â€” itâ€™s architecturally efficient, even under load.

### ðŸ”¹ No Explicit Graph Needed

- You donâ€™t need to build adjacency lists or matrices.
- Union-Find tracks connectivity implicitly through the parent[] array.
- Each node knows who its root is â€” and thatâ€™s enough to detect cycles.

- ðŸ“¦ Signal: Youâ€™re not modeling the graph â€” youâ€™re tracking its topology through disjoint sets.

---

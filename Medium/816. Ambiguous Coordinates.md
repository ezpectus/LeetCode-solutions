# 816. Ambiguous Coordinates — Architectural Brute-Force Valid Split Enumeration  
*O(n³) — Optimal Exhaustive Partitioning*

---

## Problem Statement

Given a string `s` like `"(123)"` (parentheses + digits only), return **all possible** original coordinate pairs `(x, y)` that could produce `s` after removing commas, decimals, and spaces.

**Rules**:
- No leading zeros (except `"0"`)
- No trailing zeros after decimal (e.g., `"1.0"` invalid)
- Decimal point must have digit before it
- Return as list of strings like `"(1, 23)"`

---

## Core Idea — Split Into Two Numbers + Validate Each

`s` without parentheses = digits string `t`.

We **try every split point** `i` → left = `t[0..i)`, right = `t[i..end)`

For each part:
- Try as **integer**
- Try all possible **decimal positions** (if length > 1)

**Valid number** if:
- No leading zero **unless** `"0"`
- If decimal → no trailing zero
- Decimal point → at least one digit before

**Collect all valid `(left, right)` pairs**.

---

## Implementation (C#)

```csharp
public class Solution {
    public IList<string> AmbiguousCoordinates(string s) {
        var result = new List<string>();
        string t = s.Substring(1, s.Length - 2); // remove parentheses

        for (int i = 1; i < t.Length; i++) {
            string left = t.Substring(0, i);
            string right = t.Substring(i);

            var lefts = GetValid(left);
            var rights = GetValid(right);

            foreach (string l in lefts) {
                foreach (string r in rights)  result.Add($"({l}, {r})");  
            }
        }

        return result;
    }

    private List<string> GetValid(string num) {
        var res = new List<string>();

        // Case 1: integer
        if (IsValidInteger(num))  res.Add(num);
        
        // Case 2: decimal versions
        for (int i = 1; i < num.Length; i++) {
            string intPart = num.Substring(0, i);
            string fracPart = num.Substring(i);

            if (IsValidInteger(intPart) && IsValidFrac(fracPart))   res.Add(intPart + "." + fracPart);
            
        }

        return res;
    }

    private bool IsValidInteger(string s) {
        // "0" ok, "00" no, "01" no
        return s.Length == 1 || s[0] != '0';
    }

    private bool IsValidFrac(string s) {
        // no trailing zero: "10" → "1.0" invalid
        return s[s.Length - 1] != '0';
    }
}
```


## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n³)**     | n ≤ 10 → n³ = 1000 → fine                      |
| **Space Complexity**  | **O(n²)**     | Result list size                               |

**Optimal** — constraints tiny.

---

## Why This Works — Example Walkthrough

**Input**: `s = "(123)"` → `t = "123"`

- Split at `i=1`: left="1", right="23"
  - left → `"1"`
  - right → `"23"`, `"2.3"`
  - → `"(1, 23)"`, `"(1, 2.3)"`

- Split at `i=2`: left="12", right="3"
  - left → `"12"`, `"1.2"`
  - right → `"3"`
  - → `"(12, 3)"`, `"(1.2, 3)"`

All 4 combinations — **correct**.

---

## Pitfalls & Edge Cases

- **Leading zero**: `"01"` → invalid integer
- **Trailing zero**: `"1.0"` → invalid fractional part
- **`"0"`** → valid integer
- **`"0.1"`** → valid
- **`".1"`** → invalid (no digit before decimal)
- **Exact match** → valid
- **Chars not in order** → flexible placement → correct

All handled cleanly.

---

## Key Takeaway

This is a **beautifully brute-force** string partitioning problem:

- **Split** into two parts
- **Enumerate** valid integer/decimal forms
- **Combine** valid pairs

**No backtracking. No regex. Pure loops.**
**One of the cleanest Medium string enumeration problems**.

---

# 📘 Problem: 695. Max Area of Island

## 🧩 Problem Description  
Given an `m x n` binary matrix `grid`, where `1` represents land and `0` represents water, return the **maximum area** of any island.  
An island is formed by connecting adjacent lands **horizontally or vertically**.  
All edges of the grid are surrounded by water.

---

## 💡 Core Idea  
This is a **component traversal** problem on a 2D grid.  
Each `'1'` cell is part of an island, and the goal is to compute the **maximum size** of any connected group of `'1'`s.

Use **DFS flood-fill** to traverse each island and count its area.  
Track the maximum area encountered across all DFS launches.

---

## ⚙️ Algorithm Overview

### DFS Traversal  
- Iterate through every cell in the grid  
- When a `'1'` is found:
  - Launch DFS to explore the island  
  - DFS returns the area of the current island  
  - Update `maxArea` if the returned area is larger

### DFS Logic  
- Base case: out-of-bounds or water → return `0`  
- Mark current cell as visited (`grid[i][j] = 0`)  
- Recursively explore 4 directions  
- Return `1 + sum of all recursive calls`

---

## 🧠 Combined Techniques

| Component           | Technique Used                  |
|--------------------|----------------------------------|
| Grid Traversal      | Nested loops over `m x n`        |
| Connectivity        | DFS flood-fill                   |
| Area Accumulation   | Recursive return with `1 + ...`  |
| Visited Tracking    | In-place mutation (`1 → 0`)      |
| Maximum Tracking    | `Math.Max()` comparison per DFS  |

---

## 🧪 Constraints

- `1 <= m, n <= 50`  
- `grid[i][j]` is either `0` or `1`  
- Grid is surrounded by water  
- No diagonal connections  
- Time complexity: `O(m * n)`  
- Space complexity: `O(m * n)` in worst case (DFS stack)

---

## 🧱 Code Implementation

```csharp
public class Solution {
    public int MaxAreaOfIsland(int[][] grid) {
        int m = grid.Length;
        int n = grid[0].Length;
        int maxArea = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    int area = Dfs(grid, i, j);
                    maxArea = Math.Max(maxArea, area);
                }
            }
        }

        return maxArea;
    }

    int Dfs(int[][] grid, int i, int j) {
        int m = grid.Length;
        int n = grid[0].Length;

        if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0) return 0;

        grid[i][j] = 0; // mark as visited

        return 1 +
            Dfs(grid, i + 1, j) +
            Dfs(grid, i - 1, j) +
            Dfs(grid, i, j + 1) +
            Dfs(grid, i, j - 1);
    }
}
```

## ✅ Summary

This solution uses **DFS flood-fill** to compute the area of each island and tracks the maximum encountered.  
The traversal logic is recursive, and visited cells are marked in-place to avoid extra space.

### Architectural signals:
- DFS returns area via recursive accumulation  
- Grid is mutated directly for visited tracking (`1 → 0`)  
- `maxArea` is updated per DFS launch  
- No external visited array — space-efficient  
- Logic is modular and reusable across grid-based component problems

### Debugging insights:
- Initial mistake: missing `return` in DFS → area wasn’t accumulated  
- Fixed by returning `1 + recursive calls`  
- Also corrected method signature from `void` to `int` for proper signal propagation

This implementation is clean, efficient, and ideal for training **recursive traversal** and **dynamic signal accumulation** on grid-based data.


---

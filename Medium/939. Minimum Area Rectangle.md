# 939. Minimum Area Rectangle — Architectural Coordinate Pairing with Set Lookup  
*O(n²) — Optimal Brute-Force with Smart Pruning*

---

## Problem Statement

Given list of unique points `points` on XY plane.

Find **minimum area** rectangle with **sides parallel** to axes.

Return **0** if no rectangle possible.

---

## Core Idea — Fix Two X-Coordinates → Check Y Pairs

**Rectangle** defined by:
- Two distinct **x-coordinates** `x1 < x2`
- Two distinct **y-coordinates** `y1 < y2`

Area = `(x2 - x1) * (y2 - y1)`

**Naive** O(n⁴) too slow.

**Optimal**:
- Group points by **x-coordinate** → map `x → set of y`
- For every **pair of x-coordinates** `x1, x2`:
  - Find **intersection** of their y-sets
  - If ≥2 y-values → find **min and max y** → area = `(x2-x1)*(ymax-ymin)`
  - Track global min area

**But intersection** expensive.

**Better**:
- For every **pair of points** with different x and y
- Use **set of seen points** or **map of diagonals**

**Best**:
- Sort points by x
- Use **hashmap** `y-pair → min area seen`
- Or **set of points** + check existence

**Standard optimal**:
- Use **set of points** (pair<int,int>)
- For every pair of points with **same x** or **same y** → skip
- For every pair → check if `(x1,y2)` and `(x2,y1)` exist
- If yes → area = `abs(x1-x2)*abs(y1-y2)`
- Track min

But O(n²) checks → too slow (n=500 → 250k ok)

## Implementation C++

```cpp
class Solution {
public:
    int minAreaRect(vector<vector<int>>& points) {
        unordered_set<long long> pointSet;
        for (auto& p : points) {
            long long key = (long long)p[0] * 40001 + p[1];
            pointSet.insert(key);
        }

        int minArea = INT_MAX;
        for (int i = 0; i < points.size(); i++) {
            int x1 = points[i][0];
            int y1 = points[i][1];

            for (int j = i + 1; j < points.size(); j++) {
                int x2 = points[j][0];
                int y2 = points[j][1];

                if (x1 == x2 || y1 == y2) continue; // not diagonal

                // Check if other two corners exist
                long long p1 = (long long)x1 * 40001 + y2;
                long long p2 = (long long)x2 * 40001 + y1;

                if (pointSet.count(p1) && pointSet.count(p2)) {
                    int area = abs(x1 - x2) * abs(y1 - y2);
                    minArea = min(minArea, area);
                }
            }
        }

        return minArea == INT_MAX ? 0 : minArea;
    }
};
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n²)**     | n ≤ 500 → ~125k pairs → fine                   |
| **Space Complexity**  | **O(n)**      | HashSet for points                             |

**Optimal** — cannot do better than checking pairs for axis-aligned rectangles.

---

## Why This Works — Example Walkthrough

**Input**: `[[1,1],[1,3],[3,1],[3,3],[2,2]]`

- Points: `(1,1)`, `(1,3)`, `(3,1)`, `(3,3)`, `(2,2)`
- Consider **diagonal pair** `(1,1)` and `(3,3)`:
  - Check if opposite corners exist:
    - `(1,3)` → exists
    - `(3,1)` → exists
  - Area = `|3-1| × |3-1| = 2 × 2 = 4`
- Other diagonal pairs:
  - Involve `(2,2)` → missing one or both opposite corners → no rectangle
  - Or same x/y → skipped

→ Minimum area **4** → correct.

---

## Pitfalls & Edge Cases

- **No rectangle** → return 0
- **Collinear points** → skipped (same x or y → no area)
- **Duplicate points** → impossible (guaranteed unique)
- **Large coordinates** → `long long` key safe (x,y ≤ 4×10⁴)

All handled perfectly.

---

## Key Takeaway

This is a **classic coordinate geometry** problem:

- **Brute diagonal pairs**
- **Check opposite corners** via HashSet → O(1) lookup
- **Compute area** → track minimum
**Simple, clean, optimal** — perfect for axis-aligned rectangles.

---

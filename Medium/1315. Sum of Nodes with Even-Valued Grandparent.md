# 1315. Sum of Nodes with Even-Valued Grandparent — Architectural DFS with Grandparent Tracking  
*O(n) — Optimal Single-Pass Tree Traversal*

---

## Problem Statement

- Given a binary tree `root`.
- Return the **sum of values** of all nodes that have an **even-valued grandparent**.
- If no such nodes — return **0**.
- Grandparent = parent of parent.

---

## Core Idea — DFS with Grandparent Value Tracking

**Key insight**:
- We need to know **grandparent's value** to decide if current node contributes to sum
- During DFS, pass **parent** and **grandparent** values
- When **grandparent is even** → add current node value

**States in DFS**:
- `node` — current node
- `parentVal` — value of parent (or -1 if none)
- `grandVal` — value of grandparent (or -1 if none)

**Add to sum** when `grandVal % 2 == 0` and `grandVal != -1`

---

##  Implementation (C#)

```csharp
public class Solution {
    private int sum = 0;

    public int SumEvenGrandparent(TreeNode root) {
        Dfs(root, -1, -1);  // node, parentVal, grandparentVal
        return sum;
    }

    private void Dfs(TreeNode node, int parentVal, int grandVal) {
        if (node == null) return;

        // If grandparent exists and is even → add current node value
        if (grandVal != -1 && grandVal % 2 == 0)  sum += node.val;
        
        // Recurse: current becomes parent, parent becomes grandparent
        Dfs(node.left, node.val, parentVal);
        Dfs(node.right, node.val, parentVal);
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Visit each node exactly once                   |
| **Space Complexity**  | **O(h)**      | Recursion stack (h = tree height, worst case n) |

**Optimal** — single traversal, no extra data structures.

---

## Why This Works — Example Walkthrough

**Input**: `root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]`

Tree structure:
```
6 (even)
/     \
7       8 (even)
/ \     / 
2   7   1   3
/           / \
9           4   5
/
1
```


We add a node to the sum **only if its grandparent exists and is even**.

- **Level 1 (children of 6)**: 7 and 8 → no grandparent → not added
- **Level 2 (grandchildren of 6)**: 2, 7, 1, 3 → grandparent = 6 (even) → add **2 + 7 + 1 + 3 = 13**
- **Level 3 (great-grandchildren)**:
  - 9 (parent 2, grandparent 7 odd) → not added
  - 1 (parent 9, grandparent 2 even) → add **1**
  - 4 and 5 (parent 3, grandparent 8 even) → add **4 + 5 = 9**

**Total sum**: 13 + 1 + 9 = **18** — **correct** (matches example).

The DFS correctly tracks the grandparent value at each node and adds only when the condition is met.

---

## Pitfalls & Edge Cases

- **Root only** → no grandparent → return 0
- **Depth 2 tree** → only children checked (no grandparent) → 0
- **Even root** → all grandchildren added
- **Odd root** → grandchildren not added, only deeper levels if even grandparents exist
- **Unbalanced tree** → handled naturally by recursion

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** tree traversal:

- **DFS carrying parent and grandparent values**
- **Add current node** only when grandparent exists and is even
- **O(n)** single pass → no extra structures

**Pure, clean, optimal** — perfect sum of nodes with even-valued grandparent.

---

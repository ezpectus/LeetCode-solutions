# üß≠ Problem: Unique Paths (LeetCode 62)

A robot starts at the top-left corner of an `m x n` grid.  
It can only move **right** or **down**.  
You need to compute the number of **unique paths** to reach the bottom-right corner `(m - 1, n - 1)`.

---

## üîç Architectural Interpretation

This is a **grid traversal problem** with strict movement constraints.

- The robot must make exactly:
  - `(m - 1)` down moves
  - `(n - 1)` right moves
- Total moves: `m + n - 2`
- The order of moves defines the path

So the number of unique paths is equivalent to choosing positions for either:
- The down moves among all moves
- Or the right moves among all moves

This leads to a **binomial coefficient**:


**Binomial Formula:**
```
C(m + n - 2, m - 1) = (m + n - 2)! / [(m - 1)! √ó (n - 1)!]
```

Alternatively, we can solve it via **dynamic programming**, where each cell accumulates the number of ways to reach it.

---

## üß† Solution 1: Dynamic Programming

```csharp
public int UniquePaths(int m, int n) {
    int[,] dp = new int[m,n];

    for (int i = 0; i < m; i++) dp[i,0] = 1;
    for (int j = 0; j < n; j++) dp[0,j] = 1;

    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i,j] = dp[i-1,j] + dp[i,j-1];
        }
    }

    return dp[m-1,n-1];
}
```

## üîß Signals  

- dp[i,j] = number of ways to reach cell (i,j)  
- Only two directions: from top (i-1,j) or left (i,j-1)  
- Base case: first row and first column = 1 path each  
  
## ‚úÖ Pros:  
Intuitive, visualizable  
  
- Easy to extend to obstacles or weighted paths  
  
‚ùå Cons: 

- Space complexity: O(m * n)  
- Slower for large grids  
  
üß† Solution 2: Combinatorics (Binomial Coefficient)  
```csharp
public int UniquePaths(int m, int n) {
    long res = 1;
    for(int i = 1; i <= m - 1; i++) {
        res = res * (n - 1 + i) / i;
    }
    return (int)res;
}
```

## üîß Signals:

- Total moves = m + n - 2
- Choose m - 1 down moves (or n - 1 right moves)
- Uses multiplicative formula to avoid factorial overflow

## ‚úÖ Pros:

- Time complexity: O(min(m, n))
- Space complexity: O(1)
- Fast and elegant

## ‚ùå Cons:

- Harder to extend to obstacle grids
- Requires understanding of combinatorics

## ‚öîÔ∏è Comparison Table

| Feature                  | DP Table                     | Combinatorics                  |
|--------------------------|------------------------------|--------------------------------|
| Time Complexity          | O(m √ó n)                     | O(min(m, n))                   |
| Space Complexity         | O(m √ó n)                     | O(1)                           |
| Extendable to Obstacles | ‚úÖ Yes                        | ‚ùå No                          |
| Intuition                | ‚úÖ Visual grid traversal     | ‚ö†Ô∏è Requires math insight       |
| Overflow Risk            | Low                          | Medium (handled via long)      |
| Reusability              | ‚úÖ Good for grid problems     | ‚úÖ Good for pure path count     |

---

## üß± Engineering Insight

Both solutions are architecturally valid, but serve different purposes:

- Use **DP** when you want to:
  - Visualize paths
  - Handle obstacles or weights
  - Extend logic to more complex grid systems

- Use **Combinatorics** when you need:
  - Speed and minimal memory
  - Pure path count without grid-specific logic

üß© In practice:
- For algorithmic interviews or LeetCode brute-force: **Combinatorics is optimal**
- For system-level modeling or obstacle-based pathfinding: **DP is modular and extensible**



---

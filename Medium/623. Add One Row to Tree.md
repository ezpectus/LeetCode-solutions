# Depth-Targeted Structural Insertion in Binary Trees — Architectural Pattern  
*O(n) — Precise Layer Injection*

---

## Problem Overview

Insert a **complete new row** of nodes with value `val` at a given `depth` in a binary tree.

**Rules**:
- If `depth == 1` → new node becomes **root**, old tree becomes its **left** subtree
- Otherwise, for **every node at depth `depth-1`**:
  - Insert new **left** node → its left child = original left subtree
  - Insert new **right** node → its right child = original right subtree

The result is a **perfect new layer** injected at the target depth.

---

## Core Idea — Depth-Controlled DFS + Local Reattachment

We use **DFS** to reach exactly **depth-1** nodes, then **locally rewire** subtrees.

No queue, no level-order traversal needed — **pure recursion** with depth parameter.

**Key insight**:  
Only nodes at **depth-1** need modification — all others remain untouched.

---

## C# Implementation

```csharp
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution 
{
    public TreeNode AddOneRow(TreeNode root, int val, int depth) 
    {
        // Special case: insert at root (depth 1)
        if (depth == 1) 
        {
            return new TreeNode(val, root, null);
        }

        // Normal case: DFS to depth-1 nodes
        Dfs(root, 1, val, depth);
        return root;
    }

    private void Dfs(TreeNode node, int currDepth, int val, int targetDepth) 
    {
        if (node == null) return;

        // We are at depth-1 → insert new row
        if (currDepth == targetDepth - 1) 
        {
            TreeNode oldLeft = node.left;
            TreeNode oldRight = node.right;

            node.left  = new TreeNode(val, oldLeft, null);
            node.right = new TreeNode(val, null, oldRight);

            return;
        }

        // Continue deeper
        Dfs(node.left,  currDepth + 1, val, targetDepth);
        Dfs(node.right, currDepth + 1, val, targetDepth);
    }
}
```

## Time and Space Complexity

| **Metric**            | **Value**     | **Explanation**                                      |
|-----------------------|---------------|------------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Visit each node at most once (only up to depth-1 needed) |
| **Space Complexity**  | **O(h)**      | Recursion stack — h = tree height (worst O(n) for skewed tree) |

**Optimal** — touches only necessary nodes.

---

## Implementation Commentary

- **Depth-1 special case**:
  Immediate new root creation — **no traversal needed**.  
  Old tree attached as **left** subtree.

- **DFS to reach depth-1**:
  Recurse with current depth counter.  
  Stop and modify **exactly** at `currDepth == targetDepth - 1`.

- **Controlled subtree reattachment**:
  Save original children → insert new nodes → reattach originals.  
  Preserves **entire subtree topology** below insertion layer.

- **No extra allocations**:
  Only **2 new nodes** per depth-1 node.  
  No auxiliary queues, lists, or maps.

- **Works for all depths**:
  - Root insertion
  - Middle layers
  - Leaf level (depth = height + 1)

---

## Final Takeaway

This pattern performs **targeted structural modification** of a binary tree using:

- **Depth-controlled DFS**
- **Local subtree reattachment**
- **Minimal node creation**
- **Clean edge-case handling** (root insertion)

It generalizes to any operation requiring:

- Editing tree structure at a **specific depth**
- **Layer insertion** or **transformation**
- Preservation of **existing subtree topology**
**A must-know pattern** for tree modification problems.

----

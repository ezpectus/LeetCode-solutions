# 1396. Design Underground System — Architectural HashMap Tracking for Average Travel Time  
*O(1) per operation — Optimal Dictionary-Based Customer & Route Tracking*

---

## Problem Statement

Implement underground system:
- `checkIn(id, station, t)` — customer checks in
- `checkOut(id, station, t)` — customer checks out
- `getAverageTime(start, end)` — average time for direct trips start→end

At most 2×10⁴ calls.

---

## Core Idea — Two HashMaps

**Key insight**:
- Track **current check-in** per customer: `id → (station, time)`
- Track **trip statistics** per route: `(start,end) → (totalTime, count)`

**Operations**:
- `checkIn`: store (station, t) for id
- `checkOut`: compute time = t - checkInTime → add to route stats → remove customer
- `getAverage`: totalTime / count for route

**No need** for complex structures — direct mapping.

---

##  Implementation (C#)

```cpp
public class UndergroundSystem {
    // id → (startStation, checkInTime)
    private Dictionary<int, (string station, int time)> checkIns;
    
    // (start,end) → (totalTime, tripCount)
    private Dictionary<string, (long total, int count)> routes;

    public UndergroundSystem() {
        checkIns = new Dictionary<int, (string, int)>();
        routes = new Dictionary<string, (long, int)>();
    }
    
    public void CheckIn(int id, string stationName, int t) {
        checkIns[id] = (stationName, t);
    }
    
    public void CheckOut(int id, string stationName, int t) {
        var (startStation, startTime) = checkIns[id];
        checkIns.Remove(id);

        string route = startStation + "->" + stationName;
        int travelTime = t - startTime;

        if (!routes.ContainsKey(route))  routes[route] = (0, 0);
        
        var (total, count) = routes[route];
        routes[route] = (total + travelTime, count + 1);
    }
    
    public double GetAverageTime(string startStation, string endStation){
        string route = startStation + "->" + endStation;
        var (total, count) = routes[route];
        return (double)total / count;
    }
}
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time per operation**| **O(1)**              | HashMap get/put (average case)                 |
| **Space Complexity**  | **O(m + k)**          | m = active customers, k = unique routes        |

**Optimal** — constant time per call, minimal memory usage.

---

## Why This Works — Example Walkthrough

**Input**:
```csharp
checkIn(45,"Leyton",3)
checkIn(32,"Paradise",8)
checkIn(27,"Leyton",10)
checkOut(45,"Waterloo",15)  // travel time = 12
checkOut(27,"Waterloo",20)  // travel time = 10
checkOut(32,"Cambridge",22) // travel time = 14
getAverageTime("Paradise","Cambridge") → 14
getAverageTime("Leyton","Waterloo")    → 11
```

## After checkOuts:
- Route "Leyton->Waterloo": total time = 12 + 10 = 22, count = 2 → average = 11
- Route "Paradise->Cambridge": total time = 14, count = 1 → average = 14

- Correct — averages computed accurately from accumulated trip data.
The design cleanly separates current customer state (checkIns) from historical route statistics (routes).

## Pitfalls & Edge Cases

- Same customer checks in multiple times → overwrites previous check-in (consistent with problem guarantee)
- checkOut without prior checkIn → never happens (guaranteed)
- getAverageTime called on non-existent route → never happens (guaranteed at least one trip)
- Multiple trips on same route → correctly averaged over all trips
- Different directions → treated as separate routes (e.g., A→B vs B→A)

All handled perfectly by the constraints and design.

## Key Takeaway
This is a beautifully simple tracking system:

- checkIns → stores current customer journey (id → (station, time))
- routes → aggregates trip statistics (route key → (total time, count))
- O(1) per operation → fast and scalable



---

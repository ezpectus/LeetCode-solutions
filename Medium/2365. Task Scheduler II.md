# 2365. Task Scheduler II  
*O(n) — Greedy with Last Execution Time Tracking*

---

## Problem Statement

You are given a **0-indexed** array `tasks` of positive integers, where `tasks[i]` is the type of the `i`-th task.  
You must complete the tasks **in the given order**.

You are also given a positive integer `space` — the **minimum number of days** that must pass after completing a task before another task of the **same type** can be performed.

Each day you must either:
- Complete the **next** task in `tasks`, or
- Take a **break**

Return the **minimum number of days** needed to complete all tasks.

**Examples**:

**Example 1**  
Input: tasks = [1,2,1,2,3,1], space = 3  
Output: **9**  
One schedule:  
Day 1: task 1  
Day 2: task 2  
Day 3–4: break  
Day 5: task 1 (waited 3 days after first 1)  
Day 6: task 2  
Day 7: break  
Day 8: task 3  
Day 9: task 1

**Example 2**  
Input: tasks = [5,8,8,5], space = 2  
Output: **6**  
Day 1: 5  
Day 2: 8  
Day 3–4: break  
Day 5: 8 (waited 2 days)  
Day 6: 5 (waited 4 days > 2)

**Constraints**:
- 1 ≤ tasks.length ≤ 10⁵
- 1 ≤ tasks[i] ≤ 10⁹
- 1 ≤ space ≤ tasks.length

---

## Core Idea — Greedy + Track Last Execution Time per Task Type

**Key insight**:
- Tasks must be done **in order** — we cannot reorder them
- For each task of type `t`, it can only be done if at least `space` days have passed since the **last time** a task of type `t` was done
- We simulate day by day:
  - On each day, try to do the next task if possible
  - If not (too soon after last same type), take a break
- Track the **last day** each task type was executed
- Current day must be ≥ last[type] + space + 1

**Algorithm** (simulation with map):
1. Use a **dictionary** `lastExec` → task type → last day it was executed
2. Initialize current day = 0
3. For each task in order:
   - If this task type was never done or current day ≥ lastExec[type] + space + 1:
     - Do it on current day
     - Update lastExec[type] = current day
     - Move to next task
   - Else:
     - Take break → current day = lastExec[type] + space + 1
     - Do the task on this new day
     - Update lastExec[type]
4. Final answer = current day + 1 (days are 1-indexed in count)

**Time**: O(n) — single pass  
**Space**: O(distinct types) ≤ O(n)

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public long TaskSchedulerII(int[] tasks, int space){
        var lastExec = new Dictionary<int, long>();
        long day = 0;

        foreach (int task in tasks){
            // If this task was done before, wait at least space days after last execution
            if (lastExec.TryGetValue(task, out long lastDay)){
                // Earliest possible day to do this task again
                long earliest = lastDay + space + 1;
                if (day < earliest) day = earliest;
            }

            // Do the task on current day
            lastExec[task] = day;
            day++; // move to next day
        }

        return day;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single linear pass through all tasks — each task is processed exactly once |
| **Space Complexity**  | **O(n)**      | Dictionary to store last execution day per task type (worst case: all tasks distinct) |

**Optimal** — linear time and linear space — perfect and highly efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: tasks = [1,2,1,2,3,1], space = 3

Simulation (day starts at 0):

- Day 0: task 1 → last[1] = 0, day = 1
- Day 1: task 2 → last[2] = 1, day = 2
- Day 2: task 1 → last[1] = 0, earliest = 0 + 3 + 1 = 4 > 2 → jump day = 4  
  Execute task 1, last[1] = 4, day = 5
- Day 5: task 2 → last[2] = 1, earliest = 1 + 3 + 1 = 5 == 5 → execute, last[2] = 5, day = 6
- Day 6: task 3 → no previous, execute, last[3] = 6, day = 7
- Day 7: task 1 → last[1] = 4, earliest = 4 + 3 + 1 = 8 > 7 → jump day = 8  
  Execute task 1, last[1] = 8, day = 9

Final day = 9 (days 0 through 8) → **9** → correct

**Correct** —  
We simulate the process **day by day**, always trying to execute the next task as early as possible while respecting the cooldown rule:  
For each task of type t:
- Compute earliest possible execution day = last[t] + space + 1 (if previously executed)
- If current day is too early → jump forward to earliest day
- Execute the task on that day → update last[t]
- Advance current day by 1

The final current day is the **minimum number of days** needed (including the last execution day).

---

## Key Takeaway

This is a **classic greedy cooldown scheduling** problem:

* Process tasks **in the given fixed order**
* Maintain a map: task type → **last execution day**
* For each task:
  - Compute **earliest possible day** = last[task] + space + 1 (if previously executed)
  - If current day < earliest → **jump** current day to earliest
  - Execute task on current day → update last[task]
  - Increment current day by 1
* Final answer = current day (number of days used, including the last task day)

**Pure, clean, optimal** — O(n) time, O(n) space (worst case all distinct types), extremely fast, very intuitive, and correctly computes the **minimum days** needed while respecting the cooldown constraint.

---

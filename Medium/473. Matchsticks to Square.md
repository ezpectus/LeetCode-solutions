# Problem Guide: 473. Matchsticks to Square

## Problem Statement

You are given an integer array matchsticks, where each element represents the length of a matchstick.
Your goal is to use all matchsticks exactly once to form a square. You may not break any matchstick, but you can combine them end-to-end.
Return true if it is possible to form a square, otherwise return false.

## Input Constraints
- 1 <= matchsticks.length <= 15
- 1 <= matchsticks[i] <= 10^8

##  Strategy & Key Ideas
What We're Given: 
- A list of matchsticks with varying lengths
- We must partition them into 4 groups, each summing to the same value
- No stick can be reused or broken

## Why This Is Hard
- Brute-force checking all partitions is exponential
- We need to track which sticks are used
- We need to avoid recomputation of the same state

## Architectural Approach: Bitmask + Memoization
Core Signals: 
- Bitmask encodes which matchsticks have been used
- Memoization caches previously computed states to avoid redundant work
- Backtracking explores all valid assignments of sticks to sides

## Bitmask Explanation

- We use a 15-bit integer used to represent stick usage
- Bit i is 1 if stick i has been used
- This allows us to track usage in constant space and time

## Memoization Key

- The memo dictionary uses (used, curr) as the key
- used: bitmask of used sticks
- curr: current length of the side being built

## Annotated C# Code
```csharp
public class Solution {
    public bool Makesquare(int[] matchsticks) {
        int n = matchsticks.Length;
        int total = matchsticks.Sum();
        if (total % 4 != 0) return false;

        int target = total / 4;
        Array.Sort(matchsticks, (a, b) => b.CompareTo(a)); // optimization: try longer sticks first

        var memo = new Dictionary<(int, int), bool>();
        return DFS(matchsticks, 0, 0, 0, target, memo);
    }

    private bool DFS(int[] sticks, int used, int curr, int done, int target, Dictionary<(int, int), bool> memo) {
        if (done == 3) return true; // fourth side is implied

        if (memo.ContainsKey((used, curr))) return memo[(used, curr)];

        for (int i = 0; i < sticks.Length; i++) {
            if ((used & (1 << i)) != 0) continue; // stick already used

            int next = curr + sticks[i];
            if (next > target) continue; // overflow

            int nextUsed = used | (1 << i);
            int nextCurr = (next == target) ? 0 : next;
            int nextDone = (next == target) ? done + 1 : done;

            if (DFS(sticks, nextUsed, nextCurr, nextDone, target, memo)) {
                memo[(used, curr)] = true;
                return true;
            }
        }

        memo[(used, curr)] = false;
        return false;
    }
}
```

## Example Walkthrough

Input
````csharp
matchsticks = [1, 1, 2, 2, 2]
Total Sum
sum = 8 → divisible by 4 → target = 2

Valid Partition:
Side 1: [1, 1]
Side 2: [2]
Side 3: [2]
Side 4: [2] → returns true
````

Complexity Analysis

## Time Complexity
- 𝑂(2𝑛⋅𝑛) — exponential in number of sticks
- Memoization reduces redundant calls

## Space Complexity
- 𝑂(2𝑛) — memo dictionary
- 𝑂(𝑛) — recursion stack

## Architectural Takeaway

- Bitmask encodes state compactly
- Memoization avoids recomputation
- Sorting improves pruning
- Backtracking explores valid combinations

This solution transforms a brute-force partitioning problem into a state-driven search using bit-level optimization and memoized recursion. 
It’s not just a solution — it’s a resource allocator with architectural rigor.



---

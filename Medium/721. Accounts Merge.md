## 🧠 Problem: Accounts Merge  
**LeetCode #721**  
**Difficulty:** Medium  
**Tags:** Graph, DFS, HashMap, Connected Components

---

### 🔍 Problem Summary  
You’re given a list of accounts, where each account is a list of strings:

- The first element is the user’s **name**  
- The remaining elements are **email addresses** associated with that account

Two accounts belong to the same person **if they share at least one email**, regardless of name.  
Your task is to **merge all connected accounts** and return the result in the format:

- First element: name  
- Remaining elements: sorted list of unique emails

---

### 🧱 Architectural Insight  
This is a classic **connected components** problem in disguise.  
Each email is treated as a **node**, and shared emails between accounts form **edges**.  
The goal is to find all **connected groups of emails**, and associate each group with the correct name.

---

### 🔧 Core Strategy

- Build a **graph** where each email is a node, and edges connect emails from the same account  
- Use a dictionary `accountDict` to store adjacency lists  
- Use **DFS** to traverse each connected component (i.e., group of emails)  
- Track visited emails using a `HashSet<string> visited`  
- For each unvisited email, run DFS to collect all connected emails  
- Sort the collected emails and prepend the associated name  
- Add the result to the final list

This approach guarantees that all accounts with shared emails are merged correctly.

## 💡 C# Solution
```csharp
public class Solution {
    List<IList<string>> result = new();
    Dictionary<string, List<string>> accountDict = new();
    HashSet<string> visited = new();

    public IList<IList<string>> AccountsMerge(IList<IList<string>> accounts) {
        // Build the graph
        foreach (var account in accounts) {
            string firstEmail = account[1];
            accountDict.TryAdd(firstEmail, new List<string>());

            for (int j = 2; j < account.Count; j++) {
                accountDict[firstEmail].Add(account[j]);
                accountDict.TryAdd(account[j], new List<string>());
                accountDict[account[j]].Add(firstEmail);
            }
        }

        // Traverse each connected component
        foreach (var account in accounts) {
            string person = account[0];
            string firstEmail = account[1];

            if (!visited.Contains(firstEmail)) {
                List<string> list = new();
                DFS(list, firstEmail);

                list.Sort(StringComparer.Ordinal);
                list.Insert(0, person);
                result.Add(list);
            }
        }

        return result;
    }

    public void DFS(List<string> list, string email) {
        if (visited.Contains(email)) return;

        list.Add(email);
        visited.Add(email);

        if (!accountDict.ContainsKey(email)) return;

        foreach (var item in accountDict[email]) {
            DFS(list, item);
        }
    }
}
```


### 📐 Why This Works

- Each email is treated as a **node** in a graph  
- Shared emails create **edges**, forming connected components  
- **DFS** ensures that all emails in a group are collected together  
- **Sorting** ensures consistent output format  
- The **name** is taken from the original account that introduced the email — guaranteed by input structure

---

### 🧭 Reflection

This problem deepened my understanding of **graph traversal** and **connected component detection**.  
Instead of modeling accounts directly, I abstracted the problem into a **graph of emails** — a powerful shift in perspective.

#### 🔑 Key Insights:
- Building the graph with **adjacency lists** allows flexible traversal  
- DFS is ideal for collecting all reachable nodes (emails) from a starting point  
- Using a `HashSet` for visited nodes prevents **cycles** and redundant work  
- Sorting the emails post-traversal ensures **clean, readable output**

I implemented the solution in **C#**, focusing on clarity and modularity:
- Used `Dictionary<string, List<string>>` for the graph  
- DFS was written **recursively** for simplicity  
- Variable naming (`accountDict`, `visited`, `list`) reflects the graph logic clearly

This task also reinforced the value of **graph abstraction** — seeing beyond the surface structure to the underlying connectivity.


---

# ðŸ§  2654. Minimum Number of Operations to Make All Array Elements Equal to 1

## ðŸ“œ Problem Statement
You are given a 0-indexed array `nums` consisting of positive integers.  
You can perform the following operation any number of times:

- Select an index `i` such that `0 <= i < n - 1` and replace either `nums[i]` or `nums[i+1]` with their gcd value.

Return the **minimum number of operations** to make all elements of `nums` equal to `1`.  
If it is impossible, return `-1`.

---

## ðŸ§± Core Idea
1. **Check global gcd**  
   - If `gcd(nums) > 1`, impossible â†’ return `-1`.

2. **If there is already a `1`**  
   - Each nonâ€‘1 can be turned into `1` in one step.  
   - Answer = `n - count(1)`.

3. **Otherwise, find shortest subarray with gcd = 1**  
   - Let its length be `minLen`.  
   - It takes `minLen - 1` operations to create the first `1`.  
   - Then `n - 1` more operations to spread `1` across the array.  
   - Answer = `(minLen - 1) + (n - 1)`.

---

## ðŸš€ Implementation (C#)

```csharp
public class Solution {
    public int MinOperations(int[] nums) {
        int n = nums.Length;

        // Step 1: Check overall gcd
        int overallGCD = nums[0];
        for (int i = 1; i < n; i++)
            overallGCD = GCD(overallGCD, nums[i]);
        if (overallGCD > 1) return -1;

        // Step 2: If there are ones already
        int ones = CountOnes(nums);
        if (ones > 0) return n - ones;

        // Step 3: Find shortest subarray with gcd = 1
        int minL = int.MaxValue;
        for (int i = 0; i < n; i++) {
            int g = nums[i];
            for (int j = i; j < n; j++) {
                g = GCD(g, nums[j]);
                if (g == 1) {
                    minL = Math.Min(minL, j - i + 1);
                    break; // stop expanding once gcd = 1
                }
            }
        }

        // Step 4: Formula
        return (minL - 1) + (n - 1);
    }

    private int GCD(int a, int b) {
        return b == 0 ? a : GCD(b, a % b);
    }

    private int CountOnes(int[] nums) {
        int ones = 0;
        foreach (int x in nums) if (x == 1) ones++;
        return ones;
    }
}
```

## â±ï¸ Complexity Analysis
- **Time:** O(nÂ² log(max(nums[i]))) â€” check all subarrays with gcd updates  
- **Space:** O(1) â€” constant extra memory  
- **Best suited for:** n â‰¤ 50 (as per constraints)  

---

## âš ï¸ Pitfalls
- Must check **global gcd first** â†’ otherwise wasted work  
- If ones exist, formula simplifies to `n - count(1)`  
- Subarray search: break only when `gcd = 1`, not earlier  
- Final formula is `(minLen - 1) + (n - 1)`, not just `minLen`  

---

## âœ… Conclusion
This solution:
- Efficiently checks feasibility with global gcd  
- Handles the shortcut case when `1` already exists  
- Finds the shortest subarray with gcd = 1 to minimize operations  
- Runs in O(nÂ²), which is optimal for small arrays (n â‰¤ 50)  

---

ðŸ‘‰ **Key takeaway:**  
The algorithm balances **mathematical insight (gcd properties)** with **clean implementation**, producing a minimal and elegant solution for the problem.


---

# 1239. Maximum Length of a Concatenated String with Unique Characters — Architectural Bitmask Subset Merging  
*O(3^n) — Optimal Iterative Mask Combination*

---

## Problem Statement

- Given an array `arr` of strings (n ≤ 16, each string length ≤ 26, consisting of lowercase English letters).
- You must form a string `s` by **concatenating a subsequence** of `arr` (preserving the original order of the strings).
- The resulting `s` must contain **all unique characters** — no duplicates across the entire concatenated string.
- Return the **maximum possible length** of such an `s`.

---

## Core Idea - Iterative Bitmask Merging (No DP Table)

**Key observation**:
- With n ≤ 16, exponential time in n is perfectly acceptable.
- Each string can be represented as a **bitmask** (32-bit integer), where each bit corresponds to one letter from 'a' to 'z' (26 bits total).
- A string is valid on its own if it has **no duplicate characters** — its bitmask has exactly `string.Length` bits set.
- Two strings can be safely concatenated only if their bitmasks have **no overlapping bits** (bitwise AND == 0).

**Why bitmasks are perfect for this**:
- Checking for overlap is an **O(1)** bitwise AND operation.
- The length of the resulting string is exactly the **number of set bits** in the combined mask.
- The mask fully describes the **set of used characters**, regardless of string order or internal character order.

**Algorithm step by step**:
1. Start with a list containing a single mask `{0}` — representing the empty combination.
2. For each string in `arr`:
   - Compute its bitmask.
   - If the string contains duplicate characters → mask becomes invalid (0) → skip it.
   - If the mask is valid → try to **merge it with every existing mask** in the list:
     - If the current mask and the new string mask have no common bits → create and add a new combined mask (`prev | new`).
3. After processing all strings — the list contains **all achievable sets** of unique characters from valid subsequences.
4. The answer is the **maximum number of set bits** across all masks in the list.

**Why this covers all possible subsequences**:
- We process strings in their original order.
- At each step, we either skip the current string or append it to **every previously valid combination** (if characters don't overlap).
- This naturally respects subsequence order and uniqueness constraints.


---

## Implementation (C#)

```csharp
public class Solution {
    public int MaxLength(IList<string> arr) {
        var masks = new List<int> { 0 }; // start with empty

        foreach (var s in arr) {
            int mask = 0;
            foreach (char c in s) {
                int bit = 1 << (c - 'a');
                if ((mask & bit) != 0) {
                    mask = 0; // invalid
                    break;
                }
                mask |= bit;
            }
            if (mask == 0) continue;

            int size = masks.Count;
            for (int i = 0; i < size; i++) {
                int prev = masks[i];
                if ((prev & mask) == 0)   masks.Add(prev | mask);
                
            }
        }

        int res = 0;
        foreach (int mask in masks)  res = Math.Max(res, BitCount(mask));
        
        return res;
    }

    private int BitCount(int x) {
        int cnt = 0;
        while (x > 0) {
            cnt++;
            x &= x - 1;
        }
        return cnt;
    }
}
```


## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(3^n)**    | Each string: skip, use alone, or merge with existing |
| **Space Complexity**  | **O(3^n)**    | List of valid masks                            |

**Optimal** — n≤16 → practical fast (~43M worst case, but much less in practice).

---

## Why This Works — Example Walkthrough

**Input**: `arr = ["un","iq","ue"]`

- Start: `masks = [0]` (empty combination)
- **"un"** → mask = u|n → valid → add:
  - 0 | u|n → new mask **u|n**
- **"iq"** → mask = i|q → valid → add to existing:
  - 0 | i|q → **i|q**
  - u|n | i|q → **u|n|i|q** ("uniq")
- **"ue"** → mask = u|e → valid → add:
  - 0 | u|e → **u|e**
  - u|n | u|e → **conflict** (u overlap) → skip
  - i|q | u|e → **i|q|u|e** ("ique")
  - u|n|i|q | u|e → conflict → skip

- Final masks: 0, u|n, i|q, **u|n|i|q** (4), **i|q|u|e** (4), u|e
- Max bit count = **4**

**Correct** — "uniq" or "ique".

---

## Pitfalls & Edge Cases

- **Duplicate chars in one string** → mask=0 → skipped
- **Character overlap with existing mask** → not added
- **Empty string** → ignored (mask=0)
- **Single string with 26 unique chars** → length 26
- **No valid combination** → returns 0

All handled perfectly.

---

## Key Takeaway

This is a **beautifully iterative** bitmask merging:

- **Start with empty mask** → build all valid combinations incrementally
- **No overlap check** → merge only if disjoint characters
- **Dynamic list** → stores every achievable unique-char set
**Pure, clean, optimal** — perfect unique character concatenation.


---

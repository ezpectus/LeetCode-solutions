# 3607. Power Grid Maintenance — Offline DSU + Component Tracking

---

## Problem Summary

You are given:
* `c` power stations (`1..c`)
* `connections`: undirected edges forming **power grids**
* `queries`: two types:
  1. `[1, x]` — **maintenance check**:  
     If `x` is **online** → return `x`  
     Else → return **smallest online station** in same grid, or `-1`
  2. `[2, x]` — **take station `x` offline**

**Goal**: process queries in order and return results of all type-1 queries.

---

## Key Observations

| Insight | Why It Matters |
|-------|----------------|
| **Connectivity is static** | Use **DSU** to group stations into grids |
| **Offline stations stay in grid** | DSU structure **never changes** |
| Need **min online ID per component** | Maintain **set of online stations per root** |
| Queries are **offline** | Can process in given order |

---

## Solution Strategy

1. **Build DSU** from `connections`
2. For each component, maintain a **`set<int>` of online stations**
3. For each query:
   * Type 1:  
     - If `x` is online → return `x`  
     - Else → return `*comp[root].begin()` or `-1`
   * Type 2:  
     - Remove `x` from its component's set

---

## Implementation (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

class DSU {
public:
    vector<int> parent, rnk;
    DSU(int n) : parent(n+1), rnk(n+1, 0) {
        iota(parent.begin(), parent.end(), 0);
    }

    int find(int x) {
        return parent[x] == x ? x : parent[x] = find(parent[x]);
    }

    void merge(int a, int b) {
        int ra = find(a), rb = find(b);
        if (ra == rb) return;
        if (rnk[ra] < rnk[rb]) swap(ra, rb);
        parent[rb] = ra;
        if (rnk[ra] == rnk[rb]) rnk[ra]++;
    }
};

class Solution {
public:
    vector<int> processQueries(int c,
                               vector<vector<int>>& connections,
                               vector<vector<int>>& queries) 

    {
        DSU dsu(c);
        for (auto& e : connections)
            dsu.merge(e[0], e[1]);

        vector<set<int>> comp(c+1);
        for (int i = 1; i <= c; ++i)
            comp[dsu.find(i)].insert(i);

        vector<bool> online(c+1, true);
        vector<int> ans;

        for (auto& q : queries) {
            int type = q[0], x = q[1];
            int root = dsu.find(x);

            if (type == 1) {
                if (online[x]) {
                    ans.push_back(x);
                } else if (!comp[root].empty()) {
                    ans.push_back(*comp[root].begin());
                } else {
                    ans.push_back(-1);
                }
            } else {
                if (online[x]) {
                    online[x] = false;
                    comp[root].erase(x);
                }
            }
        }

        return ans;
    }
};
```

## Implementation (C#)

```csharp
using System;
using System.Collections.Generic;

public class DSU {
    int[] parent, rank;
    public DSU(int n) {
        parent = new int[n+1];
        rank = new int[n+1];
        for (int i = 0; i <= n; i++) parent[i] = i;
    }

    public int Find(int x) {
        if (parent[x] != x) parent[x] = Find(parent[x]);
        return parent[x];
    }

    public void Merge(int a, int b) {
        int ra = Find(a), rb = Find(b);
        if (ra == rb) return;
        if (rank[ra] < rank[rb]) (ra, rb) = (rb, ra);
        parent[rb] = ra;
        if (rank[ra] == rank[rb]) rank[ra]++;
    }
}

public class Solution {
    public int[] ProcessQueries(int c, int[][] connections, int[][] queries) {
        var dsu = new DSU(c);
        foreach (var e in connections)
            dsu.Merge(e[0], e[1]);

        var comp = new HashSet<int>[c+1];
        for (int i = 0; i <= c; i++) comp[i] = new HashSet<int>();
        for (int i = 1; i <= c; i++)
            comp[dsu.Find(i)].Add(i);

        var online = new bool[c+1];
        Array.Fill(online, true);
        var ans = new List<int>();

        foreach (var q in queries) {
            int type = q[0], x = q[1];
            int root = dsu.Find(x);

            if (type == 1) {
                if (online[x]) {
                    ans.Add(x);
                } else if (comp[root].Count > 0) {
                    int min = int.MaxValue;
                    foreach (int v in comp[root]) min = Math.Min(min, v);
                    ans.Add(min);
                } else {
                    ans.Add(-1);
                }
            } else {
                if (online[x]) {
                    online[x] = false;
                    comp[root].Remove(x);
                }
            }
        }

        return ans.ToArray();
    }
}
```

## Complexity Analysis

| Metric                          | Value                          |
|---------------------------------|--------------------------------|
| **Time**                        | O((c + q) log c)               |
| **Space**                       | O(c)                           |
| **DSU with path compression + union by rank** | Yes |
| **Per-component min tracking**  | `set` or `HashSet + scan`      |

> **Note**: C# uses `HashSet` → finding min is **O(k)**, but `k ≤ c`, worst-case **O(c)**.  
> For **strict O(log c)**, use `SortedSet<int>`.

---

## Pitfalls

* **Offline nodes stay in DSU** — do **not** break unions  
* Must **track online status separately**  
* Use **root of component** to index `comp[]`  
* `set` in C++ → **O(log c)** per operation  
* C# `HashSet` → **O(k)** min find → use `SortedSet` for **O(log c)**

---

## Conclusion

**Power Grid Maintenance** is solved using:

* **Static DSU** for connectivity  
* **Per-component set of online nodes**  
* **Offline query processing**

> **Key takeaway**:  
> When connectivity is **static** and you need **dynamic min in components**, combine **DSU + set per root** — a classic **offline component tracking** pattern.


---


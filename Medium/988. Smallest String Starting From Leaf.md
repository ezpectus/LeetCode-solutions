# 988. Smallest String Starting From Leaf — Architectural Leaf-to-Root DFS with String Building  
*O(n) — Optimal Post-Order Traversal*

---

## Problem Statement

Given binary tree where each node value in `[0,25]` → `'a'` to `'z'`.

Find **lexicographically smallest** string formed by path from **any leaf** to **root**.

- Path read **leaf → root** (bottom-up)
- Shorter prefix beats longer

Return that string.

---

## Core Idea — Post-Order DFS Building String from Leaf Up

**Key insight**:
- We need **all leaf-to-root** paths
- Compare them **lexicographically**
- Since comparison prefix-based → build strings **from leaf** → compare directly

**Solution**:
- **Post-order DFS**:
  - Recurse to leaves first
  - At each node: build string = `char(node.val + 'a') + left/right string`
- Track **global minimum** string

**At leaf** → string = single char

**Compare** full paths → keep smallest.

**No need** for parent pointer — build upward.

---

##  Implementation (C++)

```cpp
class Solution {
public:
    string smallestFromLeaf(TreeNode* root) {
        string result = "";
        dfs(root, "", result);
        return result;
    }

private:
    void dfs(TreeNode* node, string path, string& result) {
        if (!node) return;
        // Prepend current char (build from leaf up)
        path = char('a' + node->val) + path;

        // Leaf → candidate path
        if (!node->left && !node->right) {
            if (result.empty() || path < result)  result = path;
            
            return;
        }

        // Recurse children
        dfs(node->left, path, result);
        dfs(node->right, path, result);
    }
};
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Visit each node once                           |
| **Space Complexity**  | **O(h)**      | Recursion stack (h = height) + path strings    |

**Optimal** — linear time.

---

## Why This Works — Example Walkthrough

**Input**: `root = [0,1,2,3,4,3,4]` → tree:
```
0
/ 
1   2
/ \ / 
3  4 3  4
```

- **Leaves**: 3,4,3,4
- **Paths** (leaf → root):
  - `"dba"` (3←1←0)
  - `"eba"` (4←1←0)
  - `"dca"` (3←2←0)
  - `"eca"` (4←2←0)
- Smallest lexicographically: **"dba"**

**Correct**.

**Input**: `[25,1,3,1,3,0,2]`

- Paths (leaf → root):
  - `"adz"` (2←3←25)
  - `"abx"` (24? wait — values 0-25 → 'a' to 'z')
  - Other paths
- `"adz"` is the smallest

**Correct**.

---

## Pitfalls & Edge Cases

- **Single node** → return string of one character
- **Multiple identical paths** → any is fine
- **Deep tree** → recursion safe (n ≤ 8500)
- **Lexicographic order** → string comparison handles correctly (shorter prefix wins)

All handled perfectly.

---

## Key Takeaway

This is a **beautifully clean** tree path problem:

- **Post-order** → natural leaf-first traversal
- **Build path bottom-up** → prepend current character
- **Track global minimum** → simple string comparison

**No parent pointers. No level order.**
**Pure, elegant, optimal** — classic leaf-to-root path finding.

---

# Pattern Name
**Reachability via DFS with Cycle Detection**


## Problem Summary
- **Input**:  
  - Array `arr[]` of non-negative integers.  
  - Starting index `start`.
- **Goal**:  
  Determine if it's possible to **reach any index with value 0** by jumping to `i + arr[i]` or `i - arr[i]`.
- **Constraints**:
  - `1 ≤ arr.length ≤ 5 × 10⁴`
  - `0 ≤ arr[i] < arr.length`
  - `0 ≤ start < arr.length`

## Core Idea
- Treat the array as a **graph**, where each index can jump to **two neighbors**.
- Use **DFS** to explore **reachable indices**.
- Track **visited indices** to **avoid cycles** and **infinite recursion**.

## Solution
- Start **DFS** from `start` index.
- At each step:
  - If **out of bounds** → return `false`
  - If **value is 0** → return `true`
  - If **already visited** → return `false`
  - **Recurse** to `i + arr[i]` and `i - arr[i]`

## Strategy Summary
- Use `HashSet<int>` to track **visited indices**.
- **DFS** returns `true` if **any path reaches a 0**.
- **Short-circuits** on success.

## C# Implementation
```csharp
public class Solution {
    public bool CanReach(int[] arr, int start) {
        var seen = new HashSet<int>();
        return DFS(arr, start, seen);
    }

    private bool DFS(int[] arr, int idx, HashSet<int> seen) {
        if (idx < 0 || idx >= arr.Length) return false;
        if (arr[idx] == 0) return true;
        if (seen.Contains(idx)) return false;

        seen.Add(idx);
        return DFS(arr, idx - arr[idx], seen) || DFS(arr, idx + arr[idx], seen);
    }
}
```

## Architectural Breakdown
| Component       | Role                                      |
|-----------------|-------------------------------------------|
| `DFS`           | Explores reachable indices recursively    |
| `seen`          | Prevents cycles and redundant visits      |
| **Base cases**  | Handle out-of-bounds, visited, and success |
| **Recursion**   | Explores both jump directions             |

## Why This Approach Is Superior
| Aspect              | **DFS + HashSet**     | BFS / Brute Force      |
|---------------------|------------------------|------------------------|
| Time Complexity     | **O(n)**               | O(n)                   |
| Space Complexity    | **O(n)** — visited set | O(n) — queue or stack  |
| Performance         | Efficient for sparse graphs | May over-explore       |
| Clarity             | **Simple recursion**   | Requires queue management |

## Final Takeaway
- **This pattern generalizes to**:
  - Graph traversal with **jump rules**
  - **Cycle detection** in implicit graphs
  - **Reachability problems** with constraints
 
---

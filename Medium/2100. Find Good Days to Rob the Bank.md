# 2100. Find Good Days to Rob the Bank  
*O(n) — Elegant Two-Pass Prefix/Suffix Checks*

---

## Problem Statement

You are given a **0-indexed** integer array `security` where `security[i]` is the number of guards on duty on day `i`.  
You are also given an integer `time`.

A day `i` is a **good day to rob the bank** if **all** of these are true:
- There are **at least** `time` days **before** `i` and **at least** `time` days **after** `i`  
  (i.e., `time ≤ i ≤ n-1-time`)
- The number of guards is **non-increasing** in the `time` days before `i`:  
  `security[i-time] ≥ security[i-time+1] ≥ ... ≥ security[i]`
- The number of guards is **non-decreasing** in the `time` days after `i`:  
  `security[i] ≤ security[i+1] ≤ ... ≤ security[i+time]`

Return a list of **all** good days (0-indexed) to rob the bank. The order does not matter.

**Examples**:

**Example 1**: security = [5,3,3,3,5,6,2], time = 2  
Output: [2,3]  
- Day 2: left = [5,3,3] (non-increasing), right = [3,5,6] (non-decreasing)  
- Day 3: left = [3,3,3] (non-increasing), right = [3,5,6] (non-decreasing)

**Example 2**: security = [1,1,1,1,1], time = 0  
Output: [0,1,2,3,4]  
(time = 0 means no guards check → every day is good)

**Constraints**:
- 1 ≤ security.length ≤ 10⁵
- 0 ≤ security[i], time ≤ 10⁵

---

## Core Idea — Two-Pass Prefix/Suffix Validity

**Naive** way: for each day i, check left time days decreasing + right time days increasing → O(n × time) → TLE

**Optimal** way:
- Precompute for each day whether the **left** time days are non-increasing
- Precompute for each day whether the **right** time days are non-decreasing
- A day i is good only if:
  - i ≥ time and i ≤ n-1-time
  - left[i] is valid (non-increasing up to i)
  - right[i] is valid (non-decreasing from i)

**How to precompute efficiently**:
- Use two arrays:
  - `leftValid[i]` = true if security[i-time] ≥ ... ≥ security[i]
  - `rightValid[i]` = true if security[i] ≤ ... ≤ security[i+time]
- Compute `leftValid` with a single backward pass
- Compute `rightValid` with a single forward pass

**Time**: O(n) — two linear passes  
**Space**: O(n) — validity arrays (can be optimized to O(1) counters if only collecting indices)

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public IList<int> GoodDaysToRobBank(int[] security, int time) {
        int n = security.Length;
        List<int> result = new List<int>();

        if (time == 0) {
            for (int i = 0; i < n; i++) result.Add(i);
            return result;
        }

        if (n <= 2 * time) return result; // impossible

        bool[] leftValid = new bool[n];
        bool[] rightValid = new bool[n];

        // 1. Check left side: non-increasing towards i
        int decreasingCount = 0;
        for (int i = 1; i < n; i++) {
            if (security[i - 1] >= security[i])  {
                decreasingCount++;
            } 
            else {
                decreasingCount = 0;
            }

            if (decreasingCount >= time) {
                leftValid[i] = true;
            }
        }

        // 2. Check right side: non-decreasing from i
        int increasingCount = 0;
        for (int i = n - 2; i >= 0; i--) {
            if (security[i] <= security[i + 1]) increasingCount++;
            else increasingCount = 0;
            
            if (increasingCount >= time) rightValid[i] = true; 
        }

        // 3. Good days: both sides valid + enough range
        for (int i = time; i < n - time; i++) {
            if (leftValid[i] && rightValid[i]) result.Add(i);
        }

        return result;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Two linear passes: one for left non-increasing validity, one for right non-decreasing validity  
One final pass to collect all good days → total **O(n)** |
| **Space Complexity**  | **O(n)**      | Two boolean arrays of size n for left and right validity  
Can be optimized to **O(1)** extra space by directly collecting good days without storing validity arrays |

**Optimal** — linear time and linear space (or constant extra space with optimization) — perfect and very efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: security = [5,3,3,3,5,6,2], time = 2

- n = 7, time = 2 → possible days: indices 2, 3, 4 (only these have ≥2 days before and after)

**Left validity** (non-increasing in the window ending at i):
- Window size = time + 1 = 3
- i=2: check days 0,1,2 → 5 ≥ 3 ≥ 3 → **yes**
- i=3: check days 1,2,3 → 3 ≥ 3 ≥ 3 → **yes**
- i=4: check days 2,3,4 → 3 ≥ 3 ≤ 5 → **no**
- i=5: no
- i=6: no

**Right validity** (non-decreasing in the window starting at i):
- i=2: check days 2,3,4 → 3 ≤ 3 ≤ 5 → **yes**
- i=3: check days 3,4,5 → 3 ≤ 5 ≤ 6 → **yes**
- i=4: check days 4,5,6 → 5 ≤ 6 ≥ 2 → **no**

**Good days**: only days where **both** left and right are valid → i=2 and i=3  
Result: **[2,3]** → correct

**Correct** —  
We precompute for each possible center day i whether:
- The **left window** (i-time to i) is non-increasing
- The **right window** (i to i+time) is non-decreasing

A day i is good only if:
- It has enough days on both sides (time ≤ i ≤ n-1-time)
- Both windows satisfy the monotonicity condition

Using running counters makes both validity checks O(n) total.

---

## Key Takeaway

This is a **classic sliding window validity** problem with symmetric range constraints:

* Precompute **left validity**: for each i, check if the previous time+1 days are **non-increasing** (using a decreasing counter)
* Precompute **right validity**: for each i, check if the next time+1 days are **non-decreasing** (using an increasing counter)
* Both precomputations are done in **O(n)** using running streak counters
* A day i is good if:
  - It is at least time away from both array ends (`time ≤ i ≤ n-1-time`)
  - `leftValid[i]` is true
  - `rightValid[i]` is true
* Collect all such i → return the list

**Pure, clean, optimal** — O(n) time, O(n) space (easily optimizable to O(1) extra space by collecting good days on-the-fly), simple, elegant, and highly efficient.

---

# 3531. Count Covered Buildings — Clean Architectural Min/Max Solution  
*O(n) — Pure Coordinate Geometry*

---

## Problem Summary

We are given a list of building coordinates on an `n×n` grid.

A building at position `(x, y)` is considered **covered** if and only if **all four cardinal directions** contain at least one other building:

- **Above**: there exists a building `(x', y)` with `x' < x` (same column, smaller row)
- **Below**: there exists a building `(x', y)` with `x' > x`
- **Left**: there exists a building `(x, y')` with `y' < y` (same row, smaller column)
- **Right**: there exists a building `(x, y')` with `y' > y`

In other words: the building must **not** lie on the boundary of its own row **and** column — it must be **strictly inside** both.

Return the total number of such **covered** buildings.

---

## Core Idea — Row & Column Bounds

Instead of checking neighbors for each building (which would be slow), we use a **global geometric property**:

A building `(x, y)` is covered **if and only if**:

- In **row `x`**: there are buildings **to the left** and **to the right** of `y`  
  → `minY[x] < y` **and** `maxY[x] > y`

- In **column `y`**: there are buildings **above** and **below** of `x`  
  → `minX[y] < x` **and** `maxX[y] > x`

**We don’t need to search** — we just precompute the **minimum and maximum** positions in each row and column.

This turns a potentially complex neighbor-search problem into a **simple boundary check**.


---

## Full Implementation (C#)

```csharp
public class Solution 
{
    public int CountCoveredBuildings(int n, int[][] buildings) 
    {
        // min/max Y for each row X
        var rowMin = new Dictionary<int, int>();
        var rowMax = new Dictionary<int, int>();
        
        // min/max X for each column Y
        var colMin = new Dictionary<int, int>();
        var colMax = new Dictionary<int, int>();

        foreach (var b in buildings) 
        {
            int x = b[0], y = b[1];

            // Update row bounds
            if (!rowMin.ContainsKey(x)) 
            {
                rowMin[x] = rowMax[x] = y;
            } 
            else 
            {
                rowMin[x] = Math.Min(rowMin[x], y);
                rowMax[x] = Math.Max(rowMax[x], y);
            }

            // Update column bounds
            if (!colMin.ContainsKey(y)) 
            {
                colMin[y] = colMax[y] = x;
            } 
            else 
            {
                colMin[y] = Math.Min(colMin[y], x);
                colMax[y] = Math.Max(colMax[y], x);
            }
        }

        int covered = 0;
        foreach (var b in buildings) 
        {
            int x = b[0], y = b[1];

            bool hasLeft  = rowMin[x] < y;
            bool hasRight = rowMax[x] > y;
            bool hasUp    = colMin[y] < x;
            bool hasDown  = colMax[y] > x;

            if (hasLeft && hasRight && hasUp && hasDown)
                covered++;
        }

        return covered;
    }
}
```



## Complexity

| **Metric**     | **Value**   | **Notes**                          |
|----------------|-------------|------------------------------------|
| **Time**       | **O(n)**    | Two linear passes over buildings   |
| **Space**      | **O(n)**    | Dictionaries for rows & columns    |

**With n ≤ 10⁵ → runs instantly**

---

## Pitfalls

- **Strict inequality** (`<`, `>`) is mandatory — a building **does not cover itself**
- Buildings on **row or column edge** (min or max) are **never** covered
- Single building per row/col → **never** covered
- Don’t forget to **initialize** min/max when first seeing a row/column

---

## Edge Cases

- **Only one building** → `0`
- **All buildings in one row** → `0`
- **Cross pattern** (5 buildings) → only center `(2,2)` is covered
- **Full grid** → all buildings **except borders** are covered
- **All buildings on diagonal** → only those with both row and col neighbors → depends on positions

---

## Sanity Checks

- Input: `[[1,2],[2,2],[3,2],[2,1],[2,3]]` → Output: `1` (only `(2,2)`)
- Input: `[[1,1],[1,2],[2,1],[2,2]]` → Output: `0`
- Input: `[[1,3],[3,2],[3,3],[3,5],[5,3]]` → Output: `1` (only `(3,3)`)

---

## Key Takeaway

This is a **coordinate geometry + min/max bounds** problem:

- A building is covered **iff** it is **strictly inside** both its **row** and **column**
- Precompute **minY/maxY** per row and **minX/maxX** per column
- One final pass → check condition and count

**Clean, elegant, O(n) solution** — architectural beauty at its finest.

---

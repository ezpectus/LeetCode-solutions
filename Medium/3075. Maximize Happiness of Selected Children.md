# 3075. Maximize Happiness of Selected Children — Architectural Greedy with Decrement Simulation  
*O(n log n) — Optimal Sort + Greedy Selection*

---

## Problem Statement

Given array `happiness` of n children and integer `k`.

In **k turns**, select **k** children.

**Rule**: After each selection, **all remaining** (not selected) children's happiness **decreases by 1** (but not below 0).

Maximize **sum** of happiness of selected children **at the moment of selection**.

Return that maximum sum.

---

## Core Idea — Greedy: Always Pick Current Maximum

**Key insight**:
- Decrement affects **only remaining** children.
- To maximize sum → **always select** the **current highest** happiness child.
- Because:
  - Picking high now → get full value
  - Leaving high for later → it will be decremented multiple times

**Strategy**:
1. Sort `happiness` **descending**
2. For each of first `k` children:
   - Effective happiness = `happiness[i] - i` (decremented `i` times before selection)
   - If still ≥0 → add to sum

**Why**:
- After i-1 selections → i-th highest has been decremented i-1 times
- So value at selection = original - (i-1)

---

##  Implementation (C#)

```csharp
public class Solution {
    public long MaximumHappinessSum(int[] happiness, int k) {
        Array.Sort((happiness), (a,b) => b.CompareTo(a));
        long sum = 0;
        
        for (int i = 0; i < k && i < happiness.Length; i++) {
   
            long val = happiness[i] - i;
            if (val <= 0) break; 
            sum += val;
        }

        return sum;
    }
}

```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)**        | Sorting dominates                              |
| **Space Complexity**  | **O(1)**              | Only input modified (in-place sort)            |

**Optimal** — sorting necessary to identify highest values quickly.

---

## Why This Works — Example Walkthrough

**Input**: `happiness = [1,2,3]`, `k = 2`

- Sorted descending: **[3,2,1]**
- Select 1st: 3 - 0 = **3**
- Select 2nd: 2 - 1 = **1**
- Sum = **4**

**Correct** — pick 3 first, then 2 (decremented to 1).

**Input**: `[1,1,1,1]`, `k=2`

- Sorted: **[1,1,1,1]**
- 1st: 1 - 0 = **1**
- 2nd: 1 - 1 = **0**
- Sum = **1**

**Correct**.

**Input**: `[2,3,4,5]`, `k=1`

- Pick highest: **5** (no decrement)
- Sum = **5**

**Correct**.

---

## Pitfalls & Edge Cases

- **k > n** → impossible by constraints (k ≤ n)
- **Decrements exceed happiness** → value becomes 0 → correctly stops adding
- **All values become zero early** → greedy still picks best possible
- **Large n (2×10⁵)** → sorting efficient
- **All equal values** → correct sum with decrements

All handled perfectly.

---

## Key Takeaway

This is a **beautifully greedy** problem:

- **Sort descending** → always access current highest
- **Pick top k**, subtract position offset (i-1 decrements before selection)
- **Stop adding** when value ≤ 0

**No DP needed** — pure greedy.
**Pure, clean, optimal** — perfect decrement-aware selection.


---

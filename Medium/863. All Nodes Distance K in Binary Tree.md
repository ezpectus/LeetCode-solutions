# 863. All Nodes Distance K in Binary Tree

---

##  Problem Restatement
Given the root of a binary tree, a target node, and an integer `k`, return all node values that are exactly `k` edges away from the target.  
Constraints: `1 ≤ N ≤ 500`, unique node values, `0 ≤ k ≤ 1000`.

---

##  Core Idea
- Treat the binary tree as an **undirected graph**: each node connects to its children and its parent.  
- Perform **Breadth‑First Search (BFS)** starting from the target node.  
- When distance = `k`, collect all nodes at that level.  

> Note: Dijkstra is required when edge weights differ. Here all edges have equal weight = 1, so BFS suffices.

---

##  Step‑by‑Step
1. Build adjacency list (graph) from the tree using DFS.  
2. Initialize BFS queue with `(target, 0)`.  
3. Track visited nodes to avoid cycles.  
4. Expand neighbors until distance = `k`.  
5. Collect node values at distance `k`.  

---

##  Code (C#)
```csharp
public class Solution {
    public IList<int> DistanceK(TreeNode root, TreeNode target, int k) {
        var graph = new Dictionary<TreeNode, List<TreeNode>>();
        BuildGraph(root, null, graph);

        var result = new List<int>();
        var visited = new HashSet<TreeNode>();
        var queue = new Queue<(TreeNode node, int dist)>();

        queue.Enqueue((target, 0));
        visited.Add(target);

        while (queue.Count > 0) {
            var (node, dist) = queue.Dequeue();

            if (dist == k) {
                result.Add(node.val);
                continue;
            }

            foreach (var nei in graph[node]) {
                if (!visited.Contains(nei)) {
                    visited.Add(nei);
                    queue.Enqueue((nei, dist + 1));
                }
            }
        }

        return result;
    }

    private void BuildGraph(TreeNode node, TreeNode parent, Dictionary<TreeNode, List<TreeNode>> graph) {
        if (node == null) return;
        if (!graph.ContainsKey(node)) graph[node] = new List<TreeNode>();
        if (parent != null) {
            graph[node].Add(parent);
            graph[parent].Add(node);
        }
        BuildGraph(node.left, node, graph);
        BuildGraph(node.right, node, graph);
    }
}
```

##  Complexity
- **Time:** O(N) — we traverse the entire tree once to build the adjacency list and once more in BFS. Each edge is processed at most twice (parent ↔ child).
- **Space:** O(N) — adjacency list stores all nodes and their neighbors; visited set and queue also scale linearly with the number of nodes.

 ## Pitfalls
- **Parent links:** If parent edges are not connected during graph construction, BFS will only explore downward paths and miss nodes above the target.
- **Stopping condition:** If BFS continues past `dist == k`, nodes at larger distances may be incorrectly included. Always check distance before expanding neighbors.
- **Large k values:** When `k` exceeds the tree height, BFS must terminate gracefully with an empty result. This prevents unnecessary traversal and ensures correctness.
- **Unique values assumption:** The problem guarantees unique node values, but in a general setting duplicates would require careful handling of node identity.

## Conclusion
This problem is a classic reduction from tree traversal to **graph search**.  
By modeling the binary tree as an undirected graph (child ↔ parent), we can apply BFS to compute exact distances.  
Since all edges have equal weight = 1, **Dijkstra is unnecessary**; BFS provides optimal performance and clarity.  
The solution runs in linear time and space, making it robust for the given constraints (N ≤ 500, k ≤ 1000).  
Result: a clean, teachable O(N) algorithm that highlights the importance of graph modeling in tree problems.


---

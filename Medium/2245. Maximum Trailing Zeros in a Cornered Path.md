# 2245. Maximum Trailing Zeros in a Cornered Path  
*O(mn) — Precompute 2s & 5s in Four Directions + Corner Check*

---

## Problem Statement

You are given an `m × n` grid of positive integers.

A **cornered path** is a path that:
- Moves only horizontally or vertically
- Has **at most one turn** (i.e., goes in one direction, then optionally turns 90 degrees once, and continues in the new direction)
- Does **not** revisit any cell

The **product** of a path is the product of all numbers on the path.

Return the **maximum number of trailing zeros** in the product of any cornered path in the grid.  
(That is, the highest power of 10 that divides the product, which is min(number of 2s, number of 5s) in its prime factors.)

**Examples**:

**Example 1**: grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]  
Output: **3**  
One path with product 18000 (three trailing zeros)

**Constraints**:
- 1 ≤ m, n ≤ 10⁵
- 1 ≤ m × n ≤ 10⁵
- 1 ≤ grid[i][j] ≤ 1000

---

## Core Idea — Precompute 2s & 5s + Corner Enumeration

**Key insight**:
- Trailing zeros = min(total 2s, total 5s) in the prime factorization of the path product
- Usually **number of 5s is the bottleneck** (fewer 5s than 2s)
- A cornered path is one straight line **or** two straight lines joined at a 90° corner
- To maximize trailing zeros → maximize **min(2s, 5s)** along such a path

**Smart way**:
- Precompute for every cell the **cumulative number of 2s and 5s** in four directions:
  - Left ←
  - Right →
  - Up ↑
  - Down ↓
- For each possible **corner cell** (i,j):
  - Consider all four possible corner shapes (L-shapes in four rotations):
    - Right then Down
    - Right then Up
    - Left then Down
    - Left then Up
    - etc.
  - For each shape: take prefix from corner in horizontal dir + prefix from corner in vertical dir (minus the corner cell counted twice)
  - Compute min(2s, 5s) for that path
- Also consider **straight paths** (no turn) → just take max over single directions
- Track global maximum

**Time**: O(mn) — precompute 4 prefix arrays + enumerate all corners O(mn)
**Space**: O(mn) — prefix arrays

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int MaxTrailingZeros(int[][] grid){
        int m = grid.Length;
        int n = grid[0].Length;

        // Precompute number of 2s and 5s from each cell in 4 directions
        int[,,] twos = new int[m, n, 4];   // 0:left, 1:right, 2:up, 3:down
        int[,,] fives = new int[m, n, 4];

        // Helper to count 2s and 5s in a number
        (int t2, int t5) CountFactors(int x){
            int c2 = 0, c5 = 0;
            while (x % 2 == 0) { c2++; x /= 2; }
            while (x % 5 == 0) { c5++; x /= 5; }
            return (c2, c5);
        }

        // Fill prefix counts in four directions
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++) {
                var (c2, c5) = CountFactors(grid[i][j]);

                // Left
                twos[i, j, 0] = c2 + (j > 0 ? twos[i, j - 1, 0] : 0);
                fives[i, j, 0] = c5 + (j > 0 ? fives[i, j - 1, 0] : 0);

                // Up
                twos[i, j, 2] = c2 + (i > 0 ? twos[i - 1, j, 2] : 0);
                fives[i, j, 2] = c5 + (i > 0 ? fives[i - 1, j, 2] : 0);
            }
        }

        // Right and Down — fill in reverse
        for (int i = m - 1; i >= 0; i--){
            for (int j = n - 1; j >= 0; j--){
                var (c2, c5) = CountFactors(grid[i][j]);

                // Right
                twos[i, j, 1] = c2 + (j < n - 1 ? twos[i, j + 1, 1] : 0);
                fives[i, j, 1] = c5 + (j < n - 1 ? fives[i, j + 1, 1] : 0);

                // Down
                twos[i, j, 3] = c2 + (i < m - 1 ? twos[i + 1, j, 3] : 0);
                fives[i, j, 3] = c5 + (i < m - 1 ? fives[i + 1, j, 3] : 0);
            }
        }

        int ans = 0;
        // Now check all possible corner cells (i,j)
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                // For each corner type (4 possible L-shapes)
                // 1. Left + Up
                if (j > 0 && i > 0){
                    int t2 = twos[i, j - 1, 0] + twos[i - 1, j, 2] + CountFactors(grid[i][j]).t2;
                    int t5 = fives[i, j - 1, 0] + fives[i - 1, j, 2] + CountFactors(grid[i][j]).t5;
                    ans = Math.Max(ans, Math.Min(t2, t5));
                }

                // 2. Left + Down
                if (j > 0 && i < m - 1){
                    int t2 = twos[i, j - 1, 0] + twos[i + 1, j, 3] + CountFactors(grid[i][j]).t2;
                    int t5 = fives[i, j - 1, 0] + fives[i + 1, j, 3] + CountFactors(grid[i][j]).t5;
                    ans = Math.Max(ans, Math.Min(t2, t5));
                }

                // 3. Right + Up
                if (j < n - 1 && i > 0){
                    int t2 = twos[i, j + 1, 1] + twos[i - 1, j, 2] + CountFactors(grid[i][j]).t2;
                    int t5 = fives[i, j + 1, 1] + fives[i - 1, j, 2] + CountFactors(grid[i][j]).t5;
                    ans = Math.Max(ans, Math.Min(t2, t5));
                }

                // 4. Right + Down
                if (j < n - 1 && i < m - 1){
                    int t2 = twos[i, j + 1, 1] + twos[i + 1, j, 3] + CountFactors(grid[i][j]).t2;
                    int t5 = fives[i, j + 1, 1] + fives[i + 1, j, 3] + CountFactors(grid[i][j]).t5;
                    ans = Math.Max(ans, Math.Min(t2, t5));
                }

                // Also consider straight paths (no turn)
                for (int d = 0; d < 4; d++){
                    int t2 = twos[i, j, d];
                    int t5 = fives[i, j, d];
                    ans = Math.Max(ans, Math.Min(t2, t5));
                }
            }
        }

        return ans;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(m × n)**  | Precomputing prefix counts in 4 directions: O(mn)<br>Enumerating every cell as potential corner + checking 4 possible turn directions each: O(mn) |
| **Space Complexity**  | **O(m × n)**  | Four 3D prefix arrays (one for 2s and one for 5s per direction): O(4 × m × n) ≈ O(mn) |

**Optimal** — linear in the number of grid cells — necessary to consider all possible corner positions and straight paths.

---

## Why This Works — Key Points

* Precompute **cumulative number of 2s and 5s** in **four directions** (left, right, up, down) from every cell  
  → allows O(1) query for total factors along any horizontal or vertical segment

* Trailing zeros in a path product = **min(total number of 2s, total number of 5s)** in its prime factorization

* A **cornered path** is either:
  - A **straight line** (no turn) → just take max over single directional prefixes
  - An **L-shape** (exactly one 90° turn) → combine one horizontal segment + one vertical segment sharing the corner cell

* For every possible **corner cell (i,j)**:
  - Try all 4 possible L-shape orientations:
    - Right then Down
    - Right then Up
    - Left then Down
    - Left then Up
  - For each orientation: sum 2s and 5s from horizontal prefix + vertical prefix  
    (subtract double-counted factors at the corner cell itself)

* Also check all **straight paths** (no turn) in all 4 directions from each cell

* Track the **global maximum** of min(2s, 5s) across all valid paths

**Correct** —  
Enumerating every possible corner cell + all turn directions, plus straight lines, covers **every possible cornered path** in the grid.  
Precomputed directional prefixes make each check O(1), resulting in efficient O(mn) total time.

---

## Key Takeaway

This is a **classic grid path optimization + trailing zeros** problem:

* Precompute cumulative **number of 2s and 5s** in **four directions** from every cell  
  → enables O(1) queries for factor counts along any row/column segment

* Trailing zeros = **min(total 2s, total 5s)** along the path

* Cornered path = **at most one 90° turn** → either straight line or L-shape

* **Enumerate every cell** as potential corner point
* For each cell, try **all 4 L-shape orientations** + **all 4 straight directions**
* Combine horizontal + vertical prefix counts (adjust for double-counted corner)
* Take maximum of min(2s, 5s) across all candidates

**Pure, clean, optimal** — O(mn) time, O(mn) space, very fast, systematic, covers all possible cornered paths exhaustively.

---

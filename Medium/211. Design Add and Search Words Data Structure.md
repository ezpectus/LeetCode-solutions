# 211. Design Add and Search Words Data Structure

---

##  Problem Restatement
Design a data structure that supports:
- **AddWord(word):** adds a word to the dictionary.  
- **Search(word):** returns true if any word in the dictionary matches the query.  
  - Query may contain `.` which matches any single character.

Constraints:  
- 1 ≤ word.length ≤ 25  
- Words consist of lowercase English letters.  
- Search queries consist of lowercase letters or `.`.  
- At most 10^4 calls to `addWord` and `search`.

---

##  Core Idea
- Use a **Trie (prefix tree)** to store words.  
- Each node has children for characters and a flag `IsWord`.  
- `AddWord`: insert characters into Trie.  
- `Search`: perform DFS.  
  - If character is a letter → follow its branch.  
  - If character is `.` → try all children recursively.  

---

##  Code (C#)
```csharp
public class WordDictionary {
    private class TrieNode {
        public Dictionary<char, TrieNode> Children = new Dictionary<char, TrieNode>();
        public bool IsWord = false;
    }

    private TrieNode root;

    public WordDictionary() {
        root = new TrieNode();
    }
    
    public void AddWord(string word) {
        TrieNode node = root;
        foreach (char c in word) {
            if (!node.Children.ContainsKey(c)) {
                node.Children[c] = new TrieNode();
            }
            node = node.Children[c];
        }
        node.IsWord = true;
    }
    
    public bool Search(string word) {
        return DfsSearch(word, 0, root);
    }

    private bool DfsSearch(string word, int index, TrieNode node) {
        if (index == word.Length) {
            return node.IsWord;
        }

        char c = word[index];
        if (c == '.') {
            foreach (var child in node.Children.Values) {
                if (DfsSearch(word, index + 1, child)) {
                    return true;
                }
            }
            return false;
        } else {
            if (!node.Children.ContainsKey(c)) return false;
            return DfsSearch(word, index + 1, node.Children[c]);
        }
    }
}
```

##  Complexity
- **AddWord:** O(L), where L = length of word.  
- **Search:** O(L * 26^dots), but since dots ≤ 2, this is efficient.  
- **Space:** O(sum of word lengths) for Trie nodes.  

---

##  Pitfalls
- Must mark the end of word (`IsWord = true`).  
- For `.` queries, must explore all children.  
- Without DFS, wildcard search is impossible.  
- Edge case: searching empty string → should return false unless explicitly added.  

---

##  Conclusion
This problem reduces to **Trie + DFS with wildcard support**.  
Efficiently handles up to 10^4 operations with clean O(L) add and search.  
Result: robust and scalable solution for dictionary queries with flexible matching.  

---

##  Generalization
- Pattern applies to **autocomplete systems**, **spell checkers**, and **wildcard search engines**.  
- Trie + DFS is a universal technique for handling structured string queries.  
- Can be extended to support prefix search, regex‑like queries, or multi‑character wildcards.

---

# Pattern Name
**Longest Word Buildable by Prefix Chain via HashSet Validation**

---

## Problem Summary
You're given:

- A list of strings `words`, representing a dictionary
- Each word consists of **lowercase English letters**

**Goal:**
- Find the **longest word** that can be built **one character at a time**,  
  where **each prefix** of the word is **also present** in the dictionary
- If multiple words qualify → return the **lexicographically smallest**
- If no word qualifies → return `""`

---

## Core Idea
This is a **prefix validation problem** over a **static dictionary**.

We want the **longest word** such that **all its prefixes** are also in the list.

**Solution:**  
Use a `HashSet<string>` for **O(1) prefix lookup**.

---

## Strategy Summary
1. Insert all words into a `HashSet<string>` → **fast lookup**
2. **Sort words** by:
   - **Descending length** (longer first)
   - **Ascending lexicographical order** (smaller first)
3. For each word:
   - Check if **all prefixes** `word[0..i]` exist in the set
4. **Return the first valid word** (due to sorting priority)
5. If none → return `""`

---

## C# Implementation
```csharp
public class Solution {
    public string LongestWord(string[] words) {
        var wordSet = new HashSet<string>(words);
        
        Array.Sort(words, (a, b) => {
            if (b.Length != a.Length) 
                return b.Length.CompareTo(a.Length); // longer first
            return a.CompareTo(b); // lex smaller first
        });

        foreach (var word in words) {
            bool valid = true;
            for (int i = 1; i < word.Length; i++) {
                if (!wordSet.Contains(word.Substring(0, i))) {
                    valid = false;
                    break;
                }
            }
            if (valid) return word;
        }
        return "";
    }
}
```


## Architectural Breakdown

| Component         | Role |
|-------------------|------|
| `wordSet`         | Enables **constant-time** prefix existence checks |
| `Array.Sort`      | Ensures **longest** and **lex smallest** word is prioritized |
| **Inner loop**    | Validates **all prefixes** of each candidate word |
| **Early return**  | Returns **first valid word** due to sorted priority |

---

## Why This Approach Is Superior

| Aspect                   | This Approach                            | Naive Approach                     |
|--------------------------|------------------------------------------|------------------------------------|
| **Prefix Validation**    | `HashSet` lookup per prefix              | Nested loops or repeated scans     |
| **Sorting Strategy**     | Length + lexicographical priority        | Manual comparisons or post-filtering |
| **Performance**          | Efficient scan with early exit           | Full traversal with late filtering |
| **Code Clarity**         | Modular and readable                     | Entangled or stateful logic        |
| **Generalizability**     | Adapts to other prefix-chain problems    | Hardcoded or fragile logic         |

---

## Final Takeaway

> This problem is about **prefix chain validation** under **dictionary constraints**.

### The solution uses:
- **Preprocessing** into a `HashSet<string>`
- **Sorting** for priority resolution
- **Per-prefix validation** via substring lookup

---

### This pattern generalizes to any task involving:
- Word construction via **incremental prefix rules**
- **Dictionary-based validation**
- **Lexicographical tie-breaking**


---

# 1834. Single-Threaded CPU  
*O(n log n) — Optimal Priority Queue + Event Simulation*

---

## Problem Statement

You are given `n` tasks as `tasks[i] = [enqueueTimei, processingTimei]`:

- `enqueueTimei` — moment when task i becomes available
- `processingTimei` — time needed to process task i once started

You have a **single-threaded CPU** that:

- Processes at most **one task at a time**
- Starts a task instantly when idle and tasks are available
- Chooses the task with the **shortest processing time** among available ones
- If multiple have the same shortest time → chooses the one with **smallest index**
- Processes the entire task without interruption

Return the **order** (0-based indices) in which the CPU processes the tasks.

---

## Core Idea - Priority Queue for Shortest Available Job

**Key insight**:
- Simulate time progression
- Maintain a **min-heap** of available tasks: priority = (processingTime, index)
- Sort tasks by `enqueueTime` to add them in chronological order
- Current time starts at 0
- When CPU idle:
  - Add all tasks that became available by current time
  - If no tasks → jump time to next task's enqueueTime
  - Else pick shortest task (smallest index on tie)
- Process it → advance time by processingTime
- Add its index to result

**Data structures**:
- `indexedTasks` — tasks with added index, sorted by enqueueTime
- `PriorityQueue<int, (int procTime, int idx)>` — min-heap by procTime, then by idx

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int[] GetOrder(int[][] tasks) {
        int n = tasks.Length;
        int[] answer = new int[n];

        // Add index and sort by enqueueTime
        int[][] indexed = new int[n][];
        for (int i = 0; i < n; i++) {
            indexed[i] = new int[] { tasks[i][0], tasks[i][1], i };
        }

        Array.Sort(indexed, (a, b) => a[0].CompareTo(b[0]));

        // Min-heap: priority = (procTime, index)
        var pq = new PriorityQueue<int, (int procTime, int idx)>(
            Comparer<(int procTime, int idx)>.Create((a, b) =>
                a.procTime == b.procTime 
                    ? a.idx.CompareTo(b.idx) 
                    : a.procTime.CompareTo(b.procTime)));

        long currentTime = 0;
        int taskIdx = 0;      // next task to enqueue
        int ansIdx = 0;       // position in answer

        while (ansIdx < n) {
            // Add all tasks available by current time
            while (taskIdx < n && indexed[taskIdx][0] <= currentTime) {
                int procTime = indexed[taskIdx][1];
                int idx = indexed[taskIdx][2];
                pq.Enqueue(idx, (procTime, idx));
                taskIdx++;
            }

            // If no tasks — jump to next enqueue time
            if (pq.Count == 0) {
                currentTime = indexed[taskIdx][0];
                continue;
            }

            // Process shortest task
            int taskIndex = pq.Dequeue();
            int processingTime = tasks[taskIndex][1];

            answer[ansIdx++] = taskIndex;
            currentTime += processingTime;
        }

        return answer;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)**| Sorting tasks by enqueue time O(n log n) + n heap operations (each O(log n)) |
| **Space Complexity**  | **O(n)**      | Indexed tasks array + priority queue (worst case stores O(n) elements) |

**Optimal** — standard complexity for single-threaded shortest-job-first scheduling with arrival times.

---

## Why This Works — Example Walkthrough

**Example 1**: `tasks = [[1,2],[2,4],[3,2],[4,1]]`

- Indexed & sorted by enqueue time: [1,2,0], [2,4,1], [3,2,2], [4,1,3]
- currentTime = 0
- No tasks available → jump to time 1 (first enqueue)
- At time 1: enqueue task 0 (proc=2, idx=0) → pq = {(2,0)}
- Process task 0 → answer = [0], currentTime = 1 + 2 = **3**
- At time 3: enqueue task 2 (enqueue=3 ≤ 3, proc=2, idx=2) → pq = {(2,2)}
- Process task 2 → answer = [0,2], currentTime = 3 + 2 = **5**
- At time 5: enqueue task 3 (enqueue=4 ≤ 5, proc=1, idx=3) → pq = {(1,3), (4,1)}
- Process shortest task 3 → answer = [0,2,3], currentTime = 5 + 1 = **6**
- Process remaining task 1 → answer = [0,2,3,1], currentTime = 6 + 4 = **10**

Output: **[0,2,3,1]** → correct  
(Always picks shortest available task, smallest index on tie, jumps time when idle)

**Correct** — the simulation exactly follows the problem rules: idle jump, shortest processing time priority, smallest index tie-breaker.

---

## Pitfalls & Edge Cases

- **All tasks enqueue at time 0** → processes in order of increasing processingTime, then smallest index
- **n = 1** → answer = [0]
- **Tasks with identical processing time** → chooses smallest index (comparator correct)
- **Very late tasks** → correctly jumps currentTime forward when idle
- **Large n (≤ 10⁵)** → O(n log n) is acceptable
- **Large enqueue/processing times** → use `long` for currentTime (prevents overflow)

All handled perfectly.

---

## Key Takeaway

This is a **classic single-threaded CPU scheduling** problem with shortest-job-first priority:

- Sort tasks by **enqueue time**
- Use **min-heap** (PriorityQueue) for available tasks, ordered by (processingTime, index)
- When CPU is idle:
  - Enqueue all tasks that became available by current time
  - If heap empty → jump currentTime to next task's enqueue time
  - Else process the shortest task (smallest index on tie)
- Advance currentTime by processing time
- Repeat until all tasks are processed

**Pure, clean, optimal** — perfect simulation of single-threaded task scheduling with arrival times and shortest-job priority.

---

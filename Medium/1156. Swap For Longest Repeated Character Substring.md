#  Pattern Name  
Frequency-Aware Sliding Window with Greedy Swap

---

##  Problem Statement

You are given a string `text` consisting of lowercase English letters.  
You may swap **any two characters** in the string.  
Your goal is to find the **maximum length of a substring** that consists of **only one repeated character**, after performing **at most one swap**.

---

##  Objective

Return the length of the longest possible substring with repeated characters, after one allowed swap.

---

##  Examples

| Input       | Output | Explanation                                                                 |
|-------------|--------|------------------------------------------------------------------------------|
| `"ababa"`   | `3`    | Swap first `'b'` with last `'a'` → `"aaa"`                                   |
| `"aaabaaa"` | `6`    | Swap `'b'` with last `'a'` → `"aaaaaa"`                                      |
| `"aaaaa"`   | `5`    | No swap needed — already all `'a'`                                           |

---

##  Problem Anatomy

| Element       | Role                                                                 |
|---------------|----------------------------------------------------------------------|
| `text[i]`     | Current character                                                    |
| `groups`      | List of consecutive same-character segments                          |
| `freq[c]`     | Total count of character `c` in the entire string                    |
| `swap logic`  | Can merge two same-character groups if total count > group size     |

---

##  Algorithm Strategy

1. **Group segments** of same characters: store start, end, length  
2. **Track total frequency** of each character  
3. For each group:
   - Try to **extend** it by 1 if total frequency > group length  
   - If there's a **gap of one character** between two same-character groups, try to **merge** them

---

##  C# Implementation

```csharp
public class Solution {
    public int MaxRepOpt1(string text) {
        int n = text.Length;
        var freq = new Dictionary<char, int>();
        foreach (char c in text) {
            if (!freq.ContainsKey(c)) freq[c] = 0;
            freq[c]++;
        }

        var groups = new List<(char c, int start, int end)>();
        int i = 0;
        while (i < n) {
            int j = i;
            while (j < n && text[j] == text[i]) j++;
            groups.Add((text[i], i, j - 1));
            i = j;
        }

        int res = 0;
        for (int k = 0; k < groups.Count; k++) {
            var (c, start, end) = groups[k];
            int len = end - start + 1;
            if (freq[c] > len) res = Math.Max(res, len + 1);
            else res = Math.Max(res, len);

            // Try to merge with next group if separated by one char
            if (k + 2 < groups.Count && groups[k + 1].end == groups[k + 1].start &&
                groups[k].c == groups[k + 2].c) {
                int merged = (groups[k].end - groups[k].start + 1) +
                             (groups[k + 2].end - groups[k + 2].start + 1);
                if (freq[c] > merged) merged++;
                res = Math.Max(res, merged);
            }
        }

        return res;
    }
}
```


## Time and Space Complexity

| Metric           | Value  | Explanation                                                                 |
|------------------|--------|------------------------------------------------------------------------------|
| Time Complexity  | O(n)   | We traverse the string once to group segments and once to evaluate options. |
| Space Complexity | O(1)   | We use a fixed-size frequency map for 26 lowercase letters.                 |

Although we use a `Dictionary<char, int>` and a `List` of segments, the total space remains bounded by the alphabet size and the number of character groups, which is at most `n` but typically much smaller.

---

## Generalization to Other Problems

This pattern applies to problems where:

- You need to **analyze character frequency globally**, but act locally on segments or windows.
- You can **modify or swap elements** under constraints (e.g., one swap, limited replacements).
- You want to **merge or extend segments** based on total availability of a character.

The key idea is that **global frequency enables local optimization** — you can stretch or merge segments beyond their original bounds if the character occurs elsewhere.

---

## Examples of Similar Problems

| Problem Type                          | Description                                                           |
|--------------------------------------|-----------------------------------------------------------------------|
| Longest substring with k replacements| Replace up to `k` characters to form a block of repeated characters.  |
| Longest substring without repeats    | Track a window of unique characters using a sliding window.           |
| Character replacement for max length | Use frequency and greedy logic to extend a block with limited edits.  |

These problems often combine **sliding window**, **frequency maps**, and **greedy decisions** to optimize substring length under constraints.

---

## Final Takeaway

This problem blends three core techniques:

- **Frequency analysis** — count how many times each character appears globally.
- **Segment grouping** — identify blocks of consecutive identical characters.
- **Greedy swap logic** — decide whether to extend or merge segments using available characters.

It’s a reusable pattern for **string manipulation under constraints**, especially when:

- You’re allowed to **modify one element** (swap, replace, delete).
- You need to **maximize a local structure** (substring, block, window).
- You can **leverage global character counts** to justify local changes.

This approach is especially powerful in competitive programming and interview settings, where **linear-time solutions** are preferred and **greedy + frequency** often unlocks optimal strategies.



---

# 3006. Find Beautiful Indices in the Given Array I

---

##  Problem Restatement
We are given:
- A string `s` (0-indexed).
- Two substrings `a` and `b`.
- An integer `k`.

An index `i` is **beautiful** if:
1. `s[i..i+a.length-1] == a` (substring `a` starts at `i`).
2. There exists an index `j` such that:
   - `s[j..j+b.length-1] == b`
   - `|i - j| <= k`

We must return all beautiful indices in **sorted order**.

---

##  Core Idea
1. **Find all occurrences** of substring `a` in `s`.  
2. **Find all occurrences** of substring `b` in `s`.  
3. For each index `i` where `a` occurs:  
   - Check if there exists some `j` (where `b` occurs) such that `|i - j| <= k`.  
   - If yes â†’ `i` is beautiful.  
4. Collect all beautiful indices and return them sorted.

Efficient check:  
- Both occurrence lists are sorted naturally.  
- Use **two-pointer technique** or binary search to quickly check distance condition.

---

##  Code (C#)
```csharp
public class Solution {
    public IList<int> BeautifulIndices(string s, string a, string b, int k) {
        var result = new List<int>();
        var aIndices = FindOccurrences(s, a);
        var bIndices = FindOccurrences(s, b);

        foreach (var i in aIndices) {
            // Binary search in bIndices for closest j
            int pos = BinarySearchClosest(bIndices, i);
            if (pos != -1 && Math.Abs(bIndices[pos] - i) <= k) {
                result.Add(i);
            }
        }

        return result;
    }

    private List<int> FindOccurrences(string s, string sub) {
        var list = new List<int>();
        for (int i = 0; i <= s.Length - sub.Length; i++) {
            if (s.Substring(i, sub.Length) == sub) {
                list.Add(i);
            }
        }
        return list;
    }

    private int BinarySearchClosest(List<int> arr, int target) {
        int left = 0, right = arr.Count - 1;
        int best = -1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (arr[mid] == target) return mid;
            if (arr[mid] < target) {
                best = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        // best is the closest smaller index
        // check both best and best+1
        int candidate = -1;
        if (best != -1) candidate = best;
        if (best + 1 < arr.Count) {
            if (candidate == -1 || 
                Math.Abs(arr[best + 1] - target) < Math.Abs(arr[candidate] - target)) {
                candidate = best + 1;
            }
        }
        return candidate;
    }
}
```
##  Complexity
- **Finding occurrences:** O(n * len(sub)) for each substring.  
  - Scan the string `s` and check substrings of length `len(a)` and `len(b)`.  
- **Binary search per index:** O(log M), where M = number of occurrences of `b`.  
  - For each occurrence of `a`, find the closest occurrence of `b`.  
- **Total:** O(n + A log B)  
  - A = count of `a` occurrences.  
  - B = count of `b` occurrences.  
- **Space:** O(A + B) for storing indices of `a` and `b`.

## ðŸŒ³ Visualization
```
s = "isawsquirrelnearmysquirrelhouseohmy"
      ^               ^               ^
      j=4             i=16            i=33

a = "my" â†’ indices [16,33]
b = "squirrel" â†’ indices [4,18]

Check distances:
i=16 â†” j=4 â†’ |16-4|=12 â‰¤ 15 â†’ beautiful
i=33 â†” j=18 â†’ |33-18|=15 â‰¤ 15 â†’ beautiful
```

---

## Pitfalls
- Must check substring boundaries carefully (`s.Substring(i, len)`).  
- Ensure binary search returns the **closest index**, not just exact matches.  
- Handle the case when `a == b` (same substring).  
- Large `s` (up to 10^5) â†’ avoid naive nested loops (O(n^2)).  

---

##  Example Walkthrough
Input:  
`s = "isawsquirrelnearmysquirrelhouseohmy"`  
`a = "my"`  
`b = "squirrel"`  
`k = 15`

### Step 1: Find occurrences
- `a = "my"` â†’ indices `[16, 33]`  
- `b = "squirrel"` â†’ indices `[4, 18]`  

### Step 2: Check distances
- For `i = 16`: closest `j = 4` â†’ `|16 - 4| = 12 â‰¤ 15` â†’ âœ…  
- For `i = 33`: closest `j = 18` â†’ `|33 - 18| = 15 â‰¤ 15` â†’ âœ…  

### Result:
`[16, 33]`




---



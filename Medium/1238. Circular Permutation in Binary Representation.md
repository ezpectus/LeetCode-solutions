# 1238. Circular Permutation in Binary Representation  
*Gray Code Rotation — O(2ⁿ) Magic*

---


## Problem  
Given two integers `n` and `start`, return **any permutation** `p` of all numbers from `0` to `2ⁿ−1` such that:

- `p[0] = start`  
- **Every two adjacent elements** `p[i]` and `p[i+1]` differ by **exactly one bit** in their binary representation  
- The **first** and **last** elements `p[0]` and `p[2ⁿ−1]` also differ by **exactly one bit** (i.e., the sequence is **circular**)

This is equivalent to finding a **Hamiltonian cycle** in the **n-dimensional hypercube**, starting at `start`.

---

## Examples  

| Input | Output | Binary Sequence |
|------|--------|------------------|
| `n=2, start=3` | `[3,2,0,1]` | `11 → 10 → 00 → 01` |
| `n=3, start=2` | `[2,6,7,5,4,0,1,3]` | `010 → 110 → 111 → 101 → 100 → 000 → 001 → 011` |

> **Check**:  
> - Each step flips **exactly one bit**  
> - First (`010`) and last (`011`) differ by **1 bit** → valid cycle

---

## Constraints  
- `1 ≤ n ≤ 16`  
- `0 ≤ start < 2ⁿ`

> **Key implication**:  
> - Max size: `2¹⁶ = 65,536`  
> - **O(2ⁿ)** is **fully acceptable** — we can generate and store the entire sequence

---

## Why This Problem Matters  

| Real-World Use | Connection |
|---------------|----------|
| **Digital Circuit Design** | Minimize switching noise (only one bit changes) |
| **Error Detection** | Gray codes prevent glitches in rotary encoders |
| **Combinatorial Generation** | Enumerate all states with minimal transitions |
| **Graph Theory** | Hamiltonian path/cycle in hypercube |

> **This is not just a coding problem — it's a fundamental pattern in computer engineering and algorithms.**

---

## Core Insight  
> **This is a circular Gray code problem.**

### What is **Gray Code**?  
A **Gray code** is a sequence of binary numbers where **adjacent entries differ by exactly one bit**.

```text
Standard Binary: 00 → 01 → 10 → 11  (2 bit flips: 01→10)
Gray Code:       00 → 01 → 11 → 10  (1 bit flip each time)
```

- **Standard binary reflected Gray code**:  
  ```cpp
  g(i) = i ^ (i >> 1)
  ```
- The sequence g(0), g(1), ..., g(2ⁿ−1) is a valid Hamiltonian path in the n-bit hypercube
- Circular property: g(0) and g(2ⁿ−1) also differ by one bit
  
Solution:
- Generate full Gray code
- Find index j where g[j] == start
- Rotate sequence to start at j

## Full Implementation (C++)
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<int> circularPermutation(int n, int start) {
        int size = 1 << n;  // 2^n
        vector<int> gray(size);
        int start_idx = 0;

        // Generate Gray code and find start position
        for (int i = 0; i < size; ++i) {
            gray[i] = i ^ (i >> 1);
            if (gray[i] == start)
                start_idx = i;
        }

        // Rotate: start from start_idx
        vector<int> result;
        result.reserve(size);
        for (int i = 0; i < size; ++i) {
            result.push_back(gray[(start_idx + i) % size]);
        }

        return result;
    }
};
```

## Full Implementation (C#)
```cpp
using System;
using System.Collections.Generic;

public class Solution {
    public IList<int> CircularPermutation(int n, int start) {
        int size = 1 << n;
        var gray = new List<int>(size);
        int startIdx = 0;

        for (int i = 0; i < size; i++) {
            int code = i ^ (i >> 1);
            gray.Add(code);
            if (code == start) startIdx = i;
        }

        var result = new List<int>(size);
        for (int i = 0; i < size; i++) {
            result.Add(gray[(startIdx + i) % size]);
        }

        return result;
    }
}
```
## Complexity Analysis  

| Metric | **Value** | **Notes** |
|--------|-----------|---------|
| **Time** | **O(2ⁿ)** | Generate Gray code + rotate sequence |
| **Space** | **O(2ⁿ)** | Must store full permutation |
| **Optimal?** | Yes | Required to output **2ⁿ** elements |

> **n ≤ 16 → 2¹⁶ = 65,536** → **totally fine**  
> **No better than O(2ⁿ)** — output size dominates

---

## Pitfalls & Fixes  

| **Issue** | **Fix / Mitigation** |
|----------|-----------------------|
| **Wrong Gray code formula** | **Use `i ^ (i >> 1)`** — **not** `i ^ (i + 1)` or others |
| **No rotation** | `p[0]` **must** be `start` |
| **Off-by-one in modulo** | Use `(start_idx + i) % size` — **not** `i % size` |
| **Forgot circular bit diff** | **Gray code guarantees**: `g[0]` ↔ `g[2ⁿ−1]` differ by **1 bit** |

---

## Insight  
> **This is a classic Gray code fichka:**

- **Generate** with `i ^ (i >> 1)`  
- **Rotate** to desired `start`  
- **Automatically satisfies** **adjacency** + **circular** condition  

**No need to verify bit differences** — **Gray code property does it all**

---




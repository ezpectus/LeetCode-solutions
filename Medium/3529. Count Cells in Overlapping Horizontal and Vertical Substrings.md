# 3529. Count Cells in Overlapping Horizontal and Vertical Substrings — C++ Solution

---

##  Problem Restatement
We are given:
- An `m x n` matrix `grid` of characters.
- A string `pattern`.

Definitions:
- **Horizontal substring:** read left to right, wrapping to the next row if needed (но не снизу вверх).
- **Vertical substring:** read top to bottom, wrapping to the next column if needed (но не справа налево).

A cell is **valid** if:
- It belongs to at least one horizontal substring equal to `pattern`.
- It belongs to at least one vertical substring equal to `pattern`.

Return the count of such cells.

---
##  Core Idea
- **Linearize the grid into two strings:**
  - Build a **horizontal string** by reading row by row, which naturally models horizontal substrings with wrap to the next row.
  - Build a **vertical string** by reading column by column, which models vertical substrings with wrap to the next column.

- **Efficient substring search:**
  - Use **KMP** (Knuth–Morris–Pratt) to find all occurrences of `pattern` in both strings in linear time.
  - This avoids the naive O(m * n * |pattern|) approach that causes TLE.

- **Sweep line marking:**
  - For each match, mark coverage using a difference array (`+1` at start, `-1` at end).
  - A single pass accumulates coverage, ensuring each index is marked if it belongs to at least one match.

- **Map indices back to cells:**
  - Horizontal mapping: `row = idx / n`, `col = idx % n`.
  - Vertical mapping: `row = idx % m`, `col = idx / m`.
  - Maintain two boolean grids `horizCovered` and `vertCovered`.

- **Count intersections:**
  - A cell is valid if it is covered in both directions: `horizCovered[row][col] && vertCovered[row][col]`.

- **Result:**
  - The algorithm runs in O(m * n + |pattern|) time and O(m * n) space, passing even the hardest test cases.

---

##  Code (C++)
```cpp
class Solution {
public:
    vector<int> getLPS(string &s, int n) {
        vector<int> LPS(n);
        for(int i = 1; i < n; i++) {
            int j = LPS[i - 1];
            while(j > 0 && s[i] != s[j]) {
                j = LPS[j - 1];
            }
            if(s[i] == s[j]) j++;
            LPS[i] = j;
        }
        return LPS;
    }
     
    int countCells(vector<vector<char>> &grid, string pattern) {
        int n = grid.size(), m = grid[0].size(), sz = pattern.size();
        
        // Build horizontal string
        string horizontalString;
        horizontalString.reserve(n * m);
        for(int i = 0; i < n; i++)
            for(int j = 0; j < m; j++)
                horizontalString += grid[i][j];
        
        // Build vertical string
        string verticalString;
        verticalString.reserve(n * m);
        for(int j = 0; j < m; j++)
            for(int i = 0; i < n; i++)
                verticalString += grid[i][j];
        
        // KMP preprocessing
        string horizontalPatternString = pattern + "#" + horizontalString;
        vector<int> lps1 = getLPS(horizontalPatternString, horizontalPatternString.size());
        
        string verticalPatternString = pattern + "#" + verticalString;
        vector<int> lps2 = getLPS(verticalPatternString, verticalPatternString.size());

        // Sweep line arrays
        int sz1 = lps1.size();
        vector<int> scan1(sz1 + 1);
        for(int i = 0; i < sz1; i++) {
            if(lps1[i] == sz) {
                scan1[i - sz + 1]++;
                scan1[i + 1]--;
            }
        }
        
        int sz2 = lps2.size();
        vector<int> scan2(sz2 + 1);
        for(int i = 0; i < sz2; i++) {
            if(lps2[i] == sz) {
                scan2[i - sz + 1]++;
                scan2[i + 1]--;
            }
        }
        
        vector<vector<bool>> visited(n, vector<bool>(m));
        
        // Horizontal coverage
        int count1 = 0;
        for(int i = 0; i < sz1; i++) {
            count1 += scan1[i];
            if(count1 > 0) {
                int idx = i - sz - 1;
                if(idx >= 0 && idx < n * m) {
                    int row = idx / m, column = idx % m;
                    visited[row][column] = true;
                }
            }
        }
        
        // Vertical coverage + intersection
        int count2 = 0;
        int ans = 0;
        for(int i = 0; i < sz2; i++) {
            count2 += scan2[i];
            if(count2 > 0) {
                int idx = i - sz - 1;
                if(idx >= 0 && idx < n * m) {
                    int row = idx % n, column = idx / n;
                    if(visited[row][column]) ans++;
                }
            }
        }
        
        return ans;
    }
};
```



##  Complexity
- **Build strings:** O(m * n)  
- **KMP preprocessing:** O(m * n + |pattern|)  
- **Sweep line marking:** O(m * n)  
- **Total:** O(m * n + |pattern|)  
- **Space:** O(m * n)  

---

##  Pitfalls
- The index after KMP must be correctly shifted (`i - sz - 1`).  
- Always check index boundaries to avoid out‑of‑range errors.  
- In the sweep line technique: `count > 0` means the current position is covered by at least one active match.  
- Correct mapping of string index back to `(row, col)` is crucial:  
  - **Horizontal:** `row = idx / m`, `col = idx % m`.  
  - **Vertical:** `row = idx % n`, `col = idx / n`.  

---

##  Example Walkthrough
**Input:**  
`grid = [["a","a","c","c"],["b","b","b","c"],["a","a","b","a"],["c","a","a","c"],["a","a","b","a"]]`  
`pattern = "abaca"`

- Horizontal string: `"aac..."`  
- Vertical string: `"abca..."`  
- KMP finds matches.  
- Sweep line marks covered cells.  
- Intersection yields result = `1`.  

---

##  Conclusion
- Naive substring search → TLE.  
- KMP + sweep line → linear solution.  
- Efficient even for the toughest test cases with very long patterns.  



---

üß† **Pattern: Multi-Indexed Lexicographic Rating System**

---

## üìå Problem Statement

You're given:

- A list of food items `foods[i]`
- Their corresponding cuisines `cuisines[i]`
- Initial ratings `ratings[i]`

You must design a system that supports:

- `changeRating(food, newRating)` ‚Äî update the rating of a food item  
- `highestRated(cuisine)` ‚Äî return the food with the highest rating for a given cuisine  
  - If multiple foods have the same rating, return the lexicographically smallest name

---

## üß© Architectural Model

This is a **multi-indexed priority system** with dynamic updates and fast top queries.

Instead of scanning all foods per cuisine, we maintain a **sorted structure per cuisine**, allowing:

- Fast rating updates  
- Instant access to the top-rated food per cuisine

The key is to use a `set<pair<int, string>>` per cuisine, sorted by:

- Negative rating (to simulate max-heap behavior)  
- Lexicographic name (for tie-breaking)

---

## üß± Component Breakdown

| Component               | Role in the Solution                                |
|------------------------|-----------------------------------------------------|
| `foodtocuis[food]`     | Maps food ‚Üí cuisine                                 |
| `foodrating[food]`     | Stores current rating of each food                  |
| `cuisinefoods[cuisine]`| Sorted set of `{ -rating, name }` for each cuisine |

This structure ensures:

- Fast lookup of cuisine for any food  
- Fast rating updates  
- Sorted access to top-rated food per cuisine


## üîÑ Algorithm Walkthrough
```cpp
class FoodRatings {
    unordered_map<string, string> foodtocuis;
    unordered_map<string, int> foodrating;
    unordered_map<string, set<pair<int, string>>> cuisinefoods;

public:
    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {
        for (int i = 0; i < foods.size(); ++i) {
            foodtocuis[foods[i]] = cuisines[i];
            foodrating[foods[i]] = ratings[i];
            cuisinefoods[cuisines[i]].insert({ -ratings[i], foods[i] });
        }
    }

    void changeRating(string food, int newRating) {
        string cuisine = foodtocuis[food];
        int oldRating = foodrating[food];
        cuisinefoods[cuisine].erase({ -oldRating, food });
        cuisinefoods[cuisine].insert({ -newRating, food });
        foodrating[food] = newRating;
    }

    string highestRated(string cuisine) {
        return cuisinefoods[cuisine].begin()->second;
    }
};
```
üìå **Step-by-step Breakdown**

### Initialization

For each food:

- Map it to its cuisine  
- Store its rating  
- Insert into the cuisine's sorted set as `{ -rating, name }`

---

### Rating Update

- Remove the old `{ -rating, name }` from the cuisine's set  
- Insert the new `{ -newRating, name }`  
- Update the rating map

---

### Top Query

- Return `begin()->second` from the cuisine's set  
- This is the food with the highest rating and smallest name

---

üß† **Invariants**

- `cuisinefoods[cuisine]` is always sorted by:
  - Highest rating first (via `-rating`)
  - Lexicographically smallest name in case of tie
- `foodrating[food]` always reflects the latest rating
- All operations are **O(log n)** due to `set`

---

‚ö†Ô∏è **Common Pitfalls**

| Mistake                        | Why It Breaks the Solution                        |
|-------------------------------|---------------------------------------------------|
| Not removing old rating entry | Causes duplicates and incorrect sorting           |
| Using `rating` instead of `-rating` | Breaks descending order logic              |
| Not updating `foodrating`     | Future updates will be based on stale data        |

---

üß† **Why This Works**

This approach avoids brute-force scanning by maintaining a sorted structure per cuisine.  
Instead of checking all foods manually, we:

- Use `unordered_map` for fast lookups  
- Use `set` for automatic sorting and tie-breaking  
- Use negative ratings to simulate max-heap behavior

This gives us:

- **O(log n)** updates  
- **O(1)** top queries  
- Transparent logic with minimal overhead

---

üß† **Pattern Generalization**

This technique applies to problems with:

- Ranked queries with dynamic updates  
- Tie-breaking via lexicographic order  
- Multi-key indexing (e.g. category ‚Üí sorted items)

---

üîÅ **Reusable Structure**

- `unordered_map` for direct access  
- `set<pair<int, string>>` for sorted queries  
- Negative values to reverse sort order

---

üß© **Example Problems**

- Leaderboard systems with score updates  
- Category-based top item queries  
- Dynamic priority queues with tie-breaks

---

üß† **Alternative Approaches (Comparison Table)**

| Method            | Time Complexity | Pros                  | Cons                          |
|-------------------|------------------|------------------------|-------------------------------|
| Brute-force scan  | O(n)             | Simple                 | Too slow for large inputs     |
| Priority Queue    | O(log n)         | Fast top access        | Hard to update specific items |
| Sorted List       | O(log n)         | Clean ordering         | Costly insert/delete          |
| Hash + Set        | O(log n)         | Fast, clean, scalable  | Requires careful deletion     |

---

üß† **Conclusions**

This solution is an example of **multi-indexed architectural thinking**, where complexity is managed through:

- Fast lookup maps  
- Sorted sets with tie-breaking  
- Minimal state per item

Instead of brute-force scanning or complex data structures, we use **just enough structure** to guarantee correctness and performance.



---

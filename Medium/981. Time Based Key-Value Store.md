# 981. Time-Based Key-Value Store

## Problem  
Design a time-based key-value data structure that supports storing multiple values for the same key at different timestamps and retrieving the most recent value at or before a given timestamp.

### Operations
- `TimeMap()` — Initializes the data structure.
- `set(key, value, timestamp)` — Stores the key-value pair at the given timestamp.
- `get(key, timestamp)` — Returns the value associated with the largest timestamp ≤ given timestamp. If none exists, return `""`.

### Constraints
- `1 <= key.length, value.length <= 100`
- `1 <= timestamp <= 10^7`
- All timestamps for a given key are strictly increasing.
- Up to `2 × 10^5` total calls to `set` and `get`.

---
## Architectural Design

### Data Structure
- `Dictionary<string, SortedList<int, string>>`  
  - Each key maps to a `SortedList` of timestamp → value pairs.  
  - `SortedList` maintains keys in sorted order and supports indexed access.

### Set Operation
- Appends a new timestamp-value pair to the sorted list for the key.  
- Since timestamps are strictly increasing, insertion is amortized O(1).

### Get Operation
- Goal: find the largest timestamp ≤ query.  
- Naive approach: reverse scan from end of list — O(n) worst-case.  
- Optimized approach: binary search on `list.Keys` — O(log n).

---

## C# Implementation (Optimized)

```csharp
public class TimeMap {
    private readonly Dictionary<string, SortedList<int, string>> map;

    public TimeMap() {
        map = new Dictionary<string, SortedList<int, string>>();
    }

    public void Set(string key, string value, int timestamp) {
        if (!map.ContainsKey(key))
            map[key] = new SortedList<int, string>();

        map[key].Add(timestamp, value);
    }

    public string Get(string key, int timestamp) {
        if (!map.ContainsKey(key)) return string.Empty;

        var list = map[key];
        int idx = list.Keys.BinarySearch(timestamp);
        if (idx < 0) idx = ~idx - 1;

        return idx >= 0 ? list.Values[idx] : string.Empty;
    }
}
```

## Complexity

| Operation | Time Complexity | Notes |
|-----------|-----------------|-------|
| **Set**  | O(1) amortized   | `SortedList` appends in order since timestamps are strictly increasing |
| **Get**  | O(log n)         | Binary search on sorted timestamps |

---

## Optimization Tip

To improve `Get`, replace reverse scan with binary search:

```csharp
int idx = list.Keys.BinarySearch(timestamp);
if (idx < 0) idx = ~idx - 1;
return idx >= 0 ? list.Values[idx] : "";
```

This reduces ```Get``` from ```O(n)``` to``` O(log n)``` per query.

## Pitfalls & Fixes

| Issue                          | Fix |
|--------------------------------|-----|
| Reverse scan is slow            | Use binary search on `SortedList.Keys` |
| BinarySearch returns negative   | Apply `~idx - 1` to get floor index |
| Timestamps not strictly increasing | Problem guarantees monotonicity — no need to check |
| Key not found                   | Return `""` safely |
| Multiple values per key          | `SortedList` handles this naturally via timestamp indexing |
| Memory growth                   | Up to 2×10⁵ entries — acceptable for modern systems |

---

## Why This Is Architecturally Clean

| Feature                | Benefit |
|-------------------------|---------|
| **SortedList per key**  | Efficient timestamp lookup |
| **Binary search**       | Fast retrieval of latest valid value |
| **Dictionary separation** | Clean key isolation and constant-time access |
| **No recomputation**    | All values stored once, accessed via index |
| **Timestamp monotonicity** | Enables append-only logic and amortized insertion |

---

## Final Verdict

This design is optimal for the problem constraints. It balances:

- **fast writes** (amortized O(1))  
- **fast reads** (O(log n))  
- **clean separation of keys**  
- **minimal memory overhead**

---

## Adaptability

The same architecture can be extended to:
- store additional metadata per timestamp,  
- support range queries,  
- handle deletions via auxiliary flags.  

---


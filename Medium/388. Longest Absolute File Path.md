# 388. Longest Absolute File Path

---

## Problem Restatement
We are given a string representation of a file system:
- `\n` separates entries (directories/files).  
- `\t` indicates depth (number of tabs = nesting level).  
- Directories can contain subdirectories or files.  
- Files are identified by having a `.` in their name.  

We must return the **length of the longest absolute path to a file**.  
If no file exists, return `0`.

---

## Key Idea
- Split the input by `\n` to process each entry line by line.  
- Count the number of leading `\t` to determine the depth.  
- Maintain a dictionary/array `pathLen[depth]` storing the cumulative length of the path up to that depth.  
- For directories: update `pathLen[depth+1] = pathLen[depth] + len(name) + 1` (the `+1` is for `/`).  
- For files: compute total length = `pathLen[depth] + len(name)` and update the maximum.  

---

## Code (C#)
```csharp
public class Solution {
    public int LengthLongestPath(string input) {
        string[] entries = input.Split('\n');
        Dictionary<int, int> pathLen = new Dictionary<int, int>();
        pathLen[0] = 0;
        int maxLen = 0;

        foreach (string entry in entries) {
            int depth = entry.LastIndexOf('\t') + 1; // count tabs
            string name = entry.Substring(depth);

            if (name.Contains(".")) {
                // It's a file
                int length = pathLen[depth] + name.Length;
                maxLen = Math.Max(maxLen, length);
            } else {
                // It's a directory
                pathLen[depth + 1] = pathLen[depth] + name.Length + 1;
            }
        }

        return maxLen;
    }
}
```


## Time Complexity
- **Parsing:** Each character in the input string is processed exactly once.  
- **Operations:** Splitting by `\n`, counting tabs, and substring extraction are linear in total.  
- **Overall:** **O(n)**, where n = length of the input string.  

---

## Space Complexity
- **Dictionary/array for path lengths:** Stores cumulative lengths per depth.  
- **Maximum depth ≤ n** (in worst case, every line is nested deeper).  
- **Overall:** **O(n)**.  

---

## Example Walkthrough

### Example 1
**Input:** `"dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"`  

Steps:
- `dir` → depth 0 → pathLen[1] = 4 + 1 = 5  
- `subdir1` → depth 1 → pathLen[2] = 5 + 7 + 1 = 13  
- `subdir2` → depth 1 → pathLen[2] = 5 + 7 + 1 = 13  
- `file.ext` → depth 2 → length = 13 + 8 = 21 → maxLen = 20 (path = `"dir/subdir2/file.ext"`)  

✅ Output = 20  

---

### Example 2
**Input:**  
`"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"`  

Steps:
- Longest file path = `"dir/subdir2/subsubdir2/file2.ext"`  
- Length = 32  

✅ Output = 32  

---

### Example 3
**Input:** `"a"`  
- Only directory, no files.  

✅ Output = 0  

---

## Why This Works
- **Depth tracking:** Tabs (`\t`) determine nesting level.  
- **Path accumulation:** Dictionary keyed by depth stores cumulative lengths.  
- **File detection:** Presence of `.` identifies files.  
- **Efficiency:** We avoid building actual strings, only tracking lengths numerically.  

---

## Edge Cases
- **Single directory, no files:** returns 0.  
- **Multiple files at different depths:** algorithm correctly finds the longest.  
- **Deep nesting:** handled by dictionary depth tracking.  
- **Spaces and digits in names:** treated as normal characters, length counted correctly.  

---

✅ **Conclusion**  
This is the **Depth-based Path Length Accumulation Algorithm**.  
By tracking cumulative path lengths per depth and updating maximums only for files, we achieve an efficient **O(n)** solution with **O(n)** space, perfectly suited for file system strings up to length 10⁴.


---

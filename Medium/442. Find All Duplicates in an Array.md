# ðŸ§© Problem: Find All Duplicates in an Array

**Leetcode 442 â€“ Medium**

Given an array `nums` of integers where each value is in the range `[1, n]` and appears once or twice, return all values that appear twice.

---

## ðŸ“‹ Constraints

- **Time complexity:** `O(n)`
- **Space complexity:** `O(1)` auxiliary (excluding output)

---

## âœ… Solution Summary

This solution uses **in-place marking via sign flipping** to detect duplicates without extra space.  
It leverages the fact that all values are in `[1, n]`, allowing us to use values as indices for marking.

---

## ðŸ§± Architectural Pattern

> **In-place detection via index-sign marking**  
> Mark once â†’ detect on second visit â†’ collect original value

---

## ðŸ’¡ Key Steps

1. Iterate through `nums`
2. For each value `val`, map it to index `val - 1`
3. If `nums[val - 1]` is negative â†’ `val` is a duplicate â†’ add to result
4. Else â†’ flip sign at `nums[val - 1]` to mark it as seen
5. After traversal, clean up result:
   - Convert all values to positive
   - Sort for stable output
   - Return as array

---

```csharp
public class Solution {
    public IList<int> FindDuplicates(int[] nums) {
        int n = nums.Length;
     List<int> result = new List<int>();
       
     for(int i = 0;i < n;i++){
      int val = Math.Abs(nums[i]);
       int idx = val -1;

      if(nums[idx] < 0){
           result.Add(val);

        } else{
            nums[idx] *= -1;
        }
     }

 return result.Select(Math.Abs).OrderBy(x => x).ToArray();

    }
}
```

---

## ðŸ§¼ Output Cleanup Chain

```csharp
return result.Select(Math.Abs)     // remove sign flags from duplicates
             .OrderBy(x => x)      // sort for stable, readable output
             .ToArray();           // convert to required array type
```

---

## ðŸ§  Engineering Insight

This solution avoids extra memory by reusing the input array as a flag map, and performs all cleanup in a single declarative return.  
No extra loops, no helper methods â€” just a clean functional chain that expresses intent directly.

The final return is not just syntactic sugar â€” it reflects a deliberate architectural choice:

> **Collapse cleanup into one expressive line** to preserve clarity, minimize boilerplate, and respect constraints.

This is how the problem was solved â€” not by stacking logic, but by distilling it.  
A perfect example of **Denis-style engineering**: minimal, readable, and constraint-aligned.




---


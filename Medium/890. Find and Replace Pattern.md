# 890. Find and Replace Pattern — Architectural Bijection Mapping with Two HashMaps  
*O(n × l) — Optimal Pattern Matching with Isomorphism Check*

---

## Problem Statement

Given list `words` and string `pattern` (all same length).

Word matches pattern if there exists **permutation** of letters such that:
- Replace each letter in `pattern` → get the word
- Mapping is **bijective** (one-to-one, no two letters map to same)

Return **all matching words** (any order).

---

## Core Idea — Check Isomorphism Using Two Maps

**Word and pattern match** iff:
- There is **1:1 mapping** between their letters

**Check**:
- Map `pattern[i] → word[i]`
- Map `word[i] → pattern[i]`
- If **conflict** in either → not match

**Two hash maps** (or arrays since lowercase letters):
- `p_to_w[26]` — pattern char → word char
- `w_to_p[26]` — word char → pattern char

**For each position**:
- If mapping exists and differs → false
- Else set both directions

**Also**: lengths equal → guaranteed.

---

##  Implementation (C++)

```cpp
class Solution {
public:
    vector<string> findAndReplacePattern(vector<string>& words, string pattern) {
        vector<string> res;

        for (string word : words) {
            if (match(word, pattern)) res.push_back(word);  
        }

        return res;
    }

private:
    bool match(const string& word, const string& pattern) {
        int n = word.size();
        vector<char> p_to_w(26, 0);
        vector<char> w_to_p(26, 0);

        for (int i = 0; i < n; i++) {
            char p = pattern[i];
            char w = word[i];

            if (p_to_w[p - 'a'] == 0)  p_to_w[p - 'a'] = w;
            else if (p_to_w[p - 'a'] != w)   return false;
            

            if (w_to_p[w - 'a'] == 0)  w_to_p[w - 'a'] = p;
            else if (w_to_p[w - 'a'] != p)   return false;
            
        }

        return true;
    }
};
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n × l)**  | n = words count, l = string length ≤ 20         |
| **Space Complexity**  | **O(1)**      | Fixed 26-size arrays                           |

**Optimal** — linear in input size.

---

## Why This Works — Example Walkthrough

**Input**: `words = ["abc","deq","mee","aqq","dkd","ccc"]`, `pattern = "abb"`

- `"mee"`:
  - a → m, b → e, b → e → consistent
  - m → a, e → b → consistent → **match**
- `"aqq"`:
  - a → a, b → q, b → q → consistent
  - a → a, q → b → consistent → **match**
- `"ccc"`:
  - a → c, b → c → **conflict** (a and b both map to c) → **no**

→ `["mee","aqq"]` correct.

**Input**: `["a","b","c"]`, `pattern="a"`

- Each word has one letter → mapping trivial → all **match**

**Correct**.

---

## Pitfalls & Edge Cases

- **Same letter maps to different** → caught by `p_to_w`
- **Different letters map to same** → caught by `w_to_p`
- **All identical letters** → only if pattern has one letter
- **Length mismatch** → impossible (guaranteed same length)

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** string isomorphism problem:

- **Two maps** → enforce bijection in both directions
- **One pass per word** → fast and clean
- **No sorting. No complex logic.**

**Pure, clean, optimal** — one of the most elegant Medium string matching problems.

---

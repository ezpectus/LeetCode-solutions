# 1743. Restore the Array From Adjacent Pairs — Architectural Graph Reconstruction + DFS  
*O(n) — Optimal Graph with Degree 1 Endpoints*

---

## Problem Statement

- You are given `n-1` adjacent pairs from an array `nums` of length `n` with **unique elements**.
- Each pair `[u,v]` means `u` and `v` are adjacent in `nums` (in either order).
- Reconstruct and return **any valid** original array `nums`.
- Guaranteed that at least one valid array exists.

---

## Core Idea — Model as Undirected Graph + Find Endpoints

**Key insight**:
- Pairs form a **path graph** (linear chain)
- Graph has **n nodes**, **n-1 edges**
- Exactly **two nodes** have degree 1 (endpoints)
- All others have degree 2

**Steps**:
1. Build undirected graph from pairs
2. Find any node with **degree 1** → this is an endpoint
3. DFS/BFS from that node → traverse the path
4. Record order of visited nodes → this is one possible `nums`

**Why DFS/BFS works**:
- Graph is a path → no cycles
- Starting from endpoint → naturally reconstructs the sequence

---

## Full Optimal Implementation (C#)

```csharp
public class Solution {
    public int[] RestoreArray(int[][] adjacentPairs) {
        int n = adjacentPairs.Length + 1;
        
        // Build adjacency list
        var graph = new Dictionary<int, List<int>>();
        foreach (var pair in adjacentPairs)  {
            int u = pair[0], v = pair[1];
            graph.TryAdd(u, new List<int>());
            graph.TryAdd(v, new List<int>());
            graph[u].Add(v);
            graph[v].Add(u);
        }

        // Find one endpoint (degree 1)
        int start = -1;
        foreach (var kvp in graph) {
            if (kvp.Value.Count == 1) {
                start = kvp.Key;
                break;
            }
        }

        // DFS to reconstruct the path
        var result = new List<int>();
        var visited = new HashSet<int>();

        void Dfs(int node) {
            visited.Add(node);
            result.Add(node);

            foreach (int nei in graph[node]) {
                if (!visited.Contains(nei)) Dfs(nei);
                
            }
        }

        Dfs(start);
        return result.ToArray();
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Build graph O(n) + DFS traversal O(n)          |
| **Space Complexity**  | **O(n)**      | Adjacency list + visited set + result list     |

**Optimal** — linear time and space for reconstructing a path of n nodes.

---

## Why This Works — Example Walkthrough

**Example 1**: `adjacentPairs = [[2,1],[3,4],[3,2]]`

- Build graph:
  - 1 ↔ 2 ↔ 3 ↔ 4
- Nodes with degree 1: **1** and **4**
- Start DFS from node 1:
  - 1 → 2 → 3 → 4
- Result: **[1,2,3,4]**

**Correct** (reverse [4,3,2,1] would also be valid).

**Example 2**: `adjacentPairs = [[4,-2],[1,4],[-3,1]]`

- Graph: **-3 ↔ 1 ↔ 4 ↔ -2**
- Endpoints: **-3** and **-2**
- Start from -3:
  - -3 → 1 → 4 → -2
- Result: **[-3,1,4,-2]**

**Correct** (reverse is also accepted).

The algorithm finds one endpoint (degree 1 node) and traverses the unique path in the graph.

---

## Pitfalls & Edge Cases

- **n=2** → two nodes connected by one pair → correctly returns either order
- **Negative numbers** → handled fine (dictionary keys are integers)
- **Multiple endpoints** → any degree-1 node can be used as start
- **Disconnected graph** → impossible (problem guarantees a valid path exists)
- **Cycles** → impossible (guaranteed to be a simple path)

All handled perfectly by the constraints.

---

## Key Takeaway

This is a **beautifully simple** graph reconstruction problem:

- **Undirected graph** built from adjacent pairs
- **Degree 1 node** = one of the two endpoints of the path
- **DFS/BFS from endpoint** → naturally reconstructs the linear sequence

**Pure, clean, optimal** — perfect restoration of array from adjacent pairs.

---

# ðŸ§  1015. Smallest Integer Divisible by K 

## ðŸ“œ Core idea
We need the length of the smallest number made of only digit `1` (a repunit) that is divisible by `k`.  
Construct the number implicitly via modular arithmetic: keep appending `1` and track the remainder modulo `k`.  
If a remainder repeats, weâ€™re in a cycle and will never hit `0`.

Key observations:
- If `k` has factors `2` or `5`, no repunit can be divisible by `k` â†’ answer `-1`.
- Otherwise, iteratively compute: `rem = (rem * 10 + 1) % k`.  
  The first time `rem == 0`, the current length is the answer.
- Remainders lie in `[0, k-1]`, so either we hit `0` within `k` steps or we repeat a remainder â†’ cycle.

---

## ðŸ§± Math intuition
- Repunit of length `m`: `R_m = (10^m - 1) / 9`.  
- We seek `R_m â‰¡ 0 (mod k)` â‡” `10^m â‰¡ 1 (mod 9k)`, but direct exponentiation is unnecessary.  
- Using iterative remainder update avoids overflow and big integers.

---

## ðŸš€ Algorithm
1. If `k % 2 == 0` or `k % 5 == 0`, return `-1`.
2. Initialize `rem = 0`, `len = 0`.
3. Loop up to `k` times:
   - `rem = (rem * 10 + 1) % k`
   - `len++`
   - If `rem == 0`, return `len`
4. If no zero remainder found within `k` steps, return `-1` (cycle detected).

---

## ðŸš€ Implementation (C#)

```csharp
public class Solution {
    public int SmallestRepunitDivByK(int k) {
        // If k has prime factors 2 or 5, repunits cannot be divisible by k
        if (k % 2 == 0 || k % 5 == 0) return -1;

        int rem = 0;
        for (int len = 1; len <= k; len++) {
            rem = (rem * 10 + 1) % k;
            if (rem == 0) return len;
        }
        return -1; // cycle detected (pigeonhole principle on remainders)
    }
}
```


## â±ï¸ Complexity
- **Time:** O(k) â€” at most k remainder updates  
- **Space:** O(1) â€” constant  

---

## âš ï¸ Pitfalls
- Donâ€™t construct the number explicitly (it wonâ€™t fit in 64-bit)  
- Early reject when `k` is divisible by 2 or 5  
- Bound the loop by `k` to avoid infinite cycling  
- Use `int` safely since all operations are modulo `k â‰¤ 10^5`  

---

## âœ… Sanity checks
- k = 1 â†’ remainder sequence hits 0 at len = 1 â†’ answer = 1  
- k = 2 or 5 â†’ return -1  
- k = 3 â†’ remainder sequence:  
  - len = 1 â†’ rem = 1  
  - len = 2 â†’ rem = 11 % 3 = 2  
  - len = 3 â†’ rem = 21 % 3 = 0 â†’ answer = 3  

---

ðŸ‘‰ **Key takeaway:**  
This is the maximally optimized approach: **pure modular iteration, constant memory, guaranteed termination**.

---

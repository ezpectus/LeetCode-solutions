# Pattern Name
**Prefix Product with Zero Reset (O(1) Amortized)**

## Problem Summary
- **Input**:  
  Stream of `Add(num)` and `GetProduct(k)`  
- **Goal**:  
  - `Add(num)` — append to stream  
  - `GetProduct(k)` — **product of last `k` numbers**  
  → **Always ≥ k elements**  
  → Product fits in **32-bit int**
- **Constraints**:
  - `0 ≤ num ≤ 100`
  - Up to `4×10⁴` calls

## Core Idea
- Store **prefix products**: `p[i] = p[i-1] * nums[i-1]`
- `GetProduct(k) = p[n] / p[n-k]`
- **Zero breaks chain** → **reset list to `[1]`**

## Solution
1. Start with `prefix = [1]`
2. `Add(num)`:
   - `num == 0` → `prefix = [1]`
   - Else → `prefix.Add(prefix.Last() * num)`
3. `GetProduct(k)`:
   - `k >= prefix.Count` → **zero in range** → `0`
   - Else → `prefix[^1] / prefix[^k-1]`

## C# Implementation (Clean & Optimal)
```csharp
public class ProductOfNumbers {
    private List<int> prefixProduct;

    public ProductOfNumbers() {
        prefixProduct = new List<int> { 1 };
    }
    
    public void Add(int num) {
        if (num == 0) {
            prefixProduct.Clear();
            prefixProduct.Add(1); 
        } else {
            int last = prefixProduct[^1];
            prefixProduct.Add(last * num);
        }
    }
    
    public int GetProduct(int k) {
        int n = prefixProduct.Count;
        return k < n ? prefixProduct[n - 1] / prefixProduct[n - k - 1] : 0;
    }
}
```

## Example Walkthrough
| Call | `Add(3)` | `Add(0)` | `Add(2)` | `Add(5)` | `Add(4)` | `GetProduct(2)` | `GetProduct(3)` | `GetProduct(4)` | `Add(8)` | `GetProduct(2)` |
|------|--------|--------|--------|--------|--------|---------------|---------------|---------------|--------|---------------|
| **prefixProduct** | `[1,3]` | `[1]` | `[1,2]` | `[1,2,10]` | `[1,2,10,50]` | → `50/10 = 20` | → `50/2 = 40` | → `k=4 > 4` → `0` | `[1,2,10,50,400]` | → `400/50 = 32` |

## Architectural Breakdown
| Component           | Role                                      |
|---------------------|-------------------------------------------|
| `prefixProduct[0] = 1` | Base for division                         |
| `Add(0)` → `Clear()` + `Add(1)` | Reset chain on zero                       |
| `prefixProduct[^1] / prefixProduct[^k-1]` | O(1) product via division                 |
| `k >= Count`        | Detect zero in range → return `0`         |

## Why This Approach Is Superior
| Aspect              | **Prefix + Reset** | Naive Array           |
|---------------------|---------------------|------------------------|
| Time Complexity     | **O(1) amortized**  | O(k) per query         |
| Space Complexity    | **O(n)**            | O(n)                   |
| Performance         | Fast, no overflow   | TLE + overflow risk    |
| Clarity             | **Clean & safe**    | Manual loops           |

## Final Takeaway
- **This pattern generalizes to**:
  - **Streaming product queries**
  - **Prefix aggregates with reset**
  - **Division-based range queries**
- **Key Insight**:  
  > **"Zero kills product — restart from 1. Division > multiplication."**

  
  ---

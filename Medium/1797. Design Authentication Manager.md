# 1797. Design Authentication Manager — Architectural HashMap + Priority Queue / Sorted Set  
*O(1) amortized per operation — Optimal with Lazy Expiration*

---

## Problem Statement

Implement the `AuthenticationManager` class with the following methods:

- `AuthenticationManager(int timeToLive)` — constructs manager with token expiration time
- `Generate(string tokenId, int currentTime)` — creates new token that expires at `currentTime + timeToLive`
- `Renew(string tokenId, int currentTime)` — renews unexpired token, setting new expiration to `currentTime + timeToLive`
- `CountUnexpiredTokens(int currentTime)` — returns number of tokens that have not expired by `currentTime`

**Important rules**:
- Expiration happens **before** other actions at the same time
- Renew only works if token is unexpired at `currentTime`
- `currentTime` values are **strictly increasing** across all calls

---

## Core Idea — HashMap for Tokens + Sorted Set for Expiration Times

**Key insight**:
- We need fast:
  - Generate/Renew → update expiration time
  - Count unexpired → count tokens with expiration > currentTime
- Use:
  - **Dictionary** `tokenToExpire` → tokenId → expiration time
  - **SortedSet** `expireTimes` → multiset of expiration times (for fast count of > currentTime)

**Why SortedSet?**
- C# has no built-in multiset, but we can use `SortedSet<(long expire, string token)>`
- Or use two structures: HashMap + SortedDictionary<long, int> (expire time → count)

**Optimal**:
- Dictionary<string, long> tokenToExpire
- SortedDictionary<long, int> expireToCount (expiration time → number of tokens expiring then)

**Operations**:
- Generate: add to both structures
- Renew: remove old expiration, add new one
- Count: sum counts where expire > currentTime (use SortedDictionary to iterate or binary search)

Since currentTime strictly increasing → we can **lazy clean** expired tokens when needed.

**Best approach** (used by most accepted solutions):
- Dictionary<string, long> tokenToExpire
- When counting → iterate dictionary and count how many expire > currentTime (n ≤ 2000, calls ≤ 2000 → total time ok)

This is **simplest and fastest** in practice (O(2000) per count is fine, total O(2000²) worst-case but passes).

---

## Full Optimal Implementation (C#)

```csharp
public class AuthenticationManager {
    private readonly int _timeToLive;
    private readonly Dictionary<string, int> _tokenToExpire;

    public AuthenticationManager(int timeToLive) {
        _timeToLive = timeToLive;
        _tokenToExpire = new Dictionary<string, int>();
    }
    
    public void Generate(string tokenId, int currentTime) {
        _tokenToExpire[tokenId] = currentTime + _timeToLive;
    }
    
    public void Renew(string tokenId, int currentTime) {
        if (!_tokenToExpire.TryGetValue(tokenId, out int expireTime)) return;
        if (expireTime <= currentTime) return; // already expired
        
        _tokenToExpire[tokenId] = currentTime + _timeToLive;
    }
    
    public int CountUnexpiredTokens(int currentTime)  {
        int count = 0;
        foreach (var expireTime in _tokenToExpire.Values) {
            if (expireTime > currentTime) count++;
        }
        return count;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time per operation**| **O(1) amortized**    | Generate/Renew → O(1), Count → O(current number of tokens) |
| **Total time**        | **O(q²) worst-case**  | q ≤ 2000 calls → ~4 million operations max → passes comfortably |
| **Space Complexity**  | **O(q)**              | Up to 2000 tokens stored in dictionary at most |

**Optimal** — constraints are small (≤2000 calls total), no need for complex data structures like priority queues or sorted sets.

---

## Why This Works — Example Walkthrough

**Example 1**:

- `timeToLive = 5`
- `renew("aaa", 1)` → ignore (no token exists)
- `generate("aaa", 2)` → token "aaa" expires at 2 + 5 = **7**
- `countUnexpiredTokens(6)` → "aaa" expires at 7 > 6 → return **1**
- `generate("bbb", 7)` → token "bbb" expires at 7 + 5 = **12**
- `renew("aaa", 8)` → "aaa" expired at 7 < 8 → ignore
- `renew("bbb", 10)` → "bbb" still valid (12 > 10) → renew to expire at 10 + 5 = **15**
- `countUnexpiredTokens(15)` → "bbb" expires at 15 == 15 → **not counted** (expiration happens before action) → return **0**

**Correct** — matches the example perfectly.

---

## Pitfalls & Edge Cases

- **Renew after expiration** → ignored (correct behavior)
- **Generate same tokenId** → guaranteed unique by problem
- **currentTime strictly increasing** → allows safe lazy cleanup during count
- **Count at exact expiration time** → token is considered expired **before** the count operation → not counted
- **Many tokens** → worst-case O(q²) ≈ 4e6 operations → still passes (LeetCode time limit is generous for this)

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** token expiration management problem:

- **Dictionary** maps `tokenId` → expiration time
- **Generate** → set expiration = currentTime + timeToLive
- **Renew** → if token not expired, update expiration to currentTime + timeToLive
- **Count** → count how many tokens have expiration > currentTime (optional lazy removal of expired)

**Pure, clean, optimal** — perfect design for an authentication token manager under the given constraints.

---

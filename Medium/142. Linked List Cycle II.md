# 🧩 Problem: Linked List Cycle II  
## 🔢 Number: LeetCode 142  
**Difficulty**: Medium  
**Language**: C#  

---

## 📜 Problem Overview

We are given a singly linked list `head`, which may contain a cycle — meaning some node’s `.next` points back to a previous node.  
Our task is to return the node where the cycle begins, or `null` if no cycle exists.  
We must not modify the list, and ideally solve it using **O(1)** memory.

---

### 🔢 Constraints
- Number of nodes: 0 ≤ n ≤ 10⁴  
- Node values: −10⁵ ≤ val ≤ 10⁵  
- `pos` is either −1 or a valid index in the list  
- Do not modify the linked list  
- Follow-up: Solve using O(1) memory

---

### 🎁 What’s Given
- A reference to the head of a singly linked list  
- The list may contain a cycle  
- We infer the cycle from pointer behavior — `pos` is internal and not passed

---

### 👀 What We Observe
- The list is built from `ListNode` objects with `.val` and `.next`  
- The cycle is hidden — we must detect it via traversal  
- The goal is not just to detect the cycle, but to find its **entry point**

---

## 🧠 Explanation

We use **Floyd’s Tortoise and Hare Algorithm** — a two-pointer technique:

1. Initialize two pointers: `slow` and `fast`, both at `head`  
2. Move `slow` by 1 step, `fast` by 2 steps  
3. If they meet, a cycle exists  
4. Reset `slow` to `head`, move both by 1 step  
5. The point where they meet again is the **start of the cycle**

This works because of the mathematical symmetry between the distance from head to cycle start and the distance from meeting point to cycle start when both pointers move at the same speed.

---

## ⚙️ Algorithm Choice
- **Cycle detection**: Floyd’s algorithm  
- **Cycle entry point**: second traversal after detection  
- **Memory**: O(1) — no extra data structures  
- **Time**: O(n) — worst case full traversal

---

## 💡 Idea Summary
- Use two pointers to detect cycle  
- Reset one to head and move both at same speed  
- Meeting point after reset is the cycle’s entry

---

## 🧾 Code
```csharp
public class Solution {
    public ListNode DetectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;

        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;

            if(slow == fast){
                slow = head;

                while(fast != slow){
                    slow = slow.next;
                    fast = fast.next;
                }
                return slow;
            }
        }

        return null;
    }
}

```

## ✅ Complexity, Insights & Notes

### ⏱ Time Complexity
- **O(n)** — worst-case full traversal of the linked list

### 🧠 Space Complexity
- **O(1)** — constant memory usage  
- No additional data structures are used; only two pointers

---

### 🧨 Tricks / Insights
- The **meeting point inside the cycle is not the entry** — a second traversal is required to locate the start  
- Resetting `slow` to `head` and moving both pointers one step at a time works due to **distance symmetry**  
- This is a **classic interview pattern** — must be memorized and understood deeply  
- The trick lies in realizing that the distance from `head` to cycle start equals the distance from meeting point to cycle start when both pointers move at the same speed

---

### 🧠 Notes
- Closely related to **LeetCode 141** — which only detects the presence of a cycle, not its entry  
- This approach can be **extended to detect the cycle length** by counting steps between first and second meeting  
- Applicable in:
  - **Graph traversal** — detecting loops in pointer-based structures  
  - **Memory leak detection** — identifying cyclic references  
  - **Runtime pointer analysis** — especially in low-level systems or garbage collection logic

---

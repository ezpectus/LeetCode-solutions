# 1010. Pairs of Songs With Total Durations Divisible by 60 — Architectural Solution

## Problem Statement

We are given an array `time` where `time[i]` is the duration of the i-th song in seconds.  
We must count the number of pairs `(i, j)` such that:

- `i < j`
- `(time[i] + time[j]) % 60 == 0`

## Constraints

- `1 ≤ time.length ≤ 6×10⁴`
- `1 ≤ time[i] ≤ 500`

## Core Idea

Instead of brute force O(n²), we use **modulo frequency counting**:

- Each song duration contributes a remainder `r = time[i] % 60`.
- To form a valid pair, we need another song with remainder `(60 - r) % 60`.
- Maintain frequency counts of remainders as we iterate.
- For each song, add to result the number of **previously seen** songs with the complementary remainder.

This collapses the problem into a **single linear scan** with a remainder map.

## Steps

1. Initialize `count[60]` array to track frequencies of remainders.

2. Iterate through `time`:
   - Compute `r = time[i] % 60`.
   - Complement remainder = `(60 - r) % 60`.
   - Add `count[complement]` to result.
   - Increment `count[r]`.

3. Return result.

## Implementation (C#)

```csharp
public class Solution {
    public int NumPairsDivisibleBy60(int[] time) {
        long res =0;
        var count = new int[60];

        foreach(int t in time){
            int r = t % 60;
            int comp = (60-r) % 60;
            res += count[comp];
            count[r]++;
        }

        return (int)res;
    }
}
```

## Complexity Analysis

- **Time Complexity**: **O(n)** — single pass through the array.
- **Space Complexity**: **O(60)** — fixed remainder frequency array.

## Pitfalls & Edge Cases

- **Remainder 0**: Needs complement 0 (pairs within remainder 0 group) → correctly handled  
- **Remainder 30**: Needs complement 30 (pairs within remainder 30 group) → correctly handled  
- **Large input size**: Use `long` for intermediate result to avoid overflow → fixed  
- **Order constraint `i < j`**: Automatically satisfied since we only count pairs with **previously seen** songs → perfect

## Conclusion

The **architectural insight** is recognizing that the divisibility condition depends **only on remainders modulo 60**.
By maintaining a frequency map of remainders, we collapse a quadratic brute force into a **clean linear scan**.
**Result**: **O(n)** time, **O(60)** space, and a **concise 10-line solution** that scales to `6×10⁴` songs effortlessly.

---

# 1986. Minimum Number of Work Sessions to Finish the Tasks  
*O(n × 2ⁿ × sessionTime) — Optimal Bitmask DP + Subset Sum Style*

---

## Problem Statement

You have `n` tasks with durations `tasks[0..n-1]` (1 ≤ n ≤ 14, 1 ≤ tasks[i] ≤ 10).  
You have a limit `sessionTime` (max(tasks) ≤ sessionTime ≤ 15).

You must finish all tasks in **minimum number of work sessions**, where:

- Each session lasts **at most sessionTime** consecutive hours
- Once you start a task in a session, you **must finish it** in the same session
- You can do tasks in **any order**
- You can start a new task immediately after finishing the previous one

Return the **minimum number of sessions** needed.

---

## Core Idea — Bitmask DP + Greedy Session Packing

**Key insight**:
- n ≤ 14 → we can use **bitmask** (2¹⁴ = 16384 states) to represent which subset of tasks is already done
- dp[mask] = minimum number of sessions needed to finish exactly the tasks in mask
- Transition: for each mask, try to choose a **non-empty subset** of undone tasks that fit into one session (sum ≤ sessionTime)
  - Then dp[new_mask] = min(dp[new_mask], dp[mask] + 1)
- Final answer = dp[(1<<n)-1]

**Optimization**:
- Precompute for each subset its total time → skip if > sessionTime
- Iterate over all submasks of remaining tasks using standard submask enumeration
- Time: O(3ⁿ × n) worst-case (submask enumeration), but with n=14 → 3¹⁴ ≈ 4.7M → acceptable

**Even better** — we can do O(2ⁿ × n × sessionTime) with knapsack-style DP per mask, but submask is faster in practice.

---

## Clean Implementation (C#) — Bitmask + Submask Enumeration

```csharp
public class Solution {
    public int MinSessions(int[] tasks, int sessionTime) {
        int n = tasks.Length;
        int full = 1 << n;

        // dp[mask] = min sessions to finish tasks in mask
        int[] dp = new int[full];
        Array.Fill(dp, n + 1); // impossible = n+1
        dp[0] = 0;

        // For each mask of done tasks
        for (int mask = 0; mask < full; mask++)  {
            if (dp[mask] == n + 1) continue;

            // Find undone tasks
            int undone = full - 1 - mask;

            // Try all non-empty submasks of undone tasks for the next session
            for (int sub = undone; sub > 0; sub = (sub - 1) & undone) {
                  int sum = 0;
                for (int i = 0; i < n; i++) {
                    if ((sub & (1 << i)) != 0) {
                        sum += tasks[i];
                        if (sum > sessionTime) break;
                    }
                }

                if (sum <= sessionTime) {
                    int newMask = mask | sub;
                    dp[newMask] = Math.Min(dp[newMask], dp[mask] + 1);
                }
            }
        }

        return dp[full - 1];
    }
}
```

## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(3ⁿ)** worst-case          | For each mask, enumerate all submasks of remaining (undone) tasks → classic 3ⁿ transitions |
| **Realistic Time**    | **Very fast**                 | n ≤ 14 → 3¹⁴ ≈ 4.78 million operations — runs in milliseconds on modern machines |
| **Space Complexity**  | **O(2ⁿ)**                     | DP array of size 2¹⁴ = 16384 integers          |

**Optimal** — exponential only in n (≤ 14), perfectly acceptable and standard for this constraint.

---

## Why This Works — Example Walkthrough

**Example 1**: `tasks = [1,2,3]`, `sessionTime = 3`

- Possible efficient packing:
  - Session 1: 1 + 2 = 3
  - Session 2: 3
- Total sessions = **2** → correct
- DP explores all ways to group tasks into sessions where each group sum ≤ 3, finds minimum number of groups

**Example 3**: `tasks = [1,2,3,4,5]`, `sessionTime = 15`

- Sum = 15 ≤ 15 → all fit in one session → **1** → correct
- DP confirms single session is possible

**Correct** — bitmask DP tries every possible subset of tasks for each new session, ensures the subset sum ≤ sessionTime, and minimizes the total number of such subsets (sessions) needed to cover all tasks.

---

## Pitfalls & Edge Cases

- **k = 0** → only one session allowed → return 1 if total sum ≤ sessionTime, else impossible (but constraints guarantee max(tasks) ≤ sessionTime)
- **n = 14** → 2¹⁴ = 16384 states, 3¹⁴ ≈ 4.8M transitions → still very fast
- **sessionTime = max(tasks)** → at least one task per session in worst case → DP correctly finds ceil(n / 1) or better
- **All tasks = 1** → min sessions = ceil(total_sum / sessionTime) → DP finds optimal packing
- **Empty tasks** → n ≥ 1 by constraints

All handled perfectly.

---

## Key Takeaway

This is a **classic minimum bin packing** problem with tiny n (≤ 14):

- Use **bitmask DP** where state `dp[mask]` = minimum sessions needed to finish exactly the tasks in mask
- Transition: from current mask, try every valid non-empty submask of remaining tasks whose sum ≤ sessionTime
  - Then dp[mask | submask] = min(dp[mask | submask], dp[mask] + 1)
- Use fast submask enumeration or knapsack-style check per mask
- Final answer = dp[(1 << n) - 1]

**Pure, clean, optimal** — O(3ⁿ) worst-case (or O(2ⁿ × n × sessionTime) with knapsack), with n ≤ 14 runs instantly.

---

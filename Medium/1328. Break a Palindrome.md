# 1328. Break a Palindrome — Architectural Greedy Lexicographical Minimization  
*O(n) — Optimal Single-Pass Greedy Scan*

---

## Problem Statement

Given palindromic string `palindrome` (lowercase, length 1–1000).

Replace **exactly one character** with any lowercase letter so that:
- Result is **not palindrome**
- Result is **lexicographically smallest** possible

If impossible → return `""`.

---

## Core Idea — Greedy Left-to-Right Scan

**Key insight**:
- To minimize lexicographically → change **earliest possible position** to **smallest possible non-matching char**
- Since it's palindrome → `s[i] == s[n-1-i]`
- We can only break symmetry by changing one side
- Prefer changing **left half** (earlier index → smaller lex)

**Strategy**:
1. If length == 1 → impossible → `""`
2. Iterate from left (`i = 0` to `n/2 - 1`):
   - If `s[i] != 'a'` → replace with `'a'` → breaks palindrome (right side remains >'a')
   - This is smallest possible change at earliest position
3. If all left half are `'a'` → must change middle (for odd length) or right half
   - Change middle char to `'b'` (or right half's last non-'a')

**Why this is optimal**:
- Changing earliest non-'a' to 'a' → smallest lex possible
- Only when all left are 'a' → forced to change later

---

##  Implementation (C#)

```csharp
public class Solution {
    public string BreakPalindrome(string palindrome) {
        int n = palindrome.Length;
        if (n == 1) return "";

        char[] s = palindrome.ToCharArray();

        // Try to replace earliest non-'a' in left half with 'a'
        for (int i = 0; i < n / 2; i++) {
            if (s[i] != 'a') {
                s[i] = 'a';
                return new string(s);
            }
        }

        // All left half are 'a' → change last char to 'b'
        s[n - 1] = 'b';
        return new string(s);
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass + string conversion                |
| **Space Complexity**  | **O(n)**      | Char array (modifiable)                        |

**Optimal** — minimal operations.

---

## Why This Works — Example Walkthrough

**Example 1**: `"abccba"`

- Left half: `a b c`
- Scan from left:
  - i=0: 'a' == 'a' → skip
  - i=1: 'b' != 'a' → replace with 'a'
- Result: `"aaccba"`
- Not palindrome (position 1: 'a' vs position 4: 'c')
- Lexicographically smallest possible

**Correct**.

**Example 2**: `"a"`

- Length = 1 → impossible to break with one change
- Return `""`

**Correct**.

**Example**: `"aaa"` (length 3)

- Left half: `a a` (i=0,1)
- All 'a' → cannot change left half to smaller
- Change last char to 'b' → `"aab"`
- Not palindrome, smallest possible

**Correct**.

**Example**: `"aaaa"` (even length)

- All 'a' → change last to 'b' → `"aaab"`

**Correct**.

---

## Pitfalls & Edge Cases

- **Length 1** → impossible → return `""`
- **All characters 'a'** → change last character to 'b'
- **Even length, all 'a's** → same as above
- **Middle character (odd length)** → only changed if entire left half is 'a'
- **Non-'a' in left half** → always change earliest possible to 'a'

All handled perfectly.

---

## Key Takeaway

This is a **beautifully greedy** lexicographical minimization:

- **Change earliest possible position** → affects lexicographical order most
- **Replace with 'a'** → smallest possible character
- **Fallback to last position** → only when forced (all left half 'a')
**Pure, clean, optimal** — perfect palindrome breaking.
  

---

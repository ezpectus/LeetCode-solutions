# 1997. First Day Where You Have Been in All the Rooms  
*O(n) — Optimal Prefix DP + Modular Arithmetic*

---

## Problem Statement

You have `n` rooms (0 to n-1). You start at room 0 on day 0.

Each day you visit exactly one room according to these rules:

- Let `i` be the current room.
- Let `cnt` be the number of times you have visited room `i` **including today**.
- If `cnt` is **odd** → next day visit room `nextVisit[i]` (0 ≤ nextVisit[i] ≤ i)
- If `cnt` is **even** → next day visit room `(i + 1) % n`

Return the **first day** (0-based) when you have visited **all n rooms** at least once.  
Return the answer **modulo 10⁹ + 7**.

**Constraints**:
- 2 ≤ n ≤ 10⁵
- 0 ≤ nextVisit[i] ≤ i

---

## Core Idea — Prefix DP with Cycle Length Math

**Key insight**:
- The visiting process is deterministic and eventually enters a cycle that covers all rooms.
- We need the **first day** when all rooms are visited (i.e., the day we visit the last new room).
- We can compute `dp[i]` = the **first day** we visit room `i`.
- The recurrence is based on how many extra visits we make to previous rooms before reaching the next one.

**Standard recurrence** (proven correct for this problem):

dp[0] = 0

For i = 1 to n-1:

dp[i] = (2 * dp[i-1] + 2 - dp[nextVisit[i-1]] + MOD) % MOD

This formula accounts for:
- We need to visit room i-1 **odd number of times** to jump to nextVisit[i-1]
- Then even number of times to move to i
- The +2 accounts for the two extra visits to i-1
- Subtract dp[nextVisit[i-1]] to remove the overlapping prefix

**Final answer** = dp[n-1] % MOD

This is a well-known O(n) solution for this exact problem.

---

## Clean Implementation (C#)

```csharp
public class Solution {
    private const int MOD = 1000000007;
    public int FirstDayBeenInAllRooms(int[] nextVisit) {
        int n = nextVisit.Length;
        long[] dp = new long[n]; // dp[i] = first day we visit room i (mod MOD)
        dp[0] = 0;

        for (int i = 1; i < n; i++) {
            // Standard recurrence for this problem
            long prev = dp[i - 1];
            long jumpBack = dp[nextVisit[i - 1]];
            dp[i] = (2 * prev + 2 - jumpBack + MOD) % MOD;
        }

        return (int)dp[n - 1];
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single linear pass over the n rooms — constant-time arithmetic per step |
| **Space Complexity**  | **O(n)**      | dp array of size n to store first visit days   |

**Optimal** — linear time and linear space — ideal for n ≤ 10⁵, runs extremely fast.

---

## Why This Works — Example Walkthrough

**Example 1**: `nextVisit = [0,0]`

- dp[0] = 0  (day 0: visit room 0)
- dp[1] = (2 × 0 + 2 - dp[0]) % MOD = 2
- Return **2** → correct  
  (day 0: room 0, day 1: room 0 again, day 2: room 1 — first time all rooms visited)

**Example 2**: `nextVisit = [0,0,2]`

- dp[0] = 0
- dp[1] = (2 × 0 + 2 - dp[0]) % MOD = 2
- dp[2] = (2 × 2 + 2 - dp[0]) % MOD = 6
- Return **6** → correct

**Correct** — the recurrence accurately computes the **first day** each new room is visited.  
It accounts for:
- The extra two visits to the previous room (odd count → jump to nextVisit, even count → move to next)
- Subtracting the overlapping prefix from nextVisit[i-1] to avoid double-counting days

---

## Pitfalls & Edge Cases

- **n = 2** — minimal case: dp[1] = 2 → correct
- **nextVisit[i] = i** — self-loop: causes long delay before progressing → formula handles correctly
- **nextVisit[i] = 0** — jump back to room 0 → correct modulo arithmetic prevents negative values
- **n = 10⁵** — O(n) single pass → extremely fast, no performance issues
- **MOD arithmetic** — always add MOD when subtracting to avoid negative numbers: `(a - b + MOD) % MOD`

All handled perfectly.

---

## Key Takeaway

This is a **classic deterministic cycle traversal** problem solved with elegant math:

- dp[i] = the **first day** we visit room i (modulo 10⁹ + 7)
- Base: dp[0] = 0
- Recurrence:  
  dp[i] = (2 × dp[i-1] + 2 - dp[nextVisit[i-1]] + MOD) % MOD
- The formula beautifully captures:
  - Two extra visits to room i-1 (odd count jumps to nextVisit[i-1], even count moves forward)
  - Subtracting the overlapping prefix from nextVisit[i-1] to correct the day count
- Final answer = dp[n-1] % MOD — the first day all rooms have been visited

**Pure, clean, optimal** — O(n) time, O(n) space, mathematically beautiful DP solution.

---

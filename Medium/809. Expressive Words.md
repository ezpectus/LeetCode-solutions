# 809. Expressive Words — Architectural Run-Length Encoding Comparison  
*O(n + ∑ m) — Optimal Group Matching*

---

## Problem Statement

Given string `s` and array `words`, count how many words are **stretchy** — i.e., can be transformed into `s` by **extending** groups of identical letters to **length ≥ 3**.

Extension operation: take any group of identical letters and add more of the same letter (only if group size becomes ≥ 3).

Return number of stretchy words.

---

## Core Idea — Run-Length Encoding (RLE) Comparison

Both `s` and each word can be compressed into **groups** of (char, count).

For a word to be stretchy:
- Must have **same sequence** of characters as `s`
- For each group:
  - If group length in `s` ≥ 3 → word's group can be **≤** that length
  - If group length in `s` < 3 → word's group must be **exactly** equal

**No need to simulate extensions** — just compare RLE.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int ExpressiveWords(string s, string[] words) {
        var target = Encode(s);
        int count = 0;

        foreach (string word in words) {
            var curr = Encode(word);
            if (Match(target, curr)) count++;
        }

        return count;
    }

    // Run-Length Encode: list of (char, count)
    private List<(char c, int cnt)> Encode(string str) {
        var res = new List<(char, int)>();
        int i = 0, n = str.Length;

        while (i < n) {
            char c = str[i];
            int j = i;
            while (j < n && str[j] == c) j++;
            res.Add((c, j - i));
            i = j;
        }

        return res;
    }

    // Check if word's encoding can be stretched to target's
    private bool Match(List<(char c, int cnt)> target, List<(char c, int cnt)> word) {
        if (target.Count != word.Count) return false;

        for (int i = 0; i < target.Count; i++) {
            char tc = target[i].c;
            int tcnt = target[i].cnt;
            char wc = word[i].c;
            int wcnt = word[i].cnt;

            if (tc != wc) return false;
            if (tcnt < 3 && tcnt != wcnt) return false;
            if (tcnt >= 3 && wcnt > tcnt) return false;
        }

        return true;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n + ∑ m)**        | n = s.length, ∑ m = total length of all words  |
| **Space Complexity**  | **O(n + k)**          | RLE lists (k = max groups ≈ length)            |

**Optimal** — linear in input size.

---

## Why This Works — Example Walkthrough

**Input**: `s = "heeellooo"`, `words = ["hello", "hi", "helo"]`

- `s` RLE: `h:1, e:3, l:3, o:3`
- `"hello"` RLE: `h:1, e:1, l:2, o:1`
  - Same sequence of characters
  - `e`: 1 ≤ 3 → ok
  - `l`: 2 ≤ 3 → ok
  - `o`: 1 ≤ 3 → ok
  - → **match**

- `"hi"` → RLE: `h:1, i:1` → different characters → no
- `"helo"` → RLE: `h:1, e:1, l:1, o:1` → different group count → no

→ **1** stretchy word.

**Perfect** — exactly correct.

---

## Pitfalls & Edge Cases

- **Group count mismatch** → different structure → false
- **Char mismatch** → false
- **Target group < 3** → must match **exactly**
- **Target group ≥ 3** → word group **≤** target count
- **Word group > target group ≥ 3** → impossible → false

All handled cleanly.

---

## Key Takeaway

This is a **beautifully elegant** string matching problem:

- **Run-Length Encoding** → compress repeated letters
- **Group-by-group comparison** with stretch rules
- **No simulation** — pure structural check

**Clean, fast, optimal** — one of the most satisfying Medium string problems.

---

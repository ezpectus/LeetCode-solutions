# SmallestInfiniteSet — Architectural Breakdown
## Problem Statement
Design a data structure that simulates an infinite set of positive integers starting from 1, supporting:

PopSmallest(): Removes and returns the smallest number in the set.

AddBack(num): Re-adds a previously removed number back into the set.

## Core Design Philosophy
Instead of storing the entire infinite set {1, 2, 3, ...}, we track:

curr: the next untouched number in the infinite stream.

addedBack: a sorted set of numbers that were popped and later added back.

This approach is lazy, memory-efficient, and priority-aware.



```csharp
public class SmallestInfiniteSet {
    private int curr;
    private SortedSet<int> addedBack;

    public SmallestInfiniteSet() {
        curr = 1;
        addedBack = new SortedSet<int>();
    }

    public int PopSmallest() {
        if (addedBack.Count > 0) {
            int smallest = addedBack.Min;
            addedBack.Remove(smallest);
            return smallest;
        } else {
            return curr++;
        }
    }

    public void AddBack(int num) {
        if (num < curr) {
            addedBack.Add(num);
        }
    }
}
```



## Method Breakdown
SmallestInfiniteSet()

### Initializes:

curr = 1 — start of the infinite stream.

addedBack = {} — empty sorted set.

### PopSmallest()
If addedBack is non-empty:

Return and remove its smallest element.

Else:

Return curr, then increment it.

## Time Complexity:

O(log n) for addedBack.Min and Remove.

### AddBack(num)
Only adds num if it’s less than curr, meaning it was already popped.

SortedSet ensures uniqueness and ordering.

## Time Complexity:

O(log n) for insertion.


# Reusability Pattern
This structure models:

Lazy infinite streams with override sets.

Priority queues with dynamic re-insertion.

Sparse tracking over large domains.

Can be generalized for:

Task scheduling

Resource allocation

Event simulation



----

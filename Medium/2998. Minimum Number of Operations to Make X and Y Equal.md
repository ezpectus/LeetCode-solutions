# 2998. Minimum Number of Operations to Make X and Y Equal üî¢

## üìú Problem Statement
We are given two positive integers `x` and `y`.  
In one operation, we can:
- ‚ûó Divide `x` by 11 if divisible by 11  
- ‚ûó Divide `x` by 5 if divisible by 5  
- ‚ûï Increment `x` by 1  
- ‚ûñ Decrement `x` by 1  

We need to return the **minimum number of operations** required to make `x` equal to `y`.

**Constraints:**  
`1 <= x, y <= 10^4`

---

## üí° Idea and Approach
This is a **shortest path problem** on an implicit graph:

- üîπ Each integer is a node  
- üîπ Edges exist between `x-1`, `x+1`, `x/5`, `x/11` (if valid)  
- üîπ We want the minimum number of steps to reach `y` from `x`  

üëâ This is a classic case for **Breadth‚ÄëFirst Search (BFS)** because BFS guarantees the shortest path in an unweighted graph.

### ‚ùå Why not DP + memoization?
- DP would require recursive exploration and memoization of states.  
- BFS is more natural here: it explores level by level and stops as soon as `y` is reached.  
- BFS avoids unnecessary exploration and is simpler to implement.

---

## üöÄ Approach 1 ‚Äî BFS with `Dictionary<int,int>` (distance map)

```csharp
// [BFS-Dict] track distance in dictionary
using System;
using System.Collections.Generic;

public class Solution {
    public int MinimumOperationsToMakeEqual(int x, int y) {
        if (x == y) return 0;

        var q = new Queue<int>();
        var dist = new Dictionary<int,int>();

        q.Enqueue(x);
        dist[x] = 0;

        while (q.Count > 0) {
            int curr = q.Dequeue();
            int steps = dist[curr];

            if (curr == y) return steps;

            // /11
            if (curr % 11 == 0 && !dist.ContainsKey(curr / 11)) {
                dist[curr / 11] = steps + 1;
                q.Enqueue(curr / 11);
            }

            // /5
            if (curr % 5 == 0 && !dist.ContainsKey(curr / 5)) {
                dist[curr / 5] = steps + 1;
                q.Enqueue(curr / 5);
            }

            // +1
            if (curr + 1 <= 20000 && !dist.ContainsKey(curr + 1)) {
                dist[curr + 1] = steps + 1;
                q.Enqueue(curr + 1);
            }

            // -1
            if (curr - 1 > 0 && !dist.ContainsKey(curr - 1)) {
                dist[curr - 1] = steps + 1;
                q.Enqueue(curr - 1);
            }
        }

        return -1; // unreachable
    }
}
```


‚ö° Approach 2 ‚Äî BFS with HashSet<int> (visited only)
```csharp
// [BFS-Set] track visited only, steps carried in queue
using System;
using System.Collections.Generic;

public class Solution {
    public int MinimumOperationsToMakeEqual(int x, int y) {
        if (x == y) return 0;

        var q = new Queue<(int val, int steps)>();
        var visited = new HashSet<int>();

        q.Enqueue((x, 0));
        visited.Add(x);

        while (q.Count > 0) {
            var (curr, steps) = q.Dequeue();

            if (curr == y) return steps;

            // /11
            if (curr % 11 == 0 && !visited.Contains(curr / 11)) {
                visited.Add(curr / 11);
                q.Enqueue((curr / 11, steps + 1));
            }

            // /5
            if (curr % 5 == 0 && !visited.Contains(curr / 5)) {
                visited.Add(curr / 5);
                q.Enqueue((curr / 5, steps + 1));
            }

            // +1
            if (curr + 1 <= 20000 && !visited.Contains(curr + 1)) {
                visited.Add(curr + 1);
                q.Enqueue((curr + 1, steps + 1));
            }

            // -1
            if (curr - 1 > 0 && !visited.Contains(curr - 1)) {
                visited.Add(curr - 1);
                q.Enqueue((curr - 1, steps + 1));
            }
        }

        return -1;
    }
}
```

## ‚è± Complexity Analysis

- **Time Complexity:**  
  Each state (integer value) is processed at most once.  
  - Maximum possible states: up to `10^4` (since `1 <= x, y <= 10^4`).  
  - Each state generates at most **4 neighbors** (`-1`, `+1`, `/5`, `/11`).  
  - Therefore, the total work is **O(N)** where `N = 10^4`.  
  - In practice, BFS will often terminate much earlier once `y` is reached.

- **Space Complexity:**  
  - **Dictionary approach:** `O(N)` for the distance map (`dist[val] = steps`).  
  - **HashSet approach:** `O(N)` for the visited set.  
  - Both also use a queue of size up to `O(N)` in the worst case.  
  - Overall: **O(N)** auxiliary space.

---

## üîç Comparison of Approaches

| Approach       | Stores what?        | Steps tracking | Pros ‚úÖ | Cons ‚ùå |
|----------------|---------------------|----------------|--------|---------|
| **Dictionary** | `dist[val] = steps` | In dictionary  | Easy to debug, can inspect distances to all nodes | Slightly more memory |
| **HashSet**    | Only visited nodes  | In queue tuple | Simpler, lighter | No global distance map |

---

## üèÅ Conclusion

This problem trains the ability to:

- üîé **Recognize shortest path patterns** in number transformation problems.  
- üß† **Implement BFS in two different flavors**:  
  - With a distance map (`Dictionary`)  
  - With a visited set (`HashSet`)  
- ‚öñÔ∏è **Understand trade‚Äëoffs** between storing full distances vs minimal visited info.  
- üõ† **Practice flexibility**: being able to switch between BFS styles depending on debugging needs, memory constraints, or problem requirements.  

üëâ Practicing both styles strengthens BFS mastery and helps adapt to different problem constraints.  




---

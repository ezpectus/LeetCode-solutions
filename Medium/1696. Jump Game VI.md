# üß© Pattern Name  
**Sliding Window Maximum over DP using Monotonic Queue**

---

## üß† Problem Type  
**Constrained Dynamic Programming with Bounded Transitions**  
You‚Äôre given an array `nums` and an integer `k`. Starting at index `0`, you can jump forward up to `k` steps. Each jump adds `nums[i]` to your score.  
**Goal:** Maximize total score to reach the last index.

---

## üîç Problem Anatomy

| Element      | Role                                               |
|--------------|----------------------------------------------------|
| `nums[i]`    | Score gained when landing on index `i`             |
| `k`          | Max jump length ‚Äî defines transition window        |
| `dp[i]`      | Max score to reach index `i`                       |
| Transition   | `dp[i] = max(dp[j]) + nums[i]` for `j ‚àà [i‚Äìk, i‚Äì1]`|
| Goal         | Compute `dp[n‚Äì1]` efficiently                      |

---

## ‚öôÔ∏è Algorithm Match  
This structure matches the **Sliding Window Maximum** pattern, where:

- You need the **maximum value** in a moving window  
- The window size is fixed (`k`)  
- The values change dynamically (`dp[i]` updates)  

Instead of scanning all `k` previous values at each step (**O(nk)**), we use a **monotonic deque** to maintain the **maximum `dp[j]`** in the current window.

---

## üí° Why Monotonic Queue Works

- The deque stores **indices** of `dp[]` in **decreasing order**
- The **front** of the deque always holds the **maximum `dp[j]`** in the window
- When `i` advances:
  - Remove outdated indices (outside `[i‚Äìk, i‚Äì1]`)
  - Pop smaller values from the back ‚Äî they‚Äôre useless for future max
- This gives **O(1)** access to the best previous score at each step

---

## ‚úÖ C# Implementation

```csharp
public class Solution {
    public int MaxResult(int[] nums, int k) {
        int n = nums.Length;
        var dp = new int[n];
        var q = new LinkedList<int>();

        dp[0] = nums[0];
        q.AddLast(0);

        for (int i = 1; i < n; i++) {
            // Use max dp[j] from front of deque
            dp[i] = dp[q.First.Value] + nums[i];

            // Remove indices out of window
            if (q.First.Value <= i - k) {
                q.RemoveFirst();
            }

            // Maintain decreasing order in deque
            while (q.Count > 0 && dp[i] >= dp[q.Last.Value]) {
                q.RemoveLast();
            }

            q.AddLast(i);
        }

        return dp[n - 1];
    }
}
```



## ‚è±Ô∏è Time and Space Complexity

| Metric           | Value  | Explanation                                                                 |
|------------------|--------|------------------------------------------------------------------------------|
| Time Complexity  | O(n)   | Each index enters and exits the deque at most once. No redundant scanning.  |
| Space Complexity | O(n)   | `dp[]` stores scores for each index. Deque holds at most `k` indices.       |

The key optimization is that the **monotonic deque avoids scanning `k` elements per step**, turning a naive **O(nk)** dynamic programming approach into a clean **O(n)** solution.

---

## üîÑ Generalization to Other Problems

This pattern applies whenever you have:

- **DP with bounded transitions** ‚Äî `dp[i]` depends on a range of previous `dp[j]` values  
- **Max/min selection** ‚Äî you need the best among those previous values  
- **Sliding window behavior** ‚Äî the range `[i‚Äìk, i‚Äì1]` moves forward as `i` increases

---

## üîÅ Examples of Similar Problems

| Problem Type                    | Description                                                             |
|----------------------------------|-------------------------------------------------------------------------|
| Jump Game with Score             | Maximize score with limited jump range (`k`)                           |
| Max Sliding Window               | Track max value in a moving window of size `k`                         |
| Stock Trading with Cooldown      | Decisions depend on previous states within a time window               |
| Game Scoring with Penalties      | Score depends on best previous state within a range                    |
| Constrained Pathfinding in Grid  | Move with limited steps, optimize cost or score                        |
| DP with Monotonic Optimization   | Maintain optimal candidates in a structured way                        |

---

## üîó Connection to Other Jump Game Variants

| Variant               | Core Mechanism                        | Pattern Used              |
|------------------------|----------------------------------------|----------------------------|
| Jump Game I            | Can you reach the end? (boolean)       | Greedy or BFS              |
| Jump Game II           | Min number of jumps                   | Greedy with range tracking |
| Jump Game III          | Can reach index with value 0          | BFS or DFS                 |
| Jump Game with Score   | Maximize score with jump limit `k`    | **DP + Monotonic Queue** ‚Üê our case

---

### üîç What‚Äôs Common

- All involve **bounded movement** across an array  
- All require **state tracking** ‚Äî either position, score, or jump count  
- Our version adds **scoring**, which turns it into a **DP problem**

---

### üß† Why Our Pattern Wins Here

- **Greedy fails** when scores vary ‚Äî you need to track optimal paths  
- **BFS is too slow** for scoring ‚Äî you need structured memory (`dp[]`)  
- **Monotonic queue** gives fast access to best previous state ‚Äî perfect for scoring with constraints

---

## üß∞ Where This Pattern Is Useful

This isn‚Äôt just a ‚Äújump game‚Äù trick ‚Äî it‚Äôs a **general optimization strategy**.

Use it when:

- You have a **sliding window of candidates**  
- You need to **select the best (max/min)** among them  
- You want to **avoid brute-force scanning**

---

### üß† Engineering Use Cases

- **Real-time scoring systems** with limited lookback  
- **Streaming analytics** where you track max/min over time  
- **Resource allocation** with cooldowns or delays  
- **Scheduling problems** with bounded dependencies  
- **Competitive programming** where time limits demand linear solutions

---

## üßæ Final Takeaway

This pattern ‚Äî **Sliding Window Maximum over DP using Monotonic Queue** ‚Äî is a **powerful optimization tool** for problems with:

- **Bounded transitions**  
- **Score accumulation**  
- **Need for fast max/min lookup**

It transforms a naive **O(nk)** approach into a clean **O(n)** solution by maintaining a **monotonic structure** of candidate states.

More importantly, it‚Äôs a **reusable mental model**.  
Once you recognize the structure ‚Äî **DP with max over a sliding window** ‚Äî you can apply this pattern across domains: from **games** to **finance** to **scheduling**.



---

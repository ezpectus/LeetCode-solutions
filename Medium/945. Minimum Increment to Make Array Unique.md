# 945. Minimum Increment to Make Array Unique

**Difficulty:** Medium  
**Topics:** Greedy, Sorting  

---

## ðŸ“– Problem Restatement
You are given an integer array `nums`.  
In one move, you can increment any element by 1.  
Return the **minimum number of moves** required to make all elements unique.

---

## ðŸ’¡ Core Idea
- If two numbers are equal, one must be incremented until it becomes unique.  
- Greedy approach:  
  1. Sort the array.  
  2. Traverse from left to right.  
  3. Ensure each element is strictly greater than the previous one.  
  4. If not, increment it to `prev + 1` and add the difference to the move counter.  

This works because sorting guarantees we only need to fix duplicates locally, and greedy increments are minimal.

---

## ðŸ”Ž Step-by-Step Algorithm
1. Sort `nums`.  
2. Initialize `moves = 0`.  
3. Traverse array:  
   - If `nums[i] <= nums[i-1]`, then:  
     - Required value = `nums[i-1] + 1`.  
     - Add `(required - nums[i])` to `moves`.  
     - Update `nums[i] = required`.  
4. Return `moves`.

---

## âœ… C# Implementation
```csharp
public class Solution {
    public int MinIncrementForUnique(int[] nums) {
        Array.Sort(nums);
        int moves = 0;

        for (int i = 1; i < nums.Length; i++) {
            if (nums[i] <= nums[i - 1]) {
                int required = nums[i - 1] + 1;
                moves += required - nums[i];
                nums[i] = required;
            }
        }

        return moves;
    }
}
```

## ðŸ“Š Complexity Analysis

- **Time Complexity: O(n log n)**  
  - Sorting the array dominates the runtime.  
  - After sorting, we perform a single linear pass (O(n)) to adjust duplicates.  
  - Total complexity: O(n log n).  
  - This is efficient enough for n up to 100,000.

- **Space Complexity: O(1)**  
  - Sorting can be done in place.  
  - We only use a few variables (`moves`, `required`).  
  - No extra data structures are needed.  
  - Overall memory usage is constant beyond the input array.

---

## âš ï¸ Pitfalls and Edge Cases

1. **Sorting is essential**  
   - Without sorting, duplicates may not be fixed optimally.  
   - Example: `[2,1,2]` â†’ if not sorted, increments may overshoot.  

2. **In-place updates**  
   - Must update `nums[i]` after incrementing.  
   - Otherwise, later comparisons will be against stale values.  

3. **Large inputs**  
   - Moves can be large, but guaranteed to fit in a 32â€‘bit integer.  
   - Example: `[0,0,0,...]` â†’ requires sequential increments up to n.  

4. **Single element**  
   - Always unique â†’ 0 moves.  

5. **Already unique array**  
   - No increments needed â†’ 0 moves.  

6. **All elements equal**  
   - Requires sequential increments.  
   - Example: `[1,1,1]` â†’ becomes `[1,2,3]` with 3 moves.  

7. **Negative or large values**  
   - Not possible here (constraints: 0 â‰¤ nums[i] â‰¤ 10âµ).  
   - But algorithm would still work if extended.

---

## ðŸ”Ž Example Walkthrough

**Input:** `[3,2,1,2,1,7]`  

1. **Sort the array:**  
   `[1,1,2,2,3,7]`  

2. **Traverse and fix duplicates:**  
   - First `1` â†’ keep as `1`.  
   - Second `1` â†’ must be â‰¥ 2 â†’ increment to `2` (moves +1).  
   - First `2` â†’ must be â‰¥ 3 â†’ increment to `3` (moves +1).  
   - Second `2` â†’ must be â‰¥ 4 â†’ increment to `4` (moves +2).  
   - `3` â†’ must be â‰¥ 5 â†’ increment to `5` (moves +2).  
   - `7` â†’ already unique, no change.  

3. **Final array:** `[1,2,3,4,5,7]`  
4. **Total moves:** 1 + 1 + 2 + 2 = 6  

**Output:** `6`

---

## âœ… Key Takeaway
- Sorting + greedy adjustment ensures minimal increments.  
- Each duplicate is raised just enough to be unique.  
- Algorithm is simple, efficient, and handles all edge cases cleanly.



---

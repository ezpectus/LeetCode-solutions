# 1104. Path In Zigzag Labelled Binary Tree — Architectural Reverse Engineering with Row Mirroring  
*O(log label) — Optimal Parent Calculation with Mirroring*

---

## Problem Statement

Infinite complete binary tree with **zigzag labeling**:

- Row 1 (root): **1** (left to right)
- Row 2: **3 2** (right to left)
- Row 3: **4 5 6 7** (left to right)
- Row 4: **15 14 13 12 11 10 9 8** (right to left)
- And so on...

Given a node `label`, return the **path from root to label** as list of labels.

---

## Core Idea — Reverse Path with Row Mirroring

**Key insight**:
- In normal binary tree: parent = `label / 2`
- In **even rows** (1-based), labels are **reversed**
- To find real parent:
  - Find current **row** of label
  - If row even → label is mirrored → compute real position in normal tree
  - Then parent = real_position / 2

**Better**: work backwards:
- Start from label
- While >1:
  - Compute row of current label
  - If row even → mirror label within row → get "normal" label
  - parent = normal_label / 2
- Add to path, reverse at end

**Math**:
- Row of label: `floor(log2(label)) + 1`
- Row start: `2^(row-1)`
- Row end: `2^row - 1`
- Mirrored = start + end - label

---

## Full Optimal Implementation (C#)

```csharp
public class Solution 
{
    public IList<int> PathInZigZagTree(int label) 
    {
        var path = new List<int>();

        while (label >= 1) 
        {
            path.Add(label);

            if (label == 1) break;

            // Find row (level) of current label
            int row = (int)Math.Floor(Math.Log2(label));
            int rowStart = 1 << row;                    // 2^row
            int rowEnd = (1 << (row + 1)) - 1;           // 2^(row+1) - 1

            // If current row is even (0-based row odd → 1-based even) → mirror
            if (row % 2 == 1) 
            {
                label = rowStart + rowEnd - label;
            }

            label /= 2; // go to parent
        }

        path.Reverse();
        return path;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(log label)**      | Height of tree (number of levels)              |
| **Space Complexity**  | **O(log label)**      | Path list size                                 |

**Optimal** — linear in path length.

---

## Why This Works — Example Walkthrough

**Input**: `label = 14`

- 14 → row = 3 (0-based), rowStart=8, rowEnd=15 → row odd (3%2==1) → mirror: 8+15-14 = **9**
- 9 / 2 = **4**
- 4 → row = 2 (even) → no mirror → 4 / 2 = **2**
- 2 → row = 1 (odd) → mirror: start=2, end=3 → 2+3-2 = **3** → 3 / 2 = **1**
- 1 → stop

Path: 14 → 4 → 2 → 1 → reverse → **[1,2,4,14]**

**Correct** — standard accepted path.

**Input**: `label = 26`

- Similar mirroring step by step → **[1,2,6,10,26]**

**Correct**.

---

## Pitfalls & Edge Cases

- **Row parity** → careful with 0-based vs 1-based indexing (even rows are mirrored)
- **label=1** → path `[1]` → handled correctly
- **Large label** → log2 operations safe (up to 10⁶)
- **Mirroring formula** → `rowStart + rowEnd - label` — key to correct parent

All handled perfectly.

---

## Key Takeaway

This is a **beautifully mathematical** reverse path:

- **Mirror** label in even rows before taking parent
- **Integer log** → find current row efficiently
- **Backwards traversal** → easy accumulation and reverse at end
**Pure, clean, optimal** — perfect zigzag tree navigation.

---

# 2181. Merge Nodes in Between Zeros  
*O(n) — Single Pass with Dummy Node*

---

## Problem Statement

You are given the head of a linked list containing a series of integers separated by `0`'s.  
The list starts and ends with `Node.val == 0`.

For every pair of consecutive `0`'s, merge all nodes **between them** into a **single node** whose value is the **sum** of those nodes.  
The modified list should contain **no zeros**.

Return the head of the modified linked list.

**Examples**:

**Example 1**: head = [0,3,1,0,4,5,2,0]  
Output: [4,11]  
- Between first and second 0: 3 + 1 = 4  
- Between second and third 0: 4 + 5 + 2 = 11

**Example 2**: head = [0,1,0,3,0,2,2,0]  
Output: [1,3,4]  
- 1  
- 3  
- 2 + 2 = 4

**Constraints**:
- 3 ≤ number of nodes ≤ 2·10⁵
- 0 ≤ Node.val ≤ 1000
- No two consecutive zeros
- First and last node have value 0

---

## Core Idea — Single Pass with Pointers

**Approach**:
- Use a **dummy node** to simplify head handling
- Maintain two pointers:
  - `prevZero`: points to the last zero node (start of current segment)
  - `current`: traverses the list
- When we find the next zero:
  - Sum all values between `prevZero` and current zero
  - Create a new node with that sum
  - Connect it after `prevZero`
  - Update `prevZero` to this new node
- Skip all intermediate nodes (they are merged)

**Time**: O(n) — single pass  
**Space**: O(1) extra (we modify in-place, except dummy)

---

## Clean Implementation (C#)

```csharp
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public int val;
 *     public ListNode next;
 *     public ListNode(int val=0, ListNode next=null) {
 *         this.val = val;
 *         this.next = next;
 *     }
 * }
 */
public class Solution{
    public ListNode MergeNodes(ListNode head){
        // Dummy node to handle head easily
        ListNode dummy = new ListNode(0);
        ListNode prevZero = dummy;
        ListNode current = head.next; // skip first 0
        int sum = 0;

        while (current != null) {
            if (current.val == 0){
                // Found next zero → merge previous segment
                ListNode merged = new ListNode(sum);
                prevZero.next = merged;
                prevZero = merged;
                sum = 0; // reset for next segment
            }
            else sum += current.val;
        
            current = current.next;
        }

        return dummy.next;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass through the entire linked list — each node is visited exactly once |
| **Space Complexity**  | **O(1)**      | Only a constant number of pointers (dummy + prevZero + current) — no extra data structures |

**Optimal** — linear time and constant extra space — perfect and very efficient for n ≤ 2·10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: head = [0, 3, 1, 0, 4, 5, 2, 0]

**Step-by-step simulation**:

- Initialize: dummy → 0 (original head)  
  prevZero = dummy  
  current = 3 (skip first 0)  
  sum = 0

- current = 3 → sum = 0 + 3 = **3**  
- current = 1 → sum = 3 + 1 = **4**  
- current = 0 → found next zero!  
  → Create new node with value 4  
  → Link: dummy → 4  
  → Update prevZero = 4  
  → Reset sum = 0  
  → Move current forward

- current = 4 → sum = 0 + 4 = **4**  
- current = 5 → sum = 4 + 5 = **9**  
- current = 2 → sum = 9 + 2 = **11**  
- current = 0 → found next zero!  
  → Create new node with value 11  
  → Link: 4 → 11  
  → Update prevZero = 11  
  → Reset sum = 0  
  → current = null → done

Final list: dummy → 4 → 11 → correct output [4, 11]

**Correct** —  
We traverse the list once, accumulating the sum of all nodes between two consecutive zeros.  
When we reach the next zero, we replace the entire segment (from after previous zero to before current zero) with a **single node** containing the accumulated sum.

---

## Key Takeaway

This is a **classic linked list segment merging** problem:

* Use a **dummy node** to simplify handling of the head and first segment
* Maintain **prevZero** pointer — points to the last processed zero (initially dummy)
* Use **current** pointer to traverse the list
* Accumulate **sum** while traversing non-zero nodes
* When next zero is found:
  * Create new node with value = accumulated sum
  * Link it right after **prevZero**
  * Update **prevZero** to this new node
  * Reset sum to 0
* All intermediate nodes are effectively **skipped** (merged into the new node)

**Pure, clean, optimal** — O(n) time, O(1) extra space, modifies the list in-place efficiently, very fast and intuitive.

---

# 673. Number of Longest Increasing Subsequence

**Difficulty:** Medium  
**Topics:** Dynamic Programming, LIS  

---

##  Problem Restatement
Given an integer array `nums`, return the number of longest increasing subsequences (LIS).  
The subsequence must be strictly increasing.

---

##  Core Idea
- Classic LIS DP tracks only the length of the longest subsequence.  
- Here we also need to count **how many** LIS exist.  
- Maintain two arrays:  
  - `length[i]` = length of LIS ending at index `i`.  
  - `count[i]` = number of LIS of that length ending at index `i`.  
- Transition:  
  - For each `i`, check all `j < i`.  
  - If `nums[j] < nums[i]`:  
    - If `length[j] + 1 > length[i]`: update `length[i]` and reset `count[i] = count[j]`.  
    - If `length[j] + 1 == length[i]`: add `count[j]` to `count[i]`.  
- After filling arrays:  
  - Find `maxLen = max(length[i])`.  
  - Sum all `count[i]` where `length[i] == maxLen`.

---

##  Step-by-Step Algorithm
1. Initialize arrays `length` and `count` of size `n`.  
   - Set `length[i] = 1`, `count[i] = 1` for all `i`.  
2. For each index `i`:  
   - Compare with all previous indices `j < i`.  
   - Update `length[i]` and `count[i]` based on LIS rules.  
3. Track the global maximum length and total count.  
4. Return the total count of LIS with maximum length.

---

##  C# Implementation
```csharp
public class Solution {
    public int FindNumberOfLIS(int[] nums) {
        int n = nums.Length;
        int[] length = new int[n];
        int[] count = new int[n];

        int maxLen = 0, result = 0;

        for (int i = 0; i < n; i++) {
            length[i] = 1;
            count[i] = 1;

            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    if (length[j] + 1 > length[i]) {
                        length[i] = length[j] + 1;
                        count[i] = count[j];
                    } else if (length[j] + 1 == length[i]) {
                        count[i] += count[j];
                    }
                }
            }

            if (length[i] > maxLen) {
                maxLen = length[i];
                result = count[i];
            } else if (length[i] == maxLen) {
                result += count[i];
            }
        }

        return result;
    }
}
```

##  Complexity Analysis

- **Time Complexity: O(n²)**  
  - We use a double loop to compare each element with all previous ones.  
  - Each transition is constant time, so total runtime is quadratic.  
  - For n ≤ 2000, this is efficient enough.

- **Space Complexity: O(n)**  
  - Two arrays are maintained:  
    - `length[i]` → LIS length ending at index i.  
    - `count[i]` → number of LIS of that length ending at index i.  
  - Memory usage grows linearly with input size.

---

##  Pitfalls

1. **Tracking both arrays**  
   - Must maintain both `length` and `count`.  
   - Forgetting one leads to incorrect results.

2. **Reset vs Add logic**  
   - When finding a longer LIS → reset `count[i] = count[j]`.  
   - When finding LIS of equal length → add `count[j]` to `count[i]`.

3. **Edge Cases**  
   - All elements equal → LIS length = 1, count = n.  
   - Strictly increasing array → LIS length = n, count = 1.  
   - Mixed duplicates → careful handling of reset/add transitions.

---

##  Example Walkthrough

**Example 1**  
Input: `nums = [1,3,5,4,7]`  
- LIS length = 4  
- LIS sequences: `[1,3,4,7]` and `[1,3,5,7]`  
- Count = 2  
**Output:** `2`

**Example 2**  
Input: `nums = [2,2,2,2,2]`  
- LIS length = 1  
- Each element alone forms LIS  
- Count = 5  
**Output:** `5`

---

##  Key Takeaway

- This problem extends the classic LIS DP by tracking both **length** and **count**.  
- Formula: update `length[i]` and `count[i]` based on previous indices.  
- Clean O(n²) solution with O(n) space, efficient for arrays up to length 2000.


---

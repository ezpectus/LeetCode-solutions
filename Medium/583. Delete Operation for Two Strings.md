# 583. Delete Operation for Two Strings

**Difficulty:** Medium  
**Topics:** Dynamic Programming, Longest Common Subsequence  

---

## ðŸ“– Problem Restatement
You are given two strings `word1` and `word2`.  
In one step, you can delete exactly one character in either string.  
Return the minimum number of steps required to make `word1` and `word2` the same.

---

## ðŸ’¡ Core Idea
- The problem reduces to finding the **Longest Common Subsequence (LCS)** of the two strings.  
- Any character not in the LCS must be deleted.  
- Formula:  ```minDeletions = (len(word1) - LCS) + (len(word2) - LCS)```
- This ensures both strings are reduced to their common subsequence.

---

## ðŸ”Ž Step-by-Step Algorithm
1. Let `m = word1.Length`, `n = word2.Length`.  
2. Create a DP table `dp[m+1][n+1]`, where `dp[i][j]` = LCS length between `word1[0..i-1]` and `word2[0..j-1]`.  
3. Fill the table:  
 - If `word1[i-1] == word2[j-1]` â†’ `dp[i][j] = dp[i-1][j-1] + 1`.  
 - Else â†’ `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`.  
4. After filling, `dp[m][n]` = LCS length.  
5. Answer = `(m - LCS) + (n - LCS)`.

---

## âœ… C# Implementation
```csharp
// LCS DP
public class Solution {
  public int MinDistance(string word1, string word2) {
      int m = word1.Length;
      int n = word2.Length;
      int[,] dp = new int[m+1, n+1];

      for (int i = 1; i <= m; i++) {
          for (int j = 1; j <= n; j++) {
              if (word1[i-1] == word2[j-1]) {
                  dp[i, j] = dp[i-1, j-1] + 1;
              } else {
                  dp[i, j] = Math.Max(dp[i, j-1], dp[i-1, j]);
              }
          }
      }

      int lcs = dp[m, n];
      return (m - lcs) + (n - lcs);
  }
}
```

## ðŸ“Š Complexity Analysis

- **Time Complexity: O(m * n)**  
  - We build a DP table of size `(m+1) x (n+1)`.  
  - Each cell `dp[i][j]` is filled in constant time.  
  - Total operations = m * n.  
  - Example: if `word1` has length 500 and `word2` has length 500, the DP runs in 250,000 steps, which is efficient enough.

- **Space Complexity: O(m * n)**  
  - The DP table stores results for all subproblems.  
  - Memory usage grows with the product of the string lengths.  
  - For maximum input sizes (500 x 500), this is about 250,000 integers, which is acceptable.  
  - Optimization: use rolling arrays to reduce space to O(min(m, n)) by keeping only the current and previous row.

---

## âš ï¸ Pitfalls

1. **Confusion with Edit Distance**  
   - Edit distance allows insertions, deletions, and substitutions.  
   - This problem only allows deletions, so the formula is simpler.  
   - Do not overcomplicate by trying to implement full edit distance.

2. **Order Matters**  
   - HashSet or set intersection cannot be used because subsequences must preserve order.  
   - Example: `"abc"` and `"cab"` share letters but their LCS is only length 1.

3. **Edge Cases**  
   - If one string is empty â†’ answer = length of the other string (all characters must be deleted).  
   - If both strings are identical â†’ answer = 0 (no deletions needed).  
   - If there is no common subsequence â†’ answer = m + n (delete all characters).

---

## ðŸ”Ž Example Walkthrough

**Example 1**  
Input: `word1 = "sea"`, `word2 = "eat"`  
- LCS = `"ea"` â†’ length = 2  
- Deletions = (3 - 2) + (3 - 2) = 2  
- Output: `2`

**Example 2**  
Input: `word1 = "leetcode"`, `word2 = "etco"`  
- LCS = `"etco"` â†’ length = 4  
- Deletions = (8 - 4) + (4 - 4) = 4  
- Output: `4`

---

## âœ… Key Takeaway

- The problem is solved by computing the **Longest Common Subsequence (LCS)**.  
- Formula: `(len(word1) - LCS) + (len(word2) - LCS)`.  
- This directly gives the minimum number of deletions required.  
- The DP solution runs in O(m * n) time and O(m * n) space, with possible optimization to O(min(m, n)) space.  
- Clean, efficient, and easy to explain in interviews.



---

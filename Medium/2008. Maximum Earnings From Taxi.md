# 2008. Maximum Earnings From Taxi  
*O(n + m log m) — Optimal DP + Greedy Sorting + Binary Search*

---

## Problem Statement

There are `n` points on a road labeled from 1 to `n`. You drive a taxi from point 1 to point `n`.

You are given `rides` — a list of passenger requests:  
rides[i] = [start_i, end_i, tip_i]  
→ passenger wants ride from `start_i` to `end_i` and pays tip `tip_i`.

Profit for a ride = (end_i - start_i) + tip_i

Rules:
- You can pick up **at most one** passenger at a time
- You can drop off and immediately pick up another passenger at the same point
- You cannot change direction (always move forward)

Return the **maximum earnings** you can make by optimally choosing rides.

**Constraints**:
- 1 ≤ n ≤ 10⁵
- 1 ≤ rides.length ≤ 3×10⁴
- 1 ≤ start_i < end_i ≤ n
- 1 ≤ tip_i ≤ 10⁵

---

## Core Idea — Dynamic Programming + Greedy Sorting

**Key insight**:
- Sort rides by **ending point** ascending
- Use DP where dp[i] = maximum earnings when ending at point i
- For each ride ending at some point end:
  - Find the best previous state: max earnings when ending at some point ≤ start
  - Then: dp[end] = max(dp[end], dp[prev] + profit_of_this_ride)
- To quickly find max dp[j] for j ≤ start → use **binary search** on sorted rides + **prefix max**

**Steps**:
1. Sort all rides by **end point** ascending
2. Create dp[0..n] where dp[i] = max earnings ending at point i
3. Also keep a list of rides ending at each point (group by end)
4. Process points from 1 to n:
   - For each ride ending at current point end:
     - Find max dp[j] for j ≤ start (previous best)
     - Update dp[end] = max(dp[end], previous + profit)
   - Use **binary search** to find the rightmost ride ending ≤ start
   - Keep prefix max of dp values to get the best previous quickly

**Optimization**:
- Instead of dp array per point — we can use a **sorted list of end points**
- Keep track of **maximum earnings up to each end point**
- For each ride → binary search for the best previous end point ≤ start

---

## Clean & Optimal Implementation (C#)

```csharp
public class Solution {
    public long MaxTaxiEarnings(int n, int[][] rides) {
        // Sort rides by ending point
        Array.Sort(rides, (a, b) => a[1].CompareTo(b[1]));
        long[] dp = new long[n + 1]; // dp[i] = max earnings ending at or before point i
        int rideIdx = 0;

        for (int i = 1; i <= n; i++){
            dp[i] = dp[i - 1]; // at least as good as previous point

            // Process all rides ending exactly at i
            while (rideIdx < rides.Length && rides[rideIdx][1] == i) {
                int start = rides[rideIdx][0];
                int tip = rides[rideIdx][2];
                long profit = i - start + tip;

                // Find max earnings ending at or before start
                long prev = dp[start];
                dp[i] = Math.Max(dp[i], prev + profit);
                rideIdx++;
            }
        }

        return dp[n];
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n + m log m)**    | Sorting rides by ending point: O(m log m) where m = rides.length  
DP / prefix max pass: O(n + m) — we visit each point 1 to n and process each ride exactly once  
Binary search version (alternative): O(m log m) total |
| **Space Complexity**  | **O(n)**              | dp or prefix max array of size n+1 (or O(n) for storing grouped rides by end point) |

**Optimal** — linear or linearithmic time, perfectly suited for n ≤ 10⁵ and m ≤ 3×10⁴.

---

## Why This Works — Example Walkthrough

**Example 1**: n = 5, rides = [[2,5,4],[1,5,1]]

- Sort rides by end point: both end at 5 (order doesn't matter since same end)
- Process points 1 to 5:

  - At end = 5, first ride [2,5,4]: profit = 5-2+4 = 7  
    Best previous ending ≤ 2 → dp[2] = 0  
    Update dp[5] = max(dp[5], 0 + 7) = 7

  - Second ride [1,5,1]: profit = 5-1+1 = 5  
    Best previous ending ≤ 1 → dp[1] = 0  
    Update dp[5] = max(7, 0 + 5) = 7

- Final dp[5] = 7 → correct

**Correct** — DP processes rides in order of increasing ending point.  
For each ride, we take the **best possible earnings** ending at or before the start point, add the current ride's profit, and update the maximum earnings possible when finishing at the ride's end point.

This ensures we always consider the optimal way to reach the start of each ride.

---

## Key Takeaway

This is a **classic ride scheduling / maximum profit on a line** problem:

- Sort all rides by **ending point** ascending
- Use DP where dp[i] = maximum earnings possible when finishing at point i (or prefixMax[i] = max earnings ending at or before i)
- For each ride ending at end:
  - Find the maximum dp[prev] where prev ≤ start (best way to reach the start point)
  - Compute profit = end - start + tip
  - Update dp[end] = max(dp[end], dp[prev] + profit)
- Use **prefix maximum** array (or binary search on sorted ends) to quickly get the best previous earnings ≤ start

**Pure, clean, optimal** — O(n + m log m) time, elegant dynamic programming combined with greedy sorting.

---

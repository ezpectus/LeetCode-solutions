# Intuition
Each continuous segment of zeros can generate several subsegments consisting only of zeros. For example, a segment of k zeros gives $$\frac{k \cdot (k + 1)}{2}$$ zero subsegments. Instead of iterating through all possible subsegments, we simply count the length of each zero segment and apply the formula.

# Approach
We initialize two counters: zeros — the current length of the zero segment, total — the total number of zero subsegments.

We go through the array:

If the current element is zero, we increase zeros.

If it is not zero, we add the number of segments from the previous segment to the total and reset the zeros.

After the cycle, we add the final segment if the array ends in zeros.

# Complexity
Time complexity: $$O(n)$$ One pass through the array, without nested loops.

Space complexity: $$O(1)$$ We use only a fixed number of variables.

# Code
```csharp []
public class Solution {
    public long ZeroFilledSubarray(int[] nums) {
        int n = nums.Length;
        long zeros = 0;
        long total = 0;

        for(int i = 0; i < n;i++){
            if(nums[i] == 0){
                zeros++;
            }else if ( nums[i] != 0){
                total += zeros * ( zeros + 1)/2;
                zeros = 0;
            }
        }
         total += zeros * ( zeros + 1)/2;

     return total;


    }
}
```

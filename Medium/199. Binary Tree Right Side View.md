# 🌳 Right Side View of Binary Tree — BFS Level Tracking

## 💡 Intuition
Imagine you're standing on the right side of a binary tree.  
At each level, the only node you see is the **rightmost one**.  
This leads directly to a **level-order traversal (BFS)** where we track the **last node of each level**.

---

## 🧭 Approach
- If `root == null`, return an empty list.
- Initialize:
  - `Queue<TreeNode>` for BFS
  - `List<int>` for the result
- While the queue is not empty:
  - Get `size` = number of nodes at current level
  - For `i = 0` to `size - 1`:
    - Dequeue a node
    - If `i == size - 1`, it's the **last node of the level** → add `node.val` to result
    - Enqueue `node.left` and `node.right` if they exist

---

## ⏱️ Complexity
- **Time:** $$O(n)$$ — each node is visited once
- **Space:** $$O(w)$$ — max width of the tree (queue size)

---

## 🧩 Reusable Pattern
- Left Side View → track `i == 0`
- Zigzag Level Order → use `Deque` and alternate insertion
- Level Aggregation → sum/max/min per level

---

## 💻 Code (C#)
```csharp
public class Solution {
    public IList<int> RightSideView(TreeNode root) {
        if (root == null) return new List<int>();

        Queue<TreeNode> queue = new Queue<TreeNode>();
        queue.Enqueue(root);
        List<int> result = new List<int>();

        while (queue.Count > 0) {
            int size = queue.Count;

            for (int i = 0; i < size; i++) {
                TreeNode node = queue.Dequeue();

                if (i == size - 1) {
                    result.Add(node.val);
                }

                if (node.left != null) queue.Enqueue(node.left);
                if (node.right != null) queue.Enqueue(node.right);
            }
        }

        return result;
    }
}
```

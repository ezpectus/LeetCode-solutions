# 🔺 Problem: Taking Maximum Energy From the Mystic Dungeon (Leetcode 3147)

## 📜 Problem Explanation

You are given an array energy where each element represents the energy gained (or lost, if negative) from a magician. 
You are cursed: after absorbing energy from magician i, you are instantly transported to magician (i + k). 
This continues until you reach an index where (i + k) is out of bounds.

You must choose a starting magician and maximize the total energy collected along the teleportation path. 
Return the maximum possible energy you can gain.

## 📏 Constraints
- 1 <= energy.length <= 10^5

- -1000 <= energy[i] <= 1000

1 <= k <= energy.length - 1

 Constraints show that:
```
n can be up to 10^5, so brute force starting from every index with simulation would be too slow.
We need an O(n) or O(n log n) solution.
```
## ⚡️ Algorithm Choice
- This is a dynamic programming from the end problem.

For each index i, the maximum energy starting at i is:

```Код
dp[i] = energy[i] + (i + k < n ? dp[i + k] : 0)
```
We compute dp backwards from the end of the array.
The answer is the maximum value among all dp[i].
This works because each path is deterministic (no branching), so DP captures the exact sum efficiently.

## 💻 C# Implementation
```csharp
public class Solution {
    public int MaximumEnergy(int[] energy, int k) {
        int n = energy.Length;
        int res = int.MinValue;
        int[] dp = new int[n];

        for (int i = n - 1; i >= 0; i--) {
            dp[i] = energy[i] + (i + k < n ? dp[i + k] : 0);
            res = Math.Max(res, dp[i]);
        }
        return res;
    }
}
```

## 🔍 Why This Works

- Backward DP: Each index depends only on i + k, so we can compute from the end.
- Deterministic path: No choices, so DP gives exact sums.
- Global maximum: The best starting point is simply the maximum over all dp[i].

## 🧮 Time & Space Complexity

- Time	O(n)	```Single backward pass```
- Space	O(n)	```DP array of size n```
- Scalability	Strong	```Works for n up to 10^5```
  
## 🧠 Engineering Takeaway
This problem is a clean example of linear DP with jumps:

- Each state depends only on one future state.
- Backward iteration avoids recomputation.
- The solution is efficient, simple, and scales perfectly.

---

# 1915. Number of Wonderful Substrings  
*O(n × 2^{10}) — Optimal Bitmask Prefix + Frequency Map*

---

## Problem Statement

- Given a string `word` consisting only of lowercase letters 'a' to 'j' (length ≤ 10⁵).
- A **wonderful substring** is a non-empty contiguous substring where **at most one** letter appears an **odd** number of times.
- Return the **total number** of wonderful substrings in `word`.
- **Note**: the same substring can appear multiple times — count each occurrence separately.

---

## Core Idea — Bitmask Prefix + Parity Tracking

**Key insight**:
- There are only **10 possible letters** ('a' to 'j') → we can use a **10-bit mask** (2¹⁰ = 1024 states) to represent the **parity** (odd/even count) of each letter in a prefix
- For a substring `word[l..r]`:
  - Its parity mask = prefix[r] XOR prefix[l-1]
  - The substring is wonderful if the XOR mask has **at most 1 bit set** (0 or 1 letter with odd count)
- We want to count pairs (l, r) where prefix[r] XOR prefix[l-1] has ≤ 1 bit set

**Algorithm**:
1. Map 'a' to bit 0, 'b' to bit 1, ..., 'j' to bit 9
2. Compute prefix XOR array:
   - prefix[0] = 0 (empty prefix)
   - prefix[i] = prefix[i-1] XOR (1 << (word[i-1] - 'a'))
3. Use a frequency map `count[mask]` = number of prefixes with that parity mask
4. For each position i (after adding prefix[i]):
   - For the current prefix mask:
     - Add count[mask] (substrings ending at i with even parity for all letters)
     - Add count[mask XOR (1<<bit)] for each bit (0 to 9) — this gives substrings with exactly one letter odd
   - Then increment count[prefix[i]]++
5. Total wonderful substrings = sum of all such additions

**Time**: O(n × 10) = O(n) since 10 is constant

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public long WonderfulSubstrings(string word) {
        int n = word.Length;
        long ans = 0;

        // count[mask] = number of prefixes with parity mask
        int[] count = new int[1 << 10];
        count[0] = 1; // empty prefix
        int prefix = 0;

        for (int i = 0; i < n; i++) {
            int bit = word[i] - 'a';
            prefix ^= (1 << bit);

            // Case 1: substrings with all even counts (mask == 0)
            ans += count[prefix];

            // Case 2: substrings with exactly one letter odd (mask has 1 bit set)
            for (int b = 0; b < 10; b++) {
                int target = prefix ^ (1 << b);
                ans += count[target];
            }

            // Add current prefix
            count[prefix]++;
        }

        return ans;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n × 10)** | n ≤ 10⁵ → O(10⁶) operations — extremely fast   |
| **Space Complexity**  | **O(2¹⁰)**    | Frequency array of size 1024 (fixed)           |

**Optimal** — linear time with tiny constant factor (×10), perfect for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: `word = "aba"`

- prefix XOR steps:
  - After 'a' (pos 0): mask = 1 (bit 0 set), ans += count[1] (=0) + count[1 XOR (1<<b)] for b=0..9
  - After 'b' (pos 1): mask = 1 ^ 2 = 3 (bits 0 and 1), ans += count[3] + count[3 XOR (1<<b)]
  - After 'a' (pos 2): mask = 3 ^ 1 = 2 (bit 1), ans += count[2] + count[2 XOR (1<<b)]

- All substrings checked via prefix XOR:
  - "a" (0..0) → odd 'a' → valid
  - "ab" (0..1) → odd 'a' and 'b' → invalid
  - "aba" (0..2) → even 'a', odd 'b' → valid
  - "b" (1..1) → odd 'b' → valid
  - "ba" (1..2) → odd 'b' and 'a' → invalid
  - "a" (2..2) → odd 'a' → valid

Total **4** → correct

**Correct** — at every prefix position i, we add the number of previous prefixes that differ in **at most one bit** from current prefix:
- count[prefix[i]] → substrings with all even counts
- count[prefix[i] XOR (1<<b)] for each b → substrings with exactly one letter odd

This counts every wonderful substring ending at i.

---

## Pitfalls & Edge Cases

- **All identical letters** → every substring has exactly one letter odd → all valid
- **Single character** → one substring → always valid (one odd letter)
- **n = 10⁵** → O(10⁶) operations → runs in milliseconds
- **Only letters 'a' to 'j'** → exactly 10 bits → 1024 states
- **Empty substrings** → not counted (problem asks for non-empty)

All handled perfectly.

---

## Key Takeaway

This is a **beautifully clever prefix bitmask** problem:

- Use a **10-bit mask** to track the **parity** (odd/even count) of each letter 'a' to 'j'
- prefix[i] = XOR mask after processing first i characters
- Substring from l+1 to r has parity mask = prefix[r] XOR prefix[l]
- Substring is wonderful if XOR mask has **≤ 1 bit set** (0 or 1 letter with odd count)
- Maintain frequency count of seen prefix masks
- For each position i:
  - Add count[prefix[i]] → all even parities
  - Add count[prefix[i] XOR (1<<b)] for each b=0..9 → exactly one odd parity
  - Then increment count[prefix[i]]++

**Pure, clean, optimal** — O(n) time with tiny constant factor (×10).
---

# 🧠 Decode XORed Permutation — Architectural Breakdown
## 🔹 Problem Statement
Given an encoded array of length n - 1, where encoded[i] = perm[i] ^ perm[i + 1], reconstruct the original permutation perm of the first n positive integers.
It is guaranteed that n is odd and the answer is unique.

## 🔸 Core Idea
We are given the XOR of adjacent elements in a hidden permutation. 

To recover the full permutation, we must:

- Reconstruct perm[0] using XOR properties
- Use the encoded array to iteratively recover the rest

### 📐 Phase 1: Total XOR of 1 to n
- This gives the XOR of all elements in perm, since it's a permutation of [1, 2, ..., n].

```csharp
int total = 0;
for (int i = 1; i <= n; i++) total ^= i;
```

### 📐 Phase 2: XOR of encoded[1], encoded[3], encoded[5], ...
- This gives the XOR of all elements in perm[1] ^ perm[2] ^ ... ^ perm[n-1], because each encoded[i] = perm[i] ^ perm[i+1].

```csharp
int oddxor = 0;
for (int i = 1; i < encoded.Length; i += 2) oddxor ^= encoded[i];
```

### 📐 Phase 3: Recover perm[0]
```
We now have:
perm[0] = total ^ oddxor

Because:
perm[0] ^ perm[1] ^ ... ^ perm[n-1] = total
perm[1] ^ perm[2] ^ ... ^ perm[n-1] = oddxor
⇒ perm[0] = total ^ oddxor
```
### 📐 Phase 4: Reconstruct the full permutation
- Using the encoded array and the known perm[0], we can recover the rest:

```csharp
perm[i + 1] = perm[i] ^ encoded[i];
```

## ✅ Final Code (C#)
```csharp
public class Solution {
    public int[] Decode(int[] encoded) {
        int n = encoded.Length + 1;
        int total = 0;
        for (int i = 1; i <= n; i++) total ^= i;

        int oddxor = 0;
        for (int i = 1; i < encoded.Length; i += 2) oddxor ^= encoded[i];

        int[] perm = new int[n];
        perm[0] = total ^ oddxor;

        for (int i = 0; i < encoded.Length; i++) {
            perm[i + 1] = perm[i] ^ encoded[i];
        }

        return perm;
    }
}
```

## 🔍 Example
```
encoded = [3, 1]
n = 3 → total = 1 ^ 2 ^ 3 = 0
oddxor = encoded[1] = 1
perm[0] = 0 ^ 1 = 1
perm[1] = 1 ^ 3 = 2
perm[2] = 2 ^ 1 = 3
⇒ perm = [1, 2, 3]
```

## 🧠 XOR Properties Used

Expression: 

- a ^ a = 0	```Self-cancellation```
- a ^ 0 = a	```Identity```
- a ^ b ^ b = a	```Reversal```
- XOR is associative and commutative	```Order doesn't matter```

## 📌 Architectural Signal
- This task is a classic bitwise reconstruction problem. 
- The key insight is to extract perm[0] using XOR algebra, then rebuild the array iteratively using the encoded values. 
- The solution is linear, reversible, and architecture-safe.


---

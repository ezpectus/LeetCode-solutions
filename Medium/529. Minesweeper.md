# 529. Minesweeper — Architectural DFS Flood Fill  
*O(mn) — Classic Conditional Reveal*

---

## Problem Statement

Given an `m × n` Minesweeper board and a click `[r, c]`, update the board according to official rules:

- Click on `'M'` → `'X'` (game over)
- Click on `'E'` (empty):
  - Count adjacent mines
  - If > 0 → write digit `'1'–'8'`
  - If = 0 → write `'B'` and **recursively reveal** all 8 neighbors

Return the updated board.

---

## Core Idea — DFS with Conditional Expansion

This is a **classic flood-fill** with a twist:

- Only **expand** when adjacent mine count == 0
- Otherwise → write digit and **stop**

**Exactly** how real Minesweeper works.

**Key insight**:  
We **mark cells as we go** (`'B'` or digit) → prevents revisiting and infinite recursion loops.

---

## Full Implementation (C#)

```csharp
public class Solution {
    private static readonly int[] dx = { -1,-1,-1, 0, 0, 1, 1, 1 };
    private static readonly int[] dy = { -1, 0, 1,-1, 1,-1, 0, 1 };

    public char[][] UpdateBoard(char[][] board, int[] click)  {
        int x = click[0], y = click[1];

        if (board[x][y] == 'M')   {
            board[x][y] = 'X';
            return board;
        }

        Dfs(board, x, y);
        return board;
    }

    private void Dfs(char[][] b, int x, int y) {
        int m = b.Length, n = b[0].Length;

        // Count adjacent mines
        int mines = 0;
        for (int d = 0; d < 8; d++) {
            int nx = x + dx[d];
            int ny = y + dy[d];
            if (nx >= 0 && nx < m && ny >= 0 && ny < n && b[nx][ny] == 'M')
                mines++;
        }

        if (mines > 0) {
            b[x][y] = (char)('0' + mines);
            return;
        }

        // No adjacent mines → reveal as blank and expand
        b[x][y] = 'B';

        for (int d = 0; d < 8; d++) 
        {
            int nx = x + dx[d];
            int ny = y + dy[d];
            if (nx >= 0 && nx < m && ny >= 0 && ny < n && b[nx][ny] == 'E')
                Dfs(b, nx, ny);
        }
    }
}
```

## Complexity Analysis

| **Metric**     | **Value**   | **Notes**                                      |
|----------------|-------------|------------------------------------------------|
| **Time**       | **O(mn)**   | Each cell is visited **at most once**          |
| **Space**      | **O(mn)**   | Recursion stack — worst case: entire board is empty cells |
| **Board**      | Modified **in-place** — no extra grid needed   |

**Optimal** — we **must** visit every cell in the worst case (full reveal).

---

## Pitfalls & Edge Cases

- **Click on `'M'`** → immediately turn to `'X'` and **stop** — game over
- Must **count mines in all 8 directions** — no shortcuts
- **Only expand** when adjacent mine count **exactly 0**
- **Mark `'E' → 'B'` immediately** → prevents infinite recursion (critical!)
- Works perfectly for:
  - **1×1 board**
  - **All mines** (click = `'X'`, others stay `'M'`)
  - **All empty** → full flood fill
  - **Edge/corner cells**
  - **Click on already revealed cell** → no action (but input guarantees unrevealed)

---

## Key Takeaway

This is a **perfect example of conditional flood-fill** — one of the most elegant grid DFS patterns:

- If **mines nearby** → write digit and **stop**
- If **no mines** → write `'B'` and **recurse** into all 8 neighbors

**Exactly how real Minesweeper works** — clean, deterministic, in-place.
**No BFS queue. No visited array. Just pure DFS with perfect backtracking via board mutation.**
**One of the most beautiful and satisfying grid DFS problems on LeetCode.**

---


# 2063. Vowels of All Substrings  
*O(n) — Elegant Contribution per Vowel Position*

---

## Problem Statement

- Given a string `word` consisting of lowercase English letters (1 ≤ length ≤ 10⁵).
- Return the **sum** of the number of vowels ('a', 'e', 'i', 'o', 'u') across **every possible substring** of `word`.
- A substring is any **contiguous non-empty** sequence of characters.
- Note: Due to large constraints, the answer may exceed 32-bit signed integer — use **long long** in C++.

---

## Core Idea — Contribution of Each Vowel

**Key insight**:
Instead of generating all substrings (O(n²)), calculate how many substrings **contain** each vowel occurrence.

For a vowel at position `i` (0-based):
- Number of substrings that include this vowel =  
  (number of possible left endpoints) × (number of possible right endpoints)

- Left endpoints: from 0 to i → **(i + 1)** choices
- Right endpoints: from i to n-1 → **(n - i)** choices

- Contribution of this vowel = **(i + 1) × (n - i)**

Sum this value over **every vowel position** in the string.

**Why this works**:
- Every substring that contains this vowel position will count this vowel exactly once in its total vowel count.
- Substrings that do not contain this vowel are not affected by it.
- Total sum = sum over all vowel positions of their contributions.

**Time**: O(n) — single pass over the string  
**Space**: O(1) — only a few variables

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public long CountVowels(string word) {
        long n = word.Length;
        long total = 0;

        for (long i = 0; i < n; i++) {
            char c = word[(int)i];
            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'){
                // Number of substrings containing this vowel at position i
                long left = i + 1;           // 0 to i inclusive
                long right = n - i;          // i to n-1 inclusive
                total += left * right;
            }
        }

        return total;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass over the string — each character is checked exactly once |
| **Space Complexity**  | **O(1)**      | Only a few variables (no extra arrays or maps needed) |

**Optimal** — linear time, constant space — ideal and extremely efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: word = "aba"

- Positions: 0:'a', 1:'b', 2:'a'
- Vowel at i=0 ('a'):
  - left choices (start from 0 to 0): 1
  - right choices (end from 0 to 2): 3
  - contribution = 1 × 3 = **3**
- Vowel at i=2 ('a'):
  - left choices (start from 0 to 2): 3
  - right choices (end from 2 to 2): 1
  - contribution = 3 × 1 = **3**
- Total = 3 + 3 = **6** → correct

**Example 2**: word = "abc"

- Positions: 0:'a', 1:'b', 2:'c'
- Vowel at i=0 ('a'):
  - left: 1, right: 3 → 1 × 3 = **3**
- No other vowels
- Total = **3** → correct

**Example 3**: word = "ltcd"

- No vowels at all
- Total = **0** → correct

**Correct** —  
Each vowel occurrence contributes independently to every substring that contains its position.  
The number of such substrings is precisely **(number of possible left endpoints) × (number of possible right endpoints)**.  
Summing these contributions over all vowel positions gives the total number of vowel occurrences across **all possible substrings**.

---

## Key Takeaway

This is a **beautiful contribution-based** counting problem:

* Instead of generating all substrings (O(n²) approach), calculate **per vowel** how many substrings include it
* For each vowel at position i (0-based):
  * Number of possible left endpoints: from 0 to i → **(i + 1)** choices
  * Number of possible right endpoints: from i to n-1 → **(n - i)** choices
  * Contribution of this vowel = **(i + 1) × (n - i)**
* Sum this value over **every position where s[i] is a vowel**

**Pure, clean, optimal** — O(n) time, O(1) space, elegant mathematical insight, no edge cases missed.

---

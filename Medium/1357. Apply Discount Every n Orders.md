# 1357. Apply Discount Every n Orders — Architectural Simple Counter + Price Map  
*O(1) per getBill — Optimal HashMap Lookup*

---

## Problem Statement

Implement `Cashier` class:

- Constructor: `n` (every nth customer gets discount), `discount` % (0–100), `products` array of IDs, `prices` array of corresponding prices
- `getBill(product[], amount[])` → return **final bill** as `double`:
  - Subtotal = sum(amount[i] * price_of_product[i])
  - If current customer is **nth** → apply discount: subtotal * (100 - discount) / 100

Customer count **1-based** — discount on customers n, 2n, 3n, ...

---

## Core Idea — Counter + Price Dictionary

**The most important part — how and why it works**

**Key idea**:
- We need to know the **current customer number** (starting from 1).
- If `customerCount % n == 0` → this customer gets the discount.
- Product prices **never change** → store them in a dictionary `productId → price` for O(1) lookup.
- On each `getBill` call:
  - Increment the customer counter.
  - Calculate **full subtotal** based on products and quantities.
  - If the customer qualifies for discount → multiply by `(100 - discount)/100`.

**Why it's so simple**:
- No need to store purchase history.
- Discount depends **only** on the customer's sequential number.
- Prices are fixed → one dictionary is enough.
- Bill calculation is linear in the number of items in the current bill (k ≤ 200).

**Potential pitfalls**:
- Counter **starts at 0**, we increment **before** checking discount → first customer = 1.
- Floating point → use `double` (allowed error 10⁻⁵).
- `discount = 100` → nth customer pays 0.
- `n = 1` → every customer gets discount.

**Bottom line**:
- Minimal state: counter + price dictionary.
- Each operation — O(k) time, O(1) extra memory.

---

##  Implementation (C#)

```csharp
public class Cashier {
    private int n;                  // every nth customer
    private int discount;           // discount percent
    private Dictionary<int, int> priceMap;  // product ID → price
    private int customerCount = 0;  // current customer number

    public Cashier(int n, int discount, int[] products, int[] prices) {
        this.n = n;
        this.discount = discount;
        priceMap = new Dictionary<int, int>();

        for (int i = 0; i < products.Length; i++) {
            priceMap[products[i]] = prices[i];
        }
    }
    
    public double GetBill(int[] product, int[] amount) 
    {
        customerCount++;

        double subtotal = 0.0;
        for (int i = 0; i < product.Length; i++) {
            subtotal += priceMap[product[i]] * amount[i];
        }

        // Apply discount if this is the nth customer
        if (customerCount % n == 0) {
            subtotal *= (100.0 - discount) / 100.0;
        }

        return subtotal;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Constructor**       | **O(p)**      | p = number of products (dictionary fill)       |
| **getBill**           | **O(k)**      | k = number of items in current bill            |
| **Space**             | **O(p)**      | Price dictionary                               |

**Optimal** — fast lookups and minimal state.

---

## Why This Works — Example Walkthrough

**Input**:
```csharp
Cashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);
```
- Customer 1: customerCount = 1 → 1 % 3 ≠ 0 → no discount → full price
- Customer 2: customerCount = 2 → 2 % 3 ≠ 0 → no discount
- Customer 3: customerCount = 3 → 3 % 3 == 0 → 50% discount applied
- Customer 4: customerCount = 4 → 4 % 3 ≠ 0 → no discount
- And so on...

**Perfectly matches the example behavior.
Correct.**

## Pitfalls & Edge Cases

- n=1 → every customer gets discount
- discount=0 → no discount ever (full price always)
- discount=100 → every nth customer pays 0
- Multiple same product → correctly handled via amount[]
- Floating point precision → double sufficient (allowed 10⁻⁵ error)

**All handled perfectly.**

## Key Takeaway
This is a beautifully simple stateful class:

- Counter → tracks current customer number
- Dictionary → O(1) price lookup
- Conditional discount → applied every nth customer

- No complex logic. No extra data structures.
- Pure, clean, optimal — perfect cashier simulation.

---

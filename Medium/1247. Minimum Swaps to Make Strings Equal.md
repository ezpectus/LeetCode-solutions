# 🧩 Problem: Minimum Swaps to Make Strings Equal (Leetcode 1247)

## 📜 Statement

You're given two strings `s1` and `s2` of equal length, consisting only of `'x'` and `'y'`. You can swap any two characters **between** the strings (i.e., swap `s1[i]` with `s2[j]`). 
Your goal is to make the strings equal using the **minimum number of swaps**, or return `-1` if it's impossible.

### Examples

- Input: `s1 = "xx"`, `s2 = "yy"` → Output: `1`
- Input: `s1 = "xy"`, `s2 = "yx"` → Output: `2`
- Input: `s1 = "xx"`, `s2 = "xy"` → Output: `-1`

---

## 🧠 Competitive Programming Insight

### 🔍 Pattern: Mismatch Pair Counting + Swap Cost Modeling

This problem is a classic example of **mismatch classification** and **cost modeling**, often seen in:

- Greedy string alignment
- Bitwise or character parity correction
- Swap-based transformation problems

### 🏆 Where It Shows Up

- **ICPC-style greedy rounds**: where you're asked to minimize operations under constraints
- **Codeforces Div 2/3**: as a constructive or parity-based transformation
- **Leetcode/AtCoder**: in string manipulation or swap-based equivalence tasks

---

## 🧪 Core Idea

1. **Identify mismatches**:
   - `xy`: `s1[i] = 'x'`, `s2[i] = 'y'`
   - `yx`: `s1[i] = 'y'`, `s2[i] = 'x'`

2. **Count mismatches**:
   - Let `xyCount` and `yxCount` be the number of such mismatches.

3. **Check feasibility**:
   - If `(xyCount + yxCount) % 2 != 0`, it's impossible to resolve all mismatches → return `-1`.

4. **Compute swaps**:
   - Each pair of `xy` mismatches → 1 swap
   - Each pair of `yx` mismatches → 1 swap
   - If one `xy` and one `yx` remain → 2 swaps

---


## 🧱 C# Implementation

```csharp
public class Solution {
    public int MinimumSwap(string s1, string s2) {
        int xy = 0;
        int yx = 0;
        int n = s1.Length;

        for(int i =0; i < n;i++){
            if(s1[i] == 'x' && s2[i] == 'y') xy++;
            else if ( s1[i] == 'y' && s2[i] == 'x') yx++;
        }

    int total = xy + yx;
    if(total % 2 != 0) return -1;

    return (xy / 2 ) + ( yx / 2) + ( xy % 2) * 2;

    }
}
```

## 🧮 Time & Space Complexity

- Time: O(n) — single pass over the strings
- Space: O(1) — only counters used

## 🧠 Engineering Takeaway
This task is a great example of:

- Mismatch classification → count types of errors
- Swap modeling → cost per fix
- Parity check → feasibility condition

## 🧩 Conclusion

This problem distills a clean competitive pattern: classify mismatches, model swap cost, and check parity for feasibility. 
It’s a great warm-up for greedy string alignment and swap-based transformation problems. 
Add it to your archive under SwapParityMismatch.cs and tag it for reuse in parity-based correction tasks.



---

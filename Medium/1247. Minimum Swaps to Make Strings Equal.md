# ğŸ§© Problem: Minimum Swaps to Make Strings Equal (Leetcode 1247)

## ğŸ“œ Statement

You're given two strings `s1` and `s2` of equal length, consisting only of `'x'` and `'y'`. You can swap any two characters **between** the strings (i.e., swap `s1[i]` with `s2[j]`). 
Your goal is to make the strings equal using the **minimum number of swaps**, or return `-1` if it's impossible.

### Examples

- Input: `s1 = "xx"`, `s2 = "yy"` â†’ Output: `1`
- Input: `s1 = "xy"`, `s2 = "yx"` â†’ Output: `2`
- Input: `s1 = "xx"`, `s2 = "xy"` â†’ Output: `-1`

---

## ğŸ§  Competitive Programming Insight

### ğŸ” Pattern: Mismatch Pair Counting + Swap Cost Modeling

This problem is a classic example of **mismatch classification** and **cost modeling**, often seen in:

- Greedy string alignment
- Bitwise or character parity correction
- Swap-based transformation problems

### ğŸ† Where It Shows Up

- **ICPC-style greedy rounds**: where you're asked to minimize operations under constraints
- **Codeforces Div 2/3**: as a constructive or parity-based transformation
- **Leetcode/AtCoder**: in string manipulation or swap-based equivalence tasks

---

## ğŸ§ª Core Idea

1. **Identify mismatches**:
   - `xy`: `s1[i] = 'x'`, `s2[i] = 'y'`
   - `yx`: `s1[i] = 'y'`, `s2[i] = 'x'`

2. **Count mismatches**:
   - Let `xyCount` and `yxCount` be the number of such mismatches.

3. **Check feasibility**:
   - If `(xyCount + yxCount) % 2 != 0`, it's impossible to resolve all mismatches â†’ return `-1`.

4. **Compute swaps**:
   - Each pair of `xy` mismatches â†’ 1 swap
   - Each pair of `yx` mismatches â†’ 1 swap
   - If one `xy` and one `yx` remain â†’ 2 swaps

---


## ğŸ§± C# Implementation

```csharp
public class Solution {
    public int MinimumSwap(string s1, string s2) {
        int xy = 0;
        int yx = 0;
        int n = s1.Length;

        for(int i =0; i < n;i++){
            if(s1[i] == 'x' && s2[i] == 'y') xy++;
            else if ( s1[i] == 'y' && s2[i] == 'x') yx++;
        }

    int total = xy + yx;
    if(total % 2 != 0) return -1;

    return (xy / 2 ) + ( yx / 2) + ( xy % 2) * 2;

    }
}
```

## ğŸ§® Time & Space Complexity

- Time: O(n) â€” single pass over the strings
- Space: O(1) â€” only counters used

## ğŸ§  Engineering Takeaway
This task is a great example of:

- Mismatch classification â†’ count types of errors
- Swap modeling â†’ cost per fix
- Parity check â†’ feasibility condition

## ğŸ§© Conclusion

This problem distills a clean competitive pattern: classify mismatches, model swap cost, and check parity for feasibility. 
Itâ€™s a great warm-up for greedy string alignment and swap-based transformation problems. 
Add it to your archive under SwapParityMismatch.cs and tag it for reuse in parity-based correction tasks.



---

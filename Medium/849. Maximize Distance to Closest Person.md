# 849. Maximize Distance to Closest Person — Architectural Linear Scan with Gap Tracking  
*O(n) — Optimal One-Pass Solution*

---

## Problem Statement

Given array `seats` where:
- `1` = person sitting
- `0` = empty seat

Find empty seat for Alex such that **distance to closest person** is **maximized**.

Return that **maximum distance**.

---

## Core Idea — Track Distances in Three Parts

**Insight**:
- Maximum distance will be in one of three places:
  1. **Left end** — from start to first person
  2. **Right end** — from last person to end
  3. **Middle gaps** — between two consecutive people

**Distances**:
- Left end: `first_person_index - 0`
- Right end: `n - 1 - last_person_index`
- Middle gap between persons at `i` and `j`: `(j - i) / 2`

**Answer** = max of these three types.

**No need to check every empty seat** — just gaps.

---

## Implementation (C#)

```csharp
public class Solution {
    public int MaxDistToClosest(int[] seats) {
        int n = seats.Length;
        int maxDist = 0;

        // Find first person
        int left = 0;
        while (seats[left] == 0) left++;
        maxDist = left; 

        // Find gaps between people
        int prev = left;
        for (int i = left + 1; i < n; i++)  {
            if (seats[i] == 1) {
                maxDist = Math.Max(maxDist, (i - prev) / 2);
                prev = i;
            }
        }

        maxDist = Math.Max(maxDist, n - 1 - prev);
        return maxDist;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single linear pass over the array              |
| **Space Complexity**  | **O(1)**      | Only a few variables (no extra data structures)|

**Optimal** — fastest possible.

---

## Why This Works — Example Walkthrough

**Input**: `seats = [1,0,0,0,1,0,1]`

- First person at index **0** → left-end distance = 0
- Gaps between people:
  - Between index 0 and 4 → distance 4 → max in gap = `4 / 2 = 2`
  - Between index 4 and 6 → distance 2 → max in gap = `2 / 2 = 1`
- Right-end distance: from last person (index 6) to end → 0
- Overall max = **2**

**Correct** — Alex sits at index 2 (distance 2 to both sides).

**Input**: `[1,0,0,0]`

- Left distance = 0
- No middle gaps
- Right distance = 3 (from index 0 to index 3)
- Max = **3**

**Correct**.

**Input**: `[0,1]`

- Left distance = 1 (from index 0 to person at 1)
- Right distance = 0
- Max = **1**

**Correct**.

---

## Pitfalls & Edge Cases

- **All empty except ends** → max from left/right ends
- **Person at start/end** → corresponding end distance = 0
- **Multiple large gaps** → middle gaps give `/2` distance
- **Only two seats** → handled correctly
- **Single person** → max distance to ends

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** gap analysis problem:

- **Three types** of maximum distance:
  - Left end
  - Middle gaps (`(j - i) / 2`)
  - Right end
- **Linear scan** → find first/last person + all gaps
- **Pure math** → compute max

**No brute force. No simulation.**
**Pure insight + clean code** — one of the most elegant Medium array problems.

---

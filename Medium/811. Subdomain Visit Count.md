# 811. Subdomain Visit Count — Architectural HashMap Aggregation  
*O(N·L) — Suffix Frequency Accumulation*

---

## Problem Statement

We are given an array of count-paired domains in the format `"rep domain"`, where:

- `rep` = number of visits  
- `domain` = full domain string (e.g. `"discuss.leetcode.com"`)

When a domain is visited, **all its parent subdomains are also visited.  
For example:

- Visiting `"discuss.leetcode.com"` also counts as visiting `"leetcode.com"` and `"com"`.

We must return the aggregated visit counts for all subdomains.

---

## Constraints

- `1 ≤ cpdomains.length ≤ 100`
- Each string length ≤ 100
- Visit counts up to `10⁴`
- Domains consist of lowercase English letters and dots.

---

## Core Idea

The problem is essentially **string decomposition + frequency aggregation**:

1. Parse each `"rep domain"` pair.  
2. Split the domain by `"."` into subdomains.  
3. For each **suffix** subdomain, add `rep` to its count.  
4. Return all subdomains with their aggregated counts.

This is a **hashmap accumulation** problem.

---

## Steps

1. Initialize `Dictionary<string, int>` for counts.  
2. For each input string:  
   - Split into count and domain  
   - Split domain by `"."`  
   - For each suffix (from full domain down to top-level), add count to dictionary  
3. Build result list in format `"count subdomain"`.

---

## Implementation (C#)

```csharp
public class Solution {
    public IList<string> SubdomainVisits(string[] cpdomains) {
        Dictionary<string, int> map = new Dictionary<string, int>();

        foreach (string entry in cpdomains) {
            string[] parts = entry.Split(' ');
            int count = int.Parse(parts[0]);
            string domain = parts[1];

            string[] tokens = domain.Split('.');
            for (int i = 0; i < tokens.Length; i++) {
                string subdomain = string.Join(".", tokens, i, tokens.Length - i);
                if (!map.ContainsKey(subdomain)) {
                    map[subdomain] = 0;
                }
                map[subdomain] += count;
            }
        }

        List<string> result = new List<string>();
        foreach (var kv in map) {
            result.Add($"{kv.Value} {kv.Key}");
        }
        return result;
    }
}
```

## Complexity Analysis

- **Time Complexity**:  
  - Parsing each domain: **O(L)**  
  - Max ~3 subdomains per domain  
  - Total: **O(N·L)** with `N ≤ 100` → **extremely efficient**

- **Space Complexity**:  
  - Hashmap stores all unique subdomains  
  - Upper bound: **O(N·L)**

---

## Pitfalls & Edge Cases

- **Single-level domains** (e.g. `"yahoo.com"`) → still split correctly  
- **Multiple domains with shared suffixes** → counts **must aggregate**  
- **Large counts** → `int.Parse` safely handles up to `10⁴`  
- **Order of output** → **any order is acceptable**

---

## Conclusion

This problem reduces to a **hashmap frequency aggregation** with **string suffix decomposition**.
The **architectural insight**: every domain **implicitly contributes to all its suffixes**.
By parsing once and updating a dictionary, we collapse the problem into a **clean linear scan**.
**Result**: a concise **O(N·L)** solution that is easy to implement and scales perfectly within constraints.

---

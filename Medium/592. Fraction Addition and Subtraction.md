# 592. Fraction Addition and Subtraction — Architectural Accumulative Rational Addition  
*O(n) — Pure Integer Arithmetic*

---

## Problem Statement

Given a string `expression` representing addition/subtraction of fractions:
```
"-1/2+1/2+1/3"
"1/3-1/2"
"5/1"
```


Return the result as a **reduced fraction** in the form `"num/den"`:

- If result is integer → `den = 1`
- Fraction must be **irreducible**
- Numerator can be negative, denominator always positive

---

## Core Idea — Accumulate with GCD Reduction

We maintain a running fraction `num/den`.

For each new fraction `±a/b`:
```
num = num * b + sign * a * den
den = den * b
→ reduce using gcd
```

**No floating point. No overflow risk** — reduce **after every step**.

---

## Full Implementation (C#)

```csharp
public class Solution {
    public string FractionAddition(string expr) {
        int n = expr.Length;
        int i = 0;

        long num = 0; // running numerator
        long den = 1; // running denominator

        while (i < n) {
            // parse sign
            int sign = 1;
            if (expr[i] == '+' || expr[i] == '-') {
                sign = expr[i] == '-' ? -1 : 1;
                i++;
            }

            // parse numerator
            long a = 0;
            while (i < n && char.IsDigit(expr[i])) {
                a = a * 10 + (expr[i] - '0');
                i++;
            }

            i++; // skip '/'

            // parse denominator
            long b = 0;
            while (i < n && char.IsDigit(expr[i])) {
                b = b * 10 + (expr[i] - '0');
                i++;
            }

            // accumulate: num/den + sign * a/b
            num = num * b + sign * a * den;
            den = den * b;

            long g = Gcd(Math.Abs(num), den);
            num /= g;
            den /= g;
        }

        return num + "/" + den;
    }

    private long Gcd(long a, long b) {
        while (b != 0) {
            long t = a % b;
            a = b;
            b = t;
        }
        return a;
    }
}
```


## Complexity Analysis

| **Metric**     | **Value**   | **Notes**                                      |
|----------------|-------------|------------------------------------------------|
| **Time**       | **O(n)**    | Single linear pass over the input string       |
| **Space**      | **O(1)**    | Only a few variables — no extra data structures|

**Optimal** — nothing beats this. Literally perfect.

---

## Pitfalls & Edge Cases

- **First fraction may lack sign** → treat as `+` (critical!)
- **Reduce after every step** → prevents overflow even with large intermediate values
- **Negative numerator allowed**, denominator **always stays positive**
- `"5/1"` → must return `"5/1"` (not `"5"`)
- `"0/1"` → valid result (zero)
- `"1/2+1/2"` → `"1/1"` (full reduction)
- `"1/3-1/2"` → `"-1/6"` (negative numerator correct)

---

## Key Takeaway

This is a **beautifully simple, mathematically pure** rational arithmetic problem:

- **Parse** fractions manually
- **Accumulate** using exact formula
- **Reduce immediately** with GCD → stays small and safe
- **No regex**, **no libraries**, **no floating point**, **no overflow**

**Pure integer math** — one of the cleanest, most elegant string-to-math transformations on LeetCode.
A masterclass in **keeping it simple, exact, and bulletproof**.

---


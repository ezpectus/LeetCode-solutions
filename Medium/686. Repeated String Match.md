 # LeetCode 686 — Repeated String Match
- Category: String / Substring Search 
- Difficulty: Medium Language: C# 
- Pattern: Length-Controlled Repetition with Substring Check

 ## Problem Summary
- You're given two strings a and b. You can repeat string a any number of times. 
- Return the minimum number of repetitions of a such that b becomes a substring of the repeated string. If impossible — return -1.

##  My Architectural Insight
- This isn’t about brute-force matching — it’s about controlled expansion.
- We don’t need to build the full repeated string blindly — we only need to go far enough to cover b.

## Key realization:

If b is to fit inside repeated a, the total length must reach at least b.Length — plus one extra a to handle boundary overlaps.
So we build up the repeated string incrementally, checking for containment at each step.

##  My C# Implementation
```csharp
public class Solution {
    public int RepeatedStringMatch(string a, string b) {
        int count = 0;
        var sb = new StringBuilder();

        while (sb.Length < a.Length + b.Length) {
            sb.Append(a);
            count++;

            if (sb.ToString().Contains(b))
                return count;
        }

        return -1;
    }
}
```

##  Architectural Breakdown

| Component                     | Role                                      |
|------------------------------|-------------------------------------------|
| `StringBuilder`              | Efficiently accumulates repeated `a`      |
| `count`                      | Tracks number of repetitions              |
| `sb.Length < a.Length + b.Length` | Ensures we don’t overshoot unnecessarily |
| `Contains(b)`                | Core substring check                      |

---

##  Why My Approach Is Superior

| Aspect               | My Approach                          | Alternative Approach                     |
|----------------------|--------------------------------------|------------------------------------------|
| Expansion Logic      | Controlled by length                 | Arbitrary or fixed repeat count          |
| Substring Check      | Direct `.Contains()`                 | Manual sliding window                    |
| Memory Usage         | Minimal via `StringBuilder`          | Potential string duplication             |
| Performance          | Linear growth, early exit            | Risk of overshooting                     |
| Code Clarity         | Modular and readable                 | Verbose or entangled                     |
| Conceptual Ownership | Derived from length-bound insight    | Driven by brute-force intuition          |

---

##  Summary

This task isn’t about repetition — it’s about minimum viable coverage.  
Once I saw that, the rest was just system-building:

- Controlled expansion  
- Substring containment  
- Early exit on success

No brute force, no guesswork, no wasted cycles.  
Just clean architecture and minimal logic.

This module now lives in my repo as a reusable pattern:

> **Length-Controlled Repetition with Substring Check**

It’s not just a solution — it’s a signal of how I think.


---

# 138. Copy List with Random Pointer

## Problem

You are given a linked list of length `n`, where each node contains:

- `val`: integer value  
- `next`: pointer to the next node  
- `random`: pointer to **any node** in the list or `null`

**Task**: Construct a **deep copy** of the list. The deep copy must consist of **exactly `n` brand new nodes**, where:

- Each new node has the same value as the original  
- Both `next` and `random` pointers **replicate the original structure**  
- **No pointer** in the new list should reference any node from the original list

**Input format**: Given as a list of `[val, random_index]` pairs.  
**Return**: The head of the copied list.

---

## Constraints

- `0 ≤ n ≤ 1000`
- `-10⁴ ≤ Node.val ≤ 10⁴`
- `random` is either `null` or points to a valid node in the list

---

## Core Insight

This is a **deep copy problem with cross-links**.  
The challenge is **not just copying values and `next`**, but **replicating `random` pointers** without referencing original nodes.

### Naive approach:
Use a **hash map** to track `original → copy` mapping.

### Optimal trick (space-efficient):
**Interleave copied nodes directly into the original list**, then extract them.

This avoids extra memory and preserves **direct access** to both original and copy during traversal.

---

## Architectural Triggers

- `"Deep copy with random pointers"` → requires preserving cross-links
- `"No pointer to original nodes"` → must fully detach structure
- `"Constraints: up to 1000 nodes"` → allows in-place simulation without hash maps

---

## What This Implies

Use a **three-pass algorithm**:

1. **Interleave copied nodes**  
   For each node `curr`, insert a copy `copy` directly after it:  
   `A → A' → B → B' → C → C'`

2. **Assign random pointers**  
   Since `copy = curr->next`, and `curr->random->next` is the copy of random:  
   → `copy->random = curr->random ? curr->random->next : nullptr`

3. **Separate the lists**  
   Restore original list and extract copied list by rewiring `next` pointers

> **No hash maps.** All operations are **constant-time per node**.

---

## Code (C++)

```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (!head) return nullptr;

        // Phase 1: interleave copied nodes
        Node* curr = head;
        while (curr) {
            Node* copy = new Node(curr->val);
            copy->next = curr->next;
            curr->next = copy;
            curr = copy->next;
        }

        // Phase 2: assign random pointers
        curr = head;
        while (curr) {
            if (curr->random)
                curr->next->random = curr->random->next;
            curr = curr->next->next;
        }

        // Phase 3: separate lists
        Node* original = head;
        Node* copyHead = head->next;
        Node* copy = copyHead;

        while (original) {
            original->next = original->next->next;
            copy->next = copy->next ? copy->next->next : nullptr;
            original = original->next;
            copy = copy->next;
        }

        return copyHead;
    }
};
```

## Complexity

| Metric | Analysis |
|--------|----------|
| **Time** | `O(n)` — Each node is visited **three times** (once per phase) |
| **Space** | `O(1)` auxiliary — No hash maps or extra structures used *(Output list uses `O(n)` space, but that’s required)* |

---

## Pitfalls

| Issue | Fix |
|-------|-----|
| **Incorrect random assignment** | Use `curr->random->next` — **not** `curr->next->random` |
| **Broken separation logic** | Always check `copy->next` before accessing `copy->next->next` |
| **Hash map temptation** | Avoid `unordered_map<Node*, Node*>` — this solution is **cleaner and optimal** |

---

## Insight

This is a **classic deep-copy pattern with cross-references**.

The **interleaving trick** is a **fichka**:  
> It gives **constant-time access** to both original and copy **without extra memory**.

### Generalizes to any structure where:

- You need to copy nodes  
- You need to preserve arbitrary cross-links  
- You want to avoid hash maps  

---

## Fichka Library Entry

> **Linked list: deep copy with random pointers — O(1) space via interleaving**

---


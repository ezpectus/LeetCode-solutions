#  3381. Maximum Subarray Sum With Length Divisible by K

---

##  Problem Summary
We are given:
- An integer array `nums` of length `n`.
- An integer `k`.

Goal:
- Find the maximum sum of a subarray whose length is divisible by `k`.

---

##  Core Idea
- Use **prefix sums** to compute subarray sums efficiently.  
- For each index `i`, we want to maximize `prefix[i] - prefix[j]` where `(i - j) % k == 0`.  
- This means: subarray length `(i - j)` must be divisible by `k`.  
- Strategy:
  - Maintain the **minimum prefix sum** for each remainder class modulo `k`.  
  - At index `i`, compute candidate sum = `prefix[i] - minPrefix[i % k]`.  
  - Update the maximum answer.  
  - Update `minPrefix[i % k]` with `prefix[i]` if smaller.

---

##  C# Implementation
```csharp
public class Solution {
    public long MaxSubarraySum(int[] nums, int k) {
        int n = nums.Length;
        long[] prefix = new long[n+1];
        for (int i = 0; i < n; i++) {
            prefix[i+1] = prefix[i] + nums[i];
        }

        long[] minPrefix = new long[k];
        for (int i = 0; i < k; i++) minPrefix[i] = long.MaxValue;
        minPrefix[0] = 0; // base case

        long ans = long.MinValue;
        for (int i = 1; i <= n; i++) {
            int mod = i % k;
            if (minPrefix[mod] != long.MaxValue) {
                ans = Math.Max(ans, prefix[i] - minPrefix[mod]);
            }
            minPrefix[mod] = Math.Min(minPrefix[mod], prefix[i]);
        }

        return ans;
    }
}
```

---

##  Complexity
- **Prefix sum computation:** O(n)  
  Build cumulative sums for the array.  
- **Single pass with updates:** O(n)  
  Iterate once, updating minimum prefix per modulo class.  
- **Total:** O(n)  
  Linear time complexity.  
- **Space:** O(n) for prefix array + O(k) for minPrefix.  

---

##  Pitfalls
- **Initialization:** Must set `minPrefix[0] = 0` to allow subarrays starting at index 0.  
- **Negative numbers:** Handle correctly since prefix sums can decrease.  
- **Divisibility check:** Ensure subarray length is divisible by `k`, not just index divisible.  
- **Large values:** With `nums[i]` up to 10^9, sums must be stored in `long`.  

---

##  Example Walkthrough
**Input:**  
`nums = [-5,1,2,-3,4]`, `k = 2`

**Prefix sums:** `[0, -5, -4, -2, -5, -1]`

- At `i=2` (mod=0): candidate = `-4 - 0 = -4`  
- At `i=4` (mod=0): candidate = `-5 - (-5) = 0`  
- At `i=5` (mod=1): candidate = `-1 - (-5) = 4`  

**Maximum = 4**

**Output:** `4`

---

##  Conclusion
- The problem reduces to finding maximum subarray sum with length divisible by `k`.  
- Prefix sums + tracking minimum prefix per modulo class solves it in O(n).  
- This approach is efficient, handles large inputs, and works with negative numbers.  


---




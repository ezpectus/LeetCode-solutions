# 2074. Reverse Nodes in Even Length Groups  
*O(n) — Elegant Group Processing with Reversal*

---

## Problem Statement

You are given the head of a singly-linked list.

The nodes are grouped sequentially into non-empty groups with lengths following the natural numbers:  
- Group 1: length 1  
- Group 2: length 2  
- Group 3: length 3  
- ... and so on  

(The last group may be shorter than its intended length.)

**Task**:  
Reverse the nodes **only** in groups whose length is **even**.  
Return the head of the modified linked list.

**Examples**:

**Example 1** — head = [5,2,6,3,9,1,7,3,8,4]  
Groups: [5] (len=1, odd) → [2,6] (len=2, even) → [3,9,1] (len=3, odd) → [7,3,8,4] (len=4, even)  
After reversing even groups: [5, 6,2, 3,9,1, 4,8,3,7] → **correct**

**Example 2** — head = [1,1,0,6]  
Groups: [1] (1,odd) → [1,0] (2,even) → [6] (1,odd)  
After: [1, 0,1, 6] → **correct**

**Example 3** — head = [1,1,0,6,5]  
Groups: [1] (1,odd) → [1,0] (2,even) → [6,5] (2,even)  
After: [1, 0,1, 5,6] → **correct**

**Constraints**:
- 1 ≤ number of nodes ≤ 10⁵
- 0 ≤ Node.val ≤ 10⁵

---

## Core Idea — Group-by-Group Traversal + Conditional Reversal

**Approach**:
1. Traverse the list while keeping track of the current group number `group = 1, 2, 3, ...`
2. For each group:
   - Try to collect exactly `group` nodes (or fewer if list ends)
   - If the group has **even length** → reverse those nodes
   - If odd → leave as is
3. Connect the reversed (or unchanged) group to the previous part
4. Move to the next group (`group++`)

**Key details**:
- Use a dummy node to simplify head handling
- Keep track of the tail of the previous group to connect
- When reversing a group: reverse the links of the collected nodes
- Handle the case when group size is limited by remaining nodes

**Time**: O(n) — each node is visited and reversed at most once  
**Space**: O(1) — only pointers (no extra arrays)

---

## Clean Implementation (C#)

```csharp
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public int val;
 *     public ListNode next;
 *     public ListNode(int val=0, ListNode next=null) {
 *         this.val = val;
 *         this.next = next;
 *     }
 * }
 */
public class Solution {
    public ListNode ReverseEvenLengthGroups(ListNode head) {
        if (head == null || head.next == null) return head;

        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode prevGroupTail = dummy;  // tail of the previous group
        int group = 1;

        while (prevGroupTail.next != null) {
            // Start of current group
            ListNode groupHead = prevGroupTail.next;
            ListNode curr = groupHead;
            int count = 0;

            // Collect up to 'group' nodes
            while (curr != null && count < group) {
                count++;
                curr = curr.next;
            }

            // If group length is odd → no reversal, just move forward
            if (count % 2 == 1) {
                prevGroupTail = groupHead;
                while (prevGroupTail.next != curr) {
                    prevGroupTail = prevGroupTail.next;
                }
            } 
            // Even length → reverse the group
            else 
            {
                ListNode prev = null;
                ListNode node = groupHead;
                ListNode nextGroupHead = curr;

                // Reverse the group
                for (int i = 0; i < count; i++) {
                    ListNode temp = node.next;
                    node.next = prev;
                    prev = node;
                    node = temp;
                }

                // Connect previous group to reversed group
                prevGroupTail.next = prev;

                // The original groupHead is now the tail of reversed group
                groupHead.next = nextGroupHead;

                // Update tail of this group
                prevGroupTail = groupHead;
            }

            group++;
        }

        return dummy.next;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Each node is visited exactly once during traversal and reversal |
| **Space Complexity**  | **O(1)**      | Only a constant number of pointers (no recursion stack or arrays) |

**Optimal** — single pass with constant extra space — ideal and highly efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: head = [5,2,6,3,9,1,7,3,8,4]

**Groups formed**:
- Group 1 (length 1): [5] → odd → no reversal
- Group 2 (length 2): [2,6] → even → reverse to [6,2]
- Group 3 (length 3): [3,9,1] → odd → no reversal
- Group 4 (length 4): [7,3,8,4] → even → reverse to [4,8,3,7]

**Final linked list**:  
5 → 6 → 2 → 3 → 9 → 1 → 4 → 8 → 3 → 7

**Correct** —  
We process the list group by group with increasing group sizes (1, 2, 3, ...).  
For groups with **even length** we reverse the nodes in-place using pointer manipulation.  
For groups with **odd length** we leave them unchanged.  
Connections between consecutive groups are preserved using a tail pointer from the previous group.

---

## Key Takeaway

This is a **classic linked list group reversal** problem:

* Traverse the list while forming groups with lengths 1, 2, 3, 4, ... (last group may be shorter)
* For each group:
  * Collect nodes up to the target group length (or until the end of the list)
  * If the actual group length is **even** → reverse the nodes in that group
  * If odd → leave the group unchanged
* Connect each processed group to the previous one using a tail pointer
* Use a dummy node to simplify handling of the head pointer

**Pure, clean, optimal** — O(n) time, O(1) extra space, elegant pointer manipulation, no recursion or additional memory needed.
---

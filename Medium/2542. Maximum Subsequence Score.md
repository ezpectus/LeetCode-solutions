# Pattern: Greedy + Heap Optimization with Rolling Sum

## Used When:
- It is necessary to select `k` elements
- The target metric depends on: 
- `sum' of selected ones 
- `min` or `max` of one of the parameters

## Strategy:
1. Construct `(value, constraint)' pairs
2. Sort by `constraint' (usually in descending order)
3. Use MinHeap to store `k` best `value`
4. Maintain `sum` manually
5. At every step: 
- Add `value` to heap 
- If heap.Count > k → remove minimal 
- If heap.Count == k → calculate the metric: `sum * constraint` 
- Update maximum

## Complexity:
- Time: $$O(n \log k)$$
- Space: $$O(k)$$


```csharp
//Greedy + Heap Optimization with Rolling Sum
public class Solution {
    public long MaxScore(int[] nums1, int[] nums2, int k) {
        int n = nums1.Length;
        var pairs = new List<(int num1,int num2)>();
        

        for(int i = 0;i < n;i++){
           pairs.Add((nums1[i], nums2[i]));
        }

         pairs.Sort((a,b) => b.num2.CompareTo(a.num2));

          var minHeap = new PriorityQueue<int, int>();
          long sum = 0;
          long maxScore = 0;

      foreach(var pair in pairs){
            minHeap.Enqueue(pair.num1, pair.num1);
            sum += pair.num1;
 
          if(minHeap.Count > k){
            int removed = minHeap.Dequeue();
            sum -= removed;
          }

          if(minHeap.Count == k){
            long score = sum * pair.num2;
            maxScore = Math.Max(maxScore,score);

           }
      }

            
   return maxScore;

    }
}

```



----

# 1981. Minimize the Difference Between Target and Chosen Elements  
*O(m × n × target) — Optimal 0/1 Knapsack DP*

---

## Problem Statement

You are given an m × n integer matrix `mat` and an integer `target`.

You must choose **exactly one** integer from **each row** such that the **absolute difference** between `target` and the sum of chosen elements is minimized.

Return that **minimum absolute difference**.

---

## Core Idea — 0/1 Knapsack Style DP

**Key insight**:
- m rows, from each row pick **exactly one** number
- Sum S of chosen numbers should be as close as possible to `target`
- Minimize |S - target|
- Since values ≤ 70 and m ≤ 70 → maximum possible sum ≤ 70 × 70 = 4900
- We can use DP to find **all achievable sums** using exactly m picks (one per row)

**DP state**:
- `dp[i][s]` = true if we can achieve sum `s` using first `i` rows (0-based)

**Transition**:
- dp[0][0] = true (no rows → sum 0)
- For each row i = 1 to m:
  - For each possible sum s from previous rows
  - For each possible choice v in row i-1
    - dp[i][s + v] = true if dp[i-1][s] = true

**Final answer**:
- Find the smallest |s - target| over all s where dp[m][s] = true

**Optimization**:
- Since target ≤ 800 and max sum ≤ 4900 → we can limit sums to 0..4900
- Use bool[][] or bitset for memory efficiency

**Time**: O(m × n × max_sum) ≈ 70 × 70 × 4900 ≈ 24M operations — acceptable

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MinimizeTheDifference(int[][] mat, int target) {
        int m = mat.Length;
        int n = mat[0].Length;

        // Max possible sum = 70*70 = 4900
        const int MAX_SUM = 4900;

        // dp[s] = true if sum s is achievable
        bool[] dp = new bool[MAX_SUM + 1];
        dp[0] = true; // 0 rows → sum 0

        foreach (int[] row in mat)  {
            bool[] next = new bool[MAX_SUM + 1];
            for (int s = 0; s <= MAX_SUM; s++) {
                if (!dp[s]) continue;

                foreach (int v in row) {
                    int newSum = s + v;
                    if (newSum <= MAX_SUM) {
                        next[newSum] = true;
                    }
                }
            }

            dp = next;
        }

        // Find closest sum to target
        int minDiff = int.MaxValue;
        for (int s = 0; s <= MAX_SUM; s++) {
            if (dp[s]) {
                minDiff = Math.Min(minDiff, Math.Abs(s - target));
            }
        }

        return minDiff;
    }
}
```

## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(m × n × max_sum)** worst-case | m rows × n choices per row × up to 4900 possible sums ≈ 70 × 70 × 4900 ≈ 24 million operations |
| **Realistic Time**    | **Fast**                      | In practice much faster — many sums are not reached, especially with HashSet version (prunes duplicates) |
| **Space Complexity**  | **O(max_sum)**                | Achievable sums set / DP array ≤ 4901 elements (max sum = 70×70 = 4900) |

**Optimal** — perfectly fits constraints (m, n ≤ 70, target ≤ 800), runs in milliseconds even in worst case.

---

## Why This Works — Example Walkthrough

**Example 1**: `mat = [[1,2,3],[4,5,6],[7,8,9]]`, `target = 13`

- Row 0 choices: 1, 2, 3
- Row 1 choices: 4, 5, 6
- Row 2 choices: 7, 8, 9
- Possible sums range: 1+4+7=12 to 3+6+9=18
- Achievable sums include 13 (e.g. 1 + 5 + 7)
- Closest to 13: 13 → difference = **0** → correct

**Correct** — DP (or HashSet) builds all possible sums by adding one row at a time (exactly one choice per row), then finds the sum closest to `target` using absolute difference.

---

## Pitfalls & Edge Cases

- **All elements = 1** → min sum = m, max sum = m × 70
- **target very small or very large** → closest will be either minimum or maximum achievable sum
- **m = 1** → just min over j of |mat[0][j] - target|
- **m = 70, n = 70** → max_sum = 4900 → HashSet size ≤ 4901 — safe and fast
- **target = 800** → well within possible sum range (0 to 4900)

All handled perfectly.

---

## Key Takeaway

This is a **classic knapsack-style** problem with small constraints:

- Treat each row as a "group" — must pick **exactly one** number from each row
- Goal: make the sum S as close as possible to `target`
- Use DP array or HashSet to track **all achievable sums** after processing each row
- Final answer = minimum |s - target| over all achievable sums s

**Pure, clean, optimal** — O(m × n × max_sum) worst-case, but in practice much faster (especially with HashSet pruning duplicates).

---

# 1959. Minimum Total Space Wasted With K Resizing Operations  
*O(n² × (k+1)) — Optimal DP with Prefix Max*

---

## Problem Statement

You are designing a dynamic array. You are given:

- `nums[0..n-1]` — at time `t`, the array must hold **at least** `nums[t]` elements
- `k` — maximum number of **resizes** allowed (0 ≤ k ≤ n-1)

The array starts with **any size** (initial size doesn't count as resize).

At each time `t`:
- Current size `s_t` must be ≥ `nums[t]`
- Wasted space at time `t` = `s_t - nums[t]`
- Total wasted space = sum over all t of wasted space

You can resize the array **up to k times** (to any size).

Return the **minimum possible total wasted space**.

---

## Core Idea — DP with Prefix Maximum

**Key insight**:
- Resizes happen at certain times — after a resize, the size stays constant until next resize
- We can think of the array being resized k+1 times (initial + k resizes)
- Between two consecutive resizes, size is constant = max(nums[t]) in that segment

**DP definition**:
- `dp[i][j]` = minimum total wasted space to process first `i` times (0..i-1), using **exactly j resizes**

**Transition**:
- For each ending time `i` (1-based), and `j` resizes used:
  - Try last resize at time `p` (p < i)
  - Size during [p..i-1] = max(nums[p] .. nums[i-1])
  - Wasted in this segment = (i-p) × max - sum(nums[p..i-1])
  - dp[i][j] = min over p of (dp[p][j-1] + wasted in [p..i-1])

**Base**:
- dp[0][0] = 0 (no times, no resizes)

**Answer**:
- min over j=0 to k of dp[n][j]

**Optimization**:
- Precompute prefix sums and prefix max to compute segment max and sum in O(1)

**Time**: O(n² × (k+1)) — n ≤ 200, k ≤ 199 → 200³ ≈ 8M operations — fast

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MinSpaceWastedKResizing(int[] nums, int k) {
        int n = nums.Length;

        // prefix[i] = sum of first i elements (0-based)
        long[] prefix = new long[n + 1];
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + nums[i];
        }

        // dp[i][j] = min wasted space for first i elements using j resizes (0-based)
        int[,] dp = new int[n + 1, k + 1];
        for (int i = 0; i <= n; i++) 
            for (int j = 0; j <= k; j++) 
                dp[i, j] = int.MaxValue / 2;

        dp[0, 0] = 0;

        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= k; j++){
                // Try last resize at every position p < i
                int maxInSeg = 0;
                for (int p = i; p >= 1; p--) {
                    maxInSeg = Math.Max(maxInSeg, nums[p - 1]);
                    long sumSeg = prefix[i] - prefix[p - 1];
                    long wasted = (long)maxInSeg * (i - p + 1) - sumSeg;
                    int prev = (j == 0 ? (p == 1 ? 0 : int.MaxValue / 2) : dp[p - 1, j - 1]);

                    if (prev < int.MaxValue / 2) {
                        dp[i, j] = Math.Min(dp[i, j], prev + (int)wasted);
                    }
                }
            }
        }

        int ans = int.MaxValue;
        for (int j = 0; j <= k; j++) {
            ans = Math.Min(ans, dp[n, j]);
        }

        return ans;
    }
}
```
## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(n² × (k+1))**             | For each ending position i (1 to n), for each number of resizes j (0 to k), try every possible start p of the last segment → 200 × 200 × 200 ≈ 8 million operations |
| **Space Complexity**  | **O(n × (k+1))**              | DP table: (n+1) × (k+1) ≈ 201 × 201 ≈ 40k integers |

**Optimal** — perfectly fits constraints (n ≤ 200, k ≤ 199), runs very fast (under 10 ms in practice).

---

## Why This Works — Example Walkthrough

**Example 1**: `nums = [10,20]`, `k = 0`

- No resizes allowed → one segment [0..1]
- Size = max(10,20) = 20
- Wasted = (20-10) + (20-20) = **10** → correct

**Example 3**: `nums = [10,20,15,30,20]`, `k = 2`

- Optimal size sequence: [10,20,20,30,30]
  - Segment [0]: size=10, wasted=0
  - Segment [1..2]: size=20, wasted=(20-20)+(20-15)=5
  - Segment [3..4]: size=30, wasted=0 + (30-20)=10
- Total wasted = 0 + 5 + 10 = **15** → correct

**Correct** — DP considers every possible ending position i, every possible number of resizes j, and every possible start p of the last segment.  
For each such segment [p..i-1], size = max(nums[p..i-1]), wasted = length × max - sum(nums[p..i-1]), and adds it to the cost of previous state.

---

## Pitfalls & Edge Cases

- **k = 0** → single fixed size = max(nums) → wasted = n × max - total sum
- **k ≥ n-1** → can resize at every step → size always equals nums[t] → wasted = 0
- **All nums equal** → wasted = 0 even with k=0
- **n = 200** → 200³ = 8 million operations → acceptable and fast
- **Large nums[i] (≤10⁶)** → use `long` for sums and wasted to avoid overflow

All handled perfectly.

---

## Key Takeaway

This is a **classic interval DP with resizes** problem:

- Add prefix sums and prefix max for O(1) range queries
- `dp[i][j]` = min wasted space to process first i elements using exactly j resizes
- Transition:
  - For each ending i and j resizes used
  - Try every possible start p of the last segment
  - Last segment [p..i-1] has size = max(nums[p..i-1])
  - Wasted = (i-p) × max - sum(nums[p..i-1])
  - dp[i][j] = min over p of dp[p-1][j-1] + wasted
- Final answer = min over j=0 to k of dp[n][j]

**Pure, clean, optimal** — O(n² × (k+1)) time, fits constraints perfectly.

---

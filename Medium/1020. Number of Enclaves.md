# 1020. Number of Enclaves — Architectural Boundary DFS/BFS Flood Fill  
*O(mn) — Optimal Single Pass Connectivity*

---

## Problem Statement

Given an `m × n` grid:
- `1` = land
- `0` = sea

A **move** consists of walking from one land cell to another **adjacent** (up, down, left, right) land cell, or walking **off the grid boundary**.

An **enclave** is a group of land cells (`1`s) from which it is **impossible** to walk off the grid (i.e., reach the boundary).

Return the **total number** of land cells that belong to enclaves.

---

## Core Idea - Flood Fill from Boundary Lands

**Key insight**:
- Any land cell that is **reachable** from a land cell on the **boundary** can escape the grid → **not an enclave**.
- All other land cells (completely surrounded by sea) → **enclaves**.

**Strategy**:
1. **Mark all land cells reachable from the boundary** as "visited" (turn them into `0` or use a visited array).
2. After marking, **count the remaining `1`s** → these are the true enclaves.

**Why start from boundary?**
- Boundary land cells are directly connected to "outside".
- Any land connected to them (through a path of `1`s) can also escape.
- Flood fill (DFS or BFS) from **all boundary `1`s** efficiently marks all such cells.

**Implementation choice**:
- Modify the grid in place (`1` → `0`) → saves space, no extra visited array needed.

**Steps in detail**:
1. Scan **all four borders** (top row, bottom row, left column, right column).
2. For every `1` on the border → run **DFS/BFS** to mark all reachable land cells as `0`.
3. After all boundary floods → iterate through entire grid and count remaining `1`s.

**Result** = number of enclaves.


---

##  Implementation (C#)

```csharp
public class Solution {
    private int m, n;
    private int[][] grid;

    public int NumEnclaves(int[][] grid) {
        this.grid = grid;
        m = grid.Length;
        n = grid[0].Length;

        // Flood from left/right borders
        for (int i = 0; i < m; i++) {
            Dfs(i, 0);
            Dfs(i, n - 1);
        }

        // Flood from top/bottom borders
        for (int j = 0; j < n; j++) {
            Dfs(0, j);
            Dfs(m - 1, j);
        }

        //Count remaining lands
        int count = 0;
        for (int i = 0; i < m; i++) 
        {
            for (int j = 0; j < n; j++) 
            {
                if (grid[i][j] == 1) 
                {
                    count++;
                }
            }
        }

        return count;
    }

    private void Dfs(int r, int c) {
        if (r < 0 || r >= m || c < 0 || c >= n || grid[r][c] != 1)  return;

        grid[r][c] = 0; //visited
        Dfs(r + 1, c);
        Dfs(r - 1, c);
        Dfs(r, c + 1);
        Dfs(r, c - 1);
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(mn)**             | Visit each cell at most once                   |
| **Space Complexity**  | **O(mn)**             | Recursion stack worst case (skewed flood fill) |

**Optimal** — linear time, minimal extra space.

---

## Why This Works — Example Walkthrough

**Input**: `[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]`

- **Boundary lands**: none on the edge
- No DFS triggered from borders
- Remaining `1`s: three inner land cells → **3**

**Correct** — fully enclosed enclave.

**Input**: `[[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]`

- **Boundary lands**: top row columns 1 and 2 (`[0,1]`, `[0,2]`)
- DFS from these → floods all connected `1`s (the whole column of `1`s)
- All `1`s marked as `0`
- No remaining `1`s → **0**

**Correct** — all land reachable from boundary.

---

## Pitfalls & Edge Cases

- **Boundary lands** → marked during flood → not counted
- **Isolated inner lands** → remain untouched → counted as enclaves
- **All land** → if any touches boundary → whole island marked → 0
- **Single cell** → if land on boundary → 0, if inner → 1
- **No land** → 0

All handled perfectly.

---

## Key Takeaway

This is a **classic flood fill** problem:

- **Mark all reachable land** from the boundary
- **Count unmarked land** → true enclaves
- **Modify grid in place** → save space
**Pure, clean, optimal** — perfect connectivity problem.

---

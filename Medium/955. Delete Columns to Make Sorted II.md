# 955. Delete Columns to Make Sorted II

---

##  Problem Restatement
You are given an array of `n` strings, all of the same length.  
You may choose any set of column indices and delete those columns from every string.  

After deletions, the resulting array must be **lexicographically sorted**:  
`strs[0] <= strs[1] <= strs[2] <= ... <= strs[n-1]`

Return the **minimum number of deletions** required.

---

##  Core Idea
- We cannot reorder strings — only delete columns.  
- Greedy principle:  
  - Scan columns left to right.  
  - If a column breaks lexicographic order for any unresolved pair of adjacent strings → delete it.  
  - Otherwise, keep it and mark pairs that are now strictly ordered.  

This ensures we delete only when necessary, minimizing deletions.

---

##  Step-by-Step Algorithm
1. Initialize an array `resolved[r]` for pairs `(strs[r], strs[r+1])`.  
2. Iterate over columns:  
   - Check all unresolved pairs.  
   - If `strs[r][c] > strs[r+1][c]` for any unresolved pair → conflict → delete column.  
   - Otherwise, keep column and update `resolved[r] = true` if `strs[r][c] < strs[r+1][c]`.  
3. Return the total number of deleted columns.

---

## C# Implementation
```csharp
public class Solution {
    public int MinDeletionSize(string[] strs) {
        int rows = strs.Length;
        int cols = strs[0].Length;
        var resolved = new bool[rows - 1];
        int deletions = 0;

        for (int c = 0; c < cols; c++) {
            bool conflict = false;

            // Check if this column breaks order
            for (int r = 0; r < rows - 1; r++) {
                if (!resolved[r] && strs[r][c] > strs[r + 1][c]) {
                    conflict = true;
                    break;
                }
            }

            if (conflict) {
                deletions++;
                continue; // skip updating resolved pairs
            }

            // Update resolved pairs if strictly ordered at this column
            for (int r = 0; r < rows - 1; r++) {
                if (!resolved[r] && strs[r][c] < strs[r + 1][c]) {
                    resolved[r] = true;
                }
            }
        }

        return deletions;
    }
}
```

##  Complexity Analysis

- **Time Complexity: O(n · m)**  
  - `n` = number of strings, `m` = length of each string.  
  - For each column (m iterations), we scan through all adjacent pairs of rows (n-1 comparisons).  
  - Worst case: every column is checked fully → O(n · m).  
  - Sorting is not required, so no extra O(n log n) overhead.  
  - This is efficient given constraints (n, m ≤ 100).  

- **Space Complexity: O(n)**  
  - We maintain a boolean array `resolved` of size `n-1`.  
  - Each entry tracks whether the pair `(strs[r], strs[r+1])` is already strictly ordered.  
  - No additional data structures are needed.  
  - Memory usage scales linearly with the number of strings, independent of string length.  

---

##  Pitfalls and Edge Cases

1. **Equality does not resolve pairs**  
   - If `strs[r][c] == strs[r+1][c]`, the pair remains unresolved.  
   - We must continue checking later columns until a strict inequality (`<` or `>`) appears.  
   - Mistakenly marking equality as resolved would break correctness.

2. **Column deletion rules**  
   - If a column introduces a conflict (`strs[r][c] > strs[r+1][c]` for any unresolved pair), that column must be deleted.  
   - Important: when a column is deleted, we do **not** update `resolved` — it’s as if the column never existed.  
   - Forgetting this rule can cause false positives in ordering.

3. **Adjacent pairs only**  
   - Lexicographic order is transitive: if all adjacent pairs are ordered, the entire array is ordered.  
   - Checking non-adjacent pairs is unnecessary and wastes time.  
   - This greedy focus on neighbors keeps the algorithm efficient.

4. **Early conflicts**  
   - A conflict detected early in a column means the entire column must be deleted, even if later pairs look fine.  
   - Greedy deletion is optimal: delaying the decision would not fix the conflict.

5. **All columns deleted case**  
   - In worst-case scenarios (e.g., `["zyx","wvu","tsr"]`), every column may need to be deleted.  
   - The algorithm correctly handles this by incrementing deletions for each conflict column.  
   - Result can be equal to the full string length.

6. **Single string input**  
   - If `n = 1`, no deletions are required because there are no pairs to compare.  
   - Algorithm still works: `resolved` array size is zero, loop runs but no conflicts are possible.

7. **Short strings**  
   - If `m = 1`, only one column exists.  
   - Either it is kept (already sorted) or deleted (conflict).  
   - Algorithm handles this naturally.

---

##  Key Takeaway
- The greedy approach ensures minimal deletions by scanning columns left to right.  
- Complexity is linear in both dimensions (rows × columns).  
- Correctness depends on carefully handling equality, conflicts, and adjacent pairs only.



---

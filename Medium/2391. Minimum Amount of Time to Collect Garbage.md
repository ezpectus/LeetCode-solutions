# 2391. Minimum Amount of Time to Collect Garbage  
*O(n) — Greedy Prefix + Last Occurrence Tracking*

---

## Problem Statement

You are given:
- A 0-indexed array of strings `garbage` where `garbage[i]` contains only `'M'`, `'P'`, `'G'` — types of garbage at house `i`
- A 0-indexed integer array `travel` where `travel[i]` = minutes needed to travel from house `i` to house `i+1`

There are **three garbage trucks** — one for each type: Metal (`M`), Paper (`P`), Glass (`G`).

Each truck:
- Starts at house 0
- Can only collect **one type** of garbage
- Must visit houses in order (0 → 1 → 2 → ...), but can skip houses
- Picking up one unit of garbage takes **1 minute**
- Only **one truck** can be active at a time (driving or collecting)

Return the **minimum total minutes** needed to collect **all** garbage.

**Examples**:

**Example 1**  
Input: garbage = ["G","P","GP","GG"], travel = [2,4,3]  
Output: **21**  
Explanation:
- Paper truck: 8 minutes
- Glass truck: 13 minutes
- Metal truck: not needed
Total: 21

**Example 2**  
Input: garbage = ["MMM","PGM","GP"], travel = [3,10]  
Output: **37**

**Constraints**:
- 2 ≤ garbage.length ≤ 10⁵
- 1 ≤ garbage[i].length ≤ 10
- travel.length = garbage.length - 1
- 1 ≤ travel[i] ≤ 100

---

## Core Idea — Greedy: Track Last Pickup Position per Type

**Key insight**:
- Each truck collects **only one type** → three independent trucks (Metal, Paper, Glass)
- Time = **driving time** + **pickup time**
- Pickup time for type T = total count of T in garbage (each unit = 1 minute)
- Driving time for type T = sum of travel[j] for all j from 0 to **last house** that has T
- Total time = sum over all types: (pickup_T + driving_to_last_T)

**Algorithm**:
1. Compute **total pickup time** = total number of garbage units (sum of lengths of all garbage[i])
2. Find the **last house** for each type (`M`, `P`, `G`) — the rightmost index with that letter
3. For each type, driving time = sum of `travel[0..last_index-1]`
4. Total time = pickup time + sum of driving times for types that appear at least once

**Optimization**:
- Precompute **prefix sums** of travel times
- For each type, find max index where it appears
- Add prefix[last-1] to total driving time (if last ≥ 1)

**Time**: O(n) — single pass to count + find last positions  
**Space**: O(1) — fixed 3 types

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int GarbageCollection(string[] garbage, int[] travel) {
        int n = garbage.Length;

        // Total pickup time = total number of garbage units
        int totalPickup = 0;
        foreach (string g in garbage) {
            totalPickup += g.Length;
        }

        // Last position of each type
        int lastM = -1, lastP = -1, lastG = -1;

        for (int i = 0; i < n; i++) {
            foreach (char c in garbage[i]) {
                if (c == 'M') lastM = i;
                else if (c == 'P') lastP = i;
                else if (c == 'G') lastG = i;
            }
        }

        // Prefix sum of travel times
        long[] prefix = new long[n];
        for (int i = 1; i < n; i++) {
            prefix[i] = prefix[i - 1] + travel[i - 1];
        }

        // Driving time = prefix[last] (time to reach house last from 0)
        long totalDriving = 0;

        if (lastM >= 0) totalDriving += prefix[lastM];
        if (lastP >= 0) totalDriving += prefix[lastP];
        if (lastG >= 0) totalDriving += prefix[lastG];

        return totalPickup + (int)totalDriving;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass to count total pickup time + find last positions for each type: O(n)<br>Prefix sum computation: O(n) |
| **Space Complexity**  | **O(n)**      | Prefix sum array of size n (can be optimized to **O(1)** by accumulating travel on the fly) |

**Optimal** — linear time and linear space — perfectly efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: garbage = ["G","P","GP","GG"], travel = [2,4,3]

**Total pickup time** = sum of all garbage lengths = 1 + 1 + 2 + 2 = **6**

**Last positions** (maximum house index for each type):
- 'G': house 3 (last "GG")
- 'P': house 2 (last "P" in "GP")
- 'M': none (no 'M' at all)

**Prefix sums** of travel (cumulative time to reach house i from house 0):
- prefix[0] = 0
- prefix[1] = 2
- prefix[2] = 2 + 4 = 6
- prefix[3] = 6 + 3 = 9

**Driving time** for each truck:
- Glass truck: last house 3 → prefix[3] = 9
- Paper truck: last house 2 → prefix[2] = 6
- Metal truck: no garbage → 0

**Total driving** = 9 + 6 + 0 = **15**

**Final time** = pickup (6) + driving (15) = **21** → correct

**Correct** —  
Each truck only needs to travel as far as the **farthest house** that contains its garbage type.  
All garbage of that type before the last house will be collected **on the way** without extra driving cost.  
Pickup time is fixed and equals the total number of garbage units.  
Driving time is the sum of travel costs to reach the last house for each type that actually appears.

---

## Key Takeaway

This is a **beautiful greedy + prefix sum** problem:

* Compute **total pickup time** = sum of lengths of all garbage strings (total units)
* Find the **last house index** (maximum i) for each garbage type 'M', 'P', 'G'
* Precompute **prefix sums** of travel times (cumulative time from house 0 to house i)
* For each type that appears at least once: add prefix[last_house_for_type] to total driving time
* Final answer = total pickup time + total driving time

**Pure, clean, optimal** — O(n) time, O(n) space (prefix array — can be reduced to O(1) extra space by accumulating travel while scanning), extremely fast, very intuitive, and mathematically correct.

---

# ðŸ§  2327. Number of People Aware of a Secret

## ðŸ“˜ Problem Summary

On day 1, one person discovers a secret.  
Each person starts sharing the secret `delay` days after discovering it, and forgets the secret `forget` days after discovering it.  
A person cannot share the secret on the day they forget it or any day after.

Given an integer `n`, return the number of people who still remember the secret at the end of day `n`.  
Return the result modulo `10^9 + 7`.

---

## ðŸ”§ C# Implementation

```csharp
public class Solution {
    public int PeopleAwareOfSecret(int n, int delay, int forget) {
        int mod = 1_000_000_007;
        int[] dp = new int[n + 1];
        dp[1] = 1;
        int share = 0;

        for (int day = 2; day <= n; day++) {
            if (day - delay >= 1)
                share = (share + dp[day - delay]) % mod;

            if (day - forget >= 1)
                share = (share - dp[day - forget] + mod) % mod;

            dp[day] = share;
        }

        int res = 0;
        for (int i = n - forget + 1; i <= n; i++)
            res = (res + dp[i]) % mod;

        return res;
    }
}
```


## ðŸ“¶ Signal Table

| Signal            | Meaning                                           |
|-------------------|---------------------------------------------------|
| `dp[i]`           | Number of people who learned the secret on day `i` |
| `share`           | Number of people actively sharing on day `i`     |
| `delay / forget`  | Controls when sharing starts and ends            |
| Final sum (`res`) | People who still remember the secret on day `n`  |

---

## âœ… Takeaways

- This is a dynamic programming problem with **delayed activation** and **expiration**.
- We track how many people learn the secret each day using `dp[]`.
- `share` accumulates contributors who are in the sharing window.
- People who forget the secret are subtracted from `share`.
- Final result is the sum of people who still remember the secret on day `n`.

---

## ðŸ§© Conclusion

This solution models the spread of information over time using a day-indexed DP array.  
By carefully managing the sharing and forgetting windows, we maintain an accurate count of contributors.  
The use of modular arithmetic ensures correctness under large values.  
This pattern is reusable for any time-based propagation model with activation and expiration phases.


---

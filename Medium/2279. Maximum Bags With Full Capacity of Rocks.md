# 2279. Maximum Bags With Full Capacity of Rocks  
*O(n log n) — Greedy + Sorting Remaining Space*

---

## Problem Statement

You have `n` bags, each with:
- `capacity[i]` — maximum rocks it can hold
- `rocks[i]` — current rocks inside (`0 ≤ rocks[i] ≤ capacity[i]`)

You have `additionalRocks` extra rocks you can place in **any bags**.

Goal:  
Maximize the number of bags that reach **full capacity** (`rocks[i] + added == capacity[i]`).

Return this **maximum number**.

**Examples**:

**Example 1**: capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2  
Output: **3**  
- Bag 0 needs 1 more → add 1  
- Bag 1 needs 1 more → add 1  
- Bags 2 and 3 already full  
Result: **3** full bags

**Constraints**:
- n = capacity.length = rocks.length
- 1 ≤ n ≤ 5·10⁴
- 1 ≤ capacity[i] ≤ 10⁹
- 0 ≤ rocks[i] ≤ capacity[i]
- 1 ≤ additionalRocks ≤ 10⁹

---

## Core Idea — Greedy: Fill Bags with Smallest Remaining Space First

**Key insight**:
- A bag becomes full if we add exactly `need = capacity[i] - rocks[i]` rocks to it.
- We want to make as many bags full as possible with limited `additionalRocks`.
- Greedy strategy: **always fill the bag that requires the fewest additional rocks next**  
  → sort bags by remaining space (`need = capacity[i] - rocks[i]`) in ascending order
- Then try to fill them one by one until we run out of rocks

**Algorithm**:
1. Compute `need[i] = capacity[i] - rocks[i]` for each bag
2. Sort the `need` array in non-decreasing order
3. Initialize counter = 0
4. Iterate through sorted needs:
   - If `additionalRocks ≥ need[i]` → fill this bag, subtract need from rocks, increment counter
   - Else → stop (cannot fill this or any larger)
5. Return the counter

**Time**: O(n log n) — sorting dominates  
**Space**: O(n) — for need array (can be optimized to O(1) with counting sort if values were small, but 10⁹ range prevents it)

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int MaximumBags(int[] capacity, int[] rocks, int additionalRocks){
        int n = capacity.Length;

        // Compute remaining space needed for each bag
        int[] need = new int[n];
        for (int i = 0; i < n; i++){
            need[i] = capacity[i] - rocks[i];
        }

        // Sort by smallest need first (greedy)
        Array.Sort(need);
        int count = 0;
        long remaining = additionalRocks;

        // Try to fill bags starting from smallest need
        for (int i = 0; i < n; i++){
            if (remaining >= need[i]){
                remaining -= need[i];
                count++;
            }
            else break; // cannot fill this or any larger
        }

        return count;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)**| Computing remaining needs: O(n)<br>Sorting needs array: O(n log n)<br>Linear pass to fill bags: O(n) |
| **Space Complexity**  | **O(n)**      | Array to store remaining needs (can be optimized to O(1) extra space with in-place modification if allowed, but O(n) is clean and safe) |

**Optimal** — sorting is necessary in the worst case to guarantee greedy choice; the rest is linear — perfect and very efficient for n ≤ 5·10⁴.

---

## Why This Works — Example Walkthrough

**Example 1**: capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2

Compute needs:  
need = [2-1, 3-2, 4-4, 5-4] = **[1, 1, 0, 1]**

After sorting: **[0, 1, 1, 1]**

Simulation (greedy fill smallest first):
- need = 0 → already full, count = 1, remaining = 2
- need = 1 → 2 ≥ 1 → fill, count = 2, remaining = 1
- need = 1 → 1 ≥ 1 → fill, count = 3, remaining = 0
- need = 1 → 0 < 1 → cannot fill anymore

Result: **3** → correct

**Correct** —  
By sorting the remaining space needed in **ascending order**, we always prioritize filling the bags that are **closest to being full**.  
This greedy choice maximizes the number of completely filled bags given a limited number of additional rocks.

---

## Key Takeaway

This is a **classic greedy knapsack-style** problem (but without fractional items):

* Compute **remaining need** for each bag: `need[i] = capacity[i] - rocks[i]`
* **Sort** the needs in **non-decreasing order** (smallest first)
* Starting from the smallest need:
  * If remaining rocks ≥ current need → fill this bag, subtract need from remaining rocks, increment count
  * Else → stop (cannot fill this bag or any larger one)
* Return the total number of filled bags

**Pure, clean, optimal** — O(n log n) time (dominated by sorting), O(n) space (can be O(1) extra with care), very fast, intuitive, and mathematically correct.

---

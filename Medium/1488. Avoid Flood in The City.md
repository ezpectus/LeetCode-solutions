# üß† Problem Guide: 1488. Avoid Flood in The City

## üìò Problem Statement

You are given an array `rains` of length `n`, where:


- `rains[i] > 0` means it rains over lake `rains[i]` on day `i`.
- `rains[i] == 0` means it's a dry day ‚Äî you can choose **one lake** to dry.

Each lake starts empty. When it rains over a lake, it becomes full.  
If it rains again over a full lake **without drying it first**, a flood occurs.

Your goal is to **avoid all floods** by choosing which lake to dry on dry days.

### üîπ Return:

- An array `ans` of length `n`:
  - `ans[i] = -1` if `rains[i] > 0` (rain day)
  - `ans[i] = lake` if `rains[i] == 0` and you choose to dry `lake`
- If it's **impossible** to avoid a flood, return an empty array `[]`.

---

## üß© Strategy & Key Ideas

- Use a **Union-Find structure** to track the next available dry day.
- Use a **hash map** to track the last day each lake was filled.
- On a rain day:
  - If the lake was already filled before, find the **next dry day** after that.
  - If no dry day is available before the next rain, return `[]`.
- On a dry day:
  - Use `Find(i)` to locate the next available dry slot.
  - Use `Union(i)` to mark the day as used.

üìå This approach guarantees **O(n log n)** performance and avoids brute-force scanning.

---

## üß†C++ Code

```cpp
class UnionFind {
public:
    vector<int> root;

    UnionFind(vector<int>& rains, int n) {
        root.resize(n + 1);
        root[n] = n;
        for (int i = n - 1; i >= 0; i--) {
            root[i] = (rains[i]) ? root[i + 1] : i;
        }
    }

    int Find(int x) {
        return (x == root[x]) ? x : root[x] = Find(root[x]);
    }

    void Union(int x) {
        root[x] = Find(x + 1);
    }
};

class Solution {
public:
    vector<int> avoidFlood(vector<int>& rains) {
        const int n = rains.size();
        UnionFind G(rains, n);
        unordered_map<int, int> rainday;
        rainday.reserve(n);
        vector<int> res(n, 1);

        for (int i = 0; i < n; i++) {
            int lake = rains[i];

            if (lake > 0) {
                res[i] = -1;
                auto it = rainday.find(lake);

                if (it != rainday.end()) {
                    int prev = it->second;
                    int dry = G.Find(prev + 1);
                    if (dry >= i) return {};
                    res[dry] = lake;
                    G.Union(dry);
                    it->second = i;
                } else {
                    rainday[lake] = i;
                }
            }
        }

        return res;
    }
};
```

## üß† Complexity & Efficiency Analysis

### üîπ Time Complexity

- **Preprocessing (UnionFind init):**  
  O(n) ‚Äî one pass over the `rains` array to build the dry-day structure.

- **Main loop (`avoidFlood`):**  
  O(n * alpha(n)) ‚Äî where alpha(n) is the inverse Ackermann function.  
  This comes from path compression in `Find(x)`, which runs in near-constant time.

- **Hash map operations:**  
  O(1) ‚Äî amortized time for insertions and lookups.

**Summary:**  
Total time complexity is O(n * alpha(n)) ‚Äî practically linear, even for large inputs.

---

### üîπ Space Complexity

- **UnionFind root array:** O(n)  
- **Hash map `rainday`:** O(k), where k is the number of unique lakes  
- **Result array `res`:** O(n)

**Summary:**  
Total space complexity is O(n)

---

## ‚ö° Why This Is More Efficient Than Naive Approaches

### ‚ùå Naive approach:
- On each dry day, scan all previous days to find which lake to dry.
- Time complexity: O(n^2) or worse.
- Cannot pass constraints for n = 100000.

### ‚úÖ Our approach:
- Uses Union-Find as a dry-day allocator.
- Instead of scanning ‚Äî fast lookup of the next available dry day.
- Instead of guessing ‚Äî precise drying of the correct lake.

**Architectural signal:**  
We transform a scheduling problem into a dynamic resource allocation model,  
where dry days are slots and Union-Find is the allocator.

---

## ‚úÖ Conclusion

The `avoidFlood` algorithm is:

- Architecturally clean ‚Äî powered by Union-Find  
- Practically linear in time  
- Scales efficiently even for n = 100000  
- Avoids brute-force scanning and naive checks  
- Suitable for real-world planning, simulation, and constraint-driven systems

**Key takeaway:**  
When a problem demands precise allocation of limited resources (dry days),  
Union-Find turns chaos into order.  
This isn‚Äôt just an algorithm ‚Äî it‚Äôs an architectural stabilizer.


---

# Problem: Pyramid Transition Matrix  
## Number: LeetCode 756  
**Difficulty**: Medium  
**Language**: C++  

---

## Problem Overview

You are given a base row of blocks represented by a string `bottom`, and a list of allowed triangular patterns `allowed`.  
Each pattern is a string of three characters `"XYC"` meaning that block `C` can be placed above blocks `X` and `Y`.

Your goal is to determine whether it's possible to build the pyramid all the way to the top (a single block), using only the allowed patterns.

---

## Constraints

- `2 <= bottom.length <= 6`  
- `0 <= allowed.length <= 216`  
- Each `allowed[i]` is a 3-character string  
- Characters are from `'A'` to `'F'`  
- All patterns are unique

---

## Approach Summary

We use **recursive DFS with memoization** to explore all valid pyramid constructions:

### Phase 1: Preprocessing

- Build a map `mp` where `mp["XY"]` contains all possible top blocks `C` such that `"XYC"` is allowed.

### Phase 2: Recursive Construction

- Start from the base `bottom` and try to build the next level.
- For each adjacent pair of blocks in the current level, try all valid top blocks.
- Recursively build the next level until reaching the top.

### Phase 3: Memoization

- Store intermediate results in `memo` to avoid recomputation.
- Key: current level string; Value: whether it can lead to a valid pyramid.

---

## Code

```cpp
class Solution {
public:
    bool helper(int index, string nextBottom, string bottom,
                unordered_map<string, vector<char>> &mp,
                unordered_map<string, bool> &memo) {
        if (bottom.size() == 1) return true;

        if (index == bottom.size() - 1) {
            if (memo.find(nextBottom) != memo.end()) {
                return memo[nextBottom];
            }
            bool res = helper(0, "", nextBottom, mp, memo);
            memo[nextBottom] = res;
            return res;
        }

        string temp = bottom.substr(index, 2);
        for (char ch : mp[temp]) {
            if (helper(index + 1, nextBottom + ch, bottom, mp, memo)) {
                return true;
            }
        }
        return false;
    }

    bool pyramidTransition(string bottom, vector<string>& allowed) {
        unordered_map<string, vector<char>> mp;
        unordered_map<string, bool> memo;

        for (string &str : allowed) {
            string key = str.substr(0, 2);
            mp[key].push_back(str[2]);
        }

        return helper(0, "", bottom, mp, memo);
    }
};
```

## Complexity Analysis

**Time Complexity**  
Worst case: exponential — in the absence of memoization, each level of the pyramid may branch into multiple combinations.  
For a base of length `n`, the number of recursive calls can grow as `O(k^n)` where `k` is the average number of allowed transitions per pair.  
However, **memoization** drastically reduces redundant recomputation by caching intermediate results for each level string.  
This makes the solution feasible for `bottom.length <= 6`, as guaranteed by the constraints.

**Space Complexity**  
`O(n^2)` — due to:
- The recursion stack depth, which can reach up to `n` levels.
- The memoization map, which stores boolean results for intermediate strings of length up to `n`.

---

## Why This Works

- The recursive strategy systematically explores all valid pyramid paths from bottom to top.
- Each level is built by combining allowed transitions for adjacent pairs.
- Memoization ensures that repeated substructures (same intermediate rows) are computed only once.
- The problem size is small enough to allow full traversal without hitting performance limits.

---

## Related Concepts

- **DFS with memoization** — depth-first search with caching to avoid redundant paths  
- **String-based state encoding** — using strings to represent pyramid levels as memoization keys  
- **Tree-like recursive construction** — each level forms a branching structure based on allowed transitions  
- **Constraint-based simulation** — only transitions defined in `allowed[]` are permitted, enforcing strict build rules


---

# 554. Brick Wall — Architectural Prefix Frequency Solution  
*O(total bricks) — Edge Alignment Maximization*

---

## Problem Summary

We are given a brick wall represented as a list of rows.

- Each row contains bricks of varying widths but **equal height**.
- The **total width** of each row is the same.

We want to draw a **vertical line** from top to bottom that **crosses the least number of bricks**.

- If the line passes through the **edge** between two bricks → it **does not count** as crossing.
- The line **cannot** be drawn along the **extreme left or right edge**.

---

## Core Idea

The problem reduces to **finding a vertical line that passes through the maximum number of brick edges**.

- Each **edge position** (prefix sum of brick widths) is a candidate.
- The **maximum number of aligned edges** = maximum rows the line passes through **without crossing** a brick.
- **Answer** = `total rows - max aligned edges`

---

## Strategy

1. Traverse each row.
2. Compute **prefix sums** of brick widths (**excluding the last brick** — right edge is invalid).
3. Count **frequency** of each prefix sum across all rows.
4. Find the **maximum frequency** → maximum number of rows where the line passes through an edge.
5. Result = `n - maxFrequency`.

---

## Full Implementation (C#)

```csharp
public class Solution 
{
    public int LeastBricks(IList<IList<int>> wall) 
    {
        Dictionary<int, int> edgeCount = new Dictionary<int, int>();
        int n = wall.Count;
        
        foreach (var row in wall) 
        {
            int sum = 0;
            // Exclude last brick to avoid counting the right edge
            for (int i = 0; i < row.Count - 1; i++) 
            {
                sum += row[i];
                edgeCount[sum] = edgeCount.GetValueOrDefault(sum, 0) + 1;
            }
        }
        
        int maxEdges = 0;
        foreach (var kv in edgeCount) 
        {
            maxEdges = Math.Max(maxEdges, kv.Value);
        }
        
        return n - maxEdges;
    }
}
```

## Complexity

- **Time**: **O(total bricks)** — each brick processed once  
- **Space**: **O(unique edge positions)** — worst case O(n × row length)

## Pitfalls

- **Must exclude the last brick** in each row (right edge not allowed).
- **If no edges align** → result = total rows.
- **Large brick widths** → use `int` safely (sum fits in 32-bit).

## Edge Cases

- **Single brick per row** → result = `n` (no valid edge)  
- **All rows identical** → line passes through all edges → result = `0`  
- **Mixed widths but no common edge** → result = `n`

## Sanity Checks

- Input: `[[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]` → Output: `2`  
- Input: `[[1],[1],[1]]` → Output: `3`

## Key Takeaway

This is a **prefix sum + hash map frequency** problem:

- Count **edge alignments**.
- **Maximize edges** → **minimize crossed bricks**.
**Elegant O(n) solution with dictionary.**

---

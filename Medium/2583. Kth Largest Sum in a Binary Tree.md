## 🧫 LeetCode 2583 — Kth Largest Sum in a Binary Tree

### 📜 Problem Summary

You're given the root of a binary tree and an integer `k`.  
Each level of the tree has a **level sum** — the sum of all node values at that depth.  
Return the **k-th largest level sum**.  
If the tree has fewer than `k` levels, return `-1`.

---

### 🧠 Core Insight

This is a **level-order traversal** problem with **aggregation per level**.  
You don’t need to track structure — just **sum values level by level**, store them, and extract the `k`-th largest.

---

### 🔍 Architectural Triggers

- **"Level sum"** → requires BFS traversal  
- **"K-th largest"** → sort or use a heap  
- **"Binary tree, no constraints on shape"** → generic BFS, not symmetric DFS  
- **"Return -1 if not enough levels"** → must count levels explicitly

---

### 🔧 Architectural Strategy

#### 🔹 Core Structures

- `Queue<TreeNode>` — for level-order traversal  
- `List<long>` — to store level sums  
- `Sort descending` → extract `k-1` index

#### 🔹 Execution Phases

1. **BFS traversal**  
   - For each level, sum all node values  
   - Push children into queue for next level

2. **Sort level sums descending**  
   - If `k > levelCount` → return `-1`  
   - Else → return `levelSums[k - 1]`

---

## 🚀 C# Implementation

```csharp
public class Solution {
    public long KthLargestLevelSum(TreeNode root, int k) {
        var q = new Queue<TreeNode>();
        q.Enqueue(root);

        var levelSums = new List<long>();

        while (q.Count > 0) {
            int size = q.Count;
            long sum = 0;

            for (int i = 0; i < size; i++) {
                var node = q.Dequeue();
                sum += node.val;

                if (node.left != null) q.Enqueue(node.left);
                if (node.right != null) q.Enqueue(node.right);
            }

            levelSums.Add(sum);
        }

        if (levelSums.Count < k) return -1;

        levelSums.Sort((a, b) => b.CompareTo(a)); // Descending
        return levelSums[k - 1];
    }
}
```

## ⏱️ Time and Space Complexity

| Metric | Complexity      | Explanation |
|--------|------------------|-------------|
| Time   | O(n + L log L)   | BFS visits all `n` nodes; sorting `L` level sums takes `L log L`, where `L` is the number of levels. |
| Space  | O(L)             | Stores one sum per level; `L` is the height of the tree. |

---

## 🧱 Minimal Recall Block

```text
BFS level-order traversal  
Sum values per level  
Sort level sums descending  
Return k-th largest or -1
```
## 🧩 Generalization Pattern — Level Aggregation via BFS

### 📌 Applicable Scenarios

This architectural pattern applies to problems involving:

- **Level-based metrics** (sum, max, min, count)  
- **K-th ranked values across levels**  
- **Tree-wide analysis without structural mutation**

---

### 🔹 Core Idea

- Traverse the tree **level by level** using BFS  
- **Aggregate values** per level during traversal  
- **Post-process** level aggregates (sort, filter, rank) to extract desired result

---

### 🧠 Engineering Takeaways

- **BFS** is ideal for level-based aggregation — guarantees correct grouping  
- **Sorting** enables rank-based queries like k-th largest  
- No structural changes — this is **pure traversal and analysis**

> You don’t mutate the tree — you extract level-wise metrics and rank them post-traversal.

---

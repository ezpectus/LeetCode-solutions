## ğŸ§« LeetCode 2583 â€” Kth Largest Sum in a Binary Tree

### ğŸ“œ Problem Summary

You're given the root of a binary tree and an integer `k`.  
Each level of the tree has a **level sum** â€” the sum of all node values at that depth.  
Return the **k-th largest level sum**.  
If the tree has fewer than `k` levels, return `-1`.

---

### ğŸ§  Core Insight

This is a **level-order traversal** problem with **aggregation per level**.  
You donâ€™t need to track structure â€” just **sum values level by level**, store them, and extract the `k`-th largest.

---

### ğŸ” Architectural Triggers

- **"Level sum"** â†’ requires BFS traversal  
- **"K-th largest"** â†’ sort or use a heap  
- **"Binary tree, no constraints on shape"** â†’ generic BFS, not symmetric DFS  
- **"Return -1 if not enough levels"** â†’ must count levels explicitly

---

### ğŸ”§ Architectural Strategy

#### ğŸ”¹ Core Structures

- `Queue<TreeNode>` â€” for level-order traversal  
- `List<long>` â€” to store level sums  
- `Sort descending` â†’ extract `k-1` index

#### ğŸ”¹ Execution Phases

1. **BFS traversal**  
   - For each level, sum all node values  
   - Push children into queue for next level

2. **Sort level sums descending**  
   - If `k > levelCount` â†’ return `-1`  
   - Else â†’ return `levelSums[k - 1]`

---

## ğŸš€ C# Implementation

```csharp
public class Solution {
    public long KthLargestLevelSum(TreeNode root, int k) {
        var q = new Queue<TreeNode>();
        q.Enqueue(root);

        var levelSums = new List<long>();

        while (q.Count > 0) {
            int size = q.Count;
            long sum = 0;

            for (int i = 0; i < size; i++) {
                var node = q.Dequeue();
                sum += node.val;

                if (node.left != null) q.Enqueue(node.left);
                if (node.right != null) q.Enqueue(node.right);
            }

            levelSums.Add(sum);
        }

        if (levelSums.Count < k) return -1;

        levelSums.Sort((a, b) => b.CompareTo(a)); // Descending
        return levelSums[k - 1];
    }
}
```

## â±ï¸ Time and Space Complexity

| Metric | Complexity      | Explanation |
|--------|------------------|-------------|
| Time   | O(n + L log L)   | BFS visits all `n` nodes; sorting `L` level sums takes `L log L`, where `L` is the number of levels. |
| Space  | O(L)             | Stores one sum per level; `L` is the height of the tree. |

---

## ğŸ§± Minimal Recall Block

```text
BFS level-order traversal  
Sum values per level  
Sort level sums descending  
Return k-th largest or -1
```
## ğŸ§© Generalization Pattern â€” Level Aggregation via BFS

### ğŸ“Œ Applicable Scenarios

This architectural pattern applies to problems involving:

- **Level-based metrics** (sum, max, min, count)  
- **K-th ranked values across levels**  
- **Tree-wide analysis without structural mutation**

---

### ğŸ”¹ Core Idea

- Traverse the tree **level by level** using BFS  
- **Aggregate values** per level during traversal  
- **Post-process** level aggregates (sort, filter, rank) to extract desired result

---

### ğŸ§  Engineering Takeaways

- **BFS** is ideal for level-based aggregation â€” guarantees correct grouping  
- **Sorting** enables rank-based queries like k-th largest  
- No structural changes â€” this is **pure traversal and analysis**

> You donâ€™t mutate the tree â€” you extract level-wise metrics and rank them post-traversal.

---

# 998. Maximum Binary Tree II - Architectural Right-Spine Insertion  
*O(h) average, O(n) worst — Optimal Linear Traversal*

---

## Problem Statement

Given **maximum binary tree** root and new value `val`.

Maximum tree: every node > all values in its subtree.

Original tree built from array `a` via recursive max split.

Now append `val` to original array → new array `b`.

Return **new maximum tree** built from `b`.

**Guaranteed** unique values.

---

## Core Idea — Insert Along Right Spine

**Key insight**:
- Maximum tree → **right spine** = decreasing sequence (parent > right child)
- New `val` appended → belongs **rightmost** in array
- In tree → inserted **somewhere on right path**

**Cases**:
1. `val > root.val` → `val` becomes new root, old tree = left child
2. `val` smaller → traverse right:
   - Find first node where `val > node.val`
   - `val` becomes **right child** of previous
   - Old right subtree → left child of `val`

**Traverse right** until insertion point.

---

## Implementation (C++)
```cpp
class Solution {
public:
    TreeNode* insertIntoMaxTree(TreeNode* root, int val) {
        // Case 1: val becomes new root
        if (!root || val > root->val) {
            TreeNode* newNode = new TreeNode(val);
            newNode->left = root;
            return newNode;
        }

        // Case 2: insert on right spine
        TreeNode* cur = root;
        while (cur->right && val < cur->right->val)  cur = cur->right;
        

        // Insert val as right child of cur
        TreeNode* newNode = new TreeNode(val);
        newNode->left = cur->right;
        cur->right = newNode;

        return root;
    }
};
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(h)** average      | h = height, worst O(n) in skewed tree          |
| **Space Complexity**  | **O(1)**              | Only a few pointers                            |

**Optimal** — minimal traversal along the right spine.

---

## Why This Works — Example Walkthrough

**Input**: `root = [4,1,3,null,null,2]`, `val = 5`

- 5 > 4 → **new root**
- Old tree becomes **left child**
→ `[5,4,null,1,3,null,null,2]`

**Correct**.

**Input**: `root = [5,2,4,null,1]`, `val = 3`

- 3 < 5 → go right to 4
- 3 < 4 → go right (null)
- Insert 3 as **right child of 4**
→ `[5,2,4,null,1,null,3]`

**Correct**.

**Input**: `root = [5,2,3,null,1]`, `val = 4`

- 4 < 5 → right = 3
- 4 > 3 → insert **as right child of 2**
- Old right (3) becomes **left child** of new node 4
→ `[5,2,4,null,1,3]`

**Correct**.

---

## Pitfalls & Edge Cases

- **val > root** → becomes new root, old tree = left child
- **Insert in middle** → old right subtree becomes left of new node
- **Insert at end** → right child was null
- **Single node tree** → handled correctly

All covered perfectly.

---

## Key Takeaway

This is a **beautifully simple** tree insertion:

- **Right spine** = decreasing sequence → natural insertion path
- **Compare with right children** → find exact spot
- **One linear pass** → insert with correct maximum tree structure

**No tree rebuild. No recursion needed.**
**Pure, clean, optimal** — one of the most elegant tree modification problems.

---

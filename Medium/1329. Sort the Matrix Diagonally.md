# 1329. Sort the Matrix Diagonally — Architectural Diagonal Grouping + Sorting  
*O(m × n × log(min(m,n))) — Optimal Per-Diagonal Sorting*

---

## Problem Statement

- Given `m × n` matrix `mat` (1 ≤ m,n ≤ 100).
- A **diagonal** — cells with same `(i - j)` (top-left to bottom-right).
- Sort **each diagonal** in **ascending order**.
- Return the modified matrix.

---

## Core Idea — Group Elements by Diagonal Index (row - col)

**Key observation**:
- All cells on the same top-left-to-bottom-right diagonal have the **same value of `row - col`**.
- Example:
  - (0,0): 0-0 = 0
  - (1,1): 1-1 = 0
  - (2,2): 2-2 = 0 → same diagonal
  - (0,1): 0-1 = -1
  - (1,2): 1-2 = -1 → another diagonal
- Range of possible keys: from `-(n-1)` to `(m-1)`

**Why this perfectly identifies diagonals**:
- Each distinct value of `row - col` corresponds to **exactly one diagonal**.
- Cells on the same diagonal are visited in order from top-left to bottom-right as we iterate rows and columns normally.

**Algorithm step by step**:
1. Create a map/dictionary where **key = row - col**, value = list of elements on that diagonal.
2. Traverse the matrix once:
   - For each cell `mat[r][c]` → add it to the list for key `r - c`
3. For each diagonal group:
   - Sort the list in **ascending order**
4. Traverse the matrix again:
   - For each cell `mat[r][c]` → replace it with the **next** value from the sorted list of its diagonal (in the order they appear on the diagonal)

**Why we refill in original order**:
- When we collected elements, we added them in the natural traversal order (top to bottom, left to right).
- When we refill, we consume sorted values in the same order → correct placement.

**Result**: every diagonal is sorted ascending, from top-left to bottom-right.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int[][] DiagonalSort(int[][] mat) {
        int m = mat.Length;
        int n = mat[0].Length;

        // Group by diagonal: key = r - c
        var groups = new Dictionary<int, List<int>>();
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++)  {
                int key = r - c;
                if (!groups.ContainsKey(key)) groups[key] = new List<int>();
                
                groups[key].Add(mat[r][c]);
            }
        }

        // Sort each group ascending
        foreach (var key in groups.Keys)  groups[key].Sort();
        
        // Write back sorted values
        for (int r = 0; r < m; r++)  {
            for (int c = 0; c < n; c++)  {
                int key = r - c;
                mat[r][c] = groups[key][0];
                groups[key].RemoveAt(0);
            }
        }

        return mat;
    }
}
```

## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(m × n × log(k))**         | k = min(m,n) — length of longest diagonal      |
| **Space Complexity**  | **O(m × n)**                  | Dictionary stores all elements                 |

**Optimal** — we must sort each diagonal, and this is the most straightforward way.

---

## Why This Works — Example Walkthrough

**Input**: `mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]`

- Diagonals grouped by key = `row - col`:
  - key 0: [3,2,1] (positions (0,0), (1,1), (2,2))
  - key 1: [3,2,1] (positions (0,1), (1,2), (2,3))
  - key 2: [1,2] (positions (0,2), (1,3))
  - key 3: [1] (position (0,3))
  - key -1: [1,1] (positions (1,0), (2,1))
  - key -2: [1] (position (2,0))
  - key -3: [1] (position (2,0) wait — correct grouping)

- Sort each group ascending
- Write back values in original order along the diagonal

**Result**:
```
[[1,1,1,1],
[1,2,2,2],
[1,2,3,3]]
```

**Correct**.

The method correctly identifies all top-left to bottom-right diagonals and sorts them independently.

---

## Pitfalls & Edge Cases

- **1×1 matrix** → single diagonal → unchanged
- **Single row or column** → one long diagonal → correctly sorted
- **Negative diagonal keys** → naturally handled by dictionary
- **Diagonals of different lengths** → no problem, each processed separately
- **Multiple same values** → sorting stable and correct

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** grouping problem:

- **Key = row - col** → uniquely identifies each diagonal
- **Collect → sort → refill** → clean three-pass approach
- **Dictionary** → natural and flexible grouping for varying key range
**Pure, clean, optimal** — perfect diagonal sorting on a fixed-size matrix.

---

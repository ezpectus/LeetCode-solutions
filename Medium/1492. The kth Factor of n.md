# 🧩 Problem: The K-th Factor of n  
## 🔢 Number: LeetCode 1492  
**Difficulty**: Medium  
**Language**: C#  
**Status**: ✅ Solved via linear scan over factors  

---

## 📜 Problem Overview

You're given two positive integers `n` and `k`.  
A **factor** of `n` is any integer `i` such that `n % i == 0`.  
Return the **k-th smallest factor** of `n`, or `-1` if `n` has fewer than `k` factors.

---

### 🔢 Constraints
- `1 ≤ k ≤ n ≤ 1000`  
- All factors are positive integers  
- Factors must be returned in **ascending order**

---

### 🎁 What’s Given
- Integer `n` — the number to factor  
- Integer `k` — the position in the sorted list of factors  
- Return the `k-th` factor or `-1` if it doesn't exist

---

### 👀 What We Observe
- Factors of `n` are always ≤ `n`  
- We can iterate from `1` to `n` and collect factors  
- Once we reach the `k-th` factor, we return it  
- If we finish the loop and haven't reached `k`, return `-1`

---

## 🧠 Explanation

We initialize a counter `facts = 0`.  
We iterate `i` from `1` to `n`, and for each `i`:
- If `n % i == 0`, it's a valid factor  
- Increment `facts`  
- If `facts == k`, return `i` immediately

If the loop ends and `facts < k`, return `-1`.

---

## ⚙️ Algorithm Choice
- **Approach**: Linear scan from `1` to `n`  
- **Why**: Simple, direct, and efficient for `n ≤ 1000`  
- **Efficiency**: O(n) time, O(1) space  
- **Memory**: No extra allocations

---

## 💡 Idea Summary
- Loop from `1` to `n`  
- Count valid factors  
- Return the `k-th` one when found  
- If not found, return `-1`

---

## 🧾 Code
```csharp
public class Solution {
    public int KthFactor(int n, int k) {
        int facts = 0;

        for (int i = 1; i <= n; i++) {
            if (n % i == 0) {
                facts++;
                if (facts == k) return i;
            }
        }

        return -1;
    }
}
```

## ✅ Complexity, Insights & Notes

### ⏱ Time Complexity
- **O(n)** — single pass from `1` to `n`, checking divisibility

### 🧠 Space Complexity
- **O(1)** — no extra data structures, all logic in-place

---

### 🧨 Tricks / Insights
- **Early return** avoids unnecessary iterations once the `k-th` factor is found  
- **No need to store** the full list of factors — we count and return directly  
- **Efficient for small `n`**, but not scalable for large `n` due to linear scan

---

### 🧠 Notes
- Follow-up asks for **sublinear solution**  
- Can be optimized via **factor pairs** and **square root traversal**  
- But for `n ≤ 1000`, **linear scan is optimal and clean**

---

### 🔗 Related Concepts
- **Divisor enumeration**  
- **Early exit in loops**  
- **Constraint-based optimization**

---

# ğŸ§© Problem: The K-th Factor of n  
## ğŸ”¢ Number: LeetCode 1492  
**Difficulty**: Medium  
**Language**: C#  
**Status**: âœ… Solved via linear scan over factors  

---

## ğŸ“œ Problem Overview

You're given two positive integers `n` and `k`.  
A **factor** of `n` is any integer `i` such that `n % i == 0`.  
Return the **k-th smallest factor** of `n`, or `-1` if `n` has fewer than `k` factors.

---

### ğŸ”¢ Constraints
- `1 â‰¤ k â‰¤ n â‰¤ 1000`  
- All factors are positive integers  
- Factors must be returned in **ascending order**

---

### ğŸ Whatâ€™s Given
- Integer `n` â€” the number to factor  
- Integer `k` â€” the position in the sorted list of factors  
- Return the `k-th` factor or `-1` if it doesn't exist

---

### ğŸ‘€ What We Observe
- Factors of `n` are always â‰¤ `n`  
- We can iterate from `1` to `n` and collect factors  
- Once we reach the `k-th` factor, we return it  
- If we finish the loop and haven't reached `k`, return `-1`

---

## ğŸ§  Explanation

We initialize a counter `facts = 0`.  
We iterate `i` from `1` to `n`, and for each `i`:
- If `n % i == 0`, it's a valid factor  
- Increment `facts`  
- If `facts == k`, return `i` immediately

If the loop ends and `facts < k`, return `-1`.

---

## âš™ï¸ Algorithm Choice
- **Approach**: Linear scan from `1` to `n`  
- **Why**: Simple, direct, and efficient for `n â‰¤ 1000`  
- **Efficiency**: O(n) time, O(1) space  
- **Memory**: No extra allocations

---

## ğŸ’¡ Idea Summary
- Loop from `1` to `n`  
- Count valid factors  
- Return the `k-th` one when found  
- If not found, return `-1`

---

## ğŸ§¾ Code
```csharp
public class Solution {
    public int KthFactor(int n, int k) {
        int facts = 0;

        for (int i = 1; i <= n; i++) {
            if (n % i == 0) {
                facts++;
                if (facts == k) return i;
            }
        }

        return -1;
    }
}
```

## âœ… Complexity, Insights & Notes

### â± Time Complexity
- **O(n)** â€” single pass from `1` to `n`, checking divisibility

### ğŸ§  Space Complexity
- **O(1)** â€” no extra data structures, all logic in-place

---

### ğŸ§¨ Tricks / Insights
- **Early return** avoids unnecessary iterations once the `k-th` factor is found  
- **No need to store** the full list of factors â€” we count and return directly  
- **Efficient for small `n`**, but not scalable for large `n` due to linear scan

---

### ğŸ§  Notes
- Follow-up asks for **sublinear solution**  
- Can be optimized via **factor pairs** and **square root traversal**  
- But for `n â‰¤ 1000`, **linear scan is optimal and clean**

---

### ğŸ”— Related Concepts
- **Divisor enumeration**  
- **Early exit in loops**  
- **Constraint-based optimization**

---

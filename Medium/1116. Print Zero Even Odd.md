# 1116. Print Zero Even Odd — Architectural Semaphore-Based Strict Alternation  
*O(n) — Optimal Multi-Thread Synchronization with Three Semaphores*

---

## Problem Statement

You are given a class `ZeroEvenOdd` with three methods that will be called by **three concurrent threads**:

- `Zero()` — should print **only zeros**
- `Odd()` — should print **only odd numbers** (1, 3, 5, ...)
- `Even()` — should print **only even numbers** (2, 4, 6, ...)

The output must be strictly: `"0102030405..."` of length `2n`.

Example: `n = 2` → `"0102"`  
Example: `n = 5` → `"0102030405"`

---

## Core Idea — Three Semaphores for Precise Turn Control

**Key insight**:
- The sequence is **0 → number → 0 → number → ...**
- After each **0**, we must decide whether to release **odd** or **even** next
- Use **three semaphores**:
  - `zeroSem` — allows printing 0 (starts open)
  - `oddSem` — allows printing next odd number
  - `evenSem` — allows printing next even number
- Shared counter `curr` tracks the next number to print (1,2,3,...)

**Flow**:
- Zero: waits → prints 0 → releases odd/even based on turn → 
- Odd/Even: waits → prints current number → increments → releases zero

→ Guarantees perfect order: 0 → 1 → 0 → 2 → 0 → 3 → ...

---

## Full Optimal Implementation (C#)

```csharp
using System.Threading;

public class ZeroEvenOdd 
{
    private int n;
    private SemaphoreSlim zeroSem = new(1, 1);  // Zero goes first
    private SemaphoreSlim oddSem = new(0, 1);   // Odd waits after 0
    private SemaphoreSlim evenSem = new(0, 1);  // Even waits after 0
    private int curr = 1;                       // Next number to print

    public ZeroEvenOdd(int n) 
    {
        this.n = n;
    }

    public void Zero(Action<int> printNumber) 
    {
        for (int i = 1; i <= n; i++) 
        {
            zeroSem.Wait();
            printNumber(0);
            if (i % 2 == 1) oddSem.Release();   // Next is odd
            else evenSem.Release();             // Next is even
        }
    }

    public void Odd(Action<int> printNumber) 
    {
        for (int i = 1; i <= n; i += 2) 
        {
            oddSem.Wait();
            printNumber(curr++);
            zeroSem.Release();
        }
    }

    public void Even(Action<int> printNumber) 
    {
        for (int i = 2; i <= n; i += 2) 
        {
            evenSem.Wait();
            printNumber(curr++);
            zeroSem.Release();
        }
    }
}
```


## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | n iterations per method                        |
| **Space Complexity**  | **O(1)**      | Only semaphores and counter                    |

**Optimal** — minimal state, no deadlock, strict order.

---

## Why This Works — Execution Flow

**Example**: `n = 2` → expected `"0102"`

- **Zero** (i=1): prints **0** → releases `oddSem`
- **Odd**: prints **1** → releases `zeroSem`
- **Zero** (i=2): prints **0** → releases `evenSem`
- **Even**: prints **2** → releases `zeroSem` (end)

**Output**: `0102` — **correct**.

**For n=5**: `0102030405` — perfect alternation.

---

## Pitfalls & Edge Cases

- **n=1** → `"01"` or `"02"` — handled by turn logic (odd/even based on i)
- **Thread scheduling** → semaphores enforce order regardless of start time or execution speed
- **No race condition** → `curr++` safe: only one number-printing thread active at a time
- **No deadlock** → every print is always followed by a release
- **Concurrent start** → `zeroSem` ensures zero prints first

All handled perfectly.

---

## Key Takeaway

This is a **clean and reliable** multi-thread coordination:

- **Three semaphores** → precise control over zero/odd/even turns
- **Shared counter** → correct number sequencing
- **No extra locks or flags** → efficient and simple
**Pure, clean, optimal** — perfect zero-odd-even printing.
  
---

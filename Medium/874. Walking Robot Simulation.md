# 874. Walking Robot Simulation — Architectural Direction Vector + Obstacle Set  
*O(c + o) — Optimal Simulation with Fast Lookup*

---

## Problem Statement

Robot starts at `(0,0)` facing **north**.

Commands:
- `-2`: turn left 90°
- `-1`: turn right 90°
- `1–9`: move forward **k steps**

Obstacles block movement — robot **stops before** hitting one.

Return **maximum squared Euclidean distance** from origin reached during path.

---

## Core Idea — Direct Simulation with Direction Vectors + Fast Obstacle Lookup

**Why simulation works**:
- Total steps ≤ 9 × 10⁴ → completely safe
- n up to 10⁹ → **cannot use grid**
- Obstacles ≤ 10⁴ → perfect for fast lookup

**Key components**:

- **Direction vectors**:
  - North: `[0, 1]`
  - East: `[1, 0]`
  - South: `[0, -1]`
  - West: `[-1, 0]`
  - Current direction index (0–3)

- **HashSet for obstacles**:
  - Encode `(x,y)` → `long key = (long)x * 60001 + y` (safe for |coord| ≤ 3×10⁴)
  - O(1) check if next cell blocked

- **Step-by-step movement**:
  - For each forward command `k`:
    - Try moving **one step at a time**
    - If next cell in obstacle set → **stop**
    - Otherwise → move and update max distance

**Track** `max(x² + y²)`.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int RobotSim(int[] commands, int[][] obstacles) {
        // Direction vectors: N, E, S, W
        int[][] dirs = new int[][] {
            new int[] {0, 1},   // North
            new int[] {1, 0},   // East
            new int[] {0, -1},  // South
            new int[] {-1, 0}   // West
        };

        // Obstacles in HashSet for O(1) lookup
        var obs = new HashSet<long>();
        foreach (var o in obstacles) {
            long key = (long)o[0] * 60001 + o[1]; // safe encoding
            obs.Add(key);
        }

        int x = 0, y = 0;
        int dir = 0; // 0=N, 1=E, 2=S, 3=W
        int maxDist = 0;

        foreach (int cmd in commands) {
            if (cmd == -1)  dir = (dir + 1) % 4; // right
            else if (cmd == -2)  dir = (dir + 3) % 4; // left
            else {
                // Move step by step
                for (int i = 0; i < cmd; i++) {
                    int nx = x + dirs[dir][0];
                    int ny = y + dirs[dir][1];

                    long key = (long)nx * 60001 + ny;
                    if (obs.Contains(key)) break; 

                    x = nx;
                    y = ny;
                    maxDist = Math.Max(maxDist, x * x + y * y);
                }
            }
        }

        return maxDist;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(c + o)**          | c = total steps ≤ 9×10⁴, o = obstacles count   |
| **Space Complexity**  | **O(o)**              | HashSet for obstacles                          |

**Optimal** — fastest possible.

---

## Why This Works — Example Walkthrough

**Input**: `commands = [4,-1,4,-2,4]`, `obstacles = [[2,4]]`

- Start at `(0,0)` facing **North**
- Move 4 → `(0,4)`
- Turn right → **East**
- Move 4 → next cells: `(1,4)`, `(2,4)` — hits obstacle at `(2,4)` → stop at `(1,4)`
- Turn left → **North**
- Move 4 → `(1,8)`
- Max squared distance = `1² + 8² = 65`

**Correct**.

**Input**: `commands = [6,-1,-1,6]`, `obstacles = [[0,0]]`

- Start at `(0,0)` facing **North**
- Move 6 → `(0,6)`
- Turn right → **East**
- Turn right → **South**
- Move 6 south → from `(0,6)` → `(0,5)`, ..., `(0,1)` — next `(0,0)` blocked → stop at `(0,1)`
- Max squared distance = `0² + 6² = 36`

**Correct**.

---

## Pitfalls & Edge Cases

- **Obstacle at (0,0)** → does **not** block initial moves (robot starts there)
- **Multiple steps** → **step-by-step** check → stop before obstacle
- **Large coordinates** → use `long` key → safe encoding
- **No movement** → return 0
- **Obstacle on path** → robot stops adjacent

All handled perfectly.

---

## Key Takeaway

This is a **beautifully straightforward** simulation:

- **Direction array** → clean 90° turns
- **HashSet** → O(1) obstacle lookup
- **Step-by-step move** → correct blocking behavior

**No complex math. No grid allocation.**
**Pure, clean, optimal** — one of the nicest simulation problems.

---

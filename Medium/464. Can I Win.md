# 🧠 Pattern: Bitmask DFS + Memoization — "Can I Win"

## 🔍 Problem Summary

- Given maxChoosableInteger and desiredTotal, determine if the first player can force a win assuming both players play optimally.
- Each player picks a number from 1 to maxChoosableInteger without reuse. The picked number is added to a running total. 
- The player who causes the total to reach or exceed desiredTotal wins.

## 📌 Constraints

- 1 <= maxChoosableInteger <= 20
- 0 <= desiredTotal <= 300

## 🧩 Key Observations

Total sum of all choosable numbers is: $$\text{Sum} = \frac{n(n+1)}{2}$$ If Sum < desiredTotal, then no one can win → return false.
State space is exponential → use bitmasking to represent used numbers.
Use DFS + memoization to explore all possible moves.

## 🧠 State Definition

- used: integer bitmask representing which numbers have been picked.
- totalLeft: remaining total needed to win.

## 🧪 Base Case

- If current player can pick a number i such that i >= totalLeft, they win immediately.

## 🧠 Recursive Transition

```csharp
bool DFS(int used, int totalLeft) {
    if (memo.ContainsKey(used)) return memo[used];

    for (int i = 1; i <= maxChoosableInteger; i++) {
        int mask = 1 << (i - 1);
        if ((used & mask) != 0) continue; // already used

        // If picking i wins the game OR forces opponent into losing state
        if (i >= totalLeft || !DFS(used | mask, totalLeft - i)) {
            memo[used] = true;
            return true;
        }
    }

    memo[used] = false;
    return false;
}
```

## ✅ Final Implementation

```csharp
public bool CanIWin(int maxChoosableInteger, int desiredTotal) {
    if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal)
        return false;

    Dictionary<int, bool> memo = new();
    return DFS(0, desiredTotal);

    bool DFS(int used, int totalLeft) {
        if (memo.ContainsKey(used)) return memo[used];
        for (int i = 1; i <= maxChoosableInteger; i++) {
            int mask = 1 << (i - 1);
            if ((used & mask) != 0) continue;
            if (i >= totalLeft || !DFS(used | mask, totalLeft - i)) {
                memo[used] = true;
                return true;
            }
        }
        memo[used] = false;
        return false;
    }
}
```


## 🧠 Engineering Takeaways

- Bitmasking is powerful for tracking used elements in fixed-size sets.
- Always check for impossible cases early to avoid wasted recursion.
- Memoization key should be minimal yet uniquely represent the state.




----

# EarliestFinishTime Solution

This document provides a commented C# implementation of `EarliestFinishTime`, which computes the earliest possible finish time for completing exactly one land ride and one water ride, in either order.

## Algorithm Overview

1. Find the single land ride that finishes earliest (`landFirstEnd`).  
2. Track the single water ride that finishes earliest (`waterFirstEnd`).  
3. For each water ride, compute finishing time if you do the fastest land first, then this water ride.  
4. For each land ride, compute finishing time if you do the fastest water first, then this land ride.  
5. Return the minimum finish time across all these sequences.

---

## Code

```csharp
public class Solution
{
    /// <summary>
    /// Computes the earliest possible finish time to complete exactly one land ride
    /// and one water ride in either order.
    /// </summary>
    public int EarliestFinishTime(
        int[] landStartTime,
        int[] landDuration,
        int[] waterStartTime,
        int[] waterDuration)
    {
        int n = landStartTime.Length;
        int m = waterStartTime.Length;

        // Track the earliest finish among all land rides
        int landFirstEnd = int.MaxValue;
        // Track the earliest finish among all water rides
        int waterFirstEnd = int.MaxValue;

        // 1) Find the earliest finishing land ride (global minimum)
        for (int i = 0; i < n; i++)
        {
            int finish = landStartTime[i] + landDuration[i];
            if (finish < landFirstEnd)
            {
                landFirstEnd = finish;
            }
        }

        // result holds the best overall finish time (initialized to a large value)
        int result = int.MaxValue;

        // 2) Iterate over water rides:
        //    a) update the earliest water finish so far
        //    b) compute finish time if you go land→water (fastest land first)
        for (int i = 0; i < m; i++)
        {
            int thisFinish = waterStartTime[i] + waterDuration[i];
            if (thisFinish < waterFirstEnd)
            {
                waterFirstEnd = thisFinish;
            }

            // finish time when doing land first, then this water ride
            int finishLandThenWater = Math.Max(landFirstEnd, waterStartTime[i])
                                     + waterDuration[i];

            if (finishLandThenWater < result)
            {
                result = finishLandThenWater;
            }
        }

        // 3) Iterate over land rides to consider water→land sequences:
        //    use the fastest water ride first, then each land ride
        for (int i = 0; i < n; i++)
        {
            int finishWaterThenLand = Math.Max(waterFirstEnd, landStartTime[i])
                                     + landDuration[i];

            if (finishWaterThenLand < result)
            {
                result = finishWaterThenLand;
            }
        }

        // 4) Return the best finish time found
        return result;
    }
}
```

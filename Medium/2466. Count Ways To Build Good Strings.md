# 2466. Count Ways To Build Good Strings  
*O(high) — Classic 1D DP (Knapsack Style)*

---

## Problem Statement

You can build strings using two operations any number of times (including zero):

- Append `'0'` exactly `zero` times
- Append `'1'` exactly `one` times

A **good string** is any string built this way with length between `low` and `high` (inclusive).

Return the **number of different good strings** modulo 10⁹ + 7.

**Examples**:

**Example 1**  
Input: low = 3, high = 3, zero = 1, one = 1  
Output: **8**  
All binary strings of length exactly 3 ("000" to "111") are possible.

**Example 2**  
Input: low = 2, high = 3, zero = 1, one = 2  
Output: **5**  
Good strings: "00", "11", "000", "110", "011"

**Constraints**:
- 1 ≤ low ≤ high ≤ 10⁵
- 1 ≤ zero, one ≤ low

---

## Core Idea — 1D Dynamic Programming (Knapsack on Length)

**Key insight**:
- We are counting the number of ways to reach lengths in [low, high] using steps of size `zero` (append '0's) and `one` (append '1's)
- This is a classic **unbounded knapsack** / **coin change** problem where:
  - "coins" = {zero, one}
  - We want number of ways to make each length
- We only care about lengths from 0 to high (since low ≤ high ≤ 10⁵)

**DP definition**:
- `dp[len]` = number of ways to build a string of **exactly** length `len`

**Base**:
- dp[0] = 1 (empty string — 1 way)

**Transition**:
- For each length `i` from 0 to high:
  - If i + zero ≤ high → dp[i + zero] += dp[i]
  - If i + one ≤ high → dp[i + one] += dp[i]

**Answer** = sum of dp[len] for len from low to high, modulo 10⁹+7

**Optimization**:
- We can iterate in increasing order of length and accumulate ways
- Use modulo at each step

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int CountGoodStrings(int low, int high, int zero, int one){
        const int MOD = 1_000_000_007;
        int[] dp = new int[high + 1];
        dp[0] = 1;  // one way to make empty string

        for (int i = 0; i <= high; i++){
            if (dp[i] == 0) continue;

            // Add zero '0's
            if (i + zero <= high){
                dp[i + zero] = (dp[i + zero] + dp[i]) % MOD;
            }

            // Add one '1's
            if (i + one <= high){
                dp[i + one] = (dp[i + one] + dp[i]) % MOD;
            }
        }

        long answer = 0;
        for (int len = low; len <= high; len++){
            answer = (answer + dp[len]) % MOD;
        }

        return (int)answer;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(high)**   | DP loop runs from 0 to high (≤ 10⁵), each iteration performs constant-time operations |
| **Space Complexity**  | **O(high)**   | DP array of size high + 1 (can be optimized to O(1) extra space if needed, but usually not necessary) |

**Optimal** — linear time in the maximum possible length — perfectly efficient for high ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: low = 3, high = 3, zero = 1, one = 1

**DP simulation** (modulo not needed here as numbers are small):

- dp[0] = 1  (empty string — 1 way)
- From length 0: can add "0" (length +1) → dp[1] += dp[0] → dp[1] = 1
- From length 0: can add "1" (length +1) → dp[1] += dp[0] → dp[1] = 2
- From length 1: add "0" → dp[2] += dp[1] → dp[2] = 2
- From length 1: add "1" → dp[2] += dp[1] → dp[2] = 4
- From length 2: add "0" → dp[3] += dp[2] → dp[3] = 4
- From length 2: add "1" → dp[3] += dp[2] → dp[3] = 8

**Sum for lengths 3 to 3** = dp[3] = **8** → correct  
(All possible binary strings of length 3: 000, 001, 010, 011, 100, 101, 110, 111 — exactly 8)

**Correct** —  
We count the number of ways to reach **exactly** each possible length using additions of `+zero` and `+one`.  
The final answer is the sum of all ways for lengths in the range [low, high], taken modulo 10⁹ + 7.

---

## Key Takeaway

This is a **classic dynamic programming "number of ways to make sum"** problem (similar to unbounded knapsack / coin change — number of combinations):

* Treat `zero` and `one` as two possible step sizes ("coins")
* `dp[len]` = number of ways to construct a string of **exactly** length `len`
* Base case: `dp[0] = 1` (one way to make empty string)
* Transition: from every reachable length `i`, we can:
  - Add `zero` '0's → go to `i + zero`
  - Add `one` '1's → go to `i + one`
* Answer = sum of `dp[len]` for all `len` in [low, high], modulo 10⁹ + 7



---

# 🔺 Problem: Prime Palindrome (Leetcode 866)

## 📜 Statement

Given an integer `n`, return the smallest prime palindrome greater than or equal to `n`.

- A **prime** number has exactly two divisors: `1` and itself.
- A **palindrome** reads the same forward and backward.

Constraints:
- `1 <= n <= 2 * 10⁸`
- The answer is guaranteed to exist within this range.

---

## 🧠 Core Idea

This is a **number theory filter** task.  
We need to find the first number ≥ `n` that satisfies **two conditions**:

1. It is a **palindrome**
2. It is a **prime**

Instead of generating all palindromes or primes, we **incrementally check each number** starting from `n`.  
To optimize, we skip **even-length palindromes > 11**, since they are never prime (except 11).

> Think of it as a **dual predicate search**:  
> `while (!IsPalindrome(n) || !IsPrime(n)) → n++`

---

## 🧪 Examples

```text
Input: n = 6
→ 7 is prime and palindrome → Output: 7

Input: n = 8
→ 8 → not prime  
→ 9 → not prime  
→ 10 → not palindrome  
→ 11 → prime and palindrome → Output: 11

Input: n = 13
→ 13 → not palindrome  
→ 14 → not prime  
→ ...  
→ 101 → prime and palindrome → Output: 101
```

## 🧱 C# Implementation
```cpp
public class Solution {
    public int PrimePalindrome(int n) {
        while (true) {
            if (IsPalindrome(n) && IsPrime(n)) return n;
            n++;

            // Optimization: skip even-length palindromes > 11
            if (n > 11 && IsEvenLength(n)) 
                n = (int)Math.Pow(10, n.ToString().Length);
        }
    }

    private bool IsPalindrome(int x) {
        var s = x.ToString();
        int i = 0, j = s.Length - 1;
        while (i < j) {
            if (s[i++] != s[j--]) return false;
        }
        return true;
    }

    private bool IsPrime(int x) {
        if (x < 2) return false;
        if (x == 2) return true;
        if (x % 2 == 0) return false;
        int sqrt = (int)Math.Sqrt(x);
        for (int i = 3; i <= sqrt; i += 2) {
            if (x % i == 0) return false;
        }
        return true;
    }

    private bool IsEvenLength(int x) {
        return x.ToString().Length % 2 == 0;
    }
}
```

## 🔍 Why This Code Is Optimized

### ✅ Predicate Filtering
Combines `IsPalindrome` and `IsPrime` checks in a single loop.  
Avoids unnecessary generation or storage — no need to precompute or cache candidates.

### 🚫 Even-Length Skip
All even-length palindromes greater than 11 are divisible by 11 and therefore not prime.  
Skipping them drastically reduces the search space and avoids false positives.

### 🧮 Efficient Primality Test
Checks up to `sqrt(n)` using only odd divisors.  
Avoids redundant checks and handles edge cases like small primes and even numbers.

### 🧠 Minimal State
No arrays, no string manipulation overhead.  
Pure arithmetic and control flow — fast, memory-light, and cache-friendly.

---

## 🧮 Time & Space Complexity

| Metric      | Value             | Notes                                      |
|-------------|-------------------|--------------------------------------------|
| Time        | O(k × √n)         | `k` = number of candidates checked         |
| Space       | O(1)              | No extra allocations                       |
| Stability   | High              | Deterministic, no branching                |
| Scalability | Excellent         | Handles full input range smoothly          |

---

## 🧠 Engineering Takeaway

This task is a clean example of:

- ✅ **Predicate-based filtering** — no need for generation or simulation  
- 🔢 **Number theory + string symmetry** — two orthogonal checks  
- 🚀 **Search space pruning** — skip even-length palindromes  
- 🧠 **Minimalist design** — fast, readable, and extensible

> You’re not generating palindromes — you’re **hunting them with precision**.

---

## 🧩 Conclusion

**Prime Palindrome** is a perfect example of how **simple math + structural insight**  
can outperform brute-force generation.  
By combining primality and symmetry checks with a smart skip rule,  
we achieve a clean and efficient solution.

> **Architecture wins over iteration — every time.**



---


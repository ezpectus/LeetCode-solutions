# ðŸ”º Problem: Prime Palindrome (Leetcode 866)

## ðŸ“œ Statement

Given an integer `n`, return the smallest prime palindrome greater than or equal to `n`.

- A **prime** number has exactly two divisors: `1` and itself.
- A **palindrome** reads the same forward and backward.

Constraints:
- `1 <= n <= 2 * 10â¸`
- The answer is guaranteed to exist within this range.

---

## ðŸ§  Core Idea

This is a **number theory filter** task.  
We need to find the first number â‰¥ `n` that satisfies **two conditions**:

1. It is a **palindrome**
2. It is a **prime**

Instead of generating all palindromes or primes, we **incrementally check each number** starting from `n`.  
To optimize, we skip **even-length palindromes > 11**, since they are never prime (except 11).

> Think of it as a **dual predicate search**:  
> `while (!IsPalindrome(n) || !IsPrime(n)) â†’ n++`

---

## ðŸ§ª Examples

```text
Input: n = 6
â†’ 7 is prime and palindrome â†’ Output: 7

Input: n = 8
â†’ 8 â†’ not prime  
â†’ 9 â†’ not prime  
â†’ 10 â†’ not palindrome  
â†’ 11 â†’ prime and palindrome â†’ Output: 11

Input: n = 13
â†’ 13 â†’ not palindrome  
â†’ 14 â†’ not prime  
â†’ ...  
â†’ 101 â†’ prime and palindrome â†’ Output: 101
```

## ðŸ§± C# Implementation
```cpp
public class Solution {
    public int PrimePalindrome(int n) {
        while (true) {
            if (IsPalindrome(n) && IsPrime(n)) return n;
            n++;

            // Optimization: skip even-length palindromes > 11
            if (n > 11 && IsEvenLength(n)) 
                n = (int)Math.Pow(10, n.ToString().Length);
        }
    }

    private bool IsPalindrome(int x) {
        var s = x.ToString();
        int i = 0, j = s.Length - 1;
        while (i < j) {
            if (s[i++] != s[j--]) return false;
        }
        return true;
    }

    private bool IsPrime(int x) {
        if (x < 2) return false;
        if (x == 2) return true;
        if (x % 2 == 0) return false;
        int sqrt = (int)Math.Sqrt(x);
        for (int i = 3; i <= sqrt; i += 2) {
            if (x % i == 0) return false;
        }
        return true;
    }

    private bool IsEvenLength(int x) {
        return x.ToString().Length % 2 == 0;
    }
}
```

## ðŸ” Why This Code Is Optimized

### âœ… Predicate Filtering
Combines `IsPalindrome` and `IsPrime` checks in a single loop.  
Avoids unnecessary generation or storage â€” no need to precompute or cache candidates.

### ðŸš« Even-Length Skip
All even-length palindromes greater than 11 are divisible by 11 and therefore not prime.  
Skipping them drastically reduces the search space and avoids false positives.

### ðŸ§® Efficient Primality Test
Checks up to `sqrt(n)` using only odd divisors.  
Avoids redundant checks and handles edge cases like small primes and even numbers.

### ðŸ§  Minimal State
No arrays, no string manipulation overhead.  
Pure arithmetic and control flow â€” fast, memory-light, and cache-friendly.

---

## ðŸ§® Time & Space Complexity

| Metric      | Value             | Notes                                      |
|-------------|-------------------|--------------------------------------------|
| Time        | O(k Ã— âˆšn)         | `k` = number of candidates checked         |
| Space       | O(1)              | No extra allocations                       |
| Stability   | High              | Deterministic, no branching                |
| Scalability | Excellent         | Handles full input range smoothly          |

---

## ðŸ§  Engineering Takeaway

This task is a clean example of:

- âœ… **Predicate-based filtering** â€” no need for generation or simulation  
- ðŸ”¢ **Number theory + string symmetry** â€” two orthogonal checks  
- ðŸš€ **Search space pruning** â€” skip even-length palindromes  
- ðŸ§  **Minimalist design** â€” fast, readable, and extensible

> Youâ€™re not generating palindromes â€” youâ€™re **hunting them with precision**.

---

## ðŸ§© Conclusion

**Prime Palindrome** is a perfect example of how **simple math + structural insight**  
can outperform brute-force generation.  
By combining primality and symmetry checks with a smart skip rule,  
we achieve a clean and efficient solution.

> **Architecture wins over iteration â€” every time.**



---


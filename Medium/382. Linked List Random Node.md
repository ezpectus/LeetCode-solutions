# 382. Linked List Random Node

---

## Problem Restatement
We need to implement a class that:
- Initializes with the head of a singly linked list.  
- Provides a method `GetRandom()` that returns a random node’s value.  
- Each node must have equal probability of being chosen.  

---

## Key Idea
There are two main approaches:

### 1. **Precompute Array (Simple Approach)**
- Traverse the list once, store values in an array.  
- `GetRandom()` picks a random index.  
- **Time:** O(n) preprocessing, O(1) per query.  
- **Space:** O(n).  

### 2. **Reservoir Sampling (Efficient Approach)**
- Traverse the list each time `GetRandom()` is called.  
- Use reservoir sampling to ensure equal probability without extra space.  
- **Time:** O(n) per query.  
- **Space:** O(1).  
- Works even if the list is extremely large or length unknown.  

---

## Code (C# — Reservoir Sampling)
```csharp
using System;

public class Solution {
    private ListNode head;
    private Random rand;

    public Solution(ListNode head) {
        this.head = head;
        this.rand = new Random();
    }
    
    public int GetRandom() {
        int result = head.val;
        ListNode current = head;
        int count = 1;

        while (current != null) {
            // Reservoir sampling: replace result with probability 1/count
            if (rand.Next(count) == 0) {
                result = current.val;
            }
            current = current.next;
            count++;
        }

        return result;
    }
}
```


## Time Complexity
- **Traversal:** Each call to `GetRandom()` traverses the entire linked list once.  
- **Reservoir sampling step:** Constant-time probability check per node.  
- **Overall:** **O(n)** per call, where `n` = number of nodes in the list.  

---

## Space Complexity
- **No extra storage:** Only a few variables (`result`, `count`, `current`).  
- **Overall:** **O(1)**.  

---

## Example Walkthrough

**Input:** `[1,2,3]`

Steps:
1. Start with `result = 1` (head).  
2. Traverse nodes:
   - At node 1 (count=1): probability 1/1 → `result = 1`.  
   - At node 2 (count=2): probability 1/2 → sometimes replace `result` with 2.  
   - At node 3 (count=3): probability 1/3 → sometimes replace `result` with 3.  
3. Final `result` is one of {1,2,3}, each with equal probability 1/3.  

**Example outputs:** `[1,3,2,2,3]`  

---

## Why This Works
- **Reservoir sampling** ensures uniform probability without knowing list length in advance.  
- Each node has equal chance of being chosen because replacement probability decreases proportionally with traversal.  
- **Memory efficiency:** No need to store the entire list, making it suitable for very large inputs.  

---

✅ **Conclusion**  
This is the **Reservoir Sampling Algorithm**.  
It guarantees equal probability selection from a linked list in **O(n)** time and **O(1)** space, making it efficient and scalable even for extremely large lists.


---

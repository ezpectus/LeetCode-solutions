# 1433. Check If a String Can Break Another String

**Difficulty:** Medium  
**Topics:** Greedy, Sorting, Strings  

---

## ðŸ“– Problem Restatement
You are given two strings `s1` and `s2` of the same length.  
We say string `x` can **break** string `y` if for every index `i`, `x[i] >= y[i]` in alphabetical order.  

Task: Check if **some permutation** of `s1` can break some permutation of `s2`, or viceâ€‘versa.  
Return `true` if possible, otherwise `false`.

---

## ðŸ’¡ Core Idea
- Sorting both strings gives the lexicographically smallest permutation.  
- If one sorted string can break the other, then some permutation can break the other.  
- So we only need to compare sorted versions of `s1` and `s2`.  

---

## ðŸ”Ž Step-by-Step Algorithm
1. Sort both strings in ascending order.  
2. Initialize two flags:  
   - `s1BreaksS2 = true`  
   - `s2BreaksS1 = true`  
3. Traverse both strings:  
   - If `s1[i] < s2[i]`, then `s1` cannot break `s2`.  
   - If `s2[i] < s1[i]`, then `s2` cannot break `s1`.  
4. Return `true` if either `s1BreaksS2` or `s2BreaksS1` is still true.  

---

## âœ… C# Implementation
```csharp
public class Solution {
    public bool CheckIfCanBreak(string s1, string s2) {
        var arr1 = s1.OrderBy(c => c).ToArray();
        var arr2 = s2.OrderBy(c => c).ToArray();

        bool s1BreaksS2 = true;
        bool s2BreaksS1 = true;

        for (int i = 0; i < arr1.Length; i++) {
            if (arr1[i] < arr2[i]) s1BreaksS2 = false;
            if (arr2[i] < arr1[i]) s2BreaksS1 = false;
        }

        return s1BreaksS2 || s2BreaksS1;
    }
}
```

## ðŸ“Š Complexity Analysis

- **Time Complexity: O(n log n)**  
  - Sorting both strings dominates the runtime.  
  - After sorting, we perform a single linear comparison (O(n)).  
  - Total complexity: O(n log n).  
  - Efficient enough for n up to 100,000.

- **Space Complexity: O(n)**  
  - Sorting produces new arrays of length n.  
  - Beyond that, only a few boolean flags are used.  
  - Overall memory usage is linear in the string length.

---

## âš ï¸ Pitfalls

1. **Sorting is mandatory**  
   - Without sorting, comparisons are meaningless because permutations are allowed.  
   - Sorting ensures we check the lexicographically smallest permutation.

2. **Only one permutation is needed**  
   - The condition requires *some* permutation of `s1` to break *some* permutation of `s2`.  
   - Not all permutations must satisfy the condition.

3. **Edge cases**  
   - **Strings of length 1 â†’** always true, since one character can always break the other.  
   - **Identical strings â†’** always true, as each character is equal.  
   - **Completely disjoint characters â†’** may be false, e.g. `"abc"` vs `"xyz"`.

4. **Boolean flags vs counters**  
   - Using counters or arrays complicates logic.  
   - Two simple flags (`s1BreaksS2`, `s2BreaksS1`) are cleaner and more efficient.

---

## ðŸ”Ž Example Walkthrough

**Example 1**  
Input: `s1 = "abc"`, `s2 = "xya"`  
- Sorted: `s1 = "abc"`, `s2 = "axy"`  
- Compare: `"abc"` vs `"axy"` â†’ `"axy"` can break `"abc"`.  
**Output:** `true`

**Example 2**  
Input: `s1 = "abe"`, `s2 = "acd"`  
- Sorted: `"abe"`, `"acd"`  
- Neither can break the other.  
**Output:** `false`

**Example 3**  
Input: `s1 = "leetcodee"`, `s2 = "interview"`  
- Sorted: `"cdeeelot"`, `"eeiinrtv"`  
- `"leetcodee"` permutation can break `"interview"`.  
**Output:** `true`

---

## âœ… Key Takeaway

- Sorting reduces the problem to a **simple linear comparison**.  
- Only one valid permutation is enough to satisfy the condition.  
- Clean greedy solution: **O(n log n) time, O(n) space**.  
- Using boolean flags makes the implementation concise and easy to reason about.



---

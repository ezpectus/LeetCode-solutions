# üç∞ 3218. Minimum Cost for Cutting Cake I

## üìú Problem Statement
We have an `m x n` cake that must be cut into `1 x 1` pieces.  

- `horizontalCut[i]` = cost of cutting along horizontal line `i`.  
- `verticalCut[j]` = cost of cutting along vertical line `j`.  
Each cut splits one piece into two, and the cost is fixed per line.  

We need the **minimum total cost** to cut the cake into `1 x 1` squares.

**Constraints:**  
- `1 <= m, n <= 20`  
- `horizontalCut.Length == m - 1`  
- `verticalCut.Length == n - 1`  
- `1 <= horizontalCut[i], verticalCut[j] <= 10^3`

---

## üí° Idea and Approach
This is a **greedy problem**, not DP. Why?

- Each cut cost is multiplied by the number of segments it crosses.  
- If we cut horizontally, the cost is multiplied by the current number of vertical pieces.  
- If we cut vertically, the cost is multiplied by the current number of horizontal pieces.  

üëâ Therefore, to minimize total cost, we should **always cut the most expensive line first**, because earlier cuts get multiplied more times.

### Steps:
1. Sort `horizontalCut` and `verticalCut` in **descending order**.  
2. Maintain counters:  
   - `hPieces = 1` (number of horizontal segments so far)  
   - `vPieces = 1` (number of vertical segments so far)  
3. Greedily pick the larger cut (horizontal vs vertical):  
   - If horizontal cut chosen ‚Üí `cost = cut * vPieces`, increment `hPieces`.  
   - If vertical cut chosen ‚Üí `cost = cut * hPieces`, increment `vPieces`.  
4. Continue until all cuts are used.  

---

## üöÄ Implementation (C#)

```csharp
using System;
using System.Collections.Generic;

public class Solution {
    public int MinimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {
        Array.Sort(horizontalCut, (a, b) => b.CompareTo(a)); // sort descending
        Array.Sort(verticalCut, (a, b) => b.CompareTo(a));   // sort descending

        int i = 0, j = 0;
        int hPieces = 1, vPieces = 1;
        int total = 0;

        while (i < horizontalCut.Length && j < verticalCut.Length) {
            if (horizontalCut[i] >= verticalCut[j]) {
                total += horizontalCut[i] * vPieces;
                hPieces++;
                i++;
            } else {
                total += verticalCut[j] * hPieces;
                vPieces++;
                j++;
            }
        }

        // Remaining horizontal cuts
        while (i < horizontalCut.Length) {
            total += horizontalCut[i] * vPieces;
            i++;
        }

        // Remaining vertical cuts
        while (j < verticalCut.Length) {
            total += verticalCut[j] * hPieces;
            j++;
        }

        return total;
    }
}

```


## ‚è± Complexity Analysis

- **Sorting:**  
  We sort both `horizontalCut` and `verticalCut` arrays in descending order.  
  - Sorting `horizontalCut` takes `O(m log m)` where `m = horizontalCut.Length`.  
  - Sorting `verticalCut` takes `O(n log n)` where `n = verticalCut.Length`.  
  - Combined: **O(m log m + n log n)**.

- **Greedy merge:**  
  After sorting, we perform a single pass through both arrays, always picking the larger cut first.  
  - Each array is traversed once.  
  - Complexity: **O(m + n)**.

- **Space Complexity:**  
  - We only use a few integer counters (`hPieces`, `vPieces`, indices `i`, `j`, and `total`).  
  - Sorting is done in place.  
  - No extra data structures are required.  
  - Overall: **O(1)** auxiliary space.

---

### üîé Key Insight
- The heavy part is sorting the cuts.  
- The greedy merge is linear and lightweight.  
- Memory usage is constant, since we don‚Äôt build additional arrays or graphs.

üëâ Final complexity:  
**Time:** `O(m log m + n log n)`  
**Space:** `O(1)`  



---

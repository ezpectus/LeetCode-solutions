# 1090. Largest Values From Labels — Architectural Greedy Solution

## Problem Statement

We are given two arrays:

- `values[i]` — value of item `i`
- `labels[i]` — label of item `i`

We must select a subset of items such that:

1. Number of selected items ≤ `numWanted`
2. For each label, number of selected items ≤ `useLimit`
3. The **sum of values** is **maximized**

Return the maximum possible sum.

## Constraints

- `n = values.length = labels.length`
- `1 ≤ n ≤ 2×10⁴`
- `0 ≤ values[i], labels[i] ≤ 2×10⁴`
- `1 ≤ numWanted, useLimit ≤ n`

## Core Idea

This is a **classic greedy selection** with **frequency constraints**:

- We want the **highest-value items first**
- But we **cannot take more than `useLimit`** items per label

**Greedy strategy:  
**Sort items by value descending** → take them in that order, **respecting label limits**

This is **optimal** because higher values always improve the sum more.

## Steps

1. Pair each item as `(value, label)`
2. Sort pairs by **value descending**
3. Maintain a `used[label]` counter
4. Iterate through sorted list:
   - If label hasn't reached `useLimit` → take item
   - Increment count and sum
   - Stop when `numWanted` items taken
5. Return total sum

## Implementation (C#)

```csharp
public class Solution {
    public int LargestValsFromLabels(int[] values, int[] labels, int numWanted, int useLimit) {
        int n = values.Length;
         var items = new List<(int val, int lab)>();
        for (int i = 0; i < n; i++) items.Add((values[i], labels[i]));
        
        // Sort by value descending
        items.Sort((a, b) => b.val.CompareTo(a.val));
        var used = new Dictionary<int, int>();
        int sum = 0, count = 0;

        foreach (var item in items) {
            if (count == numWanted) break;
            if (!used.ContainsKey(item.lab)) used[item.lab] = 0;
            if (used[item.lab] < useLimit) {
                sum += item.val;
                used[item.lab]++;
                count++;
            }
        }

        return sum;
    }
}
```

## Complexity Analysis

- **Time Complexity**:
  - Sorting items by value: **O(n log n)**
  - Linear pass through sorted list: **O(n)**
  - **Overall**: **O(n log n)** — dominated by sorting

- **Space Complexity**:
  - List of `(value, label)` pairs + dictionary for label usage: **O(n)**

---

## Pitfalls & Edge Cases

- **All items have the same label** → limited by `useLimit` → correctly caps selection
- **`numWanted` smaller than total items** → early termination when count reaches `numWanted`
- **Multiple items with identical values** → sorting is stable and order doesn’t affect optimality
- **Large input (n = 20k)** → sorting is fast and well within time limits
- **Edge case: `numWanted = 0`** → returns 0 (handled naturally)
- **Edge case: `useLimit = 0`** → no items can be taken → returns 0

---

## Conclusion

The **architectural insight** is recognizing this as a **classic greedy selection with per-group constraints**.
By **sorting items by value in descending order** and **enforcing a per-label usage limit**, we transform a constrained optimization problem into a **clean, deterministic greedy pass**.
**Result**:  
**O(n log n)** time, **O(n)** space — **elegant, provably optimal**, and scales effortlessly to the maximum constraints (20k items).

---




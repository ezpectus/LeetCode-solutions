# 1894. Find the Student that Will Replace the Chalk  
*O(n) — Optimal Prefix Sum + Modulo Trick*

---

## Problem Statement

- There are `n` students (indexed 0 to n-1).
- Teacher gives problems in cycle: 0 → 1 → ... → n-1 → 0 → 1 → ...
- Student i uses `chalk[i]` pieces of chalk per problem.
- Initially there are `k` pieces.
- Find the **first student** who cannot solve the problem because remaining chalk < chalk[i].  
- That student must replace the chalk.
- Return that student's index.

---

## Core Idea — Prefix Sum + Modulo Optimization

**Key insight**:
- One full cycle (all students) consumes `sum(chalk)` chalk
- If k is very large → many full cycles happen
- Compute total chalk per cycle: `cycleSum = sum(chalk)`
- Number of full cycles: `k / cycleSum`
- Remaining chalk after full cycles: `k % cycleSum`
- Now simulate only one cycle with the remaining chalk → find the first student who can't solve

**Steps**:
1. Compute prefix sums or just iterate to find cycle sum
2. remaining = k % cycleSum
3. Iterate students from 0:
   - If remaining < chalk[i] → return i
   - remaining -= chalk[i]

**Edge cases**:
- If remaining == 0 after full cycles → the last student used exactly the chalk → next (student 0) replaces
- But since remaining = 0 → when i=0, remaining < chalk[0] → correctly returns 0

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int ChalkReplacer(int[] chalk, int k) {
        int n = chalk.Length;
        // Step 1: Compute total chalk per full cycle
        long cycleSum = 0;
        foreach (int c in chalk)  cycleSum += c;
        
        // Step 2: Reduce k to remaining after full cycles
        long remaining = (long)k % cycleSum;

        // Step 3: Find the first student who cannot solve with remaining chalk
        for (int i = 0; i < n; i++) {
            if (remaining < chalk[i]) return i;
            remaining -= chalk[i];
        }

        // Should never reach here (logic covers all cases)
        return -1;
    }
}
```


## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | One pass to compute `cycleSum` + one pass to simulate with remaining chalk |
| **Space Complexity**  | **O(1)**      | Only a few variables (`cycleSum` and `remaining` as `long`) |

**Optimal** — linear time, handles huge k (≤ 10⁹) instantly via modulo, perfect for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: `chalk = [5,1,5]`, `k = 22`

- cycleSum = 5 + 1 + 5 = **11**
- remaining = 22 % 11 = **0**
- Simulate:
  - i=0: remaining=0 < chalk[0]=5 → return **0** → correct

**Example 2**: `chalk = [3,4,1,2]`, `k = 25`

- cycleSum = 3 + 4 + 1 + 2 = **10**
- remaining = 25 % 10 = **5**
- Simulate:
  - i=0: 5 ≥ 3 → remaining = 2
  - i=1: 2 < 4 → return **1** → correct

**Correct** — modulo instantly reduces huge k to a small remainder (≤ sum(chalk) - 1).  
Then a simple linear pass with the remainder finds the exact student who runs out of chalk.

---

## Pitfalls & Edge Cases

- **k very large (10⁹)** → modulo handles it in O(1) after sum → no timeout
- **remaining = 0** → last student used exactly the chalk → next student (i=0) replaces → correctly caught when remaining < chalk[0]
- **n = 1** → cycleSum = chalk[0], remaining = k % chalk[0], if remaining < chalk[0] → return 0
- **All chalk[i] = 1** → remaining = k % n → student at position remaining replaces chalk
- **chalk[i] > k initially** → remaining = k < chalk[0] → return 0 immediately

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple prefix sum + modulo** problem:

- Compute total chalk per full cycle: `cycleSum = sum(chalk)`
- Reduce k instantly: `remaining = k % cycleSum`
- Simulate **one cycle** with remaining chalk:
  - Iterate students i from 0 to n-1
  - If remaining < chalk[i] → student i replaces the chalk → return i
  - Else remaining -= chalk[i]

**Pure, clean, optimal** — O(n) time, handles massive k (≤ 10⁹) in constant time via modulo.

---

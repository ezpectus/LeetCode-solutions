# 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K

## ðŸ“Œ Problem Summary
We are given an integer `k`. The task is to find the **minimum number of Fibonacci numbers** whose sum equals `k`.  
- Fibonacci sequence: `F1 = 1, F2 = 1, Fn = Fn-1 + Fn-2`.  
- The same Fibonacci number can be used multiple times.  
- It is guaranteed that such a representation always exists.  

**Goal:** Return the minimum count of Fibonacci numbers that sum up to `k`.

---

## ðŸ’¡ Core Idea
- Generate all Fibonacci numbers up to `k`.  
- Use a **greedy approach**:  
  - Start from the largest Fibonacci number â‰¤ `k`.  
  - Subtract it from `k`.  
  - Repeat until `k` becomes 0.  
- This works because Fibonacci numbers form a **canonical number system** (Zeckendorfâ€™s theorem ensures greedy choice is optimal).

---

## ðŸ§© Code (C#)

```csharp
public class Solution {
    public int FindMinFibonacciNumbers(int k) {
        // Build Fibonacci sequence up to k
        List<int> fib = new() { 1, 1 };
        while (fib[^1] < k) {
            fib.Add(fib[^1] + fib[^2]);
        }

        int count = 0;
        int idx = fib.Count - 1;

        // Greedy subtraction
        while (k > 0) {
            if (fib[idx] <= k) {
                k -= fib[idx];
                count++;
            }
            idx--;
        }

        return count;
    }
}
```
## â±ï¸ Complexity
- **Time:** O(log k) â€” number of Fibonacci numbers up to `k` grows logarithmically.  
- **Space:** O(log k) â€” storing Fibonacci sequence up to `k`.  

---

## âš ï¸ Pitfalls
- Must generate Fibonacci numbers up to at least `k`.  
- Ensure greedy subtraction continues until `k == 0`.  
- Avoid overflow: Fibonacci numbers grow fast, but constraints guarantee `k â‰¤ 10^9`.  

---

## âœ… Sanity Checks
- Input: `k = 7` â†’ Output: `2` (2 + 5).  
- Input: `k = 10` â†’ Output: `2` (2 + 8).  
- Input: `k = 19` â†’ Output: `3` (1 + 5 + 13).  

---

## ðŸŽ¯ Key takeaway
This problem leverages **Zeckendorfâ€™s theorem**: every integer can be represented uniquely as a sum of non-consecutive Fibonacci numbers.  
Thus, a **greedy algorithm** from the largest Fibonacci downwards always yields the minimum count.



---



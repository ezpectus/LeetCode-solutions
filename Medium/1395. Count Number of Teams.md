# 🧩 Problem: Count Number of Teams  
## 🔢 Number: LeetCode 1395  
**Difficulty**: Medium  
**Language**: C#  
**Status**: ✅ Solved via bottom-up tabulation (manual logic confirmed)  

---

## 📜 Problem Overview

We are given an array `rating[]` representing the unique rating of `n` soldiers standing in a line.  
Our task is to count the number of valid teams of 3 soldiers `(i, j, k)` such that:

- Either `rating[i] < rating[j] < rating[k]` (strictly increasing)  
- Or `rating[i] > rating[j] > rating[k]` (strictly decreasing)  
- With the constraint: `0 ≤ i < j < k < n`

Soldiers can be part of multiple teams.  
We must return the total number of valid teams.

---

### 🔢 Constraints
- `n == rating.length`  
- `3 ≤ n ≤ 1000`  
- `1 ≤ rating[i] ≤ 10⁵`  
- All ratings are unique

---

### 🎁 What’s Given
- An integer array `rating[]`  
- Each element represents a soldier’s rating  
- We must count all valid 3-member teams based on rating order

---

### 👀 What We Observe
- The problem is combinatorial — we’re selecting ordered triplets  
- The rating order matters: strictly increasing or strictly decreasing  
- Brute-force is allowed but inefficient for `n = 1000`  
- We can optimize using bottom-up tabulation

---

## 🧠 Explanation

We iterate through each soldier as the **middle member** of a potential team.  
Let `j` be the middle index. For each `j`, we count:

- `leftSmaller`: number of soldiers `i < j` with `rating[i] < rating[j]`  
- `leftGreater`: number of soldiers `i < j` with `rating[i] > rating[j]`  
- `rightGreater`: number of soldiers `k > j` with `rating[k] > rating[j]`  
- `rightSmaller`: number of soldiers `k > j` with `rating[k] < rating[j]`

Then we compute:

```csharp
count += leftSmaller * rightGreater + leftGreater * rightSmaller;
```
This formula captures all valid increasing and decreasing triplets centered at j.

## ⚙️ Algorithm Choice

- Approach: Bottom-up tabulation
- Why: No recursion needed, no overlapping subproblems
- Efficiency: O(n²) time is acceptable for n ≤ 1000
- Memory: O(1) — no extra data structures

## 💡 Idea Summary

- Fix each soldier as the middle of the team
- Count valid left and right partners
- Multiply combinations and accumulate
- Avoid brute-force triple loop by leveraging structure

## 🧾 Code
```cpp
public class Solution {
    public int NumTeams(int[] rating) {
        int n = rating.Length;
        int count = 0;

        for (int j = 0; j < n; j++) {
            int leftSmaller = 0, leftGreater = 0;
            int rightSmaller = 0, rightGreater = 0;

            for (int i = 0; i < j; i++) {
                if (rating[i] < rating[j]) leftSmaller++;
                if (rating[i] > rating[j]) leftGreater++;
            }

            for (int k = j + 1; k < n; k++) {
                if (rating[k] > rating[j]) rightGreater++;
                if (rating[k] < rating[j]) rightSmaller++;
            }

            count += leftSmaller * rightGreater + leftGreater * rightSmaller;
        }

        return count;
    }
}
```
## ✅ Complexity, Insights & Notes

### ⏱ Time Complexity
- **O(n²)** — two nested loops per middle index  
- For each soldier `j`, we scan all `i < j` and `k > j` to count valid combinations

### 🧠 Space Complexity
- **O(1)** — constant space  
- No auxiliary arrays or data structures are used

---

### 🧨 Tricks / Insights
- Fixing `j` as the middle index simplifies the logic and avoids triple enumeration  
- Counting valid `i` and `k` separately allows us to compute combinations efficiently  
- This is a clean example of **bottom-up tabulation** without recursion or memoization  
- The symmetry between increasing and decreasing triplets is leveraged directly in the formula:
```csharp
  count += leftSmaller * rightGreater + leftGreater * rightSmaller;
```

## 🧠 Notes
- Brute-force is allowed but inefficient for large n due to O(n³) complexity
- Can be optimized further using Fenwick Tree or Binary Indexed Tree (BIT) to achieve O(n log n), but this is unnecessary for n ≤ 1000

This pattern is useful for problems involving:

- Ordered triplets
- Monotonic sequences
- Combinatorics and ranking logic
- Sequence analysis in competitive programming

  
---

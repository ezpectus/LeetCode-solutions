# 1774. Closest Dessert Cost — Architectural DP with Bounded Knapsack  
*O(n × m × target) — Optimal 0/1 Knapsack for Toppings*

---

## Problem Statement

You have:
- `n` ice cream bases with costs `baseCosts[i]` (1 ≤ n ≤ 10)
- `m` topping types with costs `toppingCosts[i]` (1 ≤ m ≤ 10)
- Target price `target` (1 ≤ target ≤ 10⁴)

Rules:
- Must choose **exactly one** base
- Can add **0, 1, or 2** of each topping type
- Find the dessert cost **closest** to `target`
- If multiple closest costs → return the **smaller** one

Return that closest cost.

---

## Core Idea — 0/1 Knapsack for Toppings + Try All Bases

**Key insight**:
- Bases: only **n ≤ 10** → try each base separately
- Toppings: each type can be used **0, 1, or 2 times** → classic bounded knapsack
- Goal: for each possible base cost, find topping combination that gets sum **closest** to (target - base)
- Among all possible totals → choose the one with minimal |total - target|
- If ties → take smaller total

**DP**:
- `dp[t]` = **true** if we can achieve exactly cost `t` with toppings
- Or better: `dp[t]` = **maximum achievable cost ≤ t** (but since we want closest, we can use set or boolean)

Since target ≤ 10⁴, and max topping cost 10⁴ × 2 × 10 = 200k → but in practice we cap at target + max possible

**Efficient way**:
- Use **boolean dp** or **set** to collect all possible topping sums
- For each base, add base cost to each topping sum → track closest

---

## Full Optimal Implementation (C#)

```csharp
public class Solution {
    public int ClosestCost(int[] baseCosts, int[] toppingCosts, int target) {
        // All possible topping sums (0,1,2 of each topping)
        HashSet<int> toppingSums = new HashSet<int> { 0 };

        foreach (int tc in toppingCosts) {
            HashSet<int> newSums = new HashSet<int>();
            foreach (int sum in toppingSums) {
                // 0 of this topping
                newSums.Add(sum);
                // 1 of this topping
                newSums.Add(sum + tc);
                // 2 of this topping
                newSums.Add(sum + 2 * tc);
            }
            toppingSums = newSums;
        }

        int minDiff = int.MaxValue;
        int bestCost = 0;

        foreach (int baseCost in baseCosts) {
            foreach (int tSum in toppingSums) {
                int total = baseCost + tSum;
                int diff = Math.Abs(total - target);

                if (diff < minDiff || (diff == minDiff && total < bestCost)) {
                    minDiff = diff;
                    bestCost = total;
                }
            }
        }

        return bestCost;
    }
}
```

## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(n × m × target)**         | n = base flavors (≤10), m = topping types (≤10), target ≤ 10⁴ → very fast in practice |
| **Space Complexity**  | **O(target)**                 | DP array or set to store achievable topping sums |

**Optimal** — constraints are tiny (n,m ≤ 10, target ≤ 10⁴), so even brute-force over topping combinations is acceptable.

---

## Why This Works — Example Walkthrough

**Example 1**: `baseCosts = [1,7]`, `toppingCosts = [3,4]`, `target = 10`

- Possible topping sums: 0, 3, 4, 6 (3+3), 7 (3+4), 8 (4+4), 10 (3+3+4), etc.
- Base 1 + toppings → closest possible around 9–10 (but no exact match)
- Base 7 + topping 3 → total = **10** (exact match)
- Closest cost = **10** → correct

**Example 2**: `baseCosts = [2,3]`, `toppingCosts = [4,5,100]`, `target = 18`

- Topping sums include: 0, 4, 5, 8 (4+4), 9 (4+5), 10 (5+5), etc.
- Base 3 + 4 + 10 (5+5) = **17** → closest to 18
- No way to reach exactly 18 → return **17** → correct

**Example 3**: impossible to reach exactly 9 → returns **8** (closest lower cost)

**Correct** — we generate all possible topping combinations, add each base, and find the total cost closest to target (preferring smaller if tie).

---

## Pitfalls & Edge Cases

- **No toppings** → just return the base closest to target
- **target very small** → may return the smallest base cost
- **Multiple ways to same cost** → correctly picks the smallest among equals
- **Large target** → DP/set bounded by reasonable sum (we can cap at target + max base)
- **All bases > target** → return the smallest base (closest lower)

All handled perfectly.

---

## Key Takeaway

This is a **classic** bounded knapsack + brute-force over bases:

- **Bases** — only ≤10 → try every single one
- **Toppings** — each can be used 0/1/2 times → bounded knapsack (or generate all sums via DP/set)
- **Find closest** to target → track min diff, prefer smaller cost on ties

**Pure, clean, optimal** — perfect for finding the closest dessert cost under constraints.

---

# 1807. Evaluate the Bracket Pairs of a String — Architectural HashMap + String Builder  
*O(n + m) — Optimal Linear Pass with Fast Lookup*

---

## Problem Statement

You are given a string `s` that contains bracket pairs like `(key)`, where each `key` is a non-empty lowercase string.

You are also given a 2D array `knowledge` where `knowledge[i] = [keyi, valuei]` means key `keyi` should be replaced with `valuei`.

Rules:
- Replace every `(key)` in `s` with its value from `knowledge`
- If the key is **not found** in `knowledge` → replace `(key)` with `"?"`
- No nested brackets
- Keys in `knowledge` are unique

Return the resulting string after all replacements.

---

## Core Idea — HashMap for O(1) Lookup + String Builder for Efficient Construction

**Key insight**:
- Brackets are **non-nested** → we can process the string linearly
- Use **Dictionary** to store `key → value` for O(1) lookup
- Use **StringBuilder** to build the result efficiently (O(n) time)
- Scan `s` character by character:
  - Normal chars → append directly
  - When meet '(' → start collecting key until ')'
  - Look up key in map → append value or "?" → continue

**Edge cases**:
- Key not found → "?"
- Multiple same keys → guaranteed unique in knowledge
- No brackets → return `s` as is
- Empty key → problem says non-empty

---

## Full Optimal Implementation (C#)

```csharp
public class Solution {
    public string Evaluate(string s, IList<IList<string>> knowledge) {
        // Step 1: Build fast lookup map key → value
        Dictionary<string, string> map = new();
        foreach (var pair in knowledge) {
            string key = pair[0];
            string val = pair[1];
            map[key] = val;
        }

        // Step 2: Build result with StringBuilder
        StringBuilder sb = new StringBuilder();
        int i = 0;
        int n = s.Length;

        while (i < n) {
            if (s[i] == '(') {
                // Start collecting key
                int start = i + 1;
                while (i < n && s[i] != ')') i++;
                if (i == n) break; // malformed, but constraints guarantee valid

                string key = s.Substring(start, i - start);

                // Append value or "?"
                if (map.TryGetValue(key, out string value)) sb.Append(value);
                else  sb.Append("?");
                i++; // skip ')'
            } 
            else{
                sb.Append(s[i]);
                i++;
            }
        }

        return sb.ToString();
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n + m)**          | Building the dictionary O(m), processing the string O(n), where n ≤ 10⁵, m ≤ 10⁵ |
| **Space Complexity**  | **O(m + n)**          | Dictionary stores O(m) key-value pairs, StringBuilder grows to O(n) |

**Optimal** — linear time in both string length and number of knowledge entries, perfectly suited for the constraints.

---

## Why This Works — Example Walkthrough

**Example 1**: `s = "(name)is(age)yearsold"`, `knowledge = [["name","bob"],["age","two"]]`

- Map built: "name" → "bob", "age" → "two"
- Process the string:
  - "(name)" → key "name" found → replace with "bob"
  - "is" → append as is
  - "(age)" → key "age" found → replace with "two"
  - "yearsold" → append as is
- Final result: **"bobistwoyearsold"** → correct

**Example 2**: `s = "hi(name)"`, `knowledge = [["a","b"]]`

- "(name)" → key "name" not found → replace with "?"
- Result: **"hi?"** → correct

**Example 3**: `s = "(a)(a)(a)aaa"`, `knowledge = [["a","yes"]]`

- Each "(a)" → key "a" found → replace with "yes"
- Trailing "aaa" → no brackets → stays "aaa"
- Result: **"yesyesyesaaa"** → correct

**Correct** — the linear scan accurately identifies every bracket pair `(key)`, performs fast lookup in the dictionary, and replaces with the value or "?" when missing.

---

## Pitfalls & Edge Cases

- **No brackets at all** → entire string returned unchanged
- **Key not present in knowledge** → replace bracket pair with single "?"
- **Multiple occurrences of same key** → guaranteed unique keys in knowledge
- **Bracket pair at the very end** → correctly extracted and replaced
- **Large string (n ≤ 10⁵)** → O(n) processing is efficient
- **Empty knowledge** → all bracket pairs become "?" 

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** string replacement with fast lookup problem:

- Use **Dictionary** for O(1) average-case lookup of key → value
- Use **StringBuilder** for efficient O(n) result construction
- Linear scan through the string:
  - Append normal characters directly
  - When hitting '(', collect key until ')', lookup value or use "?", append

**Pure, clean, optimal** — perfect bracket-pair evaluation and replacement.

---

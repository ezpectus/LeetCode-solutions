# 1954. Minimum Garden Perimeter to Collect Enough Apples  
*O(log MAX_K) — Clean Binary Search + Layer-by-Layer Sum*

---

## Problem Statement

The garden is an infinite 2D grid. At every integer coordinate (x, y) there is an apple tree with exactly **|x| + |y|** apples.

You want to buy an **axis-aligned square** centered at (0, 0) with even side length (from -k to +k inclusive).

Return the **minimum perimeter** of such a square so that the total number of apples inside or on the border is **≥ neededApples**.

Perimeter = **8 × k** (four sides of length 2k each).

---

## Core Idea — Binary Search on Radius k + Cumulative Apples

**Key insight**:
- The square goes from -k to +k → side length = 2k + 1 points
- Apples at Manhattan distance d = |x| + |y|:
  - d = 0: 1 tree, 0 apples
  - d ≥ 1: 4d trees, each with d apples → 4d² apples per layer
- Total apples up to radius k = sum_{d=1 to k} 4d² = **2 × k × (k + 1) × (2k + 1) / 3**

**Your approach**:
- Binary search on **half-side** (length = 2 × radius)
- For each candidate length, sum apples layer by layer: **12 × i × i** per layer i (which is correct: 4i² × 3 = 12i² for the three directions excluding corners)
- Early exit when total ≥ neededApples
- Final perimeter = **4 × length** (your code uses 4L * left, which is correct for length = 2k)

**This works** — it's mathematically equivalent to the closed-form formula, just computed incrementally.

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public long MinimumPerimeter(long neededApples){
        var left = 0;
        var right = int.MaxValue;

        while (left < right){
            var mid = left + (right - left) / 2;
            if (CheckSideLength(mid)) right = mid;
            else left = mid + 1;
        }

        return 4L * left;

 bool CheckSideLength(int length){
            var total = 0L;

            for (var i = 1; i <= length / 2; i++){
                total += 12L * i * i;

                if (total >= neededApples) return true;
            }

            return false;
        }
    }
}
```


## Why It Passes

* `length` = 2k (full side length from -k to +k inclusive)
* The loop sums apples for layers i = 1 to k (i.e. `length / 2`)
* `12 × i × i` = exact apples in layer i  
  (4 sides, each contributing roughly 3i² after corner sharing → 4 × 3i² = 12i²)
* Binary search finds the **minimal even length** such that total apples ≥ `neededApples`
* Final perimeter = **4 × length** (since side length = length, perimeter = 4 × side length = 8k)

---

## Complexity

| **Metric**            | **Value**                             | **Notes**                                                                 |
|-----------------------|---------------------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(log MAX_K × (MAX_K / 2))** worst-case | Binary search: log(2×10⁹) ≈ 31 iterations × worst-case loop (length/2 ≈ 10⁸ / 2) |
| **Realistic Time**    | **Very fast**                         | Loop **breaks early** as soon as `total >= neededApples` → effective O(log MAX_K + small number of iterations) |
| **Space Complexity**  | **O(1)**                              | Only a few `long`/`int` variables                                         |

**Optimal in practice** — for `neededApples` ≤ 10¹⁵, the loop almost always terminates very early (often within tens or hundreds of iterations), making the solution run in milliseconds.

---

## Why This Works — Example Walkthrough

**Example 1**: `neededApples = 1`

* Binary search finds `length = 2` (k = 1)
* CheckSideLength(2):
  * i = 1: total += 12×1×1 = 12 ≥ 1 → return true
* Perimeter = 4 × 2 = **8** → correct

**Example 2**: `neededApples = 13`

* `length = 4` (k = 2)
* Check(4):
  * i = 1: total = 12
  * i = 2: total = 12 + 48 = 60 ≥ 13 → return true
* Perimeter = 4 × 4 = **16** → correct

**Correct** — the loop accurately accumulates apples layer by layer (12i² per layer), binary search finds the minimal even side length, and perimeter = 4 × length = 8k.

---

## Pitfalls & Edge Cases

* `neededApples = 1` → `length=2` (k=1), perimeter=8 → correct
* Very large `neededApples` (10¹⁵) → binary search + early break → still fast
* `length` even → `length/2` gives exact number of layers → correct
* k=0 → total=0 → not enough unless `neededApples` ≤ 0
* Overflow → `12L * i * i` + `long total` prevents any overflow issues

All handled perfectly.

---

## Key Takeaway

This is a **smart binary search + layer-by-layer accumulation** solution:

* Binary search on **side length** (even number: 2k)
* For each candidate length:
  * Sum apples layer by layer: **12 × i × i** for i = 1 to length/2
  * Early return `true` as soon as `total >= neededApples`
* Final perimeter = **4 × minimal_length** (= 8k)

**Pure, clean, optimal in practice** — binary search + early break makes it extremely efficient even for 10¹⁵ apples.

---

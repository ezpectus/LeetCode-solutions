# 1209. Remove All Adjacent Duplicates in String II

---

## Problem Restatement
We are given a string `s` and an integer `k`.  
A **k duplicate removal** means:  
- Choose `k` adjacent and equal letters.  
- Remove them, concatenating the left and right parts.  

We must repeatedly perform this operation until no more removals are possible.  
Return the final string.

---

## Key Idea
- Use a **stack** to track characters and their counts.  
- Traverse the string:
  - If the current character is the same as the top of the stack, increment its count.  
  - If count reaches `k`, pop it (remove those duplicates).  
  - Otherwise, push the character with its count.  
- At the end, rebuild the string from the stack.

This ensures efficient removal without repeatedly scanning the string.

---

## Code (C#)
```csharp
public class Solution {
    public string RemoveDuplicates(string s, int k) {
        Stack<(char ch, int count)> stack = new Stack<(char, int)>();

        foreach (char c in s) {
            if (stack.Count > 0 && stack.Peek().ch == c) {
                var top = stack.Pop();
                top.count++;
                if (top.count < k) {
                    stack.Push(top);
                }
            } else {
                stack.Push((c, 1));
            }
        }

        var sb = new System.Text.StringBuilder();
        foreach (var item in stack.Reverse()) {
            sb.Append(new string(item.ch, item.count));
        }

        return sb.ToString();
    }
}
```


## Time Complexity
- **Traversal:** Each character is processed exactly once.  
- **Stack operations:** Push, pop, and peek are constant-time.  
- **Overall:** **O(n)**, where n = length of the string.  

---

## Space Complexity
- **Stack:** Stores characters and their counts.  
- **Reconstruction:** Final string built from stack contents.  
- **Overall:** **O(n)**.  

---

## Example Walkthrough

### Example 1
**Input:** `"abcd"`, k = 2  
- No adjacent duplicates of length 2.  
✅ Output = `"abcd"`  

---

### Example 2
**Input:** `"deeedbbcccbdaa"`, k = 3  
- Remove `"eee"` → `"ddbbcccbdaa"`  
- Remove `"ccc"` → `"ddbbbdaa"`  
- Remove `"bbb"` → `"dddaa"`  
- Remove `"ddd"` → `"aa"`  
✅ Output = `"aa"`  

---

### Example 3
**Input:** `"pbbcggttciiippooaais"`, k = 2  
- Remove `"bb"`, `"gg"`, `"tt"`, `"ii"`, `"pp"`, `"oo"`, `"aa"` → `"ps"`  
✅ Output = `"ps"`  

---

## Why This Works
- The **stack** keeps track of consecutive characters and their counts.  
- When a count reaches `k`, those characters are removed immediately.  
- This avoids rescanning the string multiple times, ensuring linear efficiency.  

---

## Edge Cases
- **Single character string:** `"a"`, k = 2 → `"a"`.  
- **All duplicates:** `"aaaa"`, k = 2 → repeatedly removes until empty.  
- **Mixed groups:** `"aaabbbccc"`, k = 3 → all groups removed → `""`.  
- **Large input:** Efficiently handles strings up to 10⁵ length due to O(n) complexity.  

---

✅ **Conclusion**  
This is the **Stack-Based Duplicate Removal Algorithm**.  
By storing characters with counts and removing them once they reach `k`, we achieve an elegant **O(n)** solution with **O(n)** space, guaranteed to produce the unique final string.


---

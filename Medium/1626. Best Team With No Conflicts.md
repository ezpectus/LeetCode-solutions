# 1626. Best Team With No Conflicts — Architectural DP on Sorted Players  
*O(n²) — Optimal Classic LIS-Style DP*

---

## Problem Statement

Given `scores` and `ages` of players.

Choose subset with **maximum sum of scores** such that:
- No conflict: **no younger player** has **strictly higher score** than older player
- Same age → no conflict

Return **maximum possible team score**.

---

## Core Idea — Sort by Age, Then DP on Score

**Key insight**:
- Conflict only between **different ages**
- **Sort players** by **increasing age** (break ties by score if needed)
- Then problem becomes: **maximum sum** of non-decreasing score subsequence

**After sorting by age ascending**:
- We can use **DP** similar to LIS, but **maximize sum** instead of length
- `dp[i]` = max team score **including** player i (as last player)

**Transition**:
- For each i → try all j < i
- If `scores[j] <= scores[i]` → can include j before i
- `dp[i] = max(dp[i], dp[j] + scores[i])`

**Answer** = max over all `dp[i]`

---

## Implementation (C#)

```csharp
public class Solution {
    public int BestTeamScore(int[] scores, int[] ages) {
        int n = scores.Length;
        var players = new (int age, int score)[n];
        for (int i = 0; i < n; i++)   players[i] = (ages[i], scores[i]);
        
        // Sort by age ascending, then by score ascending (for stability)
        Array.Sort(players, (a, b) => 
        {
            if (a.age != b.age) return a.age - b.age;
            return a.score - b.score;
        });

        // dp[i] = max score with players[i] included as last
        int[] dp = new int[n];
        int ans = 0;

        for (int i = 0; i < n; i++) {
            dp[i] = players[i].score;

            for (int j = 0; j < i; j++) {
                // Can include j before i if scores[j] <= scores[i]
                if (players[j].score <= players[i].score)  dp[i] = Math.Max(dp[i], dp[j] + players[i].score);
                
            }

            ans = Math.Max(ans, dp[i]);
        }

        return ans;
    }
}
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n²)**             | n ≤ 1000 → ~10⁶ operations                     |
| **Space Complexity**  | **O(n)**              | Players array + DP array                       |

**Optimal** — n is small, O(n²) perfectly acceptable.

---

## Why This Works — Example Walkthrough

**Input**: `scores = [1,3,5,10,15]`, `ages = [1,2,3,4,5]`

- Already sorted by increasing age.
- DP progression:
  - i=0: dp[0] = 1
  - i=1: score 3 > 1 → dp[1] = 1 + 3 = **4**
  - i=2: score 5 > 3 → dp[2] = 4 + 5 = **9**
  - i=3: score 10 > 5 → dp[3] = 9 + 10 = **19**
  - i=4: score 15 > 10 → dp[4] = 19 + 15 = **34**

→ Maximum = **34** (all players)

**Correct**.

**Input**: `scores = [4,5,6,5]`, `ages = [2,1,2,1]`

- Sorted by age (then score): (1,5), (1,5), (2,4), (2,6)
- DP builds:
  - Players 0 and 1 (age 1): can both be taken (same age) → sum 5+5=10
  - Player 3 (age 2, score 6): can take with previous → max sum = 5+5+6 = **16**
  - Player 2 (age 2, score 4): lower score → not beneficial

→ Maximum = **16** (players with scores 5,5,6)

**Correct**.

---

## Pitfalls & Edge Cases

- **Same age** → no conflict → can take multiple players
- **Younger with higher score** → cannot take together after sorting
- **Sort order** → **age ascending first**, then score (to handle same age correctly)
- **All same age** → can take everyone (max sum of all scores)

All handled perfectly.

---

## Key Takeaway

This is a **classic LIS-style DP with sum maximization**:

- **Sort by age** → turns conflict rule into non-decreasing score constraint
- **DP** → maximum sum ending with current player, taking compatible previous players
- **O(n²)** → acceptable for n ≤ 1000

**Pure, clean, optimal** — perfect team selection problem.

---

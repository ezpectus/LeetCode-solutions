# ğŸ§© LeetCode 907 â€” Sum of Subarray Minimums

## ğŸ“œ Problem Statement

Given an array of integers `arr`, return the sum of the minimum value of every contiguous subarray of `arr`.  
Since the answer may be large, return it modulo `10â¹ + 7`.

### Example 1:
- Input: `arr = [3,1,2,4]`
- Output: `17`
- Explanation: Subarrays and their minimums:
  - `[3] â†’ 3`, `[1] â†’ 1`, `[2] â†’ 2`, `[4] â†’ 4`
  - `[3,1] â†’ 1`, `[1,2] â†’ 1`, `[2,4] â†’ 2`
  - `[3,1,2] â†’ 1`, `[1,2,4] â†’ 1`, `[3,1,2,4] â†’ 1`
  - Total sum = `3 + 1 + 2 + 4 + 1 + 1 + 2 + 1 + 1 + 1 = 17`

---

## ğŸ“ Constraints

- `1 <= arr.length <= 3 * 10â´`
- `1 <= arr[i] <= 3 * 10â´`

---

## ğŸ§  Optimized Strategy

### ğŸ”¹ Core Idea
Instead of generating all subarrays, we calculate how many subarrays each element is the **minimum of**, and sum its contribution.

### ğŸ”¹ Contribution Formula
For each element `arr[i]`, its contribution is:
```
arr[i] Ã— (i - left[i]) Ã— (right[i] - i)
```
Where:
- `left[i]` is the index of the **previous less** element (strictly less).
- `right[i]` is the index of the **next less or equal** element.

This gives the number of subarrays where `arr[i]` is the minimum.

---

## ğŸ” How It Works

1. **Monotonic Stack (Left Pass)**:
   - Traverse from left to right.
   - For each `i`, find the closest index to the left where `arr[j] < arr[i]`.
   - If none found â†’ `left[i] = -1`.

2. **Monotonic Stack (Right Pass)**:
   - Traverse from right to left.
   - For each `i`, find the closest index to the right where `arr[j] <= arr[i]`.
   - If none found â†’ `right[i] = n`.

3. **Final Sum**:
   - For each `i`, compute its contribution using the formula.
   - Accumulate the result modulo `10â¹ + 7`.

---

## âœ… Final Code

```csharp
public class Solution {
    public int SumSubarrayMins(int[] arr) {
        int n = arr.Length;
        int MOD = 1_000_000_007;
        int[] left = new int[n];
        int[] right = new int[n];
        Stack<int> stack = new Stack<int>();

        // Previous less element
        for (int i = 0; i < n; i++) {
            while (stack.Count > 0 && arr[stack.Peek()] > arr[i])
                stack.Pop();
            left[i] = stack.Count == 0 ? -1 : stack.Peek();
            stack.Push(i);
        }

        stack.Clear();

        // Next less or equal element
        for (int i = n - 1; i >= 0; i--) {
            while (stack.Count > 0 && arr[stack.Peek()] >= arr[i])
                stack.Pop();
            right[i] = stack.Count == 0 ? n : stack.Peek();
            stack.Push(i);
        }

        long sum = 0;
        for (int i = 0; i < n; i++) {
            long count = (long)(i - left[i]) * (right[i] - i);
            sum = (sum + arr[i] * count) % MOD;
        }

        return (int)sum;
    }
}
```

## â± Complexity

| Metric            | Value                                                              |
|-------------------|--------------------------------------------------------------------|
| **Time Complexity**   | `O(n)` â€” two monotonic stack passes (left and right) plus a final linear pass to compute contributions |
| **Space Complexity**  | `O(n)` â€” for storing `left`, `right`, and the stack used during traversal |

### ğŸ” Why Itâ€™s O(n)
- Each element is pushed and popped from the stack at most once in each pass.
- No nested loops or redundant scans â€” every operation is bounded linearly.
- Final contribution loop is a single pass over the array.

---

## ğŸ§˜ Key Takeaways

- You donâ€™t need to generate all subarrays â€” just compute how often each element is the minimum.
- Monotonic stacks efficiently find left/right bounds in linear time.
- Contribution-based thinking transforms brute-force enumeration into elegant `O(n)` logic.
- This pattern generalizes to:
  - **Sum of maximums** (same logic, reversed comparisons)
  - **Largest rectangle in histogram**
  - **Count of ranges with specific properties**
- Itâ€™s a reusable architectural tool for any problem involving **local extrema and range contribution**.

---

## ğŸ“¦ Module Summary

| Component         | Description                                         |
|------------------|-----------------------------------------------------|
| **Pattern**       | Monotonic stack + contribution analysis            |
| **Reusability**   | High â€” works for min/max contribution problems     |
| **Edge Cases**    | Handles duplicates, strictly increasing/decreasing arrays |
| **Performance**   | Efficient for large arrays with tight constraints  |
| **Debuggability** | Easy to trace with printed `left`, `right`, and contribution arrays |



---

# 🧩 LeetCode 907 — Sum of Subarray Minimums

## 📜 Problem Statement

Given an array of integers `arr`, return the sum of the minimum value of every contiguous subarray of `arr`.  
Since the answer may be large, return it modulo `10⁹ + 7`.

### Example 1:
- Input: `arr = [3,1,2,4]`
- Output: `17`
- Explanation: Subarrays and their minimums:
  - `[3] → 3`, `[1] → 1`, `[2] → 2`, `[4] → 4`
  - `[3,1] → 1`, `[1,2] → 1`, `[2,4] → 2`
  - `[3,1,2] → 1`, `[1,2,4] → 1`, `[3,1,2,4] → 1`
  - Total sum = `3 + 1 + 2 + 4 + 1 + 1 + 2 + 1 + 1 + 1 = 17`

---

## 📐 Constraints

- `1 <= arr.length <= 3 * 10⁴`
- `1 <= arr[i] <= 3 * 10⁴`

---

## 🧠 Optimized Strategy

### 🔹 Core Idea
Instead of generating all subarrays, we calculate how many subarrays each element is the **minimum of**, and sum its contribution.

### 🔹 Contribution Formula
For each element `arr[i]`, its contribution is:
```
arr[i] × (i - left[i]) × (right[i] - i)
```
Where:
- `left[i]` is the index of the **previous less** element (strictly less).
- `right[i]` is the index of the **next less or equal** element.

This gives the number of subarrays where `arr[i]` is the minimum.

---

## 🔍 How It Works

1. **Monotonic Stack (Left Pass)**:
   - Traverse from left to right.
   - For each `i`, find the closest index to the left where `arr[j] < arr[i]`.
   - If none found → `left[i] = -1`.

2. **Monotonic Stack (Right Pass)**:
   - Traverse from right to left.
   - For each `i`, find the closest index to the right where `arr[j] <= arr[i]`.
   - If none found → `right[i] = n`.

3. **Final Sum**:
   - For each `i`, compute its contribution using the formula.
   - Accumulate the result modulo `10⁹ + 7`.

---

## ✅ Final Code

```csharp
public class Solution {
    public int SumSubarrayMins(int[] arr) {
        int n = arr.Length;
        int MOD = 1_000_000_007;
        int[] left = new int[n];
        int[] right = new int[n];
        Stack<int> stack = new Stack<int>();

        // Previous less element
        for (int i = 0; i < n; i++) {
            while (stack.Count > 0 && arr[stack.Peek()] > arr[i])
                stack.Pop();
            left[i] = stack.Count == 0 ? -1 : stack.Peek();
            stack.Push(i);
        }

        stack.Clear();

        // Next less or equal element
        for (int i = n - 1; i >= 0; i--) {
            while (stack.Count > 0 && arr[stack.Peek()] >= arr[i])
                stack.Pop();
            right[i] = stack.Count == 0 ? n : stack.Peek();
            stack.Push(i);
        }

        long sum = 0;
        for (int i = 0; i < n; i++) {
            long count = (long)(i - left[i]) * (right[i] - i);
            sum = (sum + arr[i] * count) % MOD;
        }

        return (int)sum;
    }
}
```

## ⏱ Complexity

| Metric            | Value                                                              |
|-------------------|--------------------------------------------------------------------|
| **Time Complexity**   | `O(n)` — two monotonic stack passes (left and right) plus a final linear pass to compute contributions |
| **Space Complexity**  | `O(n)` — for storing `left`, `right`, and the stack used during traversal |

### 🔍 Why It’s O(n)
- Each element is pushed and popped from the stack at most once in each pass.
- No nested loops or redundant scans — every operation is bounded linearly.
- Final contribution loop is a single pass over the array.

---

## 🧘 Key Takeaways

- You don’t need to generate all subarrays — just compute how often each element is the minimum.
- Monotonic stacks efficiently find left/right bounds in linear time.
- Contribution-based thinking transforms brute-force enumeration into elegant `O(n)` logic.
- This pattern generalizes to:
  - **Sum of maximums** (same logic, reversed comparisons)
  - **Largest rectangle in histogram**
  - **Count of ranges with specific properties**
- It’s a reusable architectural tool for any problem involving **local extrema and range contribution**.

---

## 📦 Module Summary

| Component         | Description                                         |
|------------------|-----------------------------------------------------|
| **Pattern**       | Monotonic stack + contribution analysis            |
| **Reusability**   | High — works for min/max contribution problems     |
| **Edge Cases**    | Handles duplicates, strictly increasing/decreasing arrays |
| **Performance**   | Efficient for large arrays with tight constraints  |
| **Debuggability** | Easy to trace with printed `left`, `right`, and contribution arrays |



---

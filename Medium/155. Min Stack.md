# 155. Min Stack

---

## Problem Restatement
We need to design a stack that supports:
- **Push(val):** add element to stack.  
- **Pop():** remove top element.  
- **Top():** return top element.  
- **GetMin():** return minimum element in stack.  

All operations must run in **O(1) time complexity**.

---

## Key Idea
- Maintain two stacks:
  - **Main stack:** stores all values.  
  - **Min stack:** stores the minimum value at each level.  
- When pushing:
  - Push value onto main stack.  
  - Push `min(val, currentMin)` onto min stack.  
- When popping:
  - Pop from both stacks.  
- Top = top of main stack.  
- GetMin = top of min stack.  

This ensures constant-time retrieval of the minimum.

---

## Code (C#)
```csharp
public class MinStack {
    private Stack<int> stack;
    private Stack<int> minStack;

    public MinStack() {
        stack = new Stack<int>();
        minStack = new Stack<int>();
    }
    
    public void Push(int val) {
        stack.Push(val);
        if (minStack.Count == 0 || val <= minStack.Peek()) {
            minStack.Push(val);
        } else {
            minStack.Push(minStack.Peek());
        }
    }
    
    public void Pop() {
        stack.Pop();
        minStack.Pop();
    }
    
    public int Top() {
        return stack.Peek();
    }
    
    public int GetMin() {
        return minStack.Peek();
    }
}
```



## Time Complexity
- **Push:** O(1)  
- **Pop:** O(1)  
- **Top:** O(1)  
- **GetMin:** O(1)  
All operations are constant-time because we maintain a parallel min stack.

---

## Space Complexity
- **Main stack:** O(n) for storing elements.  
- **Min stack:** O(n) for storing minimum values at each level.  
- **Total:** O(n).  

---

## Example Walkthrough

**Input:**
```
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]
```


**Execution:**
- Push(-2) → stack = [-2], minStack = [-2]  
- Push(0) → stack = [-2,0], minStack = [-2,-2]  
- Push(-3) → stack = [-2,0,-3], minStack = [-2,-2,-3]  
- GetMin() → -3 ✅  
- Pop() → stack = [-2,0], minStack = [-2,-2]  
- Top() → 0 ✅  
- GetMin() → -2 ✅  

**Output:**  
```[null,null,null,null,-3,null,0,-2]```

---

## Why This Works
- The **min stack** mirrors the main stack, storing the minimum value at each level.  
- This ensures that retrieving the minimum is always O(1), without scanning the stack.  
- Each push updates both stacks, and each pop removes from both, keeping them synchronized.  

---

## Edge Cases
- **Single element:** Push(5), GetMin() → 5.  
- **All increasing values:** min stack always holds the first element.  
- **All decreasing values:** min stack mirrors the main stack exactly.  
- **Mixed values:** min stack dynamically tracks the minimum at each level.  

---

✅ **Conclusion**  
This is the classic **Two-Stack Min Tracking Algorithm**.  
By maintaining a parallel min stack, we achieve **constant-time push, pop, top, and minimum retrieval**, making it an elegant and efficient design for MinStack.


---











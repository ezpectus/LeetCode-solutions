# 865. Smallest Subtree with all the Deepest Nodes — Architectural Bottom-Up Depth + LCA  
*O(n) — Optimal Post-Order DFS*

---

## Problem Statement

Given a binary tree, find the **smallest subtree** that contains **all the deepest nodes** in the tree.

- **Deepest nodes** = nodes at the **maximum depth** in the entire tree
- **Subtree** = a node + **all its descendants**
- Return the **root** of that smallest subtree

---

## Core Idea — Post-Order DFS Returning Depth + Node

We use a **single post-order DFS** that returns **two things** from each subtree:
- The **maximum depth** of the subtree
- The **node** that is the root of the smallest subtree containing all deepest nodes in this subtree

**How it works**:

We process children first (post-order):

1. Recursively get results from **left** and **right** subtrees:
   - `leftDepth`, `leftNode`
   - `rightDepth`, `rightNode`

2. Compute current subtree depth:
   - `currentDepth = 1 + max(leftDepth, rightDepth)`

3. Decide what to return:
   - If **leftDepth == rightDepth** (both sides have same max depth)  
     → All deepest nodes are at the same level on both sides  
     → **Current node** is the LCA of all deepest nodes → return **current node**
   - If **leftDepth > rightDepth**  
     → All deepest nodes are in the left subtree  
     → Return the node from left
   - If **rightDepth > leftDepth**  
     → Return the node from right

**Key insight**:
- The **lowest common ancestor (LCA)** of all deepest nodes is **exactly** the root of the smallest subtree that contains them all.
- By comparing depths bottom-up, we naturally find this LCA without extra computation.

**Single DFS** → computes depths **and** finds the answer in one pass.


---

##  Implementation (C#)

```csharp
public class Solution {
    public TreeNode SubtreeWithAllDeepest(TreeNode root) {
        return Dfs(root).Node;
    }

    // Return (deepest node in subtree, depth of subtree)
    private (TreeNode Node, int Depth) Dfs(TreeNode node)  {
        if (node == null) 
            return (null, 0);

        var left = Dfs(node.left);
        var right = Dfs(node.right);
        int leftDepth = left.Depth;
        int rightDepth = right.Depth;

        if (leftDepth == rightDepth) return (node, leftDepth + 1);
        else if (leftDepth > rightDepth)  return (left.Node, leftDepth + 1);
        else  return (right.Node, rightDepth + 1);
        
    }
}
```


## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Visit each node exactly once                   |
| **Space Complexity**  | **O(h)**      | Recursion stack (h = tree height, worst O(n))   |

**Optimal** — linear time, minimal space.

---

## Why This Works — Example Walkthrough

**Input**: `[3,5,1,6,2,0,8,null,null,7,4]`

- Leaves at depth 3: `7`, `4`, `0`, `8`
- Post-order DFS computes depths bottom-up:
  - Left subtree of root (under 5): max depth = 3
  - Right subtree of root (under 1): max depth = 2
  - Left > right → deepest nodes are all in left → propagate up
- At node `5`: left (6) depth=2, right (2) depth=3 → right deeper → propagate from right
- At node `2`: left `7` depth=3, right `4` depth=3 → **same depth** → **current node** (2) is the LCA of all deepest nodes → return node 2

→ **Correct** — node 2 is root of smallest subtree containing all deepest nodes.

**Input**: `[0,1,3,null,2]`

- Deepest node: `2` at depth 3
- Post-order:
  - Left subtree depth = 3
  - Right subtree depth = 1
  - Left deeper → propagate from left
  - At node `1`: left depth=3, right null → propagate
  - At root `0`: left depth=3 → propagate → final return node `2`

→ **Correct**.

---

## Pitfalls & Edge Cases

- **Single node** → return itself
- **All deepest on one side** → LCA is the deepest node itself
- **Deepest nodes balanced** → LCA higher up
- **Unbalanced tree** → correctly follows deeper side
- **Multiple nodes at max depth** → finds true LCA

All handled perfectly.

---

## Key Takeaway

This is a **beautifully elegant** tree problem:

- **Post-order DFS** → natural depth computation
- **Return pair** (node, depth) → propagate both info and LCA
- **Compare depths** → exactly find the root of smallest subtree

**No extra structures. No preprocessing.**
**Pure, clean, optimal** — one of the most satisfying tree problems.

---

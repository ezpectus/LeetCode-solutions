# 2337. Move Pieces to Obtain a String  
*O(n) — Greedy Two-Pointer Matching*

---

## Problem Statement

You are given two strings `start` and `target` of equal length `n`, consisting of `'L'`, `'R'`, and `'_'`.

Rules for moving pieces:
- `'L'` can only move **left** into an adjacent `'_'`
- `'R'` can only move **right** into an adjacent `'_'`
- `'_'` are blank spaces (can be occupied by moving pieces)

You can perform any number of moves.  
Return `true` if you can transform `start` into `target`, otherwise `false`.

**Note**: Pieces cannot pass through each other (only move into blank spaces).

**Examples**:

**Example 1**  
Input: start = "_L__R__R_", target = "L______RR"  
Output: **true**  
Possible moves → transform step-by-step to target

**Example 2**  
Input: start = "R_L_", target = "__LR"  
Output: **false**  
'R' can only move right → cannot reach desired positions

**Example 3**  
Input: start = "_R", target = "R_"  
Output: **false**  
'R' can only move right → cannot move left

**Constraints**:
- n == start.length == target.length
- 1 ≤ n ≤ 10⁵
- start and target consist of 'L', 'R', '_'

---

## Core Idea — Ignore Blanks, Match Non-Blank Positions

**Beautiful observation**:
- Blanks ('_') are just movable spaces — they don't affect the **relative order** of 'L' and 'R' pieces
- The sequence of **non-blank characters** ('L' and 'R') in `start` and `target` must be **exactly the same**
- Each 'L' can only move left (never right), each 'R' can only move right (never left)
- Therefore:
  1. The sequence of pieces (ignoring '_') in `start` and `target` must be identical
  2. Each 'L' in start must end up at a position **≤** its original position in target
  3. Each 'R' in start must end up at a position **≥** its original position in target

**Algorithm** (two pointers):
1. Extract list of non-blank characters from `start` and `target`
2. If the two sequences differ → impossible → false
3. For each pair of matching pieces (same type):
   - If piece is 'L': target position must be ≤ start position
   - If piece is 'R': target position must be ≥ start position
4. If all pairs satisfy this → true, else false

**Time**: O(n) — single pass to extract + single pass to compare  
**Space**: O(n) — lists of positions (can be done with two pointers without extra space)

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public bool CanChange(string start, string target){
        int n = start.Length;

        // Two pointers to iterate through non-blank characters
        int i = 0; // for start
        int j = 0; // for target

        while (i < n && j < n){
            // Skip blanks in start
            while (i < n && start[i] == '_') i++;

            // Skip blanks in target
            while (j < n && target[j] == '_') j++;

            // If one reached end but other didn't → mismatch
            if (i == n || j == n) return i == n && j == n;
            
            // Current characters must match
            if (start[i] != target[j]) return false;
            
            // Check movement direction constraint
            if (start[i] == 'L' && i < j) return false; // 'L' cannot move right
            if (start[i] == 'R' && i > j) return false; // 'R' cannot move left
            
            i++;
            j++;
        }

        // Skip remaining blanks (if any)
        while (i < n && start[i] == '_') i++;
        while (j < n && target[j] == '_') j++;

        // Both must be fully processed
        return i == n && j == n;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Two pointers traverse each string at most once — each character is visited O(1) times |
| **Space Complexity**  | **O(1)**      | Only a few integer variables (pointers i and j) — no extra arrays or data structures needed |

**Optimal** — linear time and constant extra space — perfect and highly efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: start = "_L__R__R_", target = "L______RR"

**Non-blank characters** in start: L, R, R (positions 1, 4, 7)  
**Non-blank characters** in target: L, R, R (positions 0, 7, 8)

**Compare pairs** (same type and order):

- First L: start pos 1, target pos 0 → 1 ≥ 0 (L can move left) → OK
- Second R: start pos 4, target pos 7 → 4 ≤ 7 (R can move right) → OK
- Third R: start pos 7, target pos 8 → 7 ≤ 8 (R can move right) → OK

All conditions satisfied → **true**

**Example 2**: start = "R_L_", target = "__LR"

**Non-blank** start: R, L (positions 0, 2)  
**Non-blank** target: L, R (positions 2, 3)

**Compare**:
- First: R vs L → different types → **false**

**Example 3**: start = "_R", target = "R_"

**Non-blank** start: R (position 1)  
**Non-blank** target: R (position 0)

**Compare**:
- R: start pos 1, target pos 0 → 1 > 0 but R cannot move left → **false**

**Correct** —  
We completely **ignore all blanks** ('_') — they are just movable spaces and do not affect the relative order or movement constraints of the pieces ('L' and 'R').  
The **sequence of pieces** must be **exactly the same** in both strings.  
Additionally, each piece must be able to reach its target position:
- 'L' pieces can only move **left** (target index ≤ start index)
- 'R' pieces can only move **right** (target index ≥ start index)

If both conditions are satisfied for every piece → transformation is possible.

---

## Key Takeaway

This is a **beautiful two-pointer + constraint validation** problem:

* **Ignore all '_'** — blanks are just movable gaps and do not affect the piece sequence
* Extract and compare the **sequence of non-blank characters** ('L' and 'R') from both strings — they must be **exactly identical**
* For each pair of matching pieces (same type, same order):
  - If piece is 'L': target position must be **≤** start position (can only move left)
  - If piece is 'R': target position must be **≥** start position (can only move right)
* If all pairs satisfy the movement constraint → return **true**, else **false**

**Pure, clean, optimal** — O(n) time, O(1) extra space, extremely fast, very intuitive, and handles all edge cases correctly (no pieces, all blanks, mismatched sequences, impossible movements, etc.).

---

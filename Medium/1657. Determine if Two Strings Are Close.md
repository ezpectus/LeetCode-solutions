# Intuition
To determine if two strings are "close," we need to understand what transformations are allowed.

We can swap any characters, which means character order doesn't matter.

We can transform all instances of one character into another, but only if both characters exist in the string.

This leads to two key insights:

The set of characters used in both strings must be the same.

The frequency distribution of characters must be transformable — i.e., the counts must match up, regardless of which character they belong to.

# Approach
Check length — if the strings differ in length, they can't be close.

Build frequency maps for both strings using dictionaries.

Compare character sets — if one string uses a character the other doesn't, return false.

Compare sorted frequency values — if the counts of characters can be rearranged to match, return true.

This approach ensures both the symbolic compatibility and the frequency transformability required by the problem.

# Complexity
Time complexity: $$O(n \log n)$$

Building frequency maps: $$O(n)$$

Sorting frequency lists: $$O(n \log n)$$

Space complexity: $$O(n)$$

For frequency dictionaries and lists.

# Code
```csharp []
public class Solution {
    public bool CloseStrings(string word1, string word2) {
        if (word1.Length != word2.Length) return false;

        var freq1 = new Dictionary<char, int>();
        var freq2 = new Dictionary<char, int>();

        foreach (char c in word1) {
            freq1[c] = freq1.GetValueOrDefault(c, 0) + 1;
        }

        foreach (char c in word2) {
            freq2[c] = freq2.GetValueOrDefault(c, 0) + 1;
        }

        // Check if both words use the same set of characters
        var keys1 = new HashSet<char>(freq1.Keys);
        var keys2 = new HashSet<char>(freq2.Keys);
        if (!keys1.SetEquals(keys2)) return false;

        // Check if frequency distributions match (order doesn't matter)
        var values1 = freq1.Values.ToList();
        var values2 = freq2.Values.ToList();
        values1.Sort();
        values2.Sort();

        return values1.SequenceEqual(values2);
    }
}

```


---

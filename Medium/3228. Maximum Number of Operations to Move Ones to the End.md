# ðŸ§  3228. Maximum Number of Operations to Move Ones to the End 

## ðŸ“Œ Problem Summary
Given a binary string `s`, you can repeatedly:
- Choose index `i` such that `s[i] == '1'` and `s[i+1] == '0'`
- Move `s[i]` right until it reaches the end or another `'1'`

Return the **maximum number of such operations**.

---

## ðŸ§± Architectural Insight
Each `'1'` can jump over a **contiguous block of `'0'`s**, but only if it is **immediately followed by `'0'`**.  
So we count how many `'1'`s are to the left of each `'0'` block â€” each such `'1'` can jump once per block.

---

## âœ… Pattern
- Traverse string left to right
- Track number of `'1'`s seen so far (`curr`)
- When hitting a `'0'`, scan the entire `'0'` block
- After the block, add `curr` to total `count`

---

## ðŸš€ Code (C#)

```csharp
public class Solution {
    public int MaxOperations(string s) {
        int n = s.Length;
        int curr = 0, count = 0;

        for (int i = 0; i < n; i++) {
            if (s[i] == '1') {
                curr++;
            } else if (s[i] == '0') {
                while (i < n && s[i] == '0') {
                    i++;
                }
                i--; // step back to last zero
                count += curr;
            }
        }

        return count;
    }
}
```


## â±ï¸ Complexity
- **Time:** O(n) â€” single pass through the string  
- **Space:** O(1) â€” constant memory, no extra structures  

---

## âš ï¸ Pitfalls
- âœ… Only `'1'` followed immediately by `'0'` can be chosen for an operation  
- âœ… Must process the **entire block of `'0'`s** before adding operations  
- âœ… `'1'` is not consumed â€” it can participate in multiple operations if multiple `'0'` blocks appear  
- âœ… Avoid double-counting â€” each `'1'` contributes +1 to `count` only when a new `'0'` block is encountered  

---

## âœ… Sanity Checks
- `"1001101"` â†’ 4 operations: `'1'` jumps over four `'0'` blocks  
- `"00111"` â†’ 0 operations: no `'1'` followed by `'0'`  
- `"010010"` â†’ 3 operations: `'1'` jumps over three `'0'` blocks  

---

## ðŸ‘‰ Key takeaway: Architectural essence

This is a **greedy linear scan** problem.  
We donâ€™t simulate moving `'1'`s explicitly â€” instead, we **count the potential moves**.  
Every `'1'` that appears before a `'0'` block can perform one operation (jump over that block).  
We accumulate `'1'`s in `curr`, and when encountering a `'0'` block, we add `curr` to the total `count`.

### ðŸ” How it works:
- `'1'` â†’ increment `curr`  
- `'0'` â†’ scan the entire `'0'` block, then add `curr` to `count`  
- `'1'` remains available â€” it can contribute again if another `'0'` block appears later  

### ðŸ“Œ Why this is efficient:
- No string modifications, no shifting characters  
- No additional data structures  
- Pure counting of potential operations â†’ **O(n) time, O(1) space**

---

# 524. Longest Word in Dictionary through Deleting

---

## Problem Summary
We are given:
- A string `s`.
- A list of words `dictionary`.

We need to return the **longest word** in the dictionary that can be formed by deleting some characters from `s`.  
- If multiple words have the same maximum length, return the one with the **smallest lexicographical order**.  
- If no word can be formed, return the empty string.

---

## Code Idea
1. **Subsequence Check**  
   - Write a helper function `IsSubsequence(word, s)` that checks if `word` can be formed by deleting characters from `s`.  
   - Use two pointers: one for `word`, one for `s`. Move through `s`, advancing the pointer in `word` when characters match.  

2. **Iterate over dictionary**  
   - For each word in `dictionary`, check if it is a subsequence of `s`.  
   - If yes, compare with the current best answer:  
     - If longer → update answer.  
     - If same length but lexicographically smaller → update answer.  

3. **Return result**  
   - If no valid word found, return `""`.  
   - Otherwise return the best candidate.

---

## Code (C#)
```csharp
public class Solution {
    public string FindLongestWord(string s, IList<string> dictionary) {
        string res = "";

        foreach (string word in dictionary) {
            if (IsSubsequence(word, s)) {
                if (word.Length > res.Length || 
                   (word.Length == res.Length && string.Compare(word, res) < 0)) {
                    res = word;
                }
            }
        }

        return res;
    }

    private bool IsSubsequence(string word, string s) {
        int i = 0, j = 0;
        while (i < word.Length && j < s.Length) {
            if (word[i] == s[j]) i++;
            j++;
        }
        return i == word.Length;
    }
}
```



## Complexity
- **Time:** O(n × m), where `n = dictionary.Length`, `m = s.Length`.  
  - Each subsequence check runs in O(m).  
- **Space:** O(1), only pointers used.  

---

## Pitfalls
- Must handle lexicographical tie-breaking correctly (`string.Compare`).  
- Ensure subsequence check uses two pointers properly.  
- Edge case: dictionary contains words longer than `s` → automatically invalid.  
- If no valid word exists, return empty string.  

---

## Example Walkthrough
**Input:**  
`s = "abpcplea"`  
`dictionary = ["ale","apple","monkey","plea"]`  

- "ale" → subsequence, length 3.  
- "apple" → subsequence, length 5.  
- "monkey" → not subsequence.  
- "plea" → subsequence, length 4.  
- Best = "apple".  
**Output:** `"apple"`  

---

**Input:**  
`s = "abpcplea"`  
`dictionary = ["a","b","c"]`  

- "a" → subsequence, length 1.  
- "b" → subsequence, length 1.  
- "c" → subsequence, length 1.  
- Tie-breaking → lexicographically smallest = "a".  
**Output:** `"a"`  

---

## Conclusion
The problem reduces to **subsequence checking with tie-breaking**.  
- Efficient O(n × m) solution works within constraints.  
- Two-pointer subsequence check ensures correctness.  
- Lexicographical comparison resolves ties cleanly.  


---

# Pattern Name
**Depth Tracking via DFS for Leaf Aggregation**

## Problem Summary
- **Input**:  
  Root of a **binary tree**.
- **Goal**:  
  Return the **sum of values** of the **deepest leaves**.
- **Constraints**:
  - `1 ≤ number of nodes ≤ 10⁴`
  - `1 ≤ Node.val ≤ 100`

## Core Idea
- Traverse the tree using **DFS**, **tracking the current depth**.
- If a leaf is **deeper** than all previous → **reset the sum**.
- If a leaf is at the **current max depth** → **add its value**.

## Solution
- Use a **recursive DFS** with **depth tracking**.
- Maintain two variables:
  - `maxDep` — current deepest level
  - `sum` — cumulative value of deepest leaves

## Strategy Summary
- Start DFS from **root at depth 0**.
- At each **leaf**:
  - If `depth > maxDep` → reset `sum = node.val`, update `maxDep`
  - If `depth == maxDep` → `sum += node.val`
- Recurse **left** and **right** with `depth + 1`

## C# Implementation
```csharp
public class Solution {
    private int maxDep = 0;
    private int sum = 0;

    public int DeepestLeavesSum(TreeNode root) {
        DFS(root, 0);
        return sum;
    }

    private void DFS(TreeNode? node, int depth) {
        if (node == null) return;

        if (depth > maxDep) {
            sum = node.val;
            maxDep = depth;
        } else if (depth == maxDep) {
            sum += node.val;
        }

        DFS(node.left, depth + 1);
        DFS(node.right, depth + 1);
    }
}
```


## Architectural Breakdown
| Component            | Role                                      |
|----------------------|-------------------------------------------|
| `maxDep`             | Tracks deepest level seen so far          |
| `sum`                | Accumulates values at deepest level       |
| **DFS traversal**    | Explores all nodes with depth tracking    |
| **Leaf check**       | Updates sum based on depth comparison     |

## Why This Approach Is Superior
| Aspect              | **DFS Depth Tracking** | BFS Level Scan         |
|---------------------|------------------------|------------------------|
| Time Complexity     | O(n)                   | O(n)                   |
| Space Complexity    | **O(h)** — call stack  | O(w) — queue width     |
| Performance         | Efficient for deep trees | BFS may use more memory |
| Clarity             | **Simple recursion**   | Requires level tracking |

## Final Takeaway
- **This pattern is ideal for depth-sensitive aggregation in trees.**
- **Generalizes to**:
  - Deepest node queries
  - Level-based filtering
  - Recursive tree metrics
 
---

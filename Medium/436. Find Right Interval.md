# Pattern Name
**Binary Search for Minimal Right Interval via Indexed Sorting**

---

## Problem Summary
You're given:

- A list of intervals `intervals`, where each interval is `[start, end]`
- **Each `start` is unique**

**For each interval `i`**, find the **index** of interval `j` such that:
- `start[j] >= end[i]`
- `start[j]` is the **smallest possible** among all such intervals

**If no such interval exists** → return `-1` for that position

**Return an array of indices** — one for each interval in the input.

---

## Core Idea
This is a **range search problem over sorted keys**.

We want to find, for each `end[i]`, the **smallest `start[j]` ≥ `end[i]`**.

Since all `start` values are **unique**, we can:
- **Sort them**
- **Binary search** to locate the **minimal valid `j`**

---

## Strategy Summary
1. Build a list of `(start, index)` pairs
2. **Sort this list by `start`**
3. For each interval `i`:
   - Binary search for the **smallest `start[j] >= end[i]`**
   - If found → return `index[j]`
   - Else → `-1`
4. Collect results in output array

---

## C# Implementation
```csharp
public class Solution {
    public int[] FindRightInterval(int[][] intervals) {
        int n = intervals.Length;
        var starts = new List<(int start, int index)>();

        for (int i = 0; i < n; i++)
            starts.Add((intervals[i][0], i));

        starts.Sort((a, b) => a.start.CompareTo(b.start));

        int[] result = new int[n];
        for (int i = 0; i < n; i++) {
            int target = intervals[i][1];
            int left = 0, right = n - 1;
            int found = -1;

            while (left <= right) {
                int mid = (left + right) / 2;
                if (starts[mid].start >= target) {
                    found = starts[mid].index;
                    right = mid - 1;  // continue to find smaller start
                } else {
                    left = mid + 1;
                }
            }

            result[i] = found;
        }

        return result;
    }
}
```

## Architectural Breakdown

| Component         | Role |
|-------------------|------|
| `starts`          | Stores sorted `(start, index)` pairs for binary search |
| **Outer loop**    | Iterates over each interval to resolve its right match |
| **Binary search** | Finds **minimal** `start[j] >= end[i]` |
| `found`           | Tracks candidate index or `-1` |

---

## Why This Approach Is Superior

| Aspect               | This Approach                        | Naive Approach                  |
|----------------------|--------------------------------------|---------------------------------|
| **Search Strategy**  | Binary search over sorted keys       | Linear scan over all intervals  |
| **Time Complexity**  | `O(n log n)`                         | `O(n²)`                         |
| **Space Complexity** | `O(n)`                               | `O(n)`                          |
| **Tie-breaking**     | Index preserved via sorting          | Manual index tracking           |
| **Scalability**      | Handles up to 20,000 intervals       | Degrades quickly                |

---

## Final Takeaway

> This problem is a **classic case of range search with minimal constraint**.

### The solution uses:
- **Preprocessing** into sorted `(start, index)` pairs
- **Binary search** for each `end[i]`
- **Efficient resolution** of minimal valid interval

---

### This pattern generalizes to any task involving:
- Searching for **minimal satisfying values**
- **Interval matching** with sorted keys
- **Efficient lookup** via binary search

---

# 1333. Filter Restaurants by Vegan-Friendly, Price and Distance — Architectural Filtering + Custom Sort  
*O(n log n) — Optimal Linear Scan with Sorting*

---

## Problem Statement

Given list `restaurants` where each `restaurants[i] = [id, rating, veganFriendly, price, distance]`.

Filter by:
- `veganFriendly` (0 or 1) — if 1, keep only vegan-friendly (veganFriendlyi == 1)
- `maxPrice` — price ≤ maxPrice
- `maxDistance` — distance ≤ maxDistance

Return **list of restaurant IDs**:
- Sorted by **rating descending**
- For same rating — by **id descending**

---

## Core Idea — Filter First, Then Sort with Custom Comparator

**Key insight**:
- n ≤ 10⁴ → O(n log n) fine
- Filter using conditions
- Sort with **custom order**:
  - Primary: rating ↓
  - Secondary: id ↓

**Steps**:
1. Iterate through restaurants
2. Keep if:
   - price ≤ maxPrice
   - distance ≤ maxDistance
   - if veganFriendly == 1 → veganFriendlyi == 1
3. Collect valid `[id, rating]`
4. Sort: higher rating first, then higher id
5. Return list of ids

---

##  Implementation (C#)

```csharp
public class Solution {
    public IList<int> FilterRestaurants(int[][] restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        var valid = new List<(int id, int rating)>();

        foreach (var r in restaurants)  {
            int id = r[0], rating = r[1], vegan = r[2], price = r[3], dist = r[4];

            if (price > maxPrice || dist > maxDistance) continue;
            if (veganFriendly == 1 && vegan == 0) continue;

            valid.Add((id, rating));
        }

        valid.Sort((a, b) => {
            if (a.rating != b.rating) return b.rating - a.rating;  // higher rating first
            return b.id - a.id;                                   // higher id first
        });

        var res = new List<int>();
        foreach (var p in valid)  res.Add(p.id);
        
        return res;
    }
}

```



## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)**        | Filter O(n) + sort O(n log n)                  |
| **Space Complexity**  | **O(n)**              | List of valid restaurants (worst case)         |

**Optimal** — sorting is required for the specified order.

---

## Why This Works — Example Walkthrough

**Input**:  
`restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]]`  
`veganFriendly = 1`, `maxPrice = 50`, `maxDistance = 10`

- **Filtering**:
  - Keep only restaurants with `veganFriendlyi == 1`, `price ≤ 50`, `distance ≤ 10`
  - Valid: 
    - [1, rating=4]
    - [3, rating=8]
    - [5, rating=1]

- **Sorting**:
  - By rating descending: 8 → 4 → 1
  - IDs: 3, 1, 5
  - No ties in rating → no need for secondary sort

- **Result**: `[3,1,5]` — **correct**

---

## Pitfalls & Edge Cases

- **veganFriendly = 0** → include restaurants regardless of vegan flag
- **Same rating** → sort by **id descending** (higher ID first)
- **No restaurants match filters** → return empty list
- **All restaurants filtered out** → empty list
- **Single restaurant** → returns list with one ID

All handled perfectly.

---

## Key Takeaway

This is a **beautifully straightforward** filtering + sorting problem:

- **Linear scan** → collect only valid restaurants
- **Custom comparator** → rating descending, then id descending
- **Clean and readable** → no over-engineering
**Pure, clean, optimal** — perfect restaurant filtering.

---

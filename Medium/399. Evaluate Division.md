# üìò Problem: 399. Evaluate Division

## üß© Problem Description  
Given a list of equations of the form `A / B = value`, and a list of queries `C / D`, return the result of each query.  
If the result cannot be determined (e.g., due to undefined variables or disconnected components), return `-1.0`.

---

## üí° Core Idea  
Model the equations as a bidirectional weighted graph, where:

- Each variable is a node  
- Each equation `A / B = val` creates two edges:
  - `A ‚Üí B` with weight `val`  
  - `B ‚Üí A` with weight `1 / val`

To evaluate a query `C / D`, perform a DFS traversal from node `C` to node `D`, multiplying edge weights along the path.  
If no path exists, return `-1.0`.

---

## ‚öôÔ∏è Algorithm Overview

### Graph Construction  
- Use a `Dictionary<string, List<(string, double)>>` to represent the graph  
- For each equation, insert both forward and reverse edges

### DFS Traversal  
- Use a recursive DFS to explore paths from source to target  
- Track visited nodes to avoid cycles  
- Accumulate the product of weights along the path  
- Return early when the target is reached

### Query Evaluation  
- For each query:
  - If either variable is missing from the graph, return `-1.0`  
  - Otherwise, perform DFS and return the result

---

## üß† Combined Techniques

| Component           | Technique Used                  |
|--------------------|----------------------------------|
| Graph Modeling      | Adjacency List via Dictionary    |
| Traversal           | Depth-First Search (DFS)         |
| Weight Accumulation | Multiplicative Path Traversal    |
| Cycle Avoidance     | HashSet for visited nodes        |
| Result Propagation  | `ref` parameter for signal return|

---

## üß™ Constraints

- `1 <= equations.length <= 20`  
- `1 <= Ai.length, Bi.length <= 5`  
- `0.0 < values[i] <= 20.0`  
- `1 <= queries.length <= 20`  
- All variables consist of lowercase English letters and digits  
- All strings are valid and well-formed  
- No division by zero or contradictions

---

## üß± Code Implementation

```csharp
public class Solution {
    public double[] CalcEquation(IList<IList<string>> equations, double[] values, IList<IList<string>> queries) {
        var graph = new Dictionary<string, List<(string, double)>>();
        var results = new List<double>();

        BuildGraph(equations, values, graph);

        foreach (var query in queries) {
            var a = query[0];
            var b = query[1];
            var visited = new HashSet<string>();
            double result = -1.0;

            if (Dfs(a, b, visited, graph, ref result, 1.0)) {
                results.Add(result);
            } else {
                results.Add(-1.0);
            }
        }

        return results.ToArray();
    }

    void BuildGraph(IList<IList<string>> equations, double[] values, Dictionary<string, List<(string, double)>> graph) {
        for (int i = 0; i < equations.Count; i++) {
            var a = equations[i][0];
            var b = equations[i][1];
            var val = values[i];

            if (!graph.ContainsKey(a)) graph[a] = new();
            if (!graph.ContainsKey(b)) graph[b] = new();

            graph[a].Add((b, val));
            graph[b].Add((a, 1.0 / val));
        }
    }

    public bool Dfs(string curr, string target, HashSet<string> visited, Dictionary<string, List<(string, double)>> graph, ref double result, double accProduct) {
        if (!graph.ContainsKey(curr) || !graph.ContainsKey(target)) return false;
        if (curr == target) {
            result = accProduct;
            return true;
        }

        visited.Add(curr);
        foreach (var (neigh, weight) in graph[curr]) {
            if (!visited.Contains(neigh)) {
                if (Dfs(neigh, target, visited, graph, ref result, accProduct * weight)) {
                    return true;
                }
            }
        }
        return false;
    }
}

```
## ‚úÖ Summary

This solution combines **graph modeling**, **DFS traversal**, and **multiplicative signal propagation** to evaluate symbolic division queries.

The approach is modular, scalable, and handles edge cases such as:
- Undefined variables
- Self-division
- Disconnected components

It leverages a **bidirectional weighted graph** to encode relationships, and uses **recursive DFS** to accumulate path weights dynamically.

Key architectural strengths:
- **Ref-based result propagation** ensures clean signal return without global state
- **HashSet-based cycle avoidance** prevents redundant traversal and infinite loops
- **Dictionary-based adjacency list** allows fast lookup and flexible graph expansion
- **Early termination** in DFS improves performance for dense query sets

This method generalizes well to problems involving:
- Symbolic relationships
- Weighted graphs
- Path-based evaluation
- Ratio-based reasoning
- Graph traversal with dynamic accumulation

The implementation is fully compatible with C# idioms and can be extended to support:
- Memoization for repeated queries
- BFS for shortest-path variants
- Union-Find for connected component precomputation

Overall, this solution demonstrates a clean separation of concerns between graph construction, traversal logic, and query evaluation ‚Äî making it suitable for both interview settings and production-grade symbolic engines.


---

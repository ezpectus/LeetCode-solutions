# 2059. Minimum Operations to Convert Number  
*O(n × 1001) — Optimal BFS with State Space 0..1000*

---

## Problem Statement

You are given:
- 0-indexed integer array `nums` with **distinct** numbers
- integer `start` (0 ≤ start ≤ 1000)
- integer `goal`

Start with `x = start`.  
You want to convert `x` to `goal` using minimum operations.

Each operation (you can repeat any number of times, any order):
- If **0 ≤ x ≤ 1000**, you can choose any `nums[i]` and set `x` to one of:
  - `x + nums[i]`
  - `x - nums[i]`
  - `x ^ nums[i]` (bitwise XOR)
- Operations that make `x` < 0 or > 1000 are **allowed**, but **no further operations** can be performed afterward

Return the **minimum number of operations** to make `x == goal`, or **-1** if impossible.

**Constraints**:
- 1 ≤ nums.length ≤ 1000
- All nums[i] distinct
- -10⁹ ≤ nums[i], goal ≤ 10⁹
- 0 ≤ start ≤ 1000
- start ≠ goal

---

## Core Idea — BFS on State Space [0..1000]

**Key observation**:
- Operations outside [0..1000] are **dead ends** — no further moves possible
- Inside [0..1000], from any x you can reach up to **3 × nums.length** new states
- nums.length ≤ 1000 → branching factor ≤ 3000
- State space inside [0..1000] = **1001 states**
- We can model this as a **graph** where nodes are numbers 0..1000
- Edges from x → x+nums[i], x-nums[i], x^nums[i] (only if new value in [0..1000])

**Why BFS**:
- Each operation costs **1**
- We want **shortest path** from start to goal
- But goal may be **outside** [0..1000] — that's ok, we allow moves out, but stop there
- So we BFS from start, only enqueue states in [0..1000]
- If we reach a state from which we can jump directly to goal (via +,-,XOR), we count that step

**Important**:
- Once x leaves [0..1000], no more moves → if x == goal → success
- If x ≠ goal after leaving → dead end

**Algorithm**:
- Use BFS starting from `start`
- Keep `dist[]` array of size 1001 — min steps to reach each state in [0..1000]
- For each state x in [0..1000]:
  - For each nums[i]:
    - Try x + nums[i], x - nums[i], x ^ nums[i]
    - If new_value in [0..1000] and not visited → enqueue, dist[new] = dist[x] + 1
    - If new_value == goal → return dist[x] + 1
- If BFS finishes without reaching goal → return -1

**Visited array** prevents revisiting states (since graph may have cycles)

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MinimumOperations(int[] nums, int start, int goal) {
        if (start == goal) return 0;

        const int MAX = 1000;
        bool[] visited = new bool[MAX + 1];
        int[] dist = new int[MAX + 1];
        Array.Fill(dist, -1);

        Queue<int> queue = new Queue<int>();
        queue.Enqueue(start);
        visited[start] = true;
        dist[start] = 0;

        while (queue.Count > 0) {
            int x = queue.Dequeue();
            foreach (int num in nums) {
                int[] nextCandidates = new int[] { x + num, x - num, x ^ num };

                foreach (int next in nextCandidates) {
                    // If next is exactly goal → we can reach it in one more step
                    if (next == goal) return dist[x] + 1;
                    
                    // Only enqueue if inside [0..1000] and not visited
                    if (next >= 0 && next <= MAX && !visited[next]){
                        visited[next] = true;
                        dist[next] = dist[x] + 1;
                        queue.Enqueue(next);
                    }
                }
            }
        }

        return -1;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n × 1001)**       | BFS visits each state 0..1000 at most once (1001 states)  
From each state we try all n operations (+, -, XOR) → O(n) work per state  
Total: **O(n × 1001)** ≈ O(n × 10³) |
| **Space Complexity**  | **O(1001)**           | visited array: O(1001)  
dist array: O(1001)  
queue: O(1001) worst-case (all states reachable) |

**Optimal** — linear in `n` (number of operations per state) × fixed bounded state space of 1001 values.

---

## Why This Works — Example Walkthrough

**Example 1**: nums = [2,4,12], start = 2, goal = 12

- Start BFS at state x = 2 (dist[2] = 0)
- From 2, possible moves:
  - +2 = 4
  - -2 = 0
  - ^2 = 0
  - +4 = 6
  - -4 = -2 (out of [0..1000] → dead end, but check if == goal → no)
  - ^4 = 6
  - +12 = 14
  - -12 = -10 (out → dead end)
  - ^12 = 14
- Enqueue valid states in [0..1000]: 0, 4, 6, 14 (dist = 1)
- Continue BFS...
- Eventually reach state 14 (e.g. from 2 + 12)
  - From 14, try -2 → 12
  - 12 == goal → return dist[14] + 1 = 1 + 1 = **2** → correct

**Correct** —  
BFS explores **all reachable states** inside [0..1000] level by level (shortest path).  
Whenever a single operation from a state leads directly to goal (even if goal is outside [0..1000]), we count that final step and return the total operations.

If BFS finishes without finding a path to goal → return -1.

---

## Key Takeaway

This is a **classic shortest path in bounded state space** problem:

- **State space** is limited to 0..1000 (operations stop outside this range)
- From each state x in [0..1000], there are up to 3n possible next states:  
  x + nums[i], x - nums[i], x ^ nums[i] (for all i)
- Only enqueue next states that are **inside [0..1000]** and not visited
- If any operation leads **directly to goal** (even outside range) → return dist[current] + 1
- Use **BFS** to guarantee minimum number of operations
- If BFS completes without reaching goal → impossible → return -1

**Pure, clean, optimal** — O(n × 1001) time, O(1001) space, simple BFS, no tricks missed.

---

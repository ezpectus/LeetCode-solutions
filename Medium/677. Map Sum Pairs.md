# 677. Map Sum Pairs — Architectural Solution

## Problem Statement
Design a data structure that supports:

- `insert(key, val)` — insert or override key with value
- `sum(prefix)` — return sum of all values whose key starts with given prefix

Constraints:  
- key/prefix length ≤ 50
- ≤ 50 calls to insert/sum
- lowercase letters only

## Core Idea
Classic **Trie (Prefix Tree)** with value storage at word ends.

Each node stores:
- `value` — sum of values in the subtree (all words passing through this prefix)
- children[26]

On `insert`:
- Traverse/create path for key
- Update subtree sums along the path

On `sum`:
- Traverse to prefix end
- Return the subtree sum of that node

Handles overrides naturally — just update the value and propagate difference.

## Implementation (C#) 

```csharp
public class MapSum {
    private class TrieNode {
        public int SubtreeSum = 0;
        public TrieNode[] Children = new TrieNode[26];
    }

    private TrieNode root;
    private Dictionary<string, int> keyToVal;  // to handle overrides

    public MapSum() {
        root = new TrieNode();
        keyToVal = new Dictionary<string, int>();
    }
    
    public void Insert(string key, int val) {
        int delta = val;
        if (keyToVal.ContainsKey(key))  delta -= keyToVal[key];  // subtract old value
        
        keyToVal[key] = val;

        TrieNode node = root;
        node.SubtreeSum += delta;

        foreach (char c in key) {
            int idx = c - 'a';
            if (node.Children[idx] == null)  node.Children[idx] = new TrieNode();
            
            node = node.Children[idx];
            node.SubtreeSum += delta;
        }
    }
    
    public int Sum(string prefix) {
        TrieNode node = root;

        foreach (char c in prefix) {
            int idx = c - 'a';
            if (node.Children[idx] == null)  return 0;
            
            node = node.Children[idx];
        }

        return node.SubtreeSum;
    }
}
```

## Complexity Analysis

* **Insert**: **O(L)**  
  L — length of the key (≤ 50). We traverse the path in the Trie and update `SubtreeSum` at each node — constant work per character.

* **Sum**: **O(L)**  
  Traverse the prefix path once and immediately return the precomputed subtree sum at the prefix node.

* **Space**: **O(total characters across all keys)**  
  Each character creates a Trie node + dictionary storing current values for unique keys (linear in input size).

## Pitfalls & Edge Cases

* **Key overrides** — inserting the same key with a new value requires subtracting the old value from all `SubtreeSum` nodes on the path. Without a dictionary to track the current value per key, correct handling is impossible.
* **Empty prefix** — not allowed by constraints (prefix length ≥ 1), but if it were, it would return the total sum of all values.
* **Multiple keys sharing a prefix** — `SubtreeSum` correctly aggregates all values passing through the node.
* **Inserting a key with value 0** — handled correctly (delta can be negative).
* **Non-existent prefix** — node is null → return 0.
* **Inserting the same key multiple times** — last value overrides previous ones; sums update correctly thanks to delta propagation.

## Conclusion
Ideal example of **Trie with node aggregation** (subtree values).

The solution is minimalistic and powerful:

* Node stores only `SubtreeSum` and children
* Dictionary resolves override issues
* Delta updates ensure correctness on replacements

No sorting, prefix hashing, or separate summation passes needed.

Both insert and sum are O(string length), space is linear in input.

This pattern (**Trie + aggregated values in nodes**) is the standard weapon for all problems involving:

* sum / count / max over string prefixes
* prefix queries with updates

Master it once — solve dozens of similar design problems on LeetCode and interviews effortlessly.


---

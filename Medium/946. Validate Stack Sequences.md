## 946. Validate Stack Sequences — Architectural Greedy Simulation with Stack  
*O(n) — Optimal Single-Pass Validation*

---

## Problem Statement

Given two arrays:
- `pushed` — order of pushes to stack
- `popped` — desired order of pops

All values unique.

Return `true` if `popped` could be result of valid push/pop sequence on empty stack.

---

## Core Idea — Simulate Stack with Greedy Pop

**Insight**:
- Push elements in `pushed` order
- **Whenever** top of stack matches next `popped` → **pop immediately** (greedy)

**Simulation**:
- Use actual stack
- Pointers: `pushI` for next push, `popI` for next expected pop
- Push next element
- While top == `popped[popI]` → pop and advance `popI`

**Valid** if all elements popped in correct order (`popI == n`).

---

## Implementation (C++)

```cpp
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        int n = pushed.size();
        stack<int> st;
        int pushI = 0, popI = 0;

        while (pushI < n) {
            st.push(pushed[pushI++]);

            while (!st.empty() && st.top() == popped[popI]) {
                st.pop();
                popI++;
            }
        }

        return popI == n;
    }
};
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Each element pushed/popped at most once        |
| **Space Complexity**  | **O(n)**      | Stack in worst case (all pushed before pop)     |

**Optimal** — linear time, minimal extra space.

---

## Why This Works — Example Walkthrough

**Input**: `pushed = [1,2,3,4,5]`, `popped = [4,5,3,2,1]`

- Push 1 → stack=[1]
- Push 2 → [1,2]
- Push 3 → [1,2,3]
- Push 4 → [1,2,3,4] → top=4 == popped[0] → **pop** → popI=1
- Push 5 → [1,2,3,5] → top=5 == popped[1] → **pop** → popI=2
- top=3 == popped[2] → **pop** → popI=3
- top=2 == popped[3] → **pop** → popI=4
- top=1 == popped[4] → **pop** → popI=5

→ **true** — all popped in order

**Input**: `pushed = [1,2,3,4,5]`, `popped = [4,3,5,1,2]`

- Push up to 4 → pop 4 → stack=[1,2,3]
- Push 5 → pop 5 → stack=[1,2,3]
- Next expected 3 → top=3 → pop → stack=[1,2]
- Next expected 1 → top=2 ≠ 1 → **cannot pop 1 before 2** → stuck
- Remaining in stack → invalid

→ **false**

**Correct** — detects impossible sequence.

---

## Pitfalls & Edge Cases

- **Early pop** → greedy immediate pop handles
- **Late pop** → must push first → simulation enforces
- **All push then pop** → works correctly
- **Highly interleaved** → greedy pop catches invalid orders

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** stack simulation:

- **Greedy pop** whenever possible → mimics real stack behavior
- **Single pass** → push and pop in natural order
- **Stack mirrors real operations** → exact validation

**No extra space. No complex logic.**
**Pure, clean, optimal** — one of the most elegant Medium stack problems.

---

# 2110. Number of Smooth Descent Periods of a Stock — Architectural Linear Scan with Streak Counting  
*O(n) — Optimal One-Pass Solution*

---

## Problem Statement

Given an array `prices` where `prices[i]` is the stock price on day `i`.

A **smooth descent period** is a contiguous subarray where:
- Each day (except first) the price is **exactly 1 less** than previous
- Single days always count

Return the **total number** of such periods.

---

## Core Idea — Count Length of Consecutive Descents

**Key observation**:
- Every **single day** is always a valid period → `n` base count
- For every **streak** of length `k` where prices decrease by exactly 1 each day:
  - Number of additional periods = `1 + 2 + ... + (k-1) = k*(k-1)/2`

**Strategy**:
- Linear scan
- Track current streak length of valid descent
- When streak breaks → add `len*(len-1)/2` to answer, reset streak
- At end → add final streak

**Total** = `n` (singles) + sum of triangular numbers from streaks

---

## Implementation (C#)

```csharp
public class Solution {
    public long GetDescentPeriods(int[] prices) {
        int n = prices.Length, streak = 1;
        long answer = n; 

     for (int i = 1; i < n; i++) {
         if (prices[i] == prices[i - 1] - 1)  streak++;
         else{
                answer += (long)streak * (streak - 1) / 2;
                streak = 1; 
            }
        }
        answer += (long)streak * (streak - 1) / 2;
        return answer;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single linear pass                             |
| **Space Complexity**  | **O(1)**      | Only counters                                  |

**Optimal** — cannot be faster.

---

## Why This Works — Example Walkthrough

**Input**: `prices = [3,2,1,4]`

- Day 0: `3` → streak=1
- Day 1: `2 = 3-1` → streak=2
- Day 2: `1 = 2-1` → streak=3
- Day 3: `4 ≠ 1-1` → **break**
  - Add `3*(3-1)/2 = 3` → for subarrays `[3,2,1]`, `[3,2]`, `[2,1]`
  - Reset streak=1
- End → add `1*(1-1)/2 = 0`

Total: `4` (singles) + `3` = **7** → correct

**Input**: `[8,6,7,7]`

- `8 → 6` → descent → streak=2
- `6 → 7` → break → add `2*(2-1)/2 = 1` → only `[8,6]`
- `7 → 7` → plateau → break → add `0`
- Last single → add `0`

Wait — correction: only `[8,6]` is valid descent of length 2 → `1` extra + `4` singles = `5`? No:

Actually:
- `[8]` single
- `[8,6]` descent
- `[6]` single
- `[7]` single
- `[7]` single

Extras: only `1` from `[8,6]` → total `5`? Wait — let's run code:

- Start: streak=1 (8)
- 6 = 8-2? No — 8-6=2 ≠1 → break → add `1*(0)/2=0`
- streak=1 (6)
- 7 ≠ 6-1 → break → add `0`
- streak=1 (7)
- 7 = 7-0 → break → add `0`
- streak=1 (last 7)

Total: `4` singles + `0` extras → **4**

**Perfect** — matches example.

---

## Pitfalls & Edge Cases

- **Single element** → `1`
- **All decreasing by 1** → `n + n*(n-1)/2`
- **No descent** → just `n`
- **Plateaus** → breaks streak correctly
- **Partial descent** → only valid streaks counted

All handled.

---

## Key Takeaway

This is a **beautifully simple** counting problem:

- **Every day counts** as a period
- **Longer descents** contribute **triangular number** of sub-periods
- **One pass** with streak tracking → full answer

**No DP. No prefix sums. Pure insight.**
**One of the cleanest Medium array problems** — solved with **minimal code**.

---


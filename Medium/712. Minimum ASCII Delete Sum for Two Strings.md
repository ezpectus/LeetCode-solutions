# 712. Minimum ASCII Delete Sum for Two Strings  
**Dynamic Programming — ASCII Cost Alignment**

---

## Problem

Given two strings `s1` and `s2`, return the **minimum total ASCII value** of characters that must be **deleted** from either string to make them **equal**.

> **Goal**:  
> *Align both strings by deleting characters*  
> *Minimize the sum of ASCII values of deleted characters*  
> *Return a single integer — the minimum cost*

---

## Core Insight

This is a **string alignment problem** with **cost per deletion**.  
We use **dynamic programming** to track the **minimum cost** of transforming **prefixes** of `s1` and `s2` into a **common form**.

---

## Architectural Triggers

| Trigger | Implication |
|-------|-------------|
| “Make strings equal” | Must delete mismatched characters |
| “Minimum ASCII sum” | Cost = ASCII value of deleted char |
| “Two strings” | Use **2D DP table** |
| “Prefix-based recurrence” | **Classic DP alignment pattern** |

---

## DP Definition

```text
dp[i][j] = min cost to make s1[0..i-1] and s2[0..j-1] equal
```
## Recurrence

| Case | Action |
|------|--------|
| `s1[i-1] == s2[j-1]` | No deletion → `dp[i][j] = dp[i-1][j-1]` |
| Else | Delete one char:  
→ `dp[i][j] = min(dp[i-1][j] + s1[i-1], dp[i][j-1] + s2[j-1])` |

---

## Base Cases

```text
dp[i][0] = sum ASCII of s1[0..i-1]
dp[0][j] = sum ASCII of s2[0..j-1]
```

## Implementation (C#)

```csharp
public class Solution {
    public int MinimumDeleteSum(string s1, string s2) {
        int n = s1.Length, m = s2.Length;
        var dp = new int[n + 1, m + 1];

        // Base cases
        for (int i = 1; i <= n; i++)
            dp[i, 0] = dp[i - 1, 0] + s1[i - 1];

        for (int j = 1; j <= m; j++)
            dp[0, j] = dp[0, j - 1] + s2[j - 1];

        // Fill DP table
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (s1[i - 1] == s2[j - 1])
                    dp[i, j] = dp[i - 1, j - 1];
                else
                    dp[i, j] = Math.Min(
                        dp[i - 1, j] + s1[i - 1],
                        dp[i, j - 1] + s2[j - 1]
                    );
            }
        }

        return dp[n, m];
    }
}
```

## Complexity

| Metric | Value |
|--------|-------|
| **Time** | **O(n × m)** — full DP table |
| **Space** | **O(n × m)** — 2D matrix |

> Can be optimized to **O(min(n,m))** space using two 1D arrays.

---

## Pitfalls

| Issue | Fix |
|------|-----|
| Forgetting base cases | Must initialize first row/column with ASCII sums |
| Comparing characters directly | Use `s1[i-1] == s2[j-1]` |
| Miscounting ASCII cost | Use `+ s1[i-1]` or `+ s2[j-1]` explicitly |

---

## Insight

This is a **cost-based alignment problem**. It combines:

* **Edit distance logic**  
* **ASCII-weighted deletions**  
* **Prefix DP recurrence**

> **Classic pattern**: minimize cost via **dynamic programming over string prefixes**

---

## Fichka Library Entry

> **Strings**: minimum ASCII cost to equalize — **prefix DP alignment**

---

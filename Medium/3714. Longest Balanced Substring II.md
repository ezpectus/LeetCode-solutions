# 3714. Longest Balanced Substring II  
*O(n) — Elegant Multi-Approach Prefix + HashMap Balancing*

---

## Problem Statement

You are given a string `s` consisting only of characters `'a'`, `'b'`, and `'c'` (1 ≤ length ≤ 10⁵).

A substring is **balanced** if **all distinct characters** that appear in it have **exactly the same frequency**.

Return the **length** of the **longest balanced substring** (return 0 if none exists).

---

## Core Idea — Three Separate Solvers + Prefix HashMap

The code uses **three complementary approaches** to cover all possible balanced cases efficiently:

1. **Solve1**: Longest substring with **only one character** (all same character)  
   → simple consecutive count of a single character

2. **Solve2**: Longest balanced substring using **exactly two characters**  
   → classic prefix difference + hashmap to find longest subarray where count1 == count2

3. **Solve3**: Longest balanced substring using **all three characters**  
   → prefix difference encoded into a single key (using large multiplier to avoid collisions) + hashmap

Finally take the **maximum** among all three solvers.

This covers:
- 1 distinct character (all same)
- 2 distinct characters (equal count of two)
- 3 distinct characters (equal count of all three)

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int LongestBalanced(string s) {
        var results = new int[] {
            Solve1(s, 'a'),
            Solve1(s, 'b'),
            Solve1(s, 'c'),
            Solve2(s, 'a', 'b'),
            Solve2(s, 'a', 'c'),
            Solve2(s, 'b', 'c'),
            Solve3(s)
        };
        return results.Max();
    }

    static int Solve1(string s, char t) {
        int result = 0;
        int count = 0;
        foreach(var c in s) {
            if (c == t) {
                count++;
                result = Math.Max(result, count);
            } else count = 0;
            
        }
        return result;
    }

    static int Solve2(string s, char t1, char t2) {
        int result = 0;
        int[] counts = new int[2];
        var previousPositions = new Dictionary<int, int>();

        for (int i = 0; i < s.Length; i++) {
            var c = s[i];
            if (c != t1 && c != t2) {
                previousPositions.Clear();
                counts[0] = 0;
                counts[1] = 0;
            } else {
                if (c == t1) counts[0]++;
                else counts[1]++;
                
                if (counts[0] == counts[1]) {
                    result = Math.Max(result, counts[0] * 2);
                } else {
                    var diff = counts[0] - counts[1];
                    if (previousPositions.TryGetValue(diff, out var previous)) {
                        result = Math.Max(result, i - previous);
                    } else  previousPositions[diff] = i;
                    
                }
            }
        }
        return result;
    }

    static int Solve3(string s) {
        int result = 0;
        int[] counts = new int[3];
        var previousPositions = new Dictionary<long, int>();
        for (int i = 0; i < s.Length; i++) {
            var c = s[i];
            counts[c - 'a']++;
            if (counts[0] == counts[1] && counts[1] == counts[2]) {
                result = i + 1;
            } else {
                var diff = (counts[0] - counts[1]) * 100001 + counts[1] - counts[2];
                if (previousPositions.TryGetValue(diff, out var previous)) {
                    result = Math.Max(result, i - previous);
                } else previousPositions[diff] = i;
                
            }
        }
        return result;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**              | • Solve1 called 3 times (for 'a','b','c'): O(n) each → O(n) total  
• Solve2 called 3 times (pairs 'a-b','a-c','b-c'): O(n) each → O(n) total  
• Solve3 (all three characters): O(n)  
→ Overall **O(n)** — single pass per solver, no overlapping work |
| **Space Complexity**  | **O(n)** worst-case   | • HashMap in Solve2 and Solve3: O(n) keys in worst case (many distinct prefixes/differences)  
• In practice much smaller (limited by string patterns)  
• All other structures: O(1) |

**Optimal** — linear time, very fast in practice for n ≤ 10⁵, excellent constant factors.

---

## Why This Works — Example Walkthrough

**Example 1**: `s = "abbac"`

- Solve1('a') → longest run of 'a' = 2 ("aa" at end)
- Solve1('b') → longest run of 'b' = 2 ("bb")
- Solve1('c') → longest run of 'c' = 1 ("c")
- Solve2('a','b') → finds "abba" → counts a=2, b=2 → length 4
- Solve2('a','c') → "ac" → a=1,c=1 → length 2
- Solve2('b','c') → "bc" → b=1,c=1 → length 2
- Solve3 → "abbac" has a=2,b=2,c=1 → not balanced (no substring with a=b=c equal)
- Maximum among all = **4** → correct

**Example 2**: `s = "aabcc"`

- Solve1 → max single char run = 2 ("aa" or "cc")
- Solve2('a','b') → "aab" → a=2,b=1 → not balanced
- Solve2('a','c') → "abc" → a=1,b=1,c=1 → length 3
- Solve2('b','c') → "bcc" → b=1,c=2 → not balanced
- Solve3 → "aabcc" → a=2,b=1,c=2 → not balanced, but substring "abc" found in Solve2
- Maximum = **3** → correct

**Correct** — the three solvers together cover **all possible cases**:
- 1-character balanced (all same char)
- 2-character balanced (equal count of exactly two chars)
- 3-character balanced (equal count of all three chars)

By taking the maximum over all solvers, we get the global longest balanced substring.

---

## Key Takeaway

This is a **beautiful multi-solver** approach tailored for small fixed alphabet (only 'a','b','c'):

- **Solve1** — finds longest run of a single character (trivial consecutive count)
- **Solve2** — finds longest balanced substring using **exactly two** characters  
  → classic prefix difference (count1 - count2) + hashmap to find subarrays where difference returns to 0
- **Solve3** — finds longest balanced substring using **all three** characters  
  → encodes two differences into single key: `(count_a - count_b) * LARGE + (count_b - count_c)`  
  → uses hashmap to find when the triple (ca, cb, cc) repeats
- Final answer = **maximum** among all seven solvers (3×1-char + 3×2-char + 1×3-char)

**Pure, clean, optimal** — O(n) time, O(n) space worst-case, very practical, correct, and elegant.

---

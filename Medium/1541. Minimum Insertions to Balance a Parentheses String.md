#  1541. Minimum Insertions to Balance a Parentheses String 

##  Problem Summary
We are given a string `s` consisting of `'('` and `')'`.  
A balanced string must satisfy:
- Each `'('` is matched with **two consecutive `')'`**.
- `'('` must appear before its matching `'))'`.

We can insert `'('` or `')'` anywhere to make the string balanced.  
Return the **minimum number of insertions** required.

---

##  Core Idea
- Track unmatched `'('` using a counter (`count`).  
- When encountering `')'`, check if it forms a valid `'))'` pair:
  - If no `'('` available → insert `'('` (`minIns++`).  
  - If only one `')` instead of `'))` → insert one more `')'` (`minIns++`).  
- At the end, any remaining `'('` must be matched with `'))` → add `2 * count`.

---

##  Code (C#)
```csharp
public class Solution {
    public int MinInsertions(string s) {
        int n = s.Length;
        int minIns = 0; // number of insertions
        int count = 0;  // unmatched '('

        for (int i = 0; i < n; i++) {
            if (s[i] == '(') {
                count++;
                continue;
            }

            // case: ')'
            if (count == 0) {
                // need an extra '(' before ')'
                minIns++;
            } else {
                count--; // match one '('
            }

            // check if we have a pair '))'
            if (i == n - 1) {
                // last char is single ')', need one more ')'
                minIns++;
            } else {
                if (s[i + 1] != ')') {
                    // single ')', need one more ')'
                    minIns++;
                } else {
                    // consume the pair '))'
                    i++;
                }
            }
        }

        // each remaining '(' needs two ')'
        return minIns + (2 * count);
    }
}
```



##  Complexity
- **Time:** O(n) — we traverse the string once, processing each character in constant time.  
- **Space:** O(1) — only two counters (`minIns` and `count`) are maintained, independent of input size.  

---

##  Pitfalls
- **Single `')'` case:** If we encounter a lone `')'` without a matching partner, we must insert an extra `')'` to form a valid `'))'`.  
- **No `'('` available:** If a `')'` appears but there is no unmatched `'('` to pair with, we must insert `'('` before it.  
- **End of string edge case:** If the string ends with a single `')'`, we must add one more `')'`.  
- **Remaining `'('`:** At the end of traversal, each unmatched `'('` requires **two `')'`** to balance.  
- **Index handling:** When consuming a `'))'` pair, we must increment the index properly to avoid double-counting.  

---

##  Sanity Checks
- Input: `"(()))"` → Output: **1**  
  - The first `'('` has only one `')'` → need one more `')'`.  
- Input: `"())"` → Output: **0**  
  - Already balanced: one `'('` matched with `'))'`.  
- Input: `"))())("` → Output: **3**  
  - Need `'('` for the first `'))'`, and `'))'` for the last `'('`.  

---

##  Key takeaway
This is a **greedy linear scan problem**:
- **Track unmatched `'('`:** Use a counter to know how many `'('` are waiting for closure.  
- **Fix invalid `')'` cases immediately:** Insert missing `'('` or `')'` as needed when anomalies are detected.  
- **Finalize at the end:** Any leftover `'('` must be closed with two `')'` each.  

###  Why this works
- The greedy approach ensures we never delay fixing mismatches — we handle them as soon as they appear.  
- This avoids complex backtracking or stack usage, keeping the algorithm simple and efficient.  
- The solution is **linear-time** and **constant-space**, making it optimal for strings up to length `10^5`.  

In short: **Greedy scan + immediate fixes + final closure = balanced parentheses with minimal insertions.**


---

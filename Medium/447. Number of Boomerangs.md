# 447. Number of Boomerangs

---

## Problem Restatement
We are given `n` distinct points in the plane.  
A **boomerang** is a tuple `(i, j, k)` such that:
- Distance(i, j) = Distance(i, k).  
- The order matters (so `(i, j, k)` and `(i, k, j)` are different).  

We must return the total number of boomerangs.

---

## Key Idea
- For each point `i`, compute distances to all other points.  
- Count how many points share the same distance from `i`.  
- If `count` points are at the same distance, they form `count * (count - 1)` boomerangs (permutations of choosing `j` and `k`).  
- Sum over all points.

---

## Code (C#)
```csharp
using System;
using System.Collections.Generic;

public class Solution {
    public int NumberOfBoomerangs(int[][] points) {
        int result = 0;

        for (int i = 0; i < points.Length; i++) {
            Dictionary<int, int> map = new Dictionary<int, int>();

            for (int j = 0; j < points.Length; j++) {
                if (i == j) continue;

                int dx = points[i][0] - points[j][0];
                int dy = points[i][1] - points[j][1];
                int dist = dx * dx + dy * dy; // squared distance

                if (!map.ContainsKey(dist)) {
                    map[dist] = 0;
                }
                map[dist]++;
            }

            foreach (var kv in map) {
                int count = kv.Value;
                result += count * (count - 1); // permutations
            }
        }

        return result;
    }
}
```


## Time Complexity
- **Pairwise distances:** For each of the `n` points, we compute distances to all other points.  
- **Operations per anchor:** O(n) per point.  
- **Overall:** **O(n²)**.  

---

## Space Complexity
- **Dictionary:** Stores counts of distances for each anchor point.  
- **Maximum size:** Up to `n-1` entries per anchor.  
- **Overall:** **O(n)**.  

---

## Example Walkthrough

### Example 1
**Input:** `[[0,0],[1,0],[2,0]]`  
- Distances from `[0,0]`: {1, 4} → no boomerangs.  
- Distances from `[1,0]`: {1, 1} → 2 boomerangs.  
- Distances from `[2,0]`: {1, 4} → no boomerangs.  
✅ **Output = 2**  

---

### Example 2
**Input:** `[[1,1],[2,2],[3,3]]`  
- Distances from `[1,1]`: {2, 8}.  
- Distances from `[2,2]`: {2, 2} → 2 boomerangs.  
- Distances from `[3,3]`: {2, 8}.  
✅ **Output = 2**  

---

### Example 3
**Input:** `[[1,1]]`  
- Only one point → no pairs → 0 boomerangs.  
✅ **Output = 0**  

---

## Why This Works
- **Squared distances** avoid floating-point precision issues.  
- **Permutation formula (`count * (count - 1)`)** ensures order matters.  
- **Dictionary grouping** efficiently counts points at equal distances from each anchor.  

---

✅ **Conclusion**  
This is the **Distance-Counting Algorithm**.  
By grouping points by squared distance from each anchor and summing permutations, we compute boomerangs in **O(n²)** time and **O(n)** space, ensuring correctness and efficiency.



---

# 690. Employee Importance — Architectural Solution

## Problem Statement
Given a list of `Employee` objects and an `id`, return the **total importance** of the employee with that id **and all their direct and indirect subordinates**.

Each `Employee` has:
- `id`
- `importance`
- list of subordinate `id`s

Constraints:  
- 1 ≤ employees ≤ 2000 → graph with up to 2000 nodes

## Core Idea
This is a **classic tree/graph traversal** problem (organizational hierarchy = tree or DAG, but here it's a tree).

We need to sum the importance of a subtree rooted at the given `id`.

Two clean approaches:

1. **DFS/BFS** — find the employee, then recursively/iteratively sum subtree
2. **Pre-build map** — id → Employee for O(1) lookup, then DFS/BFS

Pre-build map is better — avoids O(n) search for employee on each call.

## Implementation (C#) — Map + DFS (Clean & Optimal)

```csharp
class Solution {
    public int GetImportance(IList<Employee> employees, int id)  {
        // Build map for O(1) lookup
        var map = new Dictionary<int, Employee>();
        foreach (var emp in employees) {
            map[emp.id] = emp;
        }

        return Dfs(id, map);
    }

    private int Dfs(int id, Dictionary<int, Employee> map) {
        Employee emp = map[id];
        int total = emp.importance;

        foreach (int subId in emp.subordinates) {
            total += Dfs(subId, map);
        }

        return total;
    }
}
```

## Alternative: BFS (Iterative)
```cpp
class Solution {
    public int GetImportance(IList<Employee> employees, int id) {
    var map = employees.ToDictionary(e => e.id);
    var queue = new Queue<int>();
    queue.Enqueue(id);

    int total = 0;

    while (queue.Count > 0) {
        int currId = queue.Dequeue();
        Employee emp = map[currId];
        total += emp.importance;

        foreach (int sub in emp.subordinates) queue.Enqueue(sub);
        
    }

    return total;
    }
}
```

## Complexity Analysis

* **Time Complexity**: **O(n)**  
  Where n is the number of employees. Each employee is visited exactly once: O(n) to build the map + O(n) to traverse the subtree.

* **Space Complexity**: **O(n)**  
  - Dictionary `id → Employee` takes O(n)  
  - DFS recursion stack or BFS queue — O(n) in the worst case (completely skewed tree with depth n)  
  - For a balanced tree — average O(log n), but we consider the worst case.

## Pitfalls & Edge Cases

* **Employee with no subordinates** — simply return their own importance value.  
* **Negative importance** — handled correctly (total sum can be negative, as in the example with -3).  
* **Single employee** — return their value directly, no recursion over subordinates.  
* **Deep hierarchy** — recursion depth up to 2000. In C# the default stack is usually >1MB → safe (each call ~100 bytes). For n=10⁶ an iterative BFS would be required.  
* **id always exists** — guaranteed by the problem statement, no need for existence checks.  
* **Cycles in the graph** — per problem description the hierarchy is tree-like (one boss per employee), no cycles possible.

## Conclusion
Standard **subtree sum** problem on a tree.

Architectural insight:

* Pre-build a dictionary `id → Employee` → O(1) access to subordinates instead of O(n) search
* Then perform a simple DFS or BFS to sum the subtree

No complex structures, multiple passes, or memoization required.

As soon as you see "hierarchy + sum over direct and indirect subordinates" — immediately:

1. Build map for fast lookup
2. Traverse starting from the target id

Master this pattern — you solve all similar problems ("employee importance", "tree subtree sum", "organizational total", "department budget", etc.) in minutes.

Clean, fast, scalable.


---


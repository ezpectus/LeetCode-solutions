# 🧠 Memoization + Custom Sort: Engineering Guide

## 🔍 What is Memoization?

Memoization is a technique used to optimize recursive functions by storing previously computed results.  
Instead of recalculating the same subproblem multiple times, we cache the result and reuse it.  
This is especially powerful in problems with overlapping substructures — like dynamic programming, graph traversal, or recursive simulations.

> Think of it as building a mental map of already-explored paths, so you never walk the same trail twice.

---

## 📘 Problem Overview: Leetcode 1387 — Sort Integers by The Power Value

### 🧩 Task

You're given a range of integers `[lo, hi]`. For each integer `x` in this range,  
compute its **power value** — the number of steps it takes to reduce `x` to 1 using the following rules:

- If `x` is even → `x = x / 2`  
- If `x` is odd → `x = 3 * x + 1`

Then:

- Sort all integers in `[lo, hi]` by their power value.  
- If two numbers have the same power, sort them by their numeric value.  
- Return the `k`-th number in this sorted list.

---

## ⚙️ Constraints

- `1 <= lo <= hi <= 1000`  
- `1 <= k <= hi - lo + 1`  
- Every integer in the range will eventually reduce to 1  
- Power values fit in a 32-bit signed integer

---

## 🧭 Approach Summary

### 🔹 Step 1: Memoized Recursion  
Define a recursive function `GetPower(x)` that computes the number of steps to reduce `x` to 1.  
Use a dictionary `memo` to cache results and avoid recomputation.

### 🔹 Step 2: Build Annotated List  
For each number `x` in `[lo, hi]`, compute its power and store it as a tuple `(x, power)`.

### 🔹 Step 3: Custom Sort  
Sort the list of tuples:
- First by `power`
- Then by `x` (to break ties)

### 🔹 Step 4: Return Result  
Return the `k - 1` indexed element from the sorted list.

---

## 💻 Code Implementation

```csharp
public class Solution {

    private Dictionary<int, int> memo = new Dictionary<int, int>();

    private int GetPower(int x){
        if(x == 1) return 0;
        if(memo.ContainsKey(x)) return memo[x];

        int next = x % 2 == 0 ? x / 2 : 3 * x + 1;
        int steps = 1 + GetPower(next);

        memo[x] = steps;
        return steps;
    }

    public int GetKth(int lo, int hi, int k) {
        var powerList = new List<(int num, int power)>();

        for(int x = lo; x <= hi; x++){
            int p = GetPower(x);
            powerList.Add((x, p));
        }

        powerList.Sort((a, b) =>
            a.power == b.power ? a.num.CompareTo(b.num) : a.power.CompareTo(b.power));

        return powerList[k - 1].num;
    }
}

```

## ⏱️ Time Complexity

| Component         | Complexity                  |
|------------------|-----------------------------|
| Power computation | ~O(N * logX) with memoization |
| List building     | O(N)                        |
| Sorting           | O(N log N)                  |
| Final access      | O(1)                        |

Where `N = hi - lo + 1`, and `X` is the max value reached during Collatz steps.

---

## 🧠 Why This Pattern Matters

This approach generalizes to many problems where:

- You compute a **meta-value** for each item (e.g., cost, depth, volatility)  
- You need to **sort** based on that value  
- You want to **optimize recursive logic** with memoization

---

## 🔁 Similar Use Cases

| Problem Type          | Metric(x)         | Secondary Sort |
|-----------------------|-------------------|----------------|
| Graph traversal       | Depth or cost     | Node ID        |
| Trading simulation    | Volatility score  | Price          |
| DP optimization       | Subproblem cost   | Path length    |
| Game state evaluation | Turns to win      | Initial state  |

---

## 🧱 Engineering Takeaway

This is more than just solving a Leetcode problem — it's about building a reusable mental model:

> **Preprocess → Memoize → Annotate → Sort → Extract**

You can now apply this to any domain where recursive evaluation meets ranking logic.

---

# 842. Split Array into Fibonacci Sequence — Architectural Backtracking with Strict Validation  
*O(2^n) worst, heavily pruned — Optimal DFS Search*

---

## Problem Statement

Given string `num` of digits (length ≤ 200).

Split into **Fibonacci-like** sequence of **≥3** integers:
- Each number **fits 32-bit int** (`< 2³¹`)
- **No leading zeros** (except `"0"`)
- `f[i] + f[i+1] == f[i+2]`

Return **any** valid list, or `[]` if impossible.

---

## Core Idea — Backtracking with First Two Choices + Deterministic Rest

**Brute force** all splits → exponential.

**Smart approach**:
- **Try all possible** first two numbers (length 1–10)
- **Determine** all subsequent numbers via sum
- **Validate** each determined number:
  - Matches prefix
  - No leading zero
  - ≤ `int.MaxValue`

**Backtrack** only on first two → rest deterministic → fast pruning.

---

##  Implementation (C#)

```csharp
public class Solution {
    public IList<int> SplitIntoFibonacci(string num) {
        int n = num.Length;
        var result = new List<int>();

        // Try first number length 1 to min(10, n-2)
        for (int len1 = 1; len1 <= Math.Min(10, n - 2); len1++) {
            // Leading zero only allowed for "0"
            if (num[0] == '0' && len1 > 1) break;

            long a = long.Parse(num.Substring(0, len1));
            if (a > int.MaxValue) continue;

            // Try second number
            for (int len2 = 1; len2 <= Math.Min(10, n - len1 - 1); len2++) {
                if (num[len1] == '0' && len2 > 1) break;

                long b = long.Parse(num.Substring(len1, len2));
                if (b > int.MaxValue) continue;

                result.Clear();
                result.Add((int)a);
                result.Add((int)b);

                if (Backtrack(num, len1 + len2, a, b, result))  return result;
                
            }
        }

        return new List<int>();
    }

private bool Backtrack(string num, int start, long prev1, long prev2, List<int> result) {
        if (start == num.Length)   return result.Count >= 3;
        

        long sum = prev1 + prev2;
        if (sum > int.MaxValue) return false;

        string sumStr = sum.ToString();
        int len = sumStr.Length;

        if (start + len > num.Length) return false;
        if (sumStr[0] == '0' && len > 1) return false; // no leading zero

        if (num.Substring(start, len) == sumStr) {
            result.Add((int)sum);
            if (Backtrack(num, start + len, prev2, sum, result))  return true;
            result.RemoveAt(result.Count - 1);
        }

        return false;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(2ⁿ)** worst case  | But **heavily pruned** → very fast in practice |
| **Space Complexity**  | **O(n)**              | Recursion stack + result list                  |

**Optimal** — given small constraints (n ≤ 200) and strong pruning, runs instantly.

---

## Why This Works — Detailed Walkthrough

**Input**: `"121474836462147483647"`

The algorithm works as follows:

- **First number**: try lengths 1 to 10
  - Choose `"1"` → `a = 1`
- **Second number**: try lengths 1 to 10 starting after first
  - Choose `"2147483646"` → `b = 2147483646`
- **Next number**: compute `sum = a + b = 2147483647`
  - Convert sum to string → `"2147483647"` (10 digits)
  - Check if it **exactly matches** the next prefix of the string → yes
  - Add `2147483647` to result
- **Remaining string**: empty → done
- Result size = 3 → **valid**

→ Returns `[1, 2147483646, 2147483647]`

**Why 10 digits max**:
- `int.MaxValue = 2147483647` → exactly 10 digits
- We allow up to 10-digit numbers → covers all possible valid integers
- Use `long` for parsing and addition → safely detect overflow

**Leading zero pruning**:
- If a number starts with `'0'` and has length >1 → invalid (e.g., `"01"`, `"00"`)
- We **break** the loop early when this happens → skip invalid branches

**Overflow protection**:
- `long sum = prev1 + prev2`
- If `sum > int.MaxValue` → immediately return false

---

## Pitfalls & Edge Cases Handled

- **10-digit numbers** → fully supported (critical fix)
- **Leading zeros** → correctly skipped via early `break`
- **Overflow** → `long` + explicit check prevents invalid additions
- **Short string** → loop bounds prevent out-of-range access
- **No valid split** → exhausts all possibilities → returns `[]`
- **Multiple possible splits** → returns **first found** (problem allows any)

All handled robustly.

---

## Key Takeaway

This is a **classic backtracking with aggressive pruning**:

- **Brute-force only first two numbers** → small search space
- **Determine all subsequent** numbers via `f[i] = f[i-2] + f[i-1]`
- **Strict validation** at each step → fast failure
- **Return first valid** sequence found
**Clean, robust, optimal** — perfect pattern for constrained string partitioning problems.

---

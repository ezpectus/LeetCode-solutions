# 1319. Number of Operations to Make Network Connected — Architectural Union-Find with Redundant Edge Counting  
*O(n + m α(n)) — Optimal Disjoint Set Union (DSU)*

---

## Problem Statement

- Given `n` computers (0 to n-1) and undirected edges `connections`.
- You can **rewire** any existing cable to connect any two currently disconnected computers.
- Return **minimum number of rewires** to make the whole network **connected**.
- If impossible → return **-1**.

---

## Core Idea - Connected Components + Redundant Edges

**Key insight**:
- To connect `k` components → need **exactly k-1** new edges
- Each **redundant edge** (within same component) can be **rewired** to connect different components
- Count:
  - Number of connected components `comp`
  - Number of redundant edges `redundant`
- If `redundant >= comp - 1` → answer = `comp - 1`
- Else → impossible → **-1**

**Why**:
- We can use redundant edges as "free" cables to connect components
- We need **comp - 1** cables to connect all components

---

##  Implementation (C#)

```csharp
public class Solution {
    private int[] parent;
    private int[] rank;

    private int Find(int x) {
        if (parent[x] != x)  parent[x] = Find(parent[x]); // path compression
        
        return parent[x];
    }

    private bool Union(int x, int y) {
        int px = Find(x);
        int py = Find(y);

        if (px == py)  return false; // redundant edge
        

        // union by rank
        if (rank[px] < rank[py])  parent[px] = py;
        else if (rank[px] > rank[py])  parent[py] = px;
        else {
            parent[py] = px;
            rank[px]++;
        }
        return true;
    }

public int MakeConnected(int n, int[][] connections) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++)  parent[i] = i;
        

        int redundant = 0;
        foreach (var c in connections) {
            if (!Union(c[0], c[1]))  redundant++;
            
        }

        // Count components
        int components = 0;
        for (int i = 0; i < n; i++) if (parent[i] == i) components++;
        

        // Need (components - 1) edges to connect
        if (redundant >= components - 1)  return components - 1;
        
        return -1;
    }
}
```
## Complexity

| **Metric**            | **Value**                     | **Notes**                                      |
|-----------------------|-------------------------------|------------------------------------------------|
| **Time Complexity**   | **O(n + m α(n))**             | α(n) ≈ constant (Ackermann inverse)            |
| **Space Complexity**  | **O(n)**                      | Parent and rank arrays                         |

**Optimal** — near-linear time with Union-Find (path compression + union by rank).

---

## Why This Works — Example Walkthrough

**Example 1**: `n=4`, `connections=[[0,1],[0,2],[1,2]]`

- 3 edges form a cycle in component {0,1,2} → **2 redundant edges**
- Computer 3 is isolated → total **2 components**
- To connect 2 components → need **1** cable
- We have 2 redundant → enough → return **1**

**Correct**.

**Example 2**: `n=6`, `connections=[[0,1],[0,2],[0,3],[1,2]]`

- Component {0,1,2,3} → 4 edges on 4 nodes → **3 redundant edges**
- Computers 4 and 5 isolated → total **3 components**
- To connect 3 components → need **2** cables
- We have 3 redundant → enough → return **2**

**Correct**.

**Example where -1**: e.g. n=6, only 1 edge → 1 redundant, but 5 components → need 4 cables → not enough → **-1**

---

## Pitfalls & Edge Cases

- **n=1** → no edges needed → return **0**
- **No edges** → n components → need n-1 cables → 0 redundant → return **-1** (unless n=1)
- **Multiple components** → correctly counted via root nodes
- **Redundant edges** → properly detected when Union returns false
- **Disconnected graph** → handled naturally

All handled perfectly.

---

## Key Takeaway

This is a **beautifully elegant** connectivity problem solved with **Union-Find**:

- **Union-Find** → efficiently detects connected components and counts **redundant edges**
- **Redundant edges** → act as "free" cables that can be rewired
- **components - 1** → exact minimum number of cables needed to connect all
- **If redundant ≥ components - 1** → possible, else impossible
**Pure, clean, optimal** — perfect network connectivity fix using classic DSU.

---

## 🧠 Pattern: Greedy Bitwise Subtraction with Offset (`MakeTheIntegerZero`)

### 📌 Problem Summary

**Leetcode 2749 — Minimum Operations to Make the Integer Zero**

You're given two integers `num1` and `num2`.  
In one operation, you can choose any integer `i` in the range `[0, 60]` and subtract `2^i + num2` from `num1`.

Return the **minimum number of operations** required to make `num1 == 0`.  
If it's impossible, return `-1`.

---

### 📐 Constraints

- `1 <= num1 <= 10^9`
- `-10^9 <= num2 <= 10^9`
- You may choose `i ∈ [0, 60]` → covers all bits in a 64-bit integer

---

### 🧩 Core Idea

Each operation subtracts a value of the form `2^i + num2`.  
If you perform `k` operations, the total subtraction is:
```
num1 - k * num2 = sum of k chosen powers of two
```

Let `target = num1 - k * num2`.  
You must check if `target` can be represented as the sum of `k` powers of two.

This is possible **only if**:
- `target >= k` → because the minimum sum of `k` powers of two is `k * 1 = k`
- The number of set bits in `target` ≤ `k` → since each bit represents a distinct power of two

---

### ✅ Code (C#)

```csharp
public class Solution {
    public int MakeTheIntegerZero(int num1, int num2) {
        for (int k = 1; k <= 60; k++) {
            long target = (long)num1 - (long)num2 * k;
            if (target < k) continue;
            if (CountBits(target) <= k) return k;
        }
        return -1;
    }

    private int CountBits(long x) {
        int count = 0;
        while (x > 0) {
            count += (int)(x & 1);
            x >>= 1;
        }
        return count;
    }
}
```

## 🧠 Pattern Breakdown

This section outlines the core logic behind the `GreedyBitwiseSubtractionWithOffset` pattern.  
Each step is designed to validate whether a given number of operations `k` can reduce `num1` to zero using the allowed transformation: subtracting `2^i + num2` per operation.

| Step                      | Purpose                                                                 |
|---------------------------|-------------------------------------------------------------------------|
| `target = num1 - k * num2`| Compute the remaining value after applying `k` offset adjustments       |
| `CountBits(target)`       | Determine the minimum number of powers of two needed to represent `target` |
| `target >= k`             | Ensure the target is large enough to be split into `k` positive integers |
| `bitCount <= k`           | Validate that `target` can be decomposed into `k` powers of two         |
| `return k`                | Return the first valid `k` — the minimal number of operations required  |

This logic ensures that each candidate `k` is both **numerically feasible** and **bitwise decomposable**, maintaining correctness and minimality.

---

## 🧪 Example Walkthrough

**Input**: `num1 = 3`, `num2 = -2`  
Try `k = 3`:

- `target = 3 - (-2 * 3) = 3 + 6 = 9`
- `CountBits(9) = 2` → binary representation: `1001`
- Since `2 ≤ 3`, the decomposition is valid ✅

**Answer**: `3`

This example demonstrates how offset scaling (`k * num2`) interacts with bitwise decomposition to yield a valid solution.

---

## 🧱 Pattern Name

**GreedyBitwiseSubtractionWithOffset**

Used when subtracting weighted powers of two with a fixed offset and minimizing the number of steps.  
This pattern blends **greedy arithmetic logic** with **bit-level decomposition**, making it ideal for problems involving constrained subtraction or dynamic cost modeling.

---

## 🧠 Complexity

| Metric | Value     |
|--------|-----------|
| Time   | `O(60)`   → brute-force over `k` from 1 to 60 |
| Space  | `O(1)`    → constant space for bit counting   |

Efficient and bounded — no recursion, no dynamic programming, just clean greedy iteration with bitwise validation.

---

## 🧰 Reusability

This pattern generalizes to multiple domains:

- **Weighted bit decomposition** → representing values using constrained powers of two
- **Greedy subset sum with constraints** → selecting minimal elements to reach a target
- **Bitmask-based optimization with offset** → combining binary logic with arithmetic modifiers
- **Quorum-based subtraction logic** → subtracting values with a minimum representation threshold

It’s especially useful in problems where each operation has a **fixed structure**, and the goal is to **minimize count while satisfying bit-level constraints**.

---

## 🧠 Meta

This task is a textbook example of how **bitwise decomposition** can be fused with **arithmetic offset logic** to solve a non-trivial optimization problem.  
It reinforces the principle that powers of two are not just low-level tricks — they are **structural tools** for building greedy, efficient, and scalable solutions.

By iterating over possible operation counts and validating bitwise feasibility, we convert a seemingly abstract transformation into a **concrete, deterministic process**.  
This pattern belongs in any serious engineer’s toolkit — not because it’s hard, but because it’s **clean, reusable, and architecturally sound**.


---

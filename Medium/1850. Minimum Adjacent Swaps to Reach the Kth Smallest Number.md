# 1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number  
*O(n² + n log n) — Optimal Next Permutation Simulation + Greedy Swap Counting*

---

## Problem Statement

- You are given a string `num` representing a large integer (length 2 ≤ n ≤ 1000) consisting only of digits, and an integer `k` (1 ≤ k ≤ 1000).
- A **wonderful** integer is a permutation of the digits in `num` that is **strictly greater** than `num`.
- Among all wonderful integers, consider them sorted in increasing order. The **k-th smallest** wonderful integer exists (guaranteed by problem).
- Return the **minimum number of adjacent digit swaps** needed to transform `num` into that k-th smallest wonderful number.

---

## Core Idea — Simulate k Next Permutations + Count Adjacent Swaps

**Key insight**:
- The k-th smallest wonderful number is exactly the result of applying **next_permutation** k times to `num` (in lexicographical order)
- Since n ≤ 1000 and k ≤ 1000 → we can afford to run next_permutation k times → O(n × k) = 10⁶ operations
- After getting the target string (k-th next permutation), compute the **minimum adjacent swaps** needed to turn original `num` into this target
- Min adjacent swaps between two permutations of the same multiset = **number of bubble sort swaps** = **sum of distances each digit needs to move** (greedy matching)

**Steps**:
1. Make a copy of `num` as char[] → `target`
2. Apply **next_permutation** exactly **k times** to `target`
3. Now compute min adjacent swaps to turn original `num` into `target`:
   - Iterate through positions in target
   - For each position i, find the leftmost position j ≥ i in current array where digit == target[i]
   - Add (j - i) to swaps (that's how many adjacent swaps needed to move it to i)
   - Then shift the element from j to i (simulate bubble sort step)

This greedy left-to-right matching gives the correct minimum adjacent swaps.

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int GetMinSwaps(string num, int k) {
        char[] arr = num.ToCharArray();
        int n = arr.Length;

        // Step 1: Make target = num, apply next_permutation k times
        char[] target = (char[])arr.Clone();
        for (int i = 0; i < k; i++) {
            NextPermutation(target);
        }

        // Step 2: Count min adjacent swaps to turn arr into target
        int swaps = 0;

        for (int i = 0; i < n; i++) {
            if (arr[i] == target[i]) continue;

            // Find the leftmost j >= i where arr[j] == target[i]
            int j = i;
            while (arr[j] != target[i]) j++;

            // Cost: move arr[j] to position i → j - i adjacent swaps
            swaps += j - i;

            // Physically move arr[j] to i (shift elements right)
            char temp = arr[j];
            for (int pos = j; pos > i; pos--) {
                arr[pos] = arr[pos - 1];
            }
            arr[i] = temp;
        }

        return swaps;
    }

    private void NextPermutation(char[] a) {
        int n = a.Length;

        // 1. Find the rightmost i where a[i] < a[i+1]
        int i = n - 2;
        while (i >= 0 && a[i] >= a[i + 1]) i--;
        if (i < 0) return; // already maximum

        // 2. Find the rightmost j > i where a[j] > a[i]
        int j = n - 1;
        while (a[j] <= a[i]) j--;
        // 3. Swap i and j
        (a[i], a[j]) = (a[j], a[i]);

        // 4. Reverse suffix after i
        Array.Reverse(a, i + 1, n - i - 1);
    }
}
```


## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n × k + n²)**     | k calls to next_permutation: O(n × k), swap counting with shifts: O(n²) in worst case |
| **Space Complexity**  | **O(n)**              | Copies of char arrays + constant extra space   |

**Optimal** — under constraints n ≤ 1000, k ≤ 1000 → O(n × k) ≈ 10⁶ + O(n²) ≈ 10⁶ → passes comfortably.

---

## Why This Works — Example Walkthrough

**Example 1**: `num = "5489355142"`, `k = 4`

- After 4 next_permutations → target = "5489355421"
- Greedy shift counting:
  - Find positions where digits differ
  - For each mismatched position, find closest matching digit to the right
  - Add distance (j - i) to swaps
  - Shift digit left (simulate bubble sort step)
- Total swaps = **2** → correct (matches the two adjacent swaps shown)

**Example 2**: `num = "11112"`, `k = 4`

- k-th wonderful = "21111"
- Greedy shifts move '2' leftward step by step → **4** swaps → correct

**Example 3**: `num = "00123"`, `k = 1`

- Next permutation = "00132"
- One adjacent swap (positions 3 and 4) → **1** → correct

**Correct** — next_permutation reliably generates the exact k-th larger permutation in lex order, and the greedy right-to-left matching + shifting accurately counts the minimum adjacent swaps needed.

---

## Pitfalls & Edge Cases

- **Leading zeros** → treated as characters (allowed, since it's a string)
- **Duplicate digits** → next_permutation handles lex order correctly (including duplicates)
- **k = 1** → just one next_permutation
- **n = 1000, k = 1000** → O(n × k + n²) ≈ 2×10⁶ operations → safe
- **All identical digits** → next_permutation stops quickly (no larger permutation)

All handled perfectly.

---

## Key Takeaway

This is a **beautifully combined** next-permutation + min-adjacent-swaps problem:

- Make a copy of `num` → apply **next_permutation** exactly **k times** to get the target k-th larger string
- Then compute minimum adjacent swaps to transform original → target:
  - Greedily scan left to right in target
  - For each position i, find leftmost j ≥ i in current array with needed digit
  - Add cost (j - i) to swaps
  - Physically shift the digit from j to i (simulate bubble sort move)
- This greedy matching gives the **true minimum** adjacent swaps

**Pure, clean, optimal** — perfect way to reach the k-th permutation with minimal adjacent digit swaps.

---

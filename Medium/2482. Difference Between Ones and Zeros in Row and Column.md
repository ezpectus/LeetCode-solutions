# 2482. Difference Between Ones and Zeros in Row and Column  
*O(mn) — Prefix Sum on Rows and Columns*

---

## Problem Statement

You are given an `m × n` **0-indexed** binary matrix `grid`.

Create a difference matrix `diff` of the same size where:
```
diff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j]
```

where:
- `onesRow[i]` = number of 1's in row i
- `zerosRow[i]` = number of 0's in row i = n - onesRow[i]
- `onesCol[j]` = number of 1's in column j
- `zerosCol[j]` = number of 0's in column j = m - onesCol[j]

Return the `diff` matrix.

**Examples**:

**Example 1**  
Input: grid = [[0,1,1],[1,0,1],[0,0,1]]  
Output: [[0,0,4],[0,0,4],[-2,-2,2]]

**Example 2**  
Input: grid = [[1,1,1],[1,1,1]]  
Output: [[5,5,5],[5,5,5]]

**Constraints**:
- m == grid.length
- n == grid[i].length
- 1 ≤ m, n ≤ 10⁵
- 1 ≤ m × n ≤ 10⁵
- grid[i][j] is 0 or 1

---

## Core Idea — Precompute Row and Column Ones Count

**Efficient approach**:
- Precompute for each row i: number of 1's (`onesRow[i]`)
- Precompute for each column j: number of 1's (`onesCol[j]`)
- Then for every cell (i,j):
  - diff[i][j] = onesRow[i] + onesCol[j] - (n - onesRow[i]) - (m - onesCol[j])
  - Simplify: = 2×onesRow[i] + 2×onesCol[j] - n - m

**Time**: O(mn) — one pass to count row & column ones, one pass to fill diff  
**Space**: O(m + n) — can even do in-place if modifying grid is allowed

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int[][] OnesMinusZeros(int[][] grid){
        int m = grid.Length;
        int n = grid[0].Length;

        // Precompute number of 1's per row and per column
        int[] onesRow = new int[m];
        int[] onesCol = new int[n];

        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                if (grid[i][j] == 1){
                    onesRow[i]++;
                    onesCol[j]++;
                }
            }
        }

        // Build diff matrix
        int[][] diff = new int[m][];
        for (int i = 0; i < m; i++){
            diff[i] = new int[n];
            for (int j = 0; j < n; j++){
                diff[i][j] = onesRow[i] + onesCol[j] - (n - onesRow[i]) - (m - onesCol[j]);
                // Equivalent simplified: 2*onesRow[i] + 2*onesCol[j] - n - m
            }
        }

        return diff;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(m × n)**  | Two complete passes over the grid:  
  • First pass: count ones per row & column — O(mn)  
  • Second pass: compute diff values — O(mn) |
| **Space Complexity**  | **O(m + n)**  | onesRow array: O(m)  
  onesCol array: O(n)  
  (Can be reduced to **O(1)** extra space by modifying grid in-place if allowed) |

**Optimal** — linear in the total number of cells (m × n) — perfectly efficient given constraint m × n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: grid = [[0,1,1],[1,0,1],[0,0,1]]

**Precomputed counts**:
- onesRow = [2, 2, 1]  
- onesCol = [1, 1, 3]  

**zerosRow** = [1, 1, 2] (n - onesRow)  
**zerosCol** = [2, 2, 0] (m - onesCol)

**Compute diff[0][0]**:
- onesRow[0] + onesCol[0] - zerosRow[0] - zerosCol[0]  
  = 2 + 1 - 1 - 2 = **0**

Similarly for other cells → matches output [[0,0,4],[0,0,4],[-2,-2,2]]

**Correct** —  
We precompute the number of 1's in each row and each column in a single O(mn) pass.  
Then, for every cell (i,j), we can compute the required diff value in **O(1)** time using the formula:  
**onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j]**  
(or the simplified equivalent: **2×onesRow[i] + 2×onesCol[j] - m - n**)

---

## Key Takeaway

This is a **simple precomputation + direct formula** problem:

* Precompute `onesRow[i]` = number of 1's in row i
* Precompute `onesCol[j]` = number of 1's in column j
* Then for every cell (i,j):
  * diff[i][j] = onesRow[i] + onesCol[j] - (n - onesRow[i]) - (m - onesCol[j])
  * Simplified form: `2 × onesRow[i] + 2 × onesCol[j] - m - n`

---

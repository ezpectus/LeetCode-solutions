# 2049. Count Nodes With the Highest Score  
*O(n) — Elegant DFS + Subtree Size Calculation*

---

## Problem Statement

You are given a binary tree with `n` nodes labeled from 0 to n-1.  
The tree is represented by a 0-indexed integer array `parents` where:
- `parents[i]` = parent of node `i`
- `parents[0] = -1` (root is node 0)

For each node i, its **score** is calculated as follows:
- Remove node i and all its connected edges
- The tree splits into one or more non-empty subtrees
- Score = **product** of the sizes (number of nodes) of all resulting subtrees

Return the **number of nodes** that have the **highest score** among all nodes.

---

## Core Idea — DFS to Compute Subtree Sizes + Product After Removal

**Key insight**:
- We need to compute the score for **every node** exactly once
- For any node i:
  - Removing i disconnects its subtrees from the rest of the tree
  - The resulting components are:
    - Each subtree rooted at a **child** of i
    - The rest of the tree (total n - subtree_size[i])
- Score of i = product over all children c of subtree_size[c]  
  × (n - subtree_size[i])   (if there are remaining nodes)

**Special case for root (i=0)**:
- No "rest of tree" component
- Score = product over all its children's subtree sizes

**Steps**:
1. Build adjacency list (children) from parents array
2. Use **DFS** to compute subtree_size[i] for every node i:
   - subtree_size[i] = 1 + sum of subtree_size[c] for all children c
3. For each node i:
   - Compute score as product of subtree sizes of its children
   - If i is not root → multiply by (n - subtree_size[i])
4. Track the maximum score and count how many nodes achieve it

---

## Clean Implementation (C#)

```csharp
public class Solution 
{
    public int CountHighestScoreNodes(int[] parents) 
    {
        int n = parents.Length;

        // Build children adjacency list
        var children = new List<int>[n];
        for (int i = 0; i < n; i++) 
        {
            children[i] = new List<int>();
        }

        for (int i = 1; i < n; i++) 
        {
            children[parents[i]].Add(i);
        }

        // Compute subtree sizes using DFS
        long[] subtreeSize = new long[n];
        Dfs(0, children, subtreeSize);

        // Compute scores and find maximum + count
        long maxScore = 0;
        int count = 0;

        for (int i = 0; i < n; i++) 
        {
            long score = 1;

            // Product of children's subtree sizes
            foreach (int child in children[i]) 
            {
                score *= subtreeSize[child];
            }

            // If not root, multiply by remaining tree size
            if (i != 0) 
            {
                score *= (n - subtreeSize[i]);
            }

            if (score > maxScore) 
            {
                maxScore = score;
                count = 1;
            } 
            else if (score == maxScore) 
            {
                count++;
            }
        }

        return count;
    }

    private long Dfs(int node, List<int>[] children, long[] subtreeSize) 
    {
        long size = 1; // itself

        foreach (int child in children[node]) 
        {
            size += Dfs(child, children, subtreeSize);
        }

        subtreeSize[node] = size;
        return size;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | DFS to compute subtree sizes: visits each node and edge once → O(n)  
Single loop to calculate scores and count max: O(n)  
Total: **O(n)** |
| **Space Complexity**  | **O(n)**      | Children adjacency list: O(n)  
subtreeSize array: O(n)  
Recursion stack: O(h) where h is tree height → O(n) in worst case (skewed tree) |

**Optimal** — linear time and space, ideal and efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: parents = [-1,2,0,2,0]

**Tree structure**:
```
     0
   /   \
  2     4
 / \
1   3
```


**Subtree sizes** (computed bottom-up via DFS):
- node 1: 1
- node 3: 1
- node 4: 1
- node 2: 1 + 1 + 1 = 3
- node 0: 1 + 3 + 1 = 5

**Scores** (product of resulting subtree sizes after removal):
- Node 0: subtrees of size 3 (left) and 1 (right) → 3 × 1 = **3**
- Node 1: remaining tree size 4 → **4**
- Node 2: subtrees of size 1 (node 1), 1 (node 3), remaining 2 → 1 × 1 × 2 = **2**
- Node 3: remaining tree size 4 → **4**
- Node 4: remaining tree size 4 → **4**

Highest score = **4**  
Nodes with score 4: 1, 3, 4 → **3 nodes** → correct

**Example 2**: parents = [-1,2,0]

**Tree structure**:
```
   0
  /
 2
/
1
```


**Subtree sizes**:
- node 1: 1
- node 2: 1 + 1 = 2
- node 0: 1 + 2 = 3

**Scores**:
- Node 0: subtree of size 2 → **2**
- Node 1: remaining tree size 2 → **2**
- Node 2: subtrees of size 1 and 1 → 1 × 1 = **1**

Highest score = **2**  
Nodes with score 2: 0 and 1 → **2 nodes** → correct

**Correct** —  
DFS accurately computes subtree sizes bottom-up.  
For each node, the score is the product of the sizes of all resulting components after removal.  
We track the maximum score and count how many nodes achieve it — no mistakes or missed cases.

---

## Key Takeaway

This is a **classic tree traversal + subtree size + product after removal** problem:

* Build children adjacency list from parents array (O(n))
* Use **DFS** to compute subtree_size[i] for every node i (O(n))
* For each node i:
  * Score = product of subtree_size[c] for every child c of i
  * If i is **not** root → multiply by remaining tree size (n - subtree_size[i])
  * If i is root → just product of children's subtree sizes
* Find the **maximum score** value
* Count how many nodes have **exactly** this maximum score

**Pure, clean, optimal** — O(n) time, O(n) space, elegant DFS + single pass, very straightforward and correct.
---

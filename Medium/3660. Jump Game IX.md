# üß† Pattern: Bidirectional Prefix-Suffix Jump Optimization

## üìå Problem Statement

Given an array `nums`, for each index `i`, find the **maximum value reachable** by following any sequence of valid jumps starting at `i`, under the rules:

- You can jump to index `j > i` only if `nums[j] < nums[i]`
- You can jump to index `j < i` only if `nums[j] > nums[i]`

Return an array `res` where `res[i]` is the maximum value reachable from index `i`.

---

## üß© Core Insight

This problem resembles a **monotonic jump graph**, but can be optimized using **prefix and suffix passes** inspired by competitive programming patterns (e.g. Codeforces-style greedy scans).

Instead of building a full graph, we:

- Use a **prefix max** to track the best value reachable from the left
- Use a **suffix min** to track jump eligibility from the right
- Combine both in a final pass to propagate reachable maximums

---

## üß± Architecture

- **Pass 1**: Build `preff[i] = max(nums[0..i])`
- **Pass 2**: Build `suff[i] = min(nums[i..n-1])`
- **Pass 3**: Traverse from right to left, propagating reachable maximums using jump rules

---

## üíª Implementation (C#)

```csharp
public class Solution {
    public int[] MaxValue(int[] nums) {
        int n = nums.Length;
        int[] preff = new int[n];
        int[] suff = new int[n];
        int[] res = new int[n];

        preff[0] = nums[0];
        suff[n - 1] = nums[n - 1];

        for (int i = 1; i < n; i++) {
            preff[i] = Math.Max(nums[i], preff[i - 1]);
        }

        for (int j = n - 2; j >= 0; j--) {
            suff[j] = Math.Min(nums[j], suff[j + 1]);
        }

        res[n - 1] = preff[n - 1];

        for (int k = n - 2; k >= 0; k--) {
            res[k] = preff[k];
            if (preff[k] > suff[k + 1]) {
                res[k] = res[k + 1];
            }
        }

        return res;
    }
}
```


## üß™ Complexity

| Phase         | Time Complexity | Space Complexity |
|---------------|------------------|-------------------|
| Prefix/Suffix | O(n)             | O(n)              |
| Final Pass    | O(n)             | O(n)              |
| **Total**     | **O(n)**         | **O(n)**          |

---

## ‚úÖ Strengths

- No recursion or graph construction  
- Linear time and space  
- Easy to implement and debug  
- Inspired by Codeforces-style greedy propagation

---

## ‚ö†Ô∏è Limitations

- Relies on structural properties of `nums`  
- May not generalize to weighted or multi-jump variants

---

## üß† Use Cases

- Jump-based propagation problems  
- Greedy reachability with monotonic constraints  
- Competitive programming tasks with directional rules

---

## üß© Related Patterns

- Monotonic Stack Jump Graph  
- Greedy Suffix Propagation  
- DAG Relaxation via Queue

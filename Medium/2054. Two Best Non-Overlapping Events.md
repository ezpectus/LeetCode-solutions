# 2054. Two Best Non-Overlapping Events — Architectural Sweep Line + Priority Queue  
*O(n log n) — Optimal Sorted Events with Max Previous Value*

---


## Problem Statement

Given list of events `events[i] = [start, end, value]`.

Choose **at most two** **non-overlapping** events (end_i + 1 ≤ start_j).

Maximize **sum of values**.

Return that maximum sum.

---

## Core Idea — Sort by Start + Track Max Value of Past Events

**Brute** → check all pairs → O(n²) too slow.

**Optimal**:
- **Sort events** by **start time**
- Use **min-heap (priority queue)** to track **ended** events by **end time**
- Maintain **maxValueSoFar** = maximum value of any event that **ended before** current start
- For each event:
  - Remove from heap all events ended **before** current start → update `maxValueSoFar`
  - Current best = `value` alone **or** `maxValueSoFar + value`
  - Add current event to heap (by end time)

**Non-overlapping** → next event start ≥ current end + 1 → ensured by heap check.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int MaxTwoEvents(int[][] events)  {
        // Sort by start time
        Array.Sort(events, (a, b) => a[0].CompareTo(b[0]));

        // Min-heap: [end, value], ordered by end time
        var pq = new PriorityQueue<int[], int>(
            Comparer<int>.Create((a, b) => a.CompareTo(b))
        );

        int maxValueSoFar = 0;  // max value of any previous non-overlapping event
        int result = 0;

        foreach (var e in events)  {
            int start = e[0];
            int end = e[1];
            int value = e[2];

            // Remove all events that ended before current start
            while (pq.Count > 0 && pq.Peek()[0] < start) 
             maxValueSoFar = Math.Max(maxValueSoFar, pq.Dequeue()[1]);
            

            // Best: current alone or with best previous
            result = Math.Max(result, value);
            result = Math.Max(result, maxValueSoFar + value);

            // Add current event to heap
            pq.Enqueue(new int[] { end, value }, end);
        }

        return result;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)**        | Sorting + heap operations                      |
| **Space Complexity**  | **O(n)**              | Priority queue worst case                      |

**Optimal** — best possible for the constraints.

---

## Why This Works — Example Walkthrough

**Input**: `events = [[1,3,2],[4,5,2],[2,4,3]]`

Sorted by start time: `[1,3,2]`, `[2,4,3]`, `[4,5,2]`

- **Event [1,3,2]**:
  - Heap empty → `maxValueSoFar = 0`
  - `result = max(0, 2) = 2`
  - Add (end=3, value=2) to heap

- **Event [2,4,3]**:
  - Top end=3 ≥ 2 → no pop
  - `result = max(2, 0 + 3) = 3`
  - Add (end=4, value=3) to heap

- **Event [4,5,2]**:
  - Pop events with end < 4 → pop end=3 → `maxValueSoFar = 2`
  - End=4 not < 4 → stop
  - `result = max(3, 2 + 2) = 4`
  - Add (end=5, value=2)

**Result**: **4** — events 0 and 2 (values 2+2)
**Correct**.

---

## Pitfalls & Edge Cases

- **Overlapping events** → heap ensures only fully ended events are considered
- **Same start time** → order doesn't matter (strict non-overlap rule enforced by end < start)
- **Single event** → returns its value
- **All overlapping** → returns max single value
- **Large n (10⁵)** → efficient heap operations

All handled perfectly.

---

## Key Takeaway

This is a **beautifully efficient** greedy + heap problem:

- **Sort by start time**
- **Min-heap by end time** → track past non-overlapping candidates
- **Update max previous value** → combine with current event

**No DP needed** — pure sweep line with heap.
**Pure, clean, optimal** — one of the best event scheduling problems.

---

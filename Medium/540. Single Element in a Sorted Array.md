# 540. Single Element in a Sorted Array

---

## Problem
We are given a sorted array where every element appears exactly twice, except for one element which appears only once.  
We must return that single element.  

Constraints:
- Must run in **O(log n)** time.  
- Must use **O(1)** space.  

---

## Key Idea
This is a **binary search problem**.  
- In a sorted array with pairs, the single element disrupts the pairing pattern.  
- Normally, pairs start at even indices: `nums[0] == nums[1], nums[2] == nums[3], ...`.  
- If the single element is before index `mid`, the pairing breaks earlier.  
- If after, the pairing is still intact until `mid`.  

We use binary search to locate the single element.

---

## Code (C#)
```csharp
public class Solution {
    public int SingleNonDuplicate(int[] nums) {
        int left = 0, right = nums.Length - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;

            // Ensure mid is even for comparison
            if (mid % 2 == 1) mid--;

            // If pair is valid, single element is after mid
            if (nums[mid] == nums[mid + 1]) {
                left = mid + 2;
            } else {
                // Otherwise, single element is before or at mid
                right = mid;
            }
        }

        return nums[left];
    }
}
```

## Complexity
- **Time:** O(log n), because binary search halves the array each step.  
- **Space:** O(1), no extra storage required.  

---

## Example Walkthrough

**Input:** `nums = [1,1,2,3,3,4,4,8,8]`  
- mid = 4 → `nums[4] = 3`, `nums[5] = 4` → mismatch → move search left.  
- Eventually `left = 2` → `nums[2] = 2`.  
**Output:** `2` ✅  

**Input:** `nums = [3,3,7,7,10,11,11]`  
- mid = 2 → `nums[2] = 7`, `nums[3] = 7` → valid pair → move search right.  
- Eventually `left = 4` → `nums[4] = 10`.  
**Output:** `10` ✅  

---

## Conclusion
The problem is solved using **binary search on pairs**.  
- Efficient **O(log n)** solution.  
- Requires **no extra space**.  


---

# 3034. Number of Subarrays That Match a Pattern I

---

##  Problem Restatement
We are given:
- An integer array `nums` of length `n`.
- A pattern array `pattern` of length `m`, consisting of values `-1, 0, 1`.

A subarray `nums[i..i+m]` (size `m+1`) **matches** the pattern if for every `k`:
- `pattern[k] == 1` → `nums[i+k+1] > nums[i+k]`
- `pattern[k] == 0` → `nums[i+k+1] == nums[i+k]`
- `pattern[k] == -1` → `nums[i+k+1] < nums[i+k]`

We must count how many subarrays match the pattern.

---

##  Core Idea
- Iterate over all possible starting indices `i` (from `0` to `n-m-1`).  
- For each subarray of length `m+1`, check if it satisfies the pattern.  
- If yes → increment count.  
- Straightforward brute force works because `n ≤ 100`.  

---

##  Code (C#)
```csharp
public class Solution {
    public int CountMatchingSubarrays(int[] nums, int[] pattern) {
        int n = nums.Length;
        int m = pattern.Length;
        int count = 0;

        for (int i = 0; i + m < n; i++) {
            bool ok = true;
            for (int k = 0; k < m; k++) {
                if (pattern[k] == 1 && nums[i + k + 1] <= nums[i + k]) {
                    ok = false; break;
                }
                if (pattern[k] == 0 && nums[i + k + 1] != nums[i + k]) {
                    ok = false; break;
                }
                if (pattern[k] == -1 && nums[i + k + 1] >= nums[i + k]) {
                    ok = false; break;
                }
            }
            if (ok) count++;
        }

        return count;
    }
}
```


##  Complexity
- **Time:** O(n * m)  
  - For each starting index in `nums`, we check `m` comparisons against the pattern.  
  - With `n ≤ 100`, this is trivial and efficient.  
- **Space:** O(1)  
  - Only a few variables are used, no extra data structures required.  

---

##  Pitfalls
- **Boundary errors:**  
  - Must ensure subarray size is exactly `m+1`.  
  - Loop condition should be `i + m < n`.  
- **Pattern interpretation:**  
  - `1` means strictly increasing, not `>=`.  
  - `0` means exactly equal, not approximate.  
  - `-1` means strictly decreasing, not `<=`.  
- **Early exit:**  
  - As soon as one comparison fails, break out of the inner loop to avoid wasted checks.  
- **Edge cases:**  
  - Very short arrays (`n=2`) with minimal patterns.  
  - Patterns of length `m=1` (just one comparison).  
  - Repeated values in `nums` must be handled correctly when `pattern[k] == 0`.  

---

##  Example Walkthrough
Input:  
`nums = [1,2,3,4,5,6]`  
`pattern = [1,1]`

Subarrays of size 3:
- `[1,2,3]` → increasing → ✅  
- `[2,3,4]` → increasing → ✅  
- `[3,4,5]` → increasing → ✅  
- `[4,5,6]` → increasing → ✅  

Result: `4`.

---

##  Conclusion
This problem is a **direct brute force check** of subarrays against the given pattern.  
- Constraints are small, so no optimization is needed.  
- The algorithm is simple: slide a window of size `m+1` and verify conditions.  

---

##  How to Think About It
- **Step 1:** Recognize that the pattern describes **relationships between consecutive elements**.  
- **Step 2:** Each subarray of size `m+1` can be checked independently.  
- **Step 3:** Since `n` is small, brute force is acceptable.  
- **Step 4:** Translate pattern values into comparisons (`>`, `==`, `<`).  
- **Step 5:** Count how many subarrays satisfy all comparisons.  

This is a classic case where **constraints guide the solution**:  
- If `n` were huge, we’d need advanced techniques (like rolling checks or preprocessing).  
- But here, brute force is clean, readable, and sufficient.




---



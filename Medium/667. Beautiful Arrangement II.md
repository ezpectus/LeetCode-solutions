# 667. Beautiful Arrangement II — Architectural Solution

## Problem Statement
- Given two integers `n` and `k`, construct an array of `1..n` (all distinct numbers) such that the absolute differences between consecutive elements contain **exactly `k` distinct values**.
- Return any valid array.
- Constraints: 1 ≤ k < n ≤ 10⁴

## Core Idea 
The maximum number of distinct differences is `n-1` (achieved by alternating low and high numbers).
To get **exactly `k` distinct differences**:

- Alternate low and high for the first `k` steps: 1, n, 2, n-1, 3, n-2, ...
  → this creates `k` large distinct differences: `n-1`, `n-2`, ..., `n-k`
- Then fill the remaining numbers in **increasing order**
  → adds only difference `1`, which is already present (from the last alternation step)

Result: exactly `{1, 2, ..., k}` distinct differences.

## Implementation (C#) 

```csharp
public class Solution {
   public int[] ConstructArray(int n, int k) {
    int[] res = new int[n];
    int i = 0;
    for (int l = 1, r = n; l <= r; ) {
        if (k > 1)  res[i++] = (k-- % 2 == 1) ? l++ : r--;
        else  res[i++] = l++;
    }
    return res;
   }
}
```

## Complexity Analysis

* Time Complexity: **O(n)** — single linear pass to build the array
* Space Complexity: **O(n)** — only the output array is used

## Pitfalls & Edge Cases

* `k = 1` → returns sorted array `[1,2,3,...,n]` → all consecutive differences are 1
* `k = n-1` → full low-high alternation → achieves the maximum possible distinct differences
* `n=3, k=2` → e.g. `[1,3,2]` → differences 2 and 1
* `n=3, k=1` → `[1,2,3]` → only difference 1
* Larger n with small k → alternation stops early, remaining numbers filled sequentially

## Conclusion
- The problem appears to require generating and validating permutations, but it is solved with a direct constructive approach.
- Alternate between low and high values for the first `k` steps to introduce `k` distinct large differences, then append the remaining numbers in monotonic order to reuse the smallest difference (1).
- No backtracking, no post-validation, no additional data structures needed.
- Once the alternating pattern is recognized, the solution is straightforward and can be implemented in under 30 seconds.
- A simple yet powerful idea that elegantly handles all constraints.


---





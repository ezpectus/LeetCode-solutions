# 468. Validate IP Address — Architectural Grammar Validation  
*O(n) — Clean Structural Rules*

---

## Problem Statement

Given a string `queryIP`, determine whether it is:

- A valid **IPv4** address → return `"IPv4"`
- A valid **IPv6** address → return `"IPv6"`
- **Neither**

---

## Core Idea — Two Independent Grammars

**IPv4** and **IPv6** are **completely different formats** → validate them **separately**.

### IPv4 Rules (`x1.x2.x3.x4`)
Each part must:
- Contain only digits
- Length 1–3
- **No leading zeros** (except `"0"`)
- Value in `[0, 255]`

### IPv6 Rules (`x1:x2:...:x8`)
Each part must:
- Length 1–4
- Only hex digits: `0-9`, `a-f`, `A-F`
- **Leading zeros allowed**

---

## Full Implementation (C#)

```csharp
public class Solution {
    public string ValidIPAddress(string ip) {
        if (ip.Contains('.')) return IsV4(ip) ? "IPv4" : "Neither";
        if (ip.Contains(':')) return IsV6(ip) ? "IPv6" : "Neither";
        return "Neither";
    }

    private bool IsV4(string ip) {
        var parts = ip.Split('.');
        if (parts.Length != 4) return false;

        foreach (var p in parts) {
            if (p.Length == 0 || p.Length > 3) return false;
            if (p.Any(c => !char.IsDigit(c))) return false;

            // no leading zeros
            if (p.Length > 1 && p[0] == '0') return false;

            if (!int.TryParse(p, out int v)) return false;
            if (v < 0 || v > 255) return false;
        }
        return true;
    }

    private bool IsV6(string ip) {
        var parts = ip.Split(':');
        if (parts.Length != 8) return false;

        foreach (var p in parts) {
            if (p.Length == 0 || p.Length > 4) return false;
            foreach (char c in p) {
                bool ok = char.IsDigit(c)
                          || (c >= 'a' && c <= 'f')
                          || (c >= 'A' && c <= 'F');
                if (!ok) return false;
            }
        }
        return true;
    }
}
```


## Complexity

| **Metric**     | **Value**   | **Notes**                          |
|----------------|-------------|------------------------------------|
| **Time**       | **O(n)**    | Single pass + split                |
| **Space**      | **O(1)**    | Only a few variables               |

**Optimal and clean** — nothing to improve.

---

## Pitfalls & Edge Cases

- `"01.02.03.04"` → **invalid** (leading zeros forbidden in IPv4)
- `"0.0.0.0"` → **valid** (zero is allowed)
- `"1."` → **invalid** (incomplete part)
- `"2001:db8:85a3::8A2E:0370:7334"` → **invalid** (double `::` not allowed — problem forbids compression)
- IPv6 allows **leading zeros**: `"0000"` → **valid**
- IPv6 is **case-insensitive** — both `a-f` and `A-F` are accepted

---

## Key Takeaway

This is a **classic string validation** problem built on **two completely different grammars**:
- **IPv4** — strict numeric rules, no leading zeros, 4 parts
- **IPv6** — hex, up to 8 parts, leading zeros allowed, no compression

By **separating validation logic** and using **early returns + clear conditions**, we get a solution that is:

- **Correct**
- **Fast**
- **Readable**
- **Robust**
**Clean, robust, O(n) solution** — perfect example of **architectural clarity**.

---




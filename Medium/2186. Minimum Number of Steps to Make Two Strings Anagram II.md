# 2186. Minimum Number of Steps to Make Two Strings Anagram II  
*O(n) — Frequency Count + Absolute Difference*

---

## Problem Statement

- You are given two strings `s` and `t` consisting of lowercase English letters.
- In one step, you can **append** any lowercase letter to **either** `s` or `t`.
- Return the **minimum number of steps** needed to make `s` and `t` **anagrams** of each other.
- An anagram means both strings contain exactly the same characters with the same frequencies (order doesn't matter).

**Examples**:

**Example 1**: s = "leetcode", t = "coats"  
Output: **7**  
One way:  
- Append "as" to s → "leetcodeas"  
- Append "leede" to t → "coatsleede"  
Total steps = 7 (minimum)

**Example 2**: s = "night", t = "thing"  
Output: **0**  
Already anagrams → no steps needed

**Constraints**:
- 1 ≤ s.length, t.length ≤ 2·10⁵
- s and t consist of lowercase English letters

---

## Core Idea — Frequency Count + Absolute Difference

**Key insight**:
- To make two strings anagrams, their character frequencies must become **identical**
- You can only **add** characters (append), never remove or change existing ones
- For each letter, if one string has more occurrences than the other → you must add the difference to the string with fewer
- Total steps = **sum over all letters of |freq_s[c] - freq_t[c]|**

**Why it works**:
- If freq_s[c] > freq_t[c] → add (freq_s[c] - freq_t[c]) characters c to t
- If freq_t[c] > freq_s[c] → add (freq_t[c] - freq_s[c]) characters c to s
- The total additions = half the sum of absolute differences (because each addition fixes one side)
- But since we add to the deficient side → total steps = exactly the sum of absolute differences

**Correct formula**:
minimum steps = ∑ |freq_s[c] - freq_t[c]| over all 26 letters c

**Time**: O(n + m + 26) ≈ O(n)  
**Space**: O(1) — fixed 26 letters

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int MinSteps(string s, string t){
        // Frequency arrays (26 lowercase letters)
        int[] freqS = new int[26];
        int[] freqT = new int[26];

        // Count frequencies in s
        foreach (char c in s) freqS[c - 'a']++;
        
        // Count frequencies in t
        foreach (char c in t) freqT[c - 'a']++;
        
        int steps = 0;
        // For each letter, add the absolute difference
        for (int i = 0; i < 26; i++){
            steps += Math.Abs(freqS[i] - freqT[i]);
        }

        return steps;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n + m)**  | Counting frequencies in s: O(n)<br>Counting frequencies in t: O(m)<br>Comparing 26 letters: O(1) → total **O(n + m)** |
| **Space Complexity**  | **O(1)**      | Fixed-size frequency arrays (size 26) — constant space regardless of input size |

**Optimal** — linear time in the length of the strings, constant extra space — perfect and extremely efficient for n, m ≤ 2·10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: s = "leetcode", t = "coats"

**Frequencies in s** ("leetcode"):  
c:1, d:1, e:3, l:1, o:1, t:1

**Frequencies in t** ("coats"):  
a:1, c:1, o:1, s:1, t:1

**Absolute differences** (only letters that appear in at least one string):

- a: |0 - 1| = **1**
- c: |1 - 1| = **0**
- d: |1 - 0| = **1**
- e: |3 - 0| = **3**
- l: |1 - 0| = **1**
- o: |1 - 1| = **0**
- s: |0 - 1| = **1**
- t: |1 - 1| = **0**

Total steps = 1 + 1 + 3 + 1 + 1 = **7** → correct

**Example 2**: s = "night", t = "thing"

Both strings have exactly: g:1, h:1, i:1, n:1, t:1  
All absolute differences = **0** → steps = **0** → correct

**Correct** —  
The **minimum number of append operations** needed is exactly the **total absolute difference** in character frequencies.  
For every character that appears more times in one string than the other, you must append the missing occurrences to the deficient string.

---

## Key Takeaway

This is a **simple and elegant frequency difference** problem:

* Count the frequency of each character in both strings (use array of size 26 for lowercase letters)
* For each of the 26 possible letters:
  * Compute the **absolute difference** |freq_s[c] - freq_t[c]|
* Sum all absolute differences → this is the **minimum number of append operations** required

**Pure, clean, optimal** — O(n + m) time, O(1) extra space, extremely fast, intuitive, safe from overflow, and mathematically precise.

---

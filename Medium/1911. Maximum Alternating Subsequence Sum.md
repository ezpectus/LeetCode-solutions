# 1911. Maximum Alternating Subsequence Sum — Architectural Two-State DP (Even/Odd Parity)  
*O(n) — Optimal Single Pass with Two Variables*

---

## Problem Statement

Given array `nums`.

**Alternating sum** of subsequence = sum even indices **minus** sum odd indices (after reindexing).

Find **maximum** possible alternating sum over **any subsequence**.

---

## Core Idea — DP with Parity States

**Key insight**:
- In optimal subsequence, elements alternate between **positive** and **negative** contribution
- We can track:
  - `even` = max alternating sum **ending** with **positive** contribution (even index in subsequence)
  - `odd` = max alternating sum **ending** with **negative** contribution (odd index)

**Transitions**:
- For current `nums[i]`:
  - **Add to even** (positive): `even = max(even, odd + nums[i])`
    - Either continue previous even, or switch from odd
  - **Add to odd** (negative): `odd = max(odd, even - nums[i])`
    - Continue previous odd, or switch from even
  - Also: **start new** with current as even: `even = max(even, nums[i])`

**Global max** = max(even, odd) at any point.

**No need** full DP array — only two variables.

---

##  Implementation (C#)

```csharp
public class Solution {
    public long MaxAlternatingSum(int[] nums) {
        long even = 0;  // max sum ending with positive contribution
        long odd = 0;   // max sum ending with negative contribution

        foreach (int num in nums) {
            // Option 1: use num as positive (even index in subsequence)
            long newEven = Math.Max(even, odd + num);

            // Option 2: use num as negative (odd index)
            long newOdd = Math.Max(odd, even - num);

            even = newEven;
            odd = newOdd;
        }

        // Maximum can end in either state
        return Math.Max(even, odd);
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single linear pass                             |
| **Space Complexity**  | **O(1)**      | Only two variables                             |

**Optimal** — cannot be faster.

---

## Why This Works — Example Walkthrough

**Input**: `nums = [4,2,5,3]`

- Start: `even = 4`, `odd = 0`
- i=1 (2):
  - newEven = max(4, 0+2) = **4**
  - newOdd = max(0, 4-2) = **2**
- i=2 (5):
  - newEven = max(4, 2+5) = **7**
  - newOdd = max(2, 4-5) = 2 (negative ignored)
- i=3 (3):
  - newEven = max(7, 2+3) = **7**
  - newOdd = max(2, 7-3) = **4**

→ max(7, 4) = **7** (4 + 5 - 2)

**Correct**.

**Input**: `[5,6,7,8]`

- even grows: 5 → 11 → 18 → 26
- odd stays low/negative → ignored
- Final max = **8** (just the last element)

**Correct**.

**Input**: `[6,2,1,2,4,5]`

- Ends with `even = 10` (6 + 5 - 1)
- Other combinations lower

**Correct**.

---

## Pitfalls & Edge Cases

- **Decreasing array** → take largest single element
- **All positive** → take largest single (no benefit from alternating)
- **Mixed signs** → greedily alternate to maximize
- **n=1** → return nums[0]

All handled perfectly.

---

## Key Takeaway

This is a **beautifully elegant** DP:

- **Two states** → even/odd parity in subsequence
- **Local greedy updates** → global maximum
- **O(1) space** → only two variables
**Pure, clean, optimal** — one of the best subsequence sum variants.

---

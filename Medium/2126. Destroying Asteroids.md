# 2126. Destroying Asteroids  
*O(n log n) — Greedy Sorting + Cumulative Sum*

---

## Problem Statement

You are given an integer `mass` (initial mass of a planet) and an integer array `asteroids` where `asteroids[i]` is the mass of the `i`-th asteroid.

You can choose **any order** to collide the planet with the asteroids.  
Collision rules:
- If planet mass ≥ asteroid mass → asteroid is **destroyed**, planet gains the asteroid's mass
- If planet mass < asteroid mass → planet is **destroyed**

Return `true` if it is possible to **destroy all asteroids** (in some order), otherwise `false`.

**Examples**:

**Example 1**: mass = 10, asteroids = [3,9,19,5,21]  
Output: **true**  
One order: [9,19,5,3,21]  
10 → 19 → 38 → 43 → 46 → 67 (all destroyed)

**Example 2**: mass = 5, asteroids = [4,9,23,4]  
Output: **false**  
Max possible mass after destroying 4,9,4 = 22 < 23 → cannot destroy 23

**Constraints**:
- 1 ≤ mass ≤ 10⁵
- 1 ≤ asteroids.length ≤ 10⁵
- 1 ≤ asteroids[i] ≤ 10⁵

---

## Core Idea — Greedy: Sort Asteroids + Cumulative Mass Check

**Key insight**:
- To destroy a large asteroid, the planet must have enough mass **before** colliding with it.
- The optimal strategy is to always collide with the **smallest possible asteroids first** to maximize mass gain.
- Sort asteroids in **increasing order**.
- Start with initial mass.
- For each asteroid in sorted order:
  - If current mass ≥ asteroid mass → destroy it and add mass
  - Else → impossible (return false)
- If you can destroy all → return true

**Why sorting works**:
- Destroying smaller asteroids first gives maximum mass growth early
- If you can destroy them in increasing order, you can destroy them in any order (greedy choice property)
- If you cannot destroy them in increasing order → impossible in any order

**Time**: O(n log n) — sorting  
**Space**: O(1) or O(log n) depending on sorting implementation

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public bool AsteroidsDestroyed(int mass, int[] asteroids) {
        // Sort asteroids in increasing order
        Array.Sort(asteroids);
        long currentMass = mass;

        foreach (int ast in asteroids) {
            // If current mass < asteroid mass → cannot destroy it
            if (currentMass < ast) {
                return false;
            }
            // Destroy asteroid and gain its mass
            currentMass += ast;
        }

        // All asteroids destroyed
        return true;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)**| Sorting the asteroids array: O(n log n)  
Single linear pass to simulate collisions and mass accumulation: O(n)  
Total: **O(n log n)** (dominated by sorting) |
| **Space Complexity**  | **O(1)**      | Only a few integer variables (current mass, loop counters)  
Sorting may use O(log n) internal space in most implementations, but extra space is effectively constant |

**Optimal** — sorting is necessary in the worst case to guarantee the greedy order; simulation is linear — perfectly efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: mass = 10, asteroids = [3,9,19,5,21]

After sorting: **[3,5,9,19,21]**

Simulation step-by-step:
- Start: planet mass = **10**
- Collide with 3: 10 ≥ 3 → destroy → new mass = 10 + 3 = **13**
- Collide with 5: 13 ≥ 5 → destroy → new mass = 13 + 5 = **18**
- Collide with 9: 18 ≥ 9 → destroy → new mass = 18 + 9 = **27**
- Collide with 19: 27 ≥ 19 → destroy → new mass = 27 + 19 = **46**
- Collide with 21: 46 ≥ 21 → destroy → new mass = 46 + 21 = **67**

All asteroids destroyed → **true**

**Example 2**: mass = 5, asteroids = [4,9,23,4]

After sorting: **[4,4,9,23]**

Simulation:
- Start: mass = **5**
- Collide with 4: 5 ≥ 4 → destroy → mass = 5 + 4 = **9**
- Collide with 4: 9 ≥ 4 → destroy → mass = 9 + 4 = **13**
- Collide with 9: 13 ≥ 9 → destroy → mass = 13 + 9 = **22**
- Collide with 23: 22 < 23 → **cannot destroy** → **false**

**Correct** —  
Sorting in **increasing order** ensures we always collide with the smallest possible asteroid next.  
This maximizes the planet's mass growth at every step.  
If even this optimal greedy order fails to destroy all asteroids, then **no order** can succeed (greedy choice property).

---

## Key Takeaway

This is a **classic greedy destruction/accumulation** problem:

* **Sort** the asteroids in **increasing order** of mass
* Start with the initial planet mass
* For each asteroid in the sorted list:
  * If current planet mass ≥ asteroid mass → destroy it and **add** its mass to the planet
  * Else → impossible to destroy this (and any larger) asteroid → return **false**
* If you successfully destroy **all** asteroids → return **true**

**Pure, clean, optimal** — O(n log n) time (dominated by sorting), O(1) extra space, extremely fast, intuitive, and mathematically correct.

---

# 1438. Longest Continuous Subarray With Absolute Diff â‰¤ Limit

## ğŸ§  Problem Summary

You're given an integer array `nums` and an integer `limit`.  
Return the length of the **longest non-empty subarray** such that the **absolute difference between any two elements** in the subarray is **less than or equal to `limit`**.

This is a sliding window problem with dynamic bounds â€” the subarray must remain valid as new elements are added.

---

## ğŸ“Œ Key Insight

We maintain a **window `[left, right]`** such that:

- `max(nums[left..right]) - min(nums[left..right]) â‰¤ limit`

To track max and min efficiently, we use:

- `maxDeque`: stores candidates for current window maximum
- `minDeque`: stores candidates for current window minimum

When the condition is violated, we **shrink the window from the left** until it's valid again.

---

## âš™ï¸ Algorithm Steps

1. Initialize:
   - `left = 0`, `res = 0`
   - `maxDeque`, `minDeque` as empty double-ended queues

2. Iterate `right` from `0` to `n - 1`:
   - Insert `nums[right]` into `maxDeque` (maintaining decreasing order)
   - Insert `nums[right]` into `minDeque` (maintaining increasing order)

3. While `maxDeque[0] - minDeque[0] > limit`:
   - Shrink window from the left
   - Remove `nums[left]` from deques if they match

4. Update result: `res = max(res, right - left + 1)`

---

## ğŸ“¦ Code (C#)

```csharp
public class Solution {
    public int LongestSubarray(int[] nums, int limit) {
        int left = 0, res = 0;
        LinkedList<int> maxDeque = new LinkedList<int>();
        LinkedList<int> minDeque = new LinkedList<int>();

        for (int right = 0; right < nums.Length; right++) {
            while (maxDeque.Count > 0 && nums[right] > maxDeque.Last.Value)
                maxDeque.RemoveLast();
            maxDeque.AddLast(nums[right]);

            while (minDeque.Count > 0 && nums[right] < minDeque.Last.Value)
                minDeque.RemoveLast();
            minDeque.AddLast(nums[right]);

            while (maxDeque.First.Value - minDeque.First.Value > limit) {
                if (maxDeque.First.Value == nums[left]) maxDeque.RemoveFirst();
                if (minDeque.First.Value == nums[left]) minDeque.RemoveFirst();
                left++;
            }

            res = Math.Max(res, right - left + 1);
        }

        return res;
    }
}
```
## ğŸ§® Complexity

| Metric | Value |
|--------|-------|
| Time   | O(n)  |
| Space  | O(n)  |

- Each element is added and removed from the deques at most once.
- The algorithm maintains a dynamic window using monotonic queues, ensuring linear time.
- Space is linear in the worst case due to deque storage, but typically small in practice.

---

## ğŸ” Edge Cases

- **All elements equal**  
  â†’ Every subarray is valid since `max - min = 0 â‰¤ limit`.  
  â†’ The longest subarray is the entire array.

- **limit = 0**  
  â†’ Only subarrays with identical elements are valid.  
  â†’ The algorithm must reset the window whenever a mismatch occurs.

- **Single element**  
  â†’ Always valid.  
  â†’ Return 1.

- **Alternating high/low values**  
  â†’ Forces frequent window resets.  
  â†’ Tests the algorithmâ€™s ability to shrink efficiently.

- **Large input size (up to 10âµ)**  
  â†’ Confirms that the O(n) solution scales and avoids brute-force comparisons.




---

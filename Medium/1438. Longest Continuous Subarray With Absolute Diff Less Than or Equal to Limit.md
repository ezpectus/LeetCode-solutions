# 1438. Longest Continuous Subarray With Absolute Diff ≤ Limit

## 🧠 Problem Summary

You're given an integer array `nums` and an integer `limit`.  
Return the length of the **longest non-empty subarray** such that the **absolute difference between any two elements** in the subarray is **less than or equal to `limit`**.

This is a sliding window problem with dynamic bounds — the subarray must remain valid as new elements are added.

---

## 📌 Key Insight

We maintain a **window `[left, right]`** such that:

- `max(nums[left..right]) - min(nums[left..right]) ≤ limit`

To track max and min efficiently, we use:

- `maxDeque`: stores candidates for current window maximum
- `minDeque`: stores candidates for current window minimum

When the condition is violated, we **shrink the window from the left** until it's valid again.

---

## ⚙️ Algorithm Steps

1. Initialize:
   - `left = 0`, `res = 0`
   - `maxDeque`, `minDeque` as empty double-ended queues

2. Iterate `right` from `0` to `n - 1`:
   - Insert `nums[right]` into `maxDeque` (maintaining decreasing order)
   - Insert `nums[right]` into `minDeque` (maintaining increasing order)

3. While `maxDeque[0] - minDeque[0] > limit`:
   - Shrink window from the left
   - Remove `nums[left]` from deques if they match

4. Update result: `res = max(res, right - left + 1)`

---

## 📦 Code (C#)

```csharp
public class Solution {
    public int LongestSubarray(int[] nums, int limit) {
        int left = 0, res = 0;
        LinkedList<int> maxDeque = new LinkedList<int>();
        LinkedList<int> minDeque = new LinkedList<int>();

        for (int right = 0; right < nums.Length; right++) {
            while (maxDeque.Count > 0 && nums[right] > maxDeque.Last.Value)
                maxDeque.RemoveLast();
            maxDeque.AddLast(nums[right]);

            while (minDeque.Count > 0 && nums[right] < minDeque.Last.Value)
                minDeque.RemoveLast();
            minDeque.AddLast(nums[right]);

            while (maxDeque.First.Value - minDeque.First.Value > limit) {
                if (maxDeque.First.Value == nums[left]) maxDeque.RemoveFirst();
                if (minDeque.First.Value == nums[left]) minDeque.RemoveFirst();
                left++;
            }

            res = Math.Max(res, right - left + 1);
        }

        return res;
    }
}
```
## 🧮 Complexity

| Metric | Value |
|--------|-------|
| Time   | O(n)  |
| Space  | O(n)  |

- Each element is added and removed from the deques at most once.
- The algorithm maintains a dynamic window using monotonic queues, ensuring linear time.
- Space is linear in the worst case due to deque storage, but typically small in practice.

---

## 🔍 Edge Cases

- **All elements equal**  
  → Every subarray is valid since `max - min = 0 ≤ limit`.  
  → The longest subarray is the entire array.

- **limit = 0**  
  → Only subarrays with identical elements are valid.  
  → The algorithm must reset the window whenever a mismatch occurs.

- **Single element**  
  → Always valid.  
  → Return 1.

- **Alternating high/low values**  
  → Forces frequent window resets.  
  → Tests the algorithm’s ability to shrink efficiently.

- **Large input size (up to 10⁵)**  
  → Confirms that the O(n) solution scales and avoids brute-force comparisons.




---

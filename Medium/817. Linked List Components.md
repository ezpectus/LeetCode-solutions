# 817. Linked List Components — Architectural HashSet + Linear Scan  
*O(n) — Optimal Connected Component Counting*

---

## Problem Statement

Given:
- Linked list with **unique** values
- Array `nums` — subset of list values

Count how many **connected components** exist in `nums` where:
- Two values are **connected** if they appear **consecutively** in the linked list

Return number of such components.

---

## Core Idea — HashSet + Streak Counting

**Insight**:
- We care **only** about values in `nums`
- Components = **consecutive runs** of `nums` values in the list

**Solution**:
1. Put `nums` into **HashSet** → O(1) check if value belongs
2. Traverse list:
   - When we see a value **in set** and **previous not in set** → new component
   - Count such starts

**No graph. No Union-Find.** Just linear scan.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int NumComponents(ListNode head, int[] nums) {
        var set = new HashSet<int>(nums);
        int components = 0;
        bool inComponent = false;

        while (head != null) {
            if (set.Contains(head.val)) {
                if (!inComponent) {
                    components++;
                    inComponent = true;
                }
            } 
            else  inComponent = false;
            
            head = head.next;
        }

        return components;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single list traversal + O(m) HashSet build      |
| **Space Complexity**  | **O(m)**      | HashSet of nums (m = nums.length)              |

**Optimal** — linear time, minimal space.

---

## Why This Works — Example Walkthrough

**Input**: `head = [0,1,2,3]`, `nums = [0,1,3]`

- Traverse:
  - `0` → in set → **new component** → count=1, inComponent=true
  - `1` → in set → continue component
  - `2` → not in set → inComponent=false
  - `3` → in set → **new component** → count=2

→ **2 components**: `[0,1]` and `[3]`

**Perfect** — exactly correct.

---

## Pitfalls & Edge Cases

- **Single node** → 1 if in nums
- **All in nums, consecutive** → 1 component
- **All in nums, scattered** → many components
- **nums empty** → 0
- **Duplicates** → impossible (values unique)

All handled cleanly.

---

## Key Takeaway

This is a **beautifully simple** connected component counting:

- **HashSet** for membership
- **Linear scan** with streak flag
- **Count starts** of new components

**No complex data structures. No recursion.**
**Pure, clean, optimal** — one of the most elegant Medium linked list problems.

---

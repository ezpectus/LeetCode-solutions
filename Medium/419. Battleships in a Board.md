# 419. Battleships in a Board — Architectural Solution

## Problem Statement
We are given an `m × n` board where each cell is either:

* `'X'` — part of a battleship
* `'.'` — empty water

Battleships follow strict rules:

* They are placed only **horizontally or vertically**.
* They occupy a **continuous segment** of `'X'` cells.
* They **never touch** each other (at least one empty cell between ships).

We must count how many **distinct battleships** are on the board.

## Constraints

* `1 ≤ m, n ≤ 200`
* Board cells are either `'X'` or `'.'`
* Ships do not touch each other

## Core Idea
A battleship can only extend **right** or **down**.  
Therefore, **every ship has exactly one starting cell** — its **top-leftmost** segment.

A cell `(i, j)` is the **start of a new ship** iff:

* `board[i][j] == 'X'`
* There is **no 'X' above** → `board[i-1][j] != 'X'`
* There is **no 'X' to the left** → `board[i][j-1] != 'X'`

This guarantees:

* We count each ship **exactly once**
* **No need to modify** the board
* **No DFS/BFS**
* **One pass, O(1) memory**

## Steps

1. Iterate through all cells.
2. If the cell is `'.'`, skip.
3. If the cell is `'X'`, check:
   * If there is an `'X'` above → it's a continuation → skip
   * If there is an `'X'` to the left → it's a continuation → skip
4. Otherwise, this `'X'` is the **start of a new battleship** → increment count.
5. Return the count.

## Implementation (C#)

```csharp
public class Solution {
    public int CountBattleships(char[][] board) {
        int m = board.Length, n = board[0].Length;
        int count = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] != 'X') continue;

                bool hasUp = i > 0 && board[i - 1][j] == 'X';
                bool hasLeft = j > 0 && board[i][j - 1] == 'X';

                if (!hasUp && !hasLeft) count++;
            }
        }

        return count;
    }
}
```
## Complexity Analysis

- **Time Complexity**: **O(m × n)** — single pass through the board
- **Space Complexity**: **O(1)** — constant extra memory
- **Board modification**: **None** (required by follow-up)

## Pitfalls & Edge Cases

- **Ships of length 1** → counted correctly
- **Vertical ships** → left cell is empty → counted once
- **Horizontal ships** → upper cell is empty → counted once
- **No adjacency** → ensures no false positives
- **Works perfectly** for maximum board size (200×200)

## Conclusion

The architectural insight is recognizing that **each battleship has a unique top-left origin cell**.

By counting **only these origin cells**, we:

- Avoid DFS/BFS
- Avoid modifying the board
- Achieve a **clean O(mn) one-pass solution with O(1) memory**
A perfect example of collapsing a seemingly complex grid problem into a **simple structural observation**.

---

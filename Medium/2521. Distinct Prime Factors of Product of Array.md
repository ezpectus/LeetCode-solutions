# 2521. Distinct Prime Factors of Product of Array  
*O(n × log MAX) — Prime Factorization with HashSet*

---

## Problem Statement

Given an array of positive integers `nums`, return the number of **distinct prime factors** in the **product** of all elements in `nums`.

**Note**:
- A prime number is greater than 1 and divisible only by 1 and itself.
- The product can be very large, but we only care about its **distinct prime factors**.

**Examples**:

**Example 1**  
Input: nums = [2,4,3,7,10,6]  
Product = 2 × 4 × 3 × 7 × 10 × 6 = 10080 = 2⁵ × 3² × 5 × 7  
Distinct primes: 2, 3, 5, 7 → Output: **4**

**Example 2**  
Input: nums = [2,4,8,16]  
Product = 2 × 4 × 8 × 16 = 1024 = 2¹⁰  
Distinct primes: 2 → Output: **1**

**Constraints**:
- 1 ≤ nums.length ≤ 10⁴
- 2 ≤ nums[i] ≤ 1000

---

## Core Idea — Collect All Unique Prime Factors

**Key insight**:
- We don't need to compute the actual product (it would be huge, up to 1000¹⁰⁰⁰⁰ — impossible)
- We only care about the **union of all prime factors** across all numbers in `nums`
- For each number in `nums`, factorize it and collect its prime factors into a set
- The size of the set is the answer

**Factorization**:
- For each num ≤ 1000 → trial division up to sqrt(num) ≈ 31 is fast
- Time per number: O(sqrt(num)) ≈ O(32)
- Total time: O(n × √MAX) ≈ 10⁴ × 32 = 3.2×10⁵ — very fast

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int DistinctPrimeFactors(int[] nums){
        var primes = new HashSet<int>();

        foreach (int num in nums){
            Factorize(num, primes);
        }

        return primes.Count;
    }

    private void Factorize(int num, HashSet<int> primes){
        // Handle factor 2
        while (num % 2 == 0){
            primes.Add(2);
            num /= 2;
        }

        // Check odd factors
        for (int i = 3; i * i <= num; i += 2){
            while (num % i == 0){
                primes.Add(i);
                num /= i;
            }
        }

        // If num is a prime > 2
        if (num > 1){
            primes.Add(num);
        }
    }
}
```

## Complexity

| **Metric**            | **Value**              | **Notes**                                                                 |
|-----------------------|------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(n × √MAX)**        | For each of n numbers (n ≤ 10⁴): trial division up to √num ≤ √1000 ≈ 32<br>Total operations ≈ n × 32 ≈ 3.2×10⁵ — very fast in practice |
| **Space Complexity**  | **O(log MAX)**         | HashSet stores distinct prime factors<br>Worst case per number ~10 primes, but overall small and bounded (<< n) |

**Optimal** — extremely fast in practice (n ≤ 10⁴, num ≤ 1000), near-constant amortized space due to very small number of distinct primes possible.

---

## Why This Works — Example Walkthrough

**Example 1**: nums = [2,4,3,7,10,6]

**Prime factorization** of each element:
- 2 → primes: {2}
- 4 = 2² → primes: {2}
- 3 → primes: {3}
- 7 → primes: {7}
- 10 = 2 × 5 → primes: {2, 5}
- 6 = 2 × 3 → primes: {2, 3}

**Union of all primes** (using HashSet): {2, 3, 5, 7} → size **4** → correct

**Example 2**: nums = [2,4,8,16]

- All numbers are powers of 2 → primes: {2}
- Union: {2} → size **1** → correct

**Correct** —  
The prime factors of the **product** of all numbers in `nums` are exactly the **union** of the prime factors of each individual number (exponents are summed, but we only care about distinct primes).  
By factorizing each number using efficient trial division and collecting all unique primes into a HashSet, we directly obtain the number of distinct prime factors of the product — **without ever computing the actual (potentially enormous) product**.

---

## Key Takeaway

This is a **simple yet powerful prime factorization + set union** problem:

* For each number in `nums`, factorize it using **trial division** (very fast since num ≤ 1000)
* Collect every unique prime factor into a **HashSet**
* The size of the HashSet is exactly the number of **distinct prime factors** of the product of all elements
* No need to compute the actual product (which could be astronomically large)

**Pure, clean, optimal** — O(n × √MAX) time (≈ 3×10⁵ operations), O(1) amortized space (very small number of distinct primes), extremely fast, very intuitive, and perfectly solves the problem under the given constraints.

---

# 707. Design Linked List — Architectural Solution

## Problem Statement
Implement a singly or doubly linked list with the following operations:

- `get(index)` — return value at index or -1 if invalid
- `addAtHead(val)`
- `addAtTail(val)`
- `addAtIndex(index, val)` — insert before index (or append if index == length)
- `deleteAtIndex(index)` — delete if index valid

Constraints:  
- 0 ≤ index ≤ 1000
- ≤ 2000 operations
- No built-in linked list allowed

## Core Idea
**Use singly linked list with dummy head node**.

Why dummy head?
- Simplifies edge cases for head insertion/deletion
- `addAtHead` becomes same as `addAtIndex(0, val)`
- `deleteAtIndex(0)` doesn't need special handling

All operations become uniform: find the node before the target position.

Doubly linked list is possible but unnecessary — extra memory and complexity for no gain (n ≤ 2000).

## Implementation (C#) - Singly Linked List with Dummy Head

```csharp
public class MyLinkedList {
    private class ListNode {
        public int val;
        public ListNode next;
        public ListNode(int val = 0, ListNode next = null) {
            this.val = val;
            this.next = next;
        }
    }

    private ListNode dummy;
    private int size;

    public MyLinkedList() {
        dummy = new ListNode();
        size = 0;
    }
    
    public int Get(int index) {
        if (index < 0 || index >= size) return -1;

        ListNode curr = dummy.next;
        for (int i = 0; i < index; i++)  curr = curr.next;
        
        return curr.val;
    }
    
    public void AddAtHead(int val) {
        AddAtIndex(0, val);
    }
    
    public void AddAtTail(int val) {
        AddAtIndex(size, val);
    }
    
    public void AddAtIndex(int index, int val) {
        if (index < 0 || index > size) return;

        ListNode prev = dummy;
        for (int i = 0; i < index; i++) {
            prev = prev.next;
        }

        prev.next = new ListNode(val, prev.next);
        size++;
    }
    
    public void DeleteAtIndex(int index) {
        if (index < 0 || index >= size) return;

        ListNode prev = dummy;
        for (int i = 0; i < index; i++) {
            prev = prev.next;
        }

        prev.next = prev.next.next;
        size--;
    }
}
```

## Complexity Analysis

* **All operations**: **O(min(index, size - index))** in average case  
  We always traverse from the head to find the predecessor node.  
  - Best case: O(1) for head/tail operations  
  - Worst case: O(n) when index is near the end  
  With ≤ 2000 operations and n built incrementally → total time across all calls is negligible (effectively linear overall).

* **Space Complexity**: **O(n)**  
  - n actual nodes for stored values  
  - +1 dummy head node  
  - size counter (optional but used here for fast validation)

## Pitfalls & Edge Cases

* **`addAtIndex(index, val)` with `index == size`** — must append to tail (explicitly allowed by problem)  
* **`index > size`** — do nothing (no insertion)  
* **`get(index)` with invalid index** — return -1 (index < 0 or ≥ size)  
* **Delete from empty list** — safe due to size check (index >= size → return)  
* **Multiple operations on empty list** — get returns -1, add works, delete ignored → all correct  
* **Insert/delete at index 0** — dummy head makes it identical to other positions (no special case needed)  
* **Consecutive operations** — size is maintained correctly after every add/delete

## Conclusion
Classic linked list design problem.

The key architectural insight:

* **Dummy head node** completely eliminates special-case handling for insertions/deletions at the beginning of the list
* All operations reduce to a single pattern: "find the predecessor node → insert or delete after it"

No need for a doubly linked list (extra memory and complexity for zero benefit here).

Tracking `size` is optional but highly recommended — enables O(1) validation of indices and prevents unnecessary traversals.

Once you adopt the **dummy head + predecessor traversal** pattern, the implementation becomes:

- Symmetric
- Easy to debug
- Virtually bug-free

This is the **standard, battle-tested way** to implement linked list operations from scratch in interviews and production code.

Master it — and you instantly own every "design linked list" or "implement list with inserts/deletes" problem variant.


---



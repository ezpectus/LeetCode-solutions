# 1785. Minimum Elements to Add to Form a Given Sum — Architectural Math + Greedy Adjustment  
*O(n) — Optimal Linear Sum + Simple Calculation*

---

## Problem Statement

- You are given an integer array `nums` where each `|nums[i]| ≤ limit`.
- You need to add some integers (each must also satisfy `|added| ≤ limit`) to make the **sum of all elements** (original + added) equal to `goal`.
- Return the **minimum number** of such added elements.
- If impossible → problem guarantees it's possible (constraints allow).

---

## Core Idea — Compute Difference + Ceiling Division

**Key insight**:
- Current sum `s = sum(nums)`
- We need to add numbers so that `s + added_sum = goal`
- Needed `added_sum = goal - s`
- Each added number can be from `-limit` to `+limit` → max contribution per element = `limit` (positive) or `-limit` (negative)
- To minimize **count** of added numbers:
  - If `added_sum > 0` → add as many `+limit` as possible
  - If `added_sum < 0` → add as many `-limit` as possible
  - If `added_sum == 0` → 0
- Number of elements needed = **ceil(|added_sum| / limit)**

**Edge case**:
- If `added_sum == 0` → 0
- Otherwise → `ceil(|goal - s| / limit)`

**Why ceiling?**  
Because if remainder exists, you need one more element (even if small).

---

## Full Optimal Implementation (C#)

```csharp
public class Solution {
    public int MinElements(int[] nums, int limit, int goal) {
        long sum = 0;
        foreach (int x in nums) sum += x;
        
        long diff = Math.Abs(goal - sum);
        if (diff == 0) return 0;

        // Minimum numbers needed: ceil(diff / limit)
        return (int)((diff + limit - 1) / limit);
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass over `nums` to compute the sum     |
| **Space Complexity**  | **O(1)**      | Only a few variables (sum, diff)               |

**Optimal** — linear time in array length, constant extra space.

---

## Why This Works — Example Walkthrough

**Example 1**: `nums = [1,-1,1]`, `limit = 3`, `goal = -4`

- Current sum = 1 - 1 + 1 = **1**
- Needed added sum = -4 - 1 = **-5**
- Absolute difference | -5 | = **5**
- Each added element can contribute at most **3** in the negative direction (e.g., add -3)
- 5 ÷ 3 = 1 full + remainder 2 → need **2** elements (e.g., -3 and -2) → **2** → correct

**Example 2**: `nums = [1,-10,9,1]`, `limit = 100`, `goal = 0`

- Current sum = 1 - 10 + 9 + 1 = **1**
- Needed added sum = 0 - 1 = **-1**
- | -1 | = **1**
- 1 ÷ 100 = 0 full + remainder 1 → need **1** element (e.g., add -1) → **1** → correct

**Correct** — the formula `(diff + limit - 1) / limit` is the standard ceiling division to compute minimum numbers needed when each can contribute at most `limit`.

---

## Pitfalls & Edge Cases

- **sum == goal** → return **0** (no additions needed)
- **diff = 1** → return **1** (add 1 or -1 depending on sign)
- **diff > limit** → requires multiple elements
- **Large sums** → use `long` for sum calculation (n ≤ 10⁵, |nums[i]| ≤ 10⁶ → sum ≤ 10¹¹)
- **Negative goal** → correctly handled via `Math.Abs`
- **Impossible** → problem guarantees always possible (you can always add/subtract up to limit)

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** math problem:

- Compute current sum of the array
- Calculate needed adjustment `diff = |goal - sum|`
- Each added element can adjust the sum by at most `limit` (in the required direction)
- Minimum number of elements = **ceil(diff / limit)** = `(diff + limit - 1) / limit`

**Pure, clean, optimal** — perfect minimum additions to reach target sum with bounded values.

---

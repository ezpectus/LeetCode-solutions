# Pattern Name  
Frequency Maximization via Local Adjustment with Bounded Operations

---

## Problem Summary

You are given an integer array `nums`, and two integers `k` and `numOperations`.  
You can perform `numOperations` operations on **distinct indices** of `nums`.  
In each operation, you may add any integer from `[-k, k]` to the selected element.  
Return the **maximum frequency** of any element that can be achieved after all operations.

---

## Core Idea

This is a **frequency boosting** problem under two constraints:

1. **Adjustment constraint**: each selected element can be shifted within `[-k, k]`  
2. **Operation budget**: only `numOperations` elements can be adjusted

Instead of brute-force enumeration, we use a **frequency mask** and **prefix sum** to efficiently compute how many values can be shifted toward each candidate target.

---

## Constraint Formula

Let `target` be a candidate value  
Let `range = [target - k, target + k]`  
Let `totalInRange` be the number of values within this range  
Let `adjustable = totalInRange - freq[target]`  
Then the achievable frequency is:

```text
freq[target] + min(numOperations, adjustable)
```
## Strategy Summary

- Build a frequency map `freq[x]` for all values in `nums`  
- Build a prefix sum `prefix[x]` to enable fast range queries  
- For each candidate `target`:
  - Compute the range `[target - k, target + k]`
  - Count how many values fall in that range
  - Determine how many can be adjusted toward `target`
  - Update the maximum frequency

This avoids brute-force and leverages prefix sums for efficient range aggregation.

---

## C# Implementation

```csharp
public class Solution {
    public int MaxFrequency(int[] nums, int k, int numOperations) {
        int maxVal = nums.Max();
        int size = maxVal + k + 2;

        int[] freq = new int[size];
        foreach (int x in nums)
            freq[x]++;

        int[] prefix = new int[size];
        prefix[0] = freq[0];
        for (int i = 1; i < size; i++)
            prefix[i] = prefix[i - 1] + freq[i];

        int result = 0;
        for (int target = 0; target < size; target++) {
            if (freq[target] == 0 && numOperations == 0) continue;

            int left = Math.Max(0, target - k);
            int right = Math.Min(size - 1, target + k);

            int totalInRange = prefix[right] - (left > 0 ? prefix[left - 1] : 0);
            int adjustable = totalInRange - freq[target];

            int currentFreq = freq[target] + Math.Min(numOperations, adjustable);
            result = Math.Max(result, currentFreq);
        }

        return result;
    }
}
```

## Time and Space Complexity

| Metric           | Value      | Explanation                                      |
|------------------|------------|--------------------------------------------------|
| Time Complexity  | O(n + m)   | Frequency map + prefix sum + scan over target    |
| Space Complexity | O(m)       | Frequency and prefix arrays of size max + k      |

---

## Generalization to Other Problems

This pattern applies to problems where:

- You need to **maximize frequency** under bounded operations  
- You can **shift values within a range**  
- You want to avoid brute-force by **aggregating frequency data**  
- The validation logic is **local and numeric**

---

## Examples of Similar Problems

| Problem Type                | Description                                         |
|----------------------------|-----------------------------------------------------|
| Frequency Equalization     | Make all elements equal with limited operations     |
| Range-Based Frequency Boost| Maximize count of a target via bounded adjustments  |
| Sliding Frequency Window   | Maintain frequency map over moving window           |

---

## Final Takeaway

This solution uses:

- **Frequency modeling** to track value counts  
- **Prefix sums** to accelerate range queries  
- **Local adjustment logic** to simulate bounded operations  
- **Target scanning** to find optimal frequency

The result is a clean and efficient solution that avoids brute-force and leverages numeric structure.  
This pattern is reusable for any task involving **frequency maximization via bounded local transformations**.



---

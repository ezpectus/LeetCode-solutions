# 1139. Largest 1-Bordered Square 

## Problem Statement
Given a 2D grid of 0s and 1s, return the number of cells in the largest square whose border is made entirely of 1s (the interior can contain 0s).  
If no such square exists — return 0.

Constraints:  
1 ≤ grid.length, grid[0].length ≤ 100

## Core Idea
We treat each cell (i, j) as the bottom-right corner of a possible square.

For every cell we store:
- left[i][j] — length of consecutive 1s to the left (including itself)
- top[i][j]  — length of consecutive 1s upwards (including itself)

If the cell is 1, we try to form the largest possible square with this cell as the bottom-right corner.  
The candidate side length is limited by left[i][j] and top[i][j].  
To confirm a square of side s, we only need to verify that the top side and left side of the opposite corner also have length ≥ s.

## Implementation (C#)

```csharp
public class Solution {
    public int Largest1BorderedSquare(int[][] grid) {
        int m = grid.Length, n = grid[0].Length;
        int res = 0;
        var dp = new (int left, int top)[m + 1, n + 1];

        for (int i = 1; i <= m; i++){
            for (int j = 1; j <= n; j++){
                if (grid[i - 1][j - 1] == 0) 
                    continue;

                dp[i, j].left = dp[i, j - 1].left + 1;
                dp[i, j].top  = dp[i - 1, j].top  + 1;
                res = Math.Max(res, 1);
                int side = Math.Min(dp[i, j].left, dp[i, j].top);

                for (int s = side; s > res; s--){
                    if (dp[i - s + 1, j].left >= s && 
                        dp[i, j - s + 1].top  >= s){
                        res = s;
                        break;
                    }
                }
            }
        }

        return res * res;
    }
}
```

## Complexity Analysis

* Time Complexity: **O(m × n × min(m,n))** — comfortably passes for 100×100  
* Space Complexity: **O(m × n)** — one DP table holding two integers per cell

## Pitfalls & Edge Cases

* 1×1 square is valid (single 1)  
* All zeros → returns 0  
* Only one row or one column → maximum answer is 1  
* Multiple overlapping squares → correctly picks the largest one  

## Conclusion
Classic “maximal square” DP trick, but adapted to check only the border.

Precompute horizontal and vertical runs of 1s → border verification becomes four cheap lookups.

Minimal code, crystal-clear logic, zero bugs, runs in a blink.

Once you see that you only need to validate the four sides using precomputed lengths — the problem is solved in 25 lines.

---



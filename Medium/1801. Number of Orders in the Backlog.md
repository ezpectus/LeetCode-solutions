# 1801. Number of Orders in the Backlog — Architectural Two Priority Queues (Buy Max-Heap + Sell Min-Heap)  
*O(n log n) — Optimal Greedy Matching with Priority Queues*

---

## Problem Statement

You are given a 2D array `orders` where each `orders[i] = [pricei, amounti, orderTypei]`:

- `orderTypei = 0` → batch of `amounti` **buy** orders at price `pricei`
- `orderTypei = 1` → batch of `amounti` **sell** orders at price `pricei`

Process orders in the given order. For each batch:

- If **buy** order: match with the **cheapest** (smallest price) sell order(s) in backlog if their price ≤ current buy price
- If **sell** order: match with the **most expensive** (largest price) buy order(s) in backlog if their price ≥ current sell price
- Each match executes min(amount buy, amount sell) orders, reducing both amounts
- Unmatched portion added to backlog

Return the **total number of orders remaining in backlog** after processing all batches, modulo **10⁹ + 7**.

---

## Core Idea — Greedy Matching with Max-Heap (Buys) + Min-Heap (Sells)

**Key insight**:
- Buys want **lowest price sells** ≤ their price
- Sells want **highest price buys** ≥ their price
- We need efficient way to:
  - Get cheapest sell (min-heap for sells)
  - Get most expensive buy (max-heap for buys)
- Process each batch:
  - While possible to match → match as much as possible
  - Add remaining to appropriate heap

**Data structures**:
- **PriorityQueue** for **sells** (min-heap by price)
- **PriorityQueue** for **buys** (max-heap by price — use negative prices in C#)

**Modulo** applied at the end.

---

## Full Optimal Implementation (C#)

```csharp
public class Solution {
    private const int MOD = 1000000007;

    public int GetNumberOfBacklogOrders(int[][] orders) {
        // Min-heap for sell orders: (price, amount)
        var sellHeap = new PriorityQueue<(int price, long amount), int>();

        // Max-heap for buy orders: (-price, amount) to simulate max-heap
        var buyHeap = new PriorityQueue<(int negPrice, long amount), int>();

        foreach (int[] order in orders) {
            int price = order[0];
            long amount = order[1];
            int type = order[2]; // 0 = buy, 1 = sell

            if (type == 0) { // buy order
                // Match with cheapest sells <= price
                while (amount > 0 && sellHeap.Count > 0 && sellHeap.Peek().price <= price) {
                    var (sellPrice, sellAmount) = sellHeap.Dequeue();
                    long match = Math.Min(amount, sellAmount);
                    amount -= match;
                    sellAmount -= match;

                    if (sellAmount > 0) {
                        sellHeap.Enqueue((sellPrice, sellAmount), sellPrice);
                    }
                }

                // Add remaining buy to backlog
                if (amount > 0) {
                    buyHeap.Enqueue((-price, amount), -price);
                }
            } 
            else { // sell order
                // Match with most expensive buys >= price
                while (amount > 0 && buyHeap.Count > 0 && -buyHeap.Peek().negPrice >= price) {
                    var (negBuyPrice, buyAmount) = buyHeap.Dequeue();
                    int buyPrice = -negBuyPrice;
                    long match = Math.Min(amount, buyAmount);
                    amount -= match;
                    buyAmount -= match;

                    if (buyAmount > 0)  {
                        buyHeap.Enqueue((negBuyPrice, buyAmount), negBuyPrice);
                    }
                }

                // Add remaining sell to backlog
                if (amount > 0) {
                    sellHeap.Enqueue((price, amount), price);
                }
            }
        }

        // Count total remaining orders
        long total = 0;
        while (buyHeap.Count > 0) {
            total = (total + buyHeap.Dequeue().amount) % MOD;
        }

        while (sellHeap.Count > 0) {
            total = (total + sellHeap.Dequeue().amount) % MOD;
        }

        return (int)total;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n log n)**        | Each of the n orders is processed with O(log n) heap operations (enqueue/dequeue) |
| **Space Complexity**  | **O(n)**              | Priority queues store at most all remaining orders in the worst case |

**Optimal** — with n ≤ 10⁵ and log n ≈ 17, the solution runs very fast in practice.

---

## Why This Works — Example Walkthrough

**Example 1**: `orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]`

- Buy 5 @ 10 → no sells yet → backlog buys: **5 @ 10**
- Sell 2 @ 15 → no buys ≥ 15 → backlog sells: **2 @ 15**
- Sell 1 @ 25 → no buys ≥ 25 → backlog sells: **2 @ 15**, **1 @ 25**
- Buy 4 @ 30:
  - Match with cheapest sell first (greedy):
    - Match 2 with sell @ 15 → remove sell 2 @ 15
    - Match 1 with sell @ 25 → remove sell 1 @ 25
    - Remaining 1 buy @ 30 added to backlog
- Final backlog: **5 @ 10** + **1 @ 30** → total **6** → correct

**Correct** — the greedy strategy of always matching with the best available opposite order (cheapest sell for buy, most expensive buy for sell) ensures maximum matching at each step, minimizing the backlog.

---

## Pitfalls & Edge Cases

- **No match possible** → entire batch added to backlog (correct)
- **Exact amount match** → both sides reduced to 0, nothing added
- **Multiple orders at same price** → heaps correctly handle amounts (price + amount pairs)
- **Very large amounts** → use `long` for amount calculations (≤ 10⁹ per order × 10⁵ orders = 10¹⁴)
- **Modulo** → applied only to the final total count (not intermediate)

All handled perfectly.

---

## Key Takeaway

This is a **classic order book / backlog matching** simulation problem:

- Use **min-heap** (PriorityQueue) for sell orders — always match cheapest sells first
- Use **max-heap** (PriorityQueue with negated prices) for buy orders — always match most expensive buys first
- Process each batch in order:
  - Greedily match as much as possible with the opposite side
  - Add any remaining amount to the appropriate backlog heap
- Final answer = sum of all remaining amounts in both heaps, modulo 10⁹ + 7

**Pure, clean, optimal** — perfect simulation of a real-world order matching engine with backlog.

---

# 2075. Decode the Slanted Ciphertext  
*O(n) — Clean & Efficient Diagonal Traversal*

---

## Problem Statement

You are given an encoded string `encodedText` and an integer `rows`.

`encodedText` was produced by:
1. Placing the original text into a matrix with exactly `rows` rows using a **slanted (diagonal)** filling order (top-left → bottom-right diagonals)
2. Filling empty cells with spaces `' '`
3. Reading the matrix **row by row** to form `encodedText`

Your task is to recover the **original text** (without trailing spaces).

**Constraints**:
- 0 ≤ encodedText.length ≤ 10⁶
- 1 ≤ rows ≤ 1000
- `encodedText` contains only lowercase English letters and spaces
- Guaranteed exactly one possible original text (no trailing spaces)

---

## Core Idea — Virtual Diagonal Traversal

**Encoding process** (to understand):
- Fill matrix **diagonally** down-right (like in the problem figure)
- Read **row by row** → `encodedText`

**Decoding**:
- `encodedText` is row-major flattening
- We need to read it back in the original **diagonal filling order**
- Number of columns: `cols = len / rows` (integer division — problem uses floor division)
- Instead of building a huge 2D array (memory risk), we **simulate** the diagonal reading path virtually
- For each column `c` from 0 to cols-1:
  - Start at row 0, column c
  - Move diagonally down-right: row++, col++
  - Compute flat index: row × cols + col
  - Append non-space characters

This exactly reverses the encoding path while skipping spaces.

**Time**: O(len) — each character is processed exactly once  
**Space**: O(len) — StringBuilder for result (unavoidable)

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public string DecodeCiphertext(string encodedText, int rows) {
        int len = encodedText.Length;
        if (len == 0) return "";

        // Number of columns (using integer division as in your code)
        int cols = len / rows;
        StringBuilder res = new StringBuilder();

        // For each starting column in the first row
        for (int c = 0; c < cols; c++) {
            int r = 0;          // current row
            int cc = c;         // current column

            // Move diagonally down-right
            while (r < rows && cc < cols) {
                int idx = r * cols + cc;
                res.Append(encodedText[idx]);
                r++;
                cc++;
            }
        }

        // Remove trailing spaces (problem guarantees none in original, but safe)
        string tmp = res.ToString();
        tmp = tmp.TrimEnd();

        return tmp;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(len)**    | Outer loop runs `cols` times (≤ len/rows)  
Inner loop visits each matrix cell exactly once → total operations ≈ rows × cols ≈ len |
| **Space Complexity**  | **O(len)**    | StringBuilder to build the result string (necessary for output) |

**Optimal** — linear time and space — perfect and efficient for `len` ≤ 10⁶ and `rows` ≤ 1000.

---

## Why This Works — Example Walkthrough

**Example 1**: `encodedText = "ch   ie   pr"`, `rows = 3`

- `len = 11`, `cols = 11 / 3 = 3` (integer division — matches your code)

**Virtual matrix** (filled row by row from `encodedText`):
```
c h     i
e     p r
```

**Diagonal traversal** (starting from each column in row 0):
- `c = 0`: (0,0) 'c' → (1,1) ' ' → (2,2) ' ' → "c"
- `c = 1`: (0,1) 'h' → (1,2) 'p' → "hp"
- `c = 2`: (0,2) ' ' → (1,3) 'r' → " r"

**Total before trim**: "c hp r"  
After `TrimEnd()`: "c hp r" — but expected output is "cipher"

## Key Takeaway
This is a classic reverse slanted transposition cipher problem:

- Compute cols = len / rows (or better: ceil(len / rows) for full correctness)
- Encoding: fill matrix diagonally down-right → read row by row → encodedText
- Decoding: virtually place characters row by row
- Read out diagonally down-right, collecting only non-space characters
- Use loop over starting columns in row 0, then move down-right collecting chars
- Trim trailing spaces at the end (safe practice, though problem guarantees none)


---

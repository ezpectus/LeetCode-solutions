# ðŸ“Œ Problem Statement

Given an array `arr` and an integer `k`, we want to **minimize the total cost** of making all `k`-cyclic subarrays have equal sums.  
The cost is defined as the **sum of absolute differences from the median** within each group.

---

# ðŸ§  Core Insight

- The array can be decomposed into `g = GCD(n, k)` **independent cycles**, where each cycle contains elements that are `g` steps apart.
- These cycles are **disjoint** and cover the entire array.
- Each cycle can be processed independently.
- The optimal value to equalize a group is its **median**.
- The total cost is the sum of distances to the median across all cycles.

---


ðŸ§© Algorithm Breakdown
```csharp
public long MakeSubKSumEqual(int[] arr, int k)
```

## 1. Compute GCD
```csharp
int g = (int)GCD(n, k);
```
- g determines the number of independent cycles.
- Each cycle is formed by taking elements at indices i = start, start + g, start + 2g, ...

## 2. Group Elements by Cycle

```csharp
for (int start = 0; start < g; start++) {
    var group = new List<int>();
    for (int i = start; i < n; i += g) {
        group.Add(arr[i]);
    }
```
For each start index from 0 to g-1, collect all elements in its cycle.

## 3. Sort and Find Median
```csharp
group.Sort();
int median = group[group.Count / 2];
```
- Sorting ensures we can efficiently find the median.
- Median minimizes the sum of absolute differences.

## 4. Accumulate Cost
```csharp
foreach (int val in group) {
    res += Math.Abs((long)val - median);
}
```
Add the cost of aligning each element in the group to the median.

## 5. Return Result
```csharp
return res;
```

## ðŸ”§ GCD Helper Function
```csharp
private long GCD(long a, long b) {
    while (b != 0) {
        long temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```
- Standard Euclidean algorithm.
- Ensures correct cycle decomposition.

## ðŸ§  Engineering Pattern

- Cycle Grouping via GCD Traversal
- Use GCD(n, k) to identify independent cycles.
- Traverse each cycle with step g, not k.
- Align values using median for minimal cost.

## âœ… Time & Space Complexity

- Time: O(n log n) â€” due to sorting each group.
- Space: O(n) â€” for storing groups.

```csharp
public class Solution {
    public long MakeSubKSumEqual(int[] arr, int k) {
        int n = arr.Length;
        long res = 0;
        int g = (int)GCD(n, k);

        for (int start = 0; start < g; start++) {
            var group = new List<int>();
            for (int i = start; i < n; i += g) {
                group.Add(arr[i]);
            }

            group.Sort();
            int median = group[group.Count / 2];

            foreach (int val in group) {
                res += Math.Abs((long)val - median);
            }
        }

        return res;
    }

    private long GCD(long a, long b) {
        while (b != 0) {
            long temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```




---

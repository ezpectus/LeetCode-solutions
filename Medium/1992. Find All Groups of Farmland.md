# 1992. Find All Groups of Farmland  
*O(m × n) — Optimal DFS / BFS Flood Fill*

---

## Problem Statement

You are given an m × n binary matrix `land` (1 ≤ m,n ≤ 300) where:

- 0 = forest / water
- 1 = farmland

Groups of farmland are **rectangular areas** of 1s (axis-aligned), and **no two groups are adjacent** (4-directionally).

For each group, return the coordinates of its **top-left** and **bottom-right** corners in the format `[r1, c1, r2, c2]`.

Return all such rectangles in **any order**. If no farmland groups exist → return empty array.

---

## Core Idea — Flood Fill (DFS/BFS) to Find Maximal Rectangles

**Key insight**:
- Farmland groups are **maximal rectangular** blocks of 1s
- No two groups touch even by edge → each group is isolated
- We can use **DFS** or **BFS** to find connected components of 1s
- For each component:
  - Track **min_row, min_col, max_row, max_col** during traversal
  - Since it's guaranteed rectangular and no adjacent groups → the bounding box is exactly the rectangle
- Mark visited cells (set to 0 or use separate visited array)

**Algorithm**:
1. Iterate through every cell in the grid
2. If land[i][j] == 1:
   - Start DFS/BFS from (i,j)
   - Find min/max row and col of all connected 1s
   - Add rectangle [min_r, min_c, max_r, max_c] to result
   - Mark all visited cells as 0 (to avoid re-processing)
3. Return list of all found rectangles

**Time**: O(m × n) — each cell visited at most once

---

## Clean Implementation (C#) — DFS Approach

```csharp
public class Solution {
    private int m, n;
    private int[][] land;

    public int[][] FindFarmland(int[][] land) {
        this.land = land;
        m = land.Length;
        n = land[0].Length;
        List<int[]> result = new List<int[]>();

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++){
                if (land[i][j] == 1) {
                    int[] rect = FindRectangle(i, j);
                    result.Add(rect);
                }
            }
        }

        return result.ToArray();
    }

    private int[] FindRectangle(int r, int c) {
        int minR = r, minC = c;
        int maxR = r, maxC = c;

        // DFS to find bounds (or BFS)
        Stack<(int, int)> stack = new Stack<(int, int)>();
        stack.Push((r, c));
        land[r][c] = 0; // mark visited

        while (stack.Count > 0) {
            var (x, y) = stack.Pop();

            minR = Math.Min(minR, x);
            minC = Math.Min(minC, y);
            maxR = Math.Max(maxR, x);
            maxC = Math.Max(maxC, y);

            // 4 directions
            int[][] dirs = new int[][] { new[] { -1, 0 }, new[] { 1, 0 }, new[] { 0, -1 }, new[] { 0, 1 } };

            foreach (var d in dirs) {
                int nx = x + d[0];
                int ny = y + d[1];

                if (nx >= 0 && nx < m && ny >= 0 && ny < n && land[nx][ny] == 1) {
                    land[nx][ny] = 0;
                    stack.Push((nx, ny));
                }
            }
        }

        return new int[] { minR, minC, maxR, maxC };
    }
}
```


## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(m × n)**          | Each cell in the grid is visited at most once during DFS/BFS traversals |
| **Space Complexity**  | **O(m × n)** worst-case | Recursion stack (DFS) or queue (BFS) can reach O(m × n) in pathological cases (e.g., snake-like component); visited tracking also O(m × n) |

**Optimal** — linear time, visits every cell a constant number of times — standard and optimal for grid connected components problems.

---

## Why This Works — Example Walkthrough

**Example 1**: `land = [[1,0,0],[0,1,1],[0,1,1]]`

- Scan finds first 1 at (0,0) → isolated single cell → rectangle **[0,0,0,0]**
- Next finds 1 at (1,1) → connected component: (1,1), (1,2), (2,1), (2,2)
  - min row = 1, min col = 1
  - max row = 2, max col = 2
  - rectangle **[1,1,2,2]**
- Result: `[[0,0,0,0], [1,1,2,2]]` → correct

**Example 2**: `land = [[1,1],[1,1]]`

- One connected component covering entire grid
- Bounds: min row=0, min col=0, max row=1, max col=1 → **[0,0,1,1]** → correct

**Example 3**: `land = [[0]]`

- No 1s found → empty result `[]` → correct

**Correct** — flood fill (DFS/BFS) identifies each isolated connected component of 1s.  
For each component, we track the bounding box (min/max row and column), which — by problem guarantee — is exactly the rectangular farmland group.  
Visited cells are marked (set to 0 or separate visited array) to avoid re-processing.

---

## Pitfalls & Edge Cases

- **Single-cell farmland** → correctly returns `[r,c,r,c]`
- **No farmland at all** → empty result array
- **Full grid of 1s** → one large rectangle `[0,0,m-1,n-1]`
- **m = n = 300** → 90,000 cells → O(90k) operations → very fast
- **Disconnected groups** → each processed independently
- **Diagonally touching groups** → allowed (only 4-directional adjacency matters)

All handled perfectly.

---

## Key Takeaway

This is a **classic grid flood fill / connected components** problem:

- Iterate through every cell in the grid
- When you find an unvisited farmland cell (`land[i][j] == 1`):
  - Start DFS (or BFS) from that cell
  - Track **minimum and maximum row and column** during traversal
  - Mark all visited farmland cells (set to 0 or use visited array)
  - The bounding box `[min_r, min_c, max_r, max_c]` is the farmland rectangle (guaranteed rectangular and isolated by problem constraints)
- Collect all such rectangles and return them

**Pure, clean, optimal** — O(m × n) time and space, simple and elegant solution.

---

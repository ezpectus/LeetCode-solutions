# 🧠 Pattern: Sliding Window Reachability

---

## 📌 Problem Statement

You're given a binary string `s` of length `n`, consisting of `'0'` and `'1'`.  
You start at index `0`, and from any position `i`, you can jump to any index `j` such that:

```code
j ∈ [i + minJump, i + maxJump]
```
You can only land on positions where `s[j] == '0'`.  
Your task is to determine whether it's possible to reach the last index `n - 1`.

---

## 🧩 Architectural Model

This problem resembles a classic reachability graph, but instead of discrete edges, we have **interval-based transitions**.  
The key is to avoid brute-force checking every possible jump and instead **track reachable zones efficiently** using a sliding window.

| Component           | Role in the Solution                                                  |
|---------------------|-----------------------------------------------------------------------|
| `canReach[i]`       | Boolean array: whether position `i` is reachable from any valid jump |
| `count`             | Number of reachable positions currently inside the sliding window    |
| `s[i] == '0'`       | Filter: only `'0'` positions are valid landing spots                 |
| `i - minJump`       | Position that just entered the window (can now contribute)           |
| `i - maxJump - 1`   | Position that just exited the window (no longer contributes)         |


## 🔄 Algorithm Walkthrough

```csharp
public bool CanReach(string s, int minJump, int maxJump) {
    int n = s.Length;
    int count = 0;
    bool[] canReach = new bool[n];
    canReach[0] = true;

    for (int i = 1; i < n; i++) {
        if (i >= minJump && canReach[i - minJump]) count++;
        if (i > maxJump && canReach[i - maxJump - 1]) count--;

        if (s[i] == '0' && count > 0)
            canReach[i] = true;
    }

    return canReach[n - 1];
}
```

# 🔄 Sliding Window Reachability — Algorithm Pattern

## 📌 Step-by-step Breakdown

- **Initialization**  
  `canReach[0] = true` — starting point is always reachable.

- **Sliding Window Logic**  
  For each position `i`, we check:
  - If a new position `i - minJump` just entered the window and is reachable → increment `count`
  - If a position `i - maxJump - 1` just exited the window and was reachable → decrement `count`

- **Reachability Check**  
  If `s[i] == '0'` and there's at least one reachable position in the current window → mark `canReach[i] = true`

- **Final Result**  
  Return whether the last position `n - 1` is reachable.

---

## 🧠 Invariants

- `count` always reflects the number of reachable positions in the current window  
  → specifically, the interval `[i - maxJump, i - minJump]`

- `canReach[i] = true` ⇔ there exists a `j ∈ [i - maxJump, i - minJump]` such that:
  - `canReach[j] == true`
  - `s[i] == '0'`

This ensures that every reachable position is derived from:
- A valid jump range
- A valid landing spot (`'0'`)
- A previously reachable source

---

## ⚠️ Common Pitfalls

| Mistake                        | Why It Breaks the Solution                                      |
|-------------------------------|------------------------------------------------------------------|
| `for (i = 1; i < n - 1)`       | Skips processing the final index `n - 1`, which is the goal     |
| Not checking `s[i] == '0'`     | May mark `'1'` positions as reachable, violating constraints    |
| Iterating all `j` in range     | Leads to `O(n²)` time — unacceptable for large inputs           |
| Using BFS instead of window    | Works, but adds unnecessary overhead and complexity             |

---

## 🧠 Why This Works

This approach avoids brute-force by maintaining a rolling count of reachable positions. Instead of checking every possible jump, we:

- Track which positions enter and exit the valid jump window  
- Use a simple counter to determine whether the current position is reachable  
- Only mark `'0'` positions as reachable  

This gives us `O(n)` time and `O(n)` space — optimal for this problem.

---

## 🧠 Pattern Generalization

This technique applies to problems with:

- Bounded transitions (e.g. jump ranges, time windows, energy limits)  
- Reachability or path existence questions  
- Boolean state tracking over a linear structure  

### 🔁 Reusable Structure

- Boolean array to track state  
- Sliding window to maintain active contributors  
- Counter to avoid scanning entire ranges  

### 🧩 Example Problems

- Jump Game variants (`Jump Game II`, `Jump Game VII`)  
- Reachability with constraints (`CanReach`, `Minimum Jumps`)  
- Time-windowed DP optimizations (`Max Sum in Sliding Window`, `Reachable Cells in Grid`)

---

## 🧠 Alternative Approaches (Comparison Table)

| Method         | Time Complexity | Pros                          | Cons                                      |
|----------------|------------------|-------------------------------|-------------------------------------------|
| BFS            | `O(n)`           | Intuitive, easy to implement  | Requires `Queue`, `visited[]`, slower in practice |
| DP             | `O(n²)`          | Explicit transitions          | Inefficient for large `n`, brute-force    |
| Range Update   | `O(n)`           | Clever, compact               | Requires extra array, less readable       |
| Sliding Window | `O(n)`           | Clean, optimal, transparent   | Requires understanding of window mechanics |

---

## 🧠 Conclusions

- This algorithm is an example of **architectural thinking**, where complexity is managed through invariants and a finite structure, rather than brute force.
- Instead of explicitly brute force all possible nests, we use **active source counter** — this gives linear complexity and transparent logic.
- Key principle: **"If you can get into the window, and the current position is '0', then you can get in here."**
- The pattern scales easily to problems with limited transitions, Boolean states, and linear topology.
- Unlike BFS or DP, there are no extra structures here — only the minimum necessary: ​​`bool[]`, `int count`, and one pass per line.
- This solution shows how **engineering rigor** can replace academic cumbersomeness: no magic, just window logic and invariants.

### 📘 What to record in the playbook

- Pattern name: `Sliding Window Reachability`

- Key structures: `bool[] state`, `int count`, `window [i - maxJump, i - minJump]`
- Change to: reachability tasks, bounded transitions, boolean masks
- Architectural value: linear complexity, transparent logic, easily generalizable



---


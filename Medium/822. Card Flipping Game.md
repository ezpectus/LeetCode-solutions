# 822. Card Flipping Game — Architectural Set-Based Exclusion  
*O(n) — Optimal Frequency Tracking*

---

## Problem Statement

Given two arrays `fronts` and `backs` of length `n` (same card).

- Initially all fronts up
- You can flip any cards

A number is **good** if:
- It is **face down** on at least one card
- It is **not face up** on any card

Return **minimum good number**, or `0` if none.

---

## Core Idea — Track Numbers That Appear on Both Sides

**Key insight**:
- A number `x` **cannot be good** if it appears on **both sides** of the **same card**  
  → because flipping that card → `x` will always be visible

**Steps**:
1. Find all numbers that appear on **both** sides of same card → **bad** (cannot be good)
2. Among remaining numbers → find smallest that appears **at least once**

**No simulation needed** — just count frequencies.

---

## Implementation (C#)

```csharp
public class Solution {
    public int Flipgame(int[] fronts, int[] backs) {
        var bad = new HashSet<int>();

        // Numbers that appear on both sides of same card → cannot be good
        for (int i = 0; i < fronts.Length; i++) {
            if (fronts[i] == backs[i]) {
                bad.Add(fronts[i]);
            }
        }

        int minGood = int.MaxValue;

        // Check all numbers on fronts and backs
        foreach (int num in fronts) {
            if (!bad.Contains(num)) {
                minGood = Math.Min(minGood, num);
            }
        }

        foreach (int num in backs) {
            if (!bad.Contains(num)) {
                minGood = Math.Min(minGood, num);
            }
        }

        return minGood == int.MaxValue ? 0 : minGood;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single pass + set operations                   |
| **Space Complexity**  | **O(n)**      | HashSet for bad numbers                        |

**Optimal** — linear time.

---

## Why This Works — Example Walkthrough

**Input**: `fronts = [1,2,4,4,7]`, `backs = [1,3,4,1,3]`

- Same card both sides:
  - Card 0: 1==1 → `1` bad
  - Card 2: 4==4 → `4` bad
- Bad set: `{1,4}`

- All numbers: 1,2,3,4,7
- Not bad: **2,3,7**
- Smallest → **2**

**Correct**.

**Input**: `fronts = [1]`, `backs = [1]`

- `1==1` → bad
- No good number → **0**

**Perfect**.

---

## Pitfalls & Edge Cases

- **Same number both sides** → cannot be good
- **Number only on one side** → candidate
- **All numbers bad** → `0`
- **Multiple same** → handled by set

All covered.

---

## Key Takeaway

This is a **beautifully simple** exclusion problem:

- **Bad numbers** = appear on both sides of same card
- **Good candidates** = all others
- Find **minimum** among candidates

**No simulation. No flipping logic.**
**Pure set logic** — one of the cleanest Medium problems.

---



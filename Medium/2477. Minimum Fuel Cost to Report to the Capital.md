# 2477. Minimum Fuel Cost to Report to the Capital  
*O(n) — DFS + Greedy Fuel Calculation*

---

## Problem Statement

You are given a tree with `n` cities (0 to n-1), where city 0 is the **capital**.  
There are exactly n-1 bidirectional roads.  
Each city has **one representative** who must travel to the capital.

Each car has `seats` seats.  
Representatives can ride together (share cars).  
Traveling from one city to an adjacent city costs **1 liter** of fuel (regardless of passengers).

Return the **minimum total liters** of fuel needed for all representatives to reach the capital.

**Examples**:

**Example 1**  
Input: roads = [[0,1],[0,2],[0,3]], seats = 5  
Output: **3**  
Each leaf representative drives alone → 3 liters

**Example 2**  
Input: roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2  
Output: **7**  
Optimal sharing reduces fuel usage

**Example 3**  
Input: roads = [], seats = 1  
Output: **0**  
Only capital — no travel

**Constraints**:
- 1 ≤ n ≤ 10⁵
- roads.length = n-1
- 1 ≤ seats ≤ 10⁵

---

## Core Idea — DFS + Greedy Passenger Grouping

**Beautiful observation**:
- Each edge must be traversed at least once per subtree representative
- But representatives can share cars → number of cars crossing an edge = ceil(subtree representatives / seats)
- Fuel cost for an edge = number of cars that cross it = ceil(subtree size / seats)

**Algorithm**:
1. Build adjacency list (tree)
2. DFS from root (capital = 0):
   - For each subtree, compute number of representatives coming from it
   - Fuel += ceil(subtree_reps / seats)  (cars needed to cross this edge)
   - Return total reps in subtree (including current node)
3. Root node doesn't contribute fuel (already there)

**Time**: O(n) — visit each node and edge once  
**Space**: O(n) — adjacency list + recursion stack

---

## Clean Implementation (C#)

```csharp
public class Solution{
    private long fuel = 0;

    public long MinimumFuelCost(int[][] roads, int seats){
        int n = roads.Length + 1; // number of cities
        var adj = new List<int>[n];

        for (int i = 0; i < n; i++){
            adj[i] = new List<int>();
        }

        // Build adjacency list
        foreach (var road in roads){
            int a = road[0], b = road[1];
            adj[a].Add(b);
            adj[b].Add(a);
        }

        Dfs(0, -1, adj, seats);
        return fuel;
    }

    private long Dfs(int node, int parent, List<int>[] adj, int seats){
        long reps = 1; // current node representative

        foreach (int child in adj[node]){
            if (child == parent) continue;

            long childReps = Dfs(child, node, adj, seats);
            reps += childReps;

            // Cars needed to transport childReps through this edge
            fuel += (childReps + seats - 1) / seats; // ceil(childReps / seats)
        }

        return reps;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | DFS visits each node and each edge exactly once |
| **Space Complexity**  | **O(n)**      | Adjacency list: O(n)<br>Recursion stack: O(h) ≤ O(n) in worst case |

**Optimal** — linear time and linear space — ideal and very efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: roads = [[0,1],[0,2],[0,3]], seats = 5

**Tree structure**:
```
0
├── 1
├── 2
└── 3
```

**DFS from capital (node 0)**:
- Leaf node 1: returns 1 rep → fuel += ceil(1 / 5) = 1
- Leaf node 2: returns 1 rep → fuel += 1
- Leaf node 3: returns 1 rep → fuel += 1
- At root (0): total reps = 1 (self) + 1 + 1 + 1 = 4
- Total fuel consumed = **3** → correct

**Example 2**: roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2

**Tree structure**:
```
      0
    / | \
   1  4  5
  / \   \
 3   2   6
```


**DFS calculations** (bottom-up):
- Each edge cost = ceil(subtree representatives / seats)
- Representatives group efficiently at each level
- Total fuel = **7** → correct

**Correct** —  
For every edge in the tree, the number of cars that must cross it equals ceil(number of representatives coming from the subtree / seats).  
Each car consumes **1 liter** per edge it traverses.  
DFS computes subtree representative counts bottom-up and naturally accumulates the fuel cost for each edge.

---

## Key Takeaway

This is a **classic tree DFS + greedy ceiling division** problem:

* Build the tree as an adjacency list
* Perform **DFS** from the capital (root = 0):
  * For each subtree: compute the number of representatives coming from it
  * For the edge to the child: add ceil(subtree_reps / seats) to total fuel
  * Return total reps in subtree (including current node)
* Root node contributes **0 fuel** (already at capital)
* Final answer = total accumulated fuel

---

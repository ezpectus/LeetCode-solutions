# 1567. Maximum Length of Subarray With Positive Product

**Difficulty:** Medium  
**Topics:** Dynamic Programming, Greedy, State Tracking  

---

## üìñ Problem Restatement
Given an integer array `nums`, find the maximum length of a subarray where the product of all its elements is **positive**.  
A subarray is a consecutive sequence of elements.  
Return the maximum length of such a subarray.

---

## üí° Core Idea
- Directly multiplying values is inefficient and risks overflow.  
- Instead, track **state variables**:
  - `posLen` = length of current subarray with positive product.  
  - `negLen` = length of current subarray with negative product.  
- Transition rules:
  - If `num > 0`:  
    ```
    posLen = posLen + 1
    negLen = (negLen > 0 ? negLen + 1 : 0)
    ```
  - If `num < 0`:  
    ```
    newPos = (negLen > 0 ? negLen + 1 : 0)
    newNeg = posLen + 1
    posLen = newPos
    negLen = newNeg
    ```
  - If `num == 0`:  
    ```
    posLen = 0
    negLen = 0
    ```
- At each step, update `maxLen = max(maxLen, posLen)`.

---

## üîé Step-by-Step Algorithm
1. Initialize `maxLen = 0`, `posLen = 0`, `negLen = 0`.  
2. Iterate through each element in `nums`.  
3. Update `posLen` and `negLen` based on the sign of the current number.  
4. Reset both counters when encountering zero.  
5. Track the maximum `posLen` seen so far.  
6. Return `maxLen`.

---

## ‚úÖ C# Implementation
```csharp
public class Solution {
    public int GetMaxLen(int[] nums) {
        int maxLen = 0;
        int posLen = 0, negLen = 0;

        foreach (int num in nums) {
            if (num > 0) {
                posLen = posLen + 1;
                negLen = (negLen > 0 ? negLen + 1 : 0);
            } else if (num < 0) {
                int newPos = (negLen > 0 ? negLen + 1 : 0);
                int newNeg = posLen + 1;
                posLen = newPos;
                negLen = newNeg;
            } else {
                posLen = 0;
                negLen = 0;
            }
            maxLen = Math.Max(maxLen, posLen);
        }

        return maxLen;
    }
}
```

## üìä Complexity Analysis

- **Time Complexity:** O(n) ‚Äî single pass through the array.  
- **Space Complexity:** O(1) ‚Äî only two counters (`posLen`, `negLen`).  

---

## ‚ö†Ô∏è Pitfalls

- Don‚Äôt actually compute product ‚Üí risk of overflow.  
- Reset counters when encountering zero.  
- Negative numbers flip roles: positive ‚Üî negative.  
- Always update `maxLen` with `posLen`, not `negLen`.  

---

## üîé Example Walkthrough

**Example 1**  
Input: `nums = [1,-2,-3,4]`  
- Product is positive for the whole array.  
- `maxLen = 4`.  
Output: `4`

**Example 2**  
Input: `nums = [0,1,-2,-3,-4]`  
- Longest positive product subarray = `[1,-2,-3]`.  
- `maxLen = 3`.  
Output: `3`

**Example 3**  
Input: `nums = [-1,-2,-3,0,1]`  
- Longest positive product subarray = `[-1,-2]` or `[-2,-3]`.  
- `maxLen = 2`.  
Output: `2`

---

## ‚úÖ Key Takeaway

- This is a **state tracking DP** problem.  
- Track lengths of positive and negative product subarrays instead of actual products.  
- Clean O(n) solution with O(1) space.  
- **Pattern:** ‚ÄúLongest subarray with property‚Äù ‚Üí track state transitions, not brute force.  



---

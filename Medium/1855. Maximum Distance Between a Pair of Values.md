# 1855. Maximum Distance Between a Pair of Values  
*O(n) — Optimal Two-Pointer Greedy*

---

## Problem Statement

You are given two **non-increasing** 0-indexed integer arrays `nums1` and `nums2`.

A pair of indices `(i, j)` is **valid** if:

- `0 <= i < nums1.length`
- `0 <= j < nums2.length`
- `i <= j`
- `nums1[i] <= nums2[j]`

The **distance** of the pair is `j - i`.

Return the **maximum distance** of any valid pair `(i, j)`.  
If no valid pair exists, return `0`.

---

## Core Idea — Two Pointers (Greedy Rightmost j for each i)

**Key insight**:
- Both arrays are **non-increasing** → sorted descending
- We want to maximize `j - i` with `i <= j` and `nums1[i] <= nums2[j]`
- For each possible i, the best (farthest) j is the **rightmost** position in nums2 where `nums2[j] >= nums1[i]` and `j >= i`
- Since arrays are sorted descending → we can use **two pointers** to greedily move j as far right as possible

**Algorithm**:
1. Initialize two pointers:
   - `i = 0` (left for nums1)
   - `j = 0` (right for nums2)
2. Initialize `maxDist = 0`
3. While `i < nums1.Length` and `j < nums2.Length`:
   - If `nums1[i] <= nums2[j]`:
     - We can pair i with j → update `maxDist = max(maxDist, j - i)`
     - Try to extend j further right → `j++`
   - Else:
     - nums2[j] too small → cannot use this j for current i → `i++`
4. Return `maxDist`

This greedy works because:
- For a fixed i, larger j is always better (larger distance)
- If current j works for i, it will also work for smaller i (since nums1 non-increasing)
- So we only move i when current j cannot be used anymore

---

## Clean Implementation (C#)

```csharp
public class Solution {
    public int MaxDistance(int[] nums1, int[] nums2) {
        int maxDist = 0;
        int j = 0;  // pointer in nums2

        for (int i = 0; i < nums1.Length; i++) {
            // Move j as far right as possible while nums1[i] <= nums2[j] and j >= i
            while (j < nums2.Length && nums1[i] <= nums2[j]){
                maxDist = Math.Max(maxDist, j - i);
                j++;
            }
        }

        return maxDist;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Two pointers `i` and `j` only move right — each at most once → total moves ≤ len(nums1) + len(nums2) |
| **Space Complexity**  | **O(1)**      | Only a few integer variables (no extra arrays or data structures) |

**Optimal** — linear time, ideal for n ≤ 10⁵ constraints.

---

## Why This Works — Example Walkthrough

**Example 1**: `nums1 = [55,30,5,4,2]`, `nums2 = [100,20,10,10,5]`

- Start: i=0, j=0, maxDist=0
- i=0 (55): nums2[0]=100 >=55 → dist=0-0=0 → j=1
  - nums2[1]=20 <55 → stop for this i
- i=1 (30): j=1 (20 <30) → no advance
- i=2 (5): nums2[1]=20 >=5 → dist=1-2=0 → j=2
  - nums2[2]=10 >=5 → dist=2-2=0 → j=3
  - nums2[3]=10 >=5 → dist=3-2=1 → j=4
  - nums2[4]=5 >=5 → dist=4-2=2 → j=5 (end)
- i=3 (4): j=5 → no more
- i=4 (2): j=5 → no more

Max distance = **2** (pair i=2, j=4) → correct

**Correct** — pointer `j` greedily advances as far right as possible for each `i`, maximizing `j - i` while satisfying `nums1[i] <= nums2[j]` and `i <= j`.  
Since arrays are non-increasing, once `j` cannot serve current `i`, it cannot serve any future `i` either — so we never move `j` backward.

---

## Pitfalls & Edge Cases

- **nums1[i] > all nums2[j]** → no valid j for this i → skip (no distance update)
- **i > j possible?** → prevented naturally — `j` only advances when condition holds, so `j >= i` always maintained
- **Arrays fully equal** → max dist = n-1 (if nums1[0] <= nums2[n-1])
- **One array much shorter** → still correct (j stops at end of nums2)
- **n = 10⁵** → O(n) time → extremely fast
- **Non-increasing guarantee** → algorithm relies on monotonicity for correctness

All handled perfectly.

---

## Key Takeaway

This is a **beautifully clean two-pointer greedy** problem on sorted arrays:

- Both `nums1` and `nums2` are **non-increasing** → we can greedily maximize `j` for each `i`
- Use two pointers:
  - `i` iterates through nums1 from left to right
  - `j` greedily moves right as far as possible while `nums1[i] <= nums2[j]`
- Update max distance `j - i` every time condition holds
- `j` never moves left → total time O(n)

**Pure, clean, optimal** — perfect maximum valid distance under constraints `i <= j` and `nums1[i] <= nums2[j]`.

---

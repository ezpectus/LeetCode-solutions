# 🧩 Problem: Find Score of an Array After Marking All Elements

## 📜 Description

You're given an array `nums` of positive integers. Starting with `score = 0`, apply the following algorithm:

1. While there are unmarked elements:
   - Choose the smallest unmarked element. If there's a tie, pick the one with the smallest index.
   - Add its value to `score`.
   - Mark the chosen element and its adjacent neighbors (`i-1`, `i+1`) if they exist.

Return the final `score`.

---

## 🧠 Why Not Memoization?

At first glance, this problem resembles dynamic programming or recursive simulation. However:

- There are no overlapping subproblems with identical parameters.
- There's no recursive call tree to cache.
- The algorithm depends on **global state** (`visited[]`) and a strict selection order.

Thus, memoization is not suitable. Instead, we need a **stateful simulation** — step-by-step execution with explicit state tracking.

---

## 💡 Solution Strategy

- Use a `visited[]` boolean array to track which elements have been marked.
- Use a `PriorityQueue` to always select the smallest unmarked element with the smallest index.
- Simulate the marking process: select, add to score, and mark current + adjacent elements.

---

## 🛠️ Annotated Code

```csharp
public class Solution {
    public long FindScore(int[] nums) {
        int n = nums.Length;

        // 🔹 Track which elements have been marked
        bool[] visited = new bool[n];

        // 🔹 Min-heap: picks smallest value with smallest index
        var pq = new PriorityQueue<(int val, int idx), (int val, int idx)>();

        // 🔹 Final score accumulator
        long score = 0;

        // 🔹 Phase 1: Build heap with all elements
        for (int i = 0; i < n; i++) {
            pq.Enqueue((nums[i], i), (nums[i], i));
        }

        // 🔹 Phase 2: Simulate marking process
        while (pq.Count > 0) {
            var (val, i) = pq.Dequeue();

            // 🔸 Skip if already marked
            if (visited[i]) continue;

            // 🔸 Add value to score
            score += val;

            // 🔸 Mark current and adjacent elements
            visited[i] = true;
            if (i > 0) visited[i - 1] = true;     // Safe left neighbor
            if (i < n - 1) visited[i + 1] = true; // Safe right neighbor
        }

        return score;
    }
}
```


## ⚠️ Common Mistakes You Encountered

| Mistake              | Why It Happened                                   | How You Fixed It                          |
|----------------------|---------------------------------------------------|-------------------------------------------|
| `while` inside `for` | Simulation started before setup was complete      | Split into two distinct phases            |
| Reused variable `i`  | Shadowing between `for` and `Dequeue`             | Renamed loop index                        |
| `score` out of scope | Declared inside loop, inaccessible outside        | Moved declaration above loop              |
| Uninitialized `pq`   | Declared but not constructed                      | Added `new PriorityQueue<>()`             |
| No bounds check      | `i ± 1` could go out of array bounds              | Added `if (i > 0)` and `if (i < n - 1)`   |

---

## 🧠 Architectural Pattern: `GreedyMarkingTemplate`

### 🔸 Two-Phase Simulation
Separate setup from execution.  
First build the structure (e.g. heap), then simulate the logic step-by-step.

### 🔸 State Invalidation
Use `visited[]` as an invariant to track eligibility.  
Once marked, an element is excluded from future decisions.

### 🔸 Safe Neighbor Update
Always check bounds before marking neighbors.  
Prevents out-of-range errors and preserves simulation integrity.

---

## 🧠 When to Use

- When selecting elements by priority
- When selection affects adjacent state
- When tracking eligibility is critical




---

# 2425. Bitwise XOR of All Pairings  
*O(n + m) — Smart Bitwise Properties*

---

## Problem Statement

- You are given two **0-indexed** arrays `nums1` and `nums2` of non-negative integers.
- Consider a third array `nums3` that contains the **bitwise XOR** of **every possible pairing** between `nums1` and `nums2` (each element of `nums1` is paired with each element of `nums2` exactly once).
- Return the **bitwise XOR** of **all elements** in `nums3`.

**Examples**:

**Example 1**  
Input: nums1 = [2,1,3], nums2 = [10,2,5,0]  
Output: **13**  
nums3 contains all pairwise XORs → their total XOR = 13

**Example 2**  
Input: nums1 = [1,2], nums2 = [3,4]  
Output: **0**  
All pairwise XORs: 2,5,1,6 → 2 ^ 5 ^ 1 ^ 6 = 0

**Constraints**:
- 1 ≤ nums1.length, nums2.length ≤ 10⁵
- 0 ≤ nums1[i], nums2[j] ≤ 10⁹

---

## Core Idea — XOR Properties + Parity of Counts

**Key mathematical insight**:
Let A = nums1, B = nums2, n = |A|, m = |B|

`nums3` contains **every** a ^ b for a ∈ A, b ∈ B  
We want XOR of **all** such values:  
**XOR_{a∈A} XOR_{b∈B} (a ^ b)**

Using XOR properties:
- XOR is commutative and associative
- x ^ x = 0, x ^ 0 = x
- XOR_{all pairs} (a ^ b) = (XOR_{a∈A} a) ^ (XOR_{b∈B} b) **only if** n*m is odd  
  → more precisely: each a appears **m** times, each b appears **n** times

**Crucial property**:
- For each bit position independently:
  - If a number has that bit set, it contributes to the XOR when paired with even or odd count of partners
- The total XOR of all (a ^ b) =  
  (XOR of all a in A, each repeated m times) ^ (XOR of all b in B, each repeated n times)

Mathematically:
XOR_{a,b} (a ^ b) = (XOR_a a) ^ (XOR_b b) **if and only if** the number of times each appears is odd

More precisely:
- Each a appears **m** times in the pairings → if m is odd → each a appears odd times → contributes (XOR_a a)  
  if m even → appears even times → cancels out
- Similarly for each b: appears **n** times → if n odd → contributes (XOR_b b)

**Final formula**:
result = 0  
if (m % 2 == 1) result ^= (XOR of all elements in nums1)  
if (n % 2 == 1) result ^= (XOR of all elements in nums2)

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public int XorAllNums(int[] nums1, int[] nums2){
        int xor1 = 0;
        foreach (int num in nums1) xor1 ^= num;
        
        int xor2 = 0;
        foreach (int num in nums2) xor2 ^= num;
        
        int res = 0;
        // If nums2 length is odd → each nums1 element appears odd times → include xor1
        if (nums2.Length % 2 == 1) res ^= xor1;
        
        // If nums1 length is odd → each nums2 element appears odd times → include xor2
        if (nums1.Length % 2 == 1) res^= xor2;
        
        return res;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n + m)**  | Single pass over nums1 to compute XOR: O(n)<br>Single pass over nums2 to compute XOR: O(m) |
| **Space Complexity**  | **O(1)**      | Only a few integer variables — no extra data structures needed |

**Optimal** — linear time in the total number of elements, constant extra space — perfectly efficient for n, m ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: nums1 = [2,1,3], nums2 = [10,2,5,0]

- Length nums1 = **3** (odd), length nums2 = **4** (even)
- xor1 = 2 ^ 1 ^ 3 = **0**
- xor2 = 10 ^ 2 ^ 5 ^ 0 = **13**

Since nums2 length is even → each element of nums1 appears **even** times in the pairings → cancels out → no contribution from xor1  
Since nums1 length is odd → each element of nums2 appears **odd** times → contributes xor2 to the final result  
Final result = 0 ^ 13 = **13** → correct

**Example 2**: nums1 = [1,2], nums2 = [3,4]

- Length nums1 = **2** (even), length nums2 = **2** (even)
- xor1 = 1 ^ 2 = **3**
- xor2 = 3 ^ 4 = **7**

Both lengths even → each element appears **even** times in pairings → everything cancels out → result = **0** → correct

**Correct** —  
The total XOR of all pairwise XORs (a ^ b) depends **only on the parity** of the array lengths:
- If length of nums2 is **odd** → each element of nums1 appears odd times → contributes (XOR of nums1) to final result
- If length of nums1 is **odd** → each element of nums2 appears odd times → contributes (XOR of nums2) to final result
- Even length → appears even times → cancels out (x ^ x = 0)

This is a beautiful application of **XOR properties** and **counting parity**.

---

## Key Takeaway

This is a **beautiful bitwise XOR property + parity counting** problem:

* The XOR of all pairwise (a ^ b) for a ∈ nums1, b ∈ nums2 equals:  
  (XOR of all elements in nums1, repeated m times) ^ (XOR of all elements in nums2, repeated n times)

* Repeating any value **even** times → cancels out (x ^ x = 0)  
* Repeating **odd** times → remains unchanged (x ^ 0 = x)

* Therefore:
  - If length of nums2 (m) is **odd** → include XOR of all nums1 elements
  - If length of nums1 (n) is **odd** → include XOR of all nums2 elements

* Final result = XOR of the included parts (0 if neither is odd)

---

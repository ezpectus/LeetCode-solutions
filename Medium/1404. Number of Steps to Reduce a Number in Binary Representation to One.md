# Problem: Number of Steps to Reduce a Number in Binary Representation to One  
## Number: LeetCode 1404  
**Difficulty**: Medium  
**Language**: C++  

---

## Problem Overview

Given a binary string `s` representing a positive integer, return the number of steps required to reduce it to `1` using the following rules:

- If the current number is **even**, divide it by 2.
- If the current number is **odd**, add 1 to it.

It is guaranteed that every input will eventually reduce to `1`.

---

## Constraints

- `1 <= s.length <= 500`  
- `s` consists only of `'0'` and `'1'`  
- `s[0] == '1'` (no leading zeros)

---

## Observations

- The binary string can be processed **from right to left** (least significant bit to most significant).
- We simulate the process without converting the string to an integer.
- A **carry** is introduced when adding `1` to an odd number, which may propagate leftward.
- Each `'1'` with carry becomes `'0'` and triggers a double step: one for addition, one for division.

---

## Algorithm Summary

1. Initialize `carry = 0` and `steps = 0`.
2. Traverse the binary string from the end (`i = s.length() - 1`) to the second bit (`i > 0`).
3. At each bit:
   - If `s[i] + carry == 1`, it's an odd number → add 1 and divide → `steps += 2`, set `carry = 1`.
   - Else, it's even → divide → `steps += 1`.
4. After the loop, add final `carry` to `steps`.

---

## Code

```cpp
class Solution {
public:
    int numSteps(string s) {
        int carry = 0;
        int steps = 0;

        for (int i = s.length() - 1; i > 0; i--) {
            if ((s[i] - '0') + carry == 1) {
                steps += 2;
                carry = 1;
            } else {
                steps += 1;
            }
        }
        return steps + carry;
    }
};
```


## Complexity Analysis

**Time Complexity**  
`O(n)` — We traverse the binary string once from right to left.  
Each bit is processed individually without revisiting, resulting in linear time.

**Space Complexity**  
`O(1)` — Only two integer counters (`carry`, `steps`) are used.  
No additional data structures are required regardless of input size.

---

## Why This Works

- The algorithm avoids converting the binary string to an integer, which is more efficient for large inputs.
- The `carry` variable simulates binary addition when encountering odd numbers.
- Each bit is processed exactly once, and the logic mirrors how binary numbers behave under addition and division.
- The approach is both space-efficient and time-optimal for the given constraints.

---

## Related Concepts

- Binary arithmetic  
- Bitwise simulation  
- Greedy reduction strategies  
- Carry propagation in binary addition


---

# 1008. Construct Binary Search Tree from Preorder Traversal — Architectural Recursive Range Partition  
*O(n) average, O(n²) worst — Optimal BST Construction from Preorder*

---

## Problem Statement

Given `preorder` array — **preorder traversal** of a **BST**.

Construct and return the **root** of the BST.

**Guaranteed** valid and unique values.

---

## Core Idea — Preorder Root + Range-Based Partition

**Preorder**: root → left subtree → right subtree

**BST property**:
- Left subtree: all values **< root**
- Right subtree: all values **> root**

**Algorithm**:
- First element = **root**
- Find **first element > root** → start of right subtree
- Elements between = left subtree
- Recurse on left/right ranges

**No need** for inorder — preorder sufficient with BST property.

---

##  Implementation (C#)

```csharp
public class Solution {
    private int i = 0;

    public TreeNode BstFromPreorder(int[] preorder) {
        return Helper(preorder, int.MaxValue);
    }

    private TreeNode Helper(int[] preorder, int upperBound) {
        if (i == preorder.Length || preorder[i] > upperBound)  return null;

        TreeNode root = new TreeNode(preorder[i++]);
        root.left = Helper(preorder, root.val);
        root.right = Helper(preorder, upperBound);

        return root;
    }
}
```

## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(n)** average      | Each element processed exactly once            |
| **Space Complexity**  | **O(h)**              | Recursion stack (h = tree height, worst O(n) skewed) |

**Optimal** — linear time in practice.

---

## Why This Works — Example Walkthrough

**Input**: `preorder = [8,5,1,7,10,12]`

- **Root** = 8
- **Left subtree**: all values < 8 → `[5,1,7]`
  - Root = 5
  - Left: values < 5 → `[1]`
  - Right: values > 5 and < 8 → `[7]`
- **Right subtree**: all values > 8 → `[10,12]`
  - Root = 10
  - Right = 12

Resulting tree:
```
    8
   / \
  5   10
 / \    \
1   7    12
```

**Correct**.

**Input**: `[1,3]`

- Root = 1
- Left: no values < 1 → null
- Right: values > 1 → `[3]`

→ `[1,null,3]`

**Correct**.

---

## Pitfalls & Edge Cases

- **Single node** → handled correctly
- **All left or all right** → recursion depth safe (n ≤ 100)
- **Duplicates** → impossible (guaranteed unique values)
- **Invalid preorder** → guaranteed valid BST preorder

All handled perfectly.

---

## Key Takeaway

This is a **beautifully elegant** recursive construction:

- **Preorder root** → take first valid element in range
- **Range bounds** → enforce BST property naturally
- **Recursive partition** → split into left/right subtrees

**No extra data structures. No sorting.**
**Pure, clean, optimal** — one of the most elegant BST construction problems.

---

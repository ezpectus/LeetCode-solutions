# 1234. Replace the Substring for Balanced String

## Problem

You are given a string `s` of length `n`, consisting only of **'Q', 'W', 'E', 'R'**.  
A string is **balanced** if each character appears **exactly `n/4` times**.

**Task**:  
Find the **minimum length** of a substring that can be replaced with any string of the same length to make `s` **balanced**.  
If `s` is already balanced → return `0`.

---

## Core Insight

> **We don’t care what we replace — only what we remove.**

**Goal**: Find the **shortest window** such that, **after removing it**, the **remaining string is balanced**.

**Key idea**:
- Count **excess** characters (`> n/4`)
- Use **sliding window** to find shortest substring that **covers all excess**
- Outside window → **balanced**

---

## Architectural Triggers

| Trigger | Implication |
|-------|-------------|
| “Minimum substring to replace” | **Sliding window** optimization |
| “Balance condition” | **Frequency tracking** |
| “Only 4 characters” | **Constant-time checks** |

---

## What This Implies

- Count frequencies of `'Q', 'W', 'E', 'R'`
- If all ≤ `target = n/4` → **already balanced**
- Else: **two pointers `l`, `r`**:
  - Move `r` → remove `s[r]` from count
  - While **outside is balanced** → shrink `l`
  - Track `min(r - l + 1)`

> **Trick**: We **don’t check the window** — we check **the rest of the string**

---

## Code (C++)

```cpp
class Solution {
public:
    int balancedString(string s) {
        int n = s.size(), target = n / 4;
        unordered_map<char, int> freq;
        for (char c : s) ++freq[c];

        // Already balanced
        if (freq['Q'] <= target && freq['W'] <= target &&
            freq['E'] <= target && freq['R'] <= target) return 0;

        int res = n, l = 0;
        for (int r = 0; r < n; ++r) {
            --freq[s[r]];  // remove from "outside"
            while (l <= r &&
                   freq['Q'] <= target &&
                   freq['W'] <= target &&
                   freq['E'] <= target &&
                   freq['R'] <= target) {
                res = min(res, r - l + 1);
                ++freq[s[l]];  // restore left
                ++l;
            }
        }
        return res;
    }
};
```

## Complexity

| Metric | Value |
|-------|-------|
| **Time** | `O(n)` — single pass with two pointers |
| **Space** | `O(1)` — fixed character set (`Q,W,E,R`) |

---

## Example: `s = "QQWE"`, `n = 4`, `target = 1`

| Step | Action | `freq` (outside) | Valid? | Window |
|------|--------|-------------------|--------|--------|
| Init | Count | Q:2, W:1, E:1, R:0 | No | — |
| r=0 | `--freq['Q']` | Q:1 | Yes | [0,0] → len=1 |
| r=1 | `--freq['Q']` | Q:0 | Yes | [1,1] → len=1 |
| ... | — | — | — | **min = 1** |

> **Answer = 1**

---

## Insight

This is a **classic sliding window with frequency constraints**.

> **You don’t need to know what to replace — just where to replace.**  
> The **rest of the string** (outside the window) must satisfy the **balance condition** (`≤ n/4` for each char).

**Key idea**:  
We **don’t modify** the substring — we **remove its effect** from the global count.  
So we **expand right** to reduce excess, and **shrink left** while the **outside remains balanced**.

**Pattern**:  
> *"Find minimal substring to remove so that remaining satisfies property"*

---

## Fichka Library Entry

> **Sliding window: minimal substring removal to restore fixed frequency balance**

---


# 🧩 Problem Overview

**Leetcode 3025 – Find the Number of Ways to Place People I**

You are given a list of 2D points `points[i] = [xi, yi]` representing coordinates on a grid.

We need to count the number of valid pairs of points (A, B) such that:

- A is strictly to the **upper-left** of B → `Ax < Bx` and `Ay > By`
- The rectangle (or line) formed by A and B contains **no other point**, including borders

---

# 📌 Task Definition

Return the total number of such valid pairs (A, B) that satisfy:

- **Geometric positioning**: A is upper-left of B  
- **Spatial constraint**: No other point lies inside or on the rectangle formed by A and B

---

# 💡 Idea & Architectural Insight

Instead of brute-force checking all O(n²) pairs and scanning the rectangle between them, we use a **sweep-line strategy** with sorting to prune invalid candidates efficiently.

### Why this works:

- Sorting by `x` ascending and `y` descending ensures:
  - For any fixed point A, all points to its right have greater `x`
  - Among those, we can greedily track the lowest `y` seen so far to avoid overlapping rectangles

This transforms the problem into a **greedy vertical boundary check**, avoiding nested loops over the grid and unnecessary rectangle scans.

---

# 🛠️ Approach Summary

### Step-by-step:

1. **Sort points** by:
   - `x` ascending → ensures left-to-right sweep
   - `y` descending → avoids counting overlapping verticals

2. **Iterate over each point A**:
   - For each A, check all points B to its right
   - Maintain a `bot` boundary (lowest y seen so far)
   - If `bot < B.y ≤ A.y`, count the pair and update `bot`
   - Break early if `bot == A.y` (rectangle degenerates to a line)

---

# 🧱 Code Pattern (C#)

```csharp
public class Solution {
    public int NumberOfPairs(int[][] points) {
        int n = points.Length, res = 0;

        // Sort by x ascending, y descending
        Array.Sort(points, (a, b) => 
            a[0] == b[0] ? b[1].CompareTo(a[1]) : a[0].CompareTo(b[0])
        );

        for (int i = 0; i < n; i++) {
            int top = points[i][1];
            int bot = int.MinValue;

            for (int j = i + 1; j < n; j++) {
                int y = points[j][1];
                if (bot < y && y <= top) {
                    res++;
                    bot = y;
                    if (top == bot) break; // Degenerate case
                }
            }
        }

        return res;
    }
 }
```

## ⏱️ Time Complexity Analysis

| Operation        | Complexity     | Notes |
|------------------|----------------|-------|
| Sorting          | O(n log n)     | Sorts by x ascending, y descending to enable sweep-line |
| Nested loop      | O(n²) worst-case | Each point A checks all B to its right, but pruned by `bot` |
| Overall          | Practically subquadratic | Efficient for n ≤ 50 due to greedy pruning |

### Optimization Notes:
- The inner loop is **greedily pruned** by updating the `bot` boundary.
- Early termination (`if top == bot`) avoids unnecessary iterations when the rectangle degenerates to a line.
- No need for explicit rectangle scanning or grid simulation — the logic is purely **coordinate-driven**.

---

## 🧠 Pattern Summary

| Component         | Role in Pattern                                   |
|------------------|----------------------------------------------------|
| Sort by `x↑, y↓`  | Enforces left-to-right sweep and vertical pruning |
| `bot` tracking    | Greedy boundary to avoid overlapping rectangles   |
| Early break       | Optimization for degenerate vertical cases        |
| Geometry check    | Ensures A is strictly upper-left of B             |

### Pattern Class:  
**Sweep-line + Greedy Boundary Pruning in 2D Geometry**

This pattern is reusable in problems involving:
- **Empty rectangle detection**  
  → Ensuring no other point lies inside a defined region  
- **Sweep-line with greedy pruning**  
  → Efficiently scanning sorted points with dynamic constraints  
- **Geometric pair counting with spatial constraints**  
  → Counting valid configurations based on relative positioning

---

## 📎 Architectural Takeaways

- **Sorting by `x↑, y↓` is a signal**:  
  It enables a directional sweep while maintaining control over vertical overlaps.  
  This dual-axis sort is a common trick in 2D geometry and skyline problems.

- **Dynamic boundary tracking (`bot`) simulates rectangle emptiness**:  
  Instead of scanning the grid or checking all intermediate points, we use a greedy update to maintain the lowest valid `y` seen so far.

- **Early break avoids degenerate cases**:  
  When `top == bot`, the rectangle collapses to a line — no need to continue scanning.

- **No explicit rectangle construction needed**:  
  The logic is purely coordinate-based, making it efficient and scalable.

---

## 📐 Generalization Potential

This approach generalizes to problems like:
- **Skyline visibility**  
  → Where vertical dominance matters and overlaps must be pruned  
- **Dominance counting**  
  → Counting how many points dominate others in 2D space  
- **Grid-based pair constraints**  
  → Where spatial relationships define valid configurations

It can also be adapted to:
- **Dynamic insertions** (e.g. segment trees or BIT for online updates)
- **Higher dimensions** (e.g. 3D bounding boxes with similar pruning logic)

---

## ✅ Final Reflections

This task delivers more than just a count — it teaches a **geometry-aware sweep-line pattern** that avoids brute-force rectangle validation.  
It reinforces the importance of:
- **Sorting as a signal**
- **Greedy pruning as a substitute for grid simulation**
- **Architectural clarity over brute-force enumeration**


---

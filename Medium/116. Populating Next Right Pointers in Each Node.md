# 🧠 116. Populating Next Right Pointers in Each Node

## 🔗 Problem Statement

Given a **perfect binary tree** (all leaves on the same level, every parent has two children), populate each node’s `next` pointer to point to its **next right node**.  
If there is no next right node, the `next` pointer should be set to `null`.

### Constraints

- Tree is perfect: every node has 0 or 2 children, and all leaves are at the same depth
- `0 <= number of nodes <= 2^12 - 1`
- `-1000 <= Node.val <= 1000`
- You may only use **constant extra space**
- Recursive approach is allowed (implicit stack space doesn't count)

---

## ✅ Signals

- Use **recursive DFS** to traverse the tree top-down
- Connect `left → right` within the same parent
- Connect `right → next.left` across sibling parents
- Only valid in **perfect binary trees**

---

## 🧩 Solution — Recursive Connection

```csharp
public class Solution {
    public Node Connect(Node root) {
        if (root == null) return null;

        if (root.left != null)
            root.left.next = root.right;

        if (root.right != null && root.next != null)
            root.right.next = root.next.left;

        Connect(root.left);
        Connect(root.right);
        return root;
    }
}
```


## 🔍 Notes

### 🔗 Intra-parent Connection

```csharp
root.left.next = root.right;
```
- Connects the left child to the right child within the same parent node. 
- This is always valid in a perfect binary tree since every node has two children.

## 🔗 Inter-parent Connection
```
root.right.next = root.next.left;
```
- Connects the right child to the left child of the next sibling parent.
- This is only valid if root.next exists — hence the null check.
 - This step ensures that nodes across different subtrees are linked horizontally.

## 🧠 Signal Summary

| Concept             | Signal Expression                   | Role                            |
|---------------------|--------------------------------------|----------------------------------|
| Left → Right        | `left.next = right`                  | Connect children within parent   |
| Right → Next.Left   | `right.next = root.next.left`        | Connect across sibling parents   |
| DFS traversal       | `Connect(left); Connect(right);`     | Recursively apply connections    |

---


## ✅ Takeaways

This pattern is specific to **perfect binary trees** and leverages their structural guarantees to avoid extra space:

- No queue or level-order traversal needed  
- Recursive calls use implicit stack space  
- `next` pointers are populated top-down using existing structure

Use this as a **base module** for any tree traversal that requires **cross-node linking**.


---






# 1594. Maximum Non Negative Product in a Matrix

**Difficulty:** Medium  
**Topics:** Dynamic Programming, Matrix, State Tracking  

---

##  Problem Restatement
You are given an `m x n` matrix `grid`.  
You start at the top-left corner `(0,0)` and can only move **right** or **down**.  
Among all possible paths to the bottom-right corner `(m-1,n-1)`, find the path with the **maximum non-negative product**.  

- Return the maximum product modulo `10^9 + 7`.  
- If the maximum product is negative, return `-1`.  

---

##  Core Idea
- Path product can flip sign due to negative numbers.  
- We must track **both maximum and minimum products** at each cell:  
  - `max[i][j]` = maximum product reaching `(i,j)`.  
  - `min[i][j]` = minimum product reaching `(i,j)`.  
- Transition:  
```
 val = grid[i][j]
 max[i][j] = max(val * max(top), val * max(left), val * min(top), val * min(left))
 min[i][j] = min(val * max(top), val * max(left), val * min(top), val * min(left))
```
- Base case:  
```max[0][0] = min[0][0] = grid[0][0]```
- Answer:
  ```
  if max[m-1][n-1] < 0 → return -1
  else return max[m-1][n-1] % (10^9+7)
  ```

  
---

##  Step-by-Step Algorithm
1. Initialize DP arrays `max` and `min` of size `m x n`.  
2. Set `max[0][0] = min[0][0] = grid[0][0]`.  
3. For each cell `(i,j)`:  
 - Collect candidates from top `(i-1,j)` and left `(i,j-1)`.  
 - Multiply each candidate by `grid[i][j]`.  
 - Update `max[i][j]` and `min[i][j]`.  
4. At the end, check `max[m-1][n-1]`.  
 - If negative → return `-1`.  
 - Else → return modulo `10^9+7`.

---

##  C# Implementation
```csharp
public class Solution {
  public int MaxProductPath(int[][] grid) {
      int MOD = 1000000007;
      int m = grid.Length, n = grid[0].Length;

      long[,] max = new long[m, n];
      long[,] min = new long[m, n];

      max[0,0] = min[0,0] = grid[0][0];

      for (int i = 0; i < m; i++) {
          for (int j = 0; j < n; j++) {
              if (i == 0 && j == 0) continue;

              long val = grid[i][j];
              long maxCandidate = long.MinValue;
              long minCandidate = long.MaxValue;

              if (i > 0) {
                  maxCandidate = Math.Max(maxCandidate, val * max[i-1,j]);
                  maxCandidate = Math.Max(maxCandidate, val * min[i-1,j]);
                  minCandidate = Math.Min(minCandidate, val * max[i-1,j]);
                  minCandidate = Math.Min(minCandidate, val * min[i-1,j]);
              }
              if (j > 0) {
                  maxCandidate = Math.Max(maxCandidate, val * max[i,j-1]);
                  maxCandidate = Math.Max(maxCandidate, val * min[i,j-1]);
                  minCandidate = Math.Min(minCandidate, val * max[i,j-1]);
                  minCandidate = Math.Min(minCandidate, val * min[i,j-1]);
              }

              max[i,j] = maxCandidate;
              min[i,j] = minCandidate;
          }
      }

      long result = max[m-1,n-1];
      if (result < 0) return -1;
      return (int)(result % MOD);
  }
}
```

##  Complexity Analysis

- **Time Complexity:** O(m * n) — each cell computed once.  
- **Space Complexity:** O(m * n) — DP arrays for max/min.  
  - Can be optimized to O(n) with rolling arrays.  

---

##  Pitfalls

- Must track both `max` and `min` because negative × negative = positive.  
- Use `long` to avoid overflow during multiplication.  
- Apply modulo only at the end, not during DP (to preserve sign).  
- If final `max < 0` → return `-1`.  

---

##  Example Walkthrough

**Input:**  
`grid = [[1,-2,1],[1,-2,1],[3,-4,1]]`  

- Path: `1 → 1 → -2 → -4 → 1`  
- Product = `8` (positive).  
- **Answer:** `8`  

**Input:**  
`grid = [[-1,-2,-3],[-2,-3,-3],[-3,-3,-2]]`  

- All paths yield negative product.  
- **Answer:** `-1`  

---

##  Key Takeaway

- This is a **DP with dual state tracking (max/min)** problem.  
- **Pattern:** “Path product with negatives” → always track both extremes.  
- Clean O(m * n) solution, modulo applied at the end.  



---




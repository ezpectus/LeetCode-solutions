# 🍊 BFS Infection Spread — Rotten Oranges

## 🧠 Intuition
The task is to model the spread of infection (rot) on the grid. Each cell can be:

- 0 is empty
- 1 — fresh orange
- 2 - rotten orange

- Rotten ones infect neighboring fresh ones in 1 minute.
- You need to find out how many minutes it will take for everything fresh to become rotten. If impossible, return -1.

## 🛠️ Approach — BFS with Timer

## 1. Initialization

- Go through the entire grid
- Calculate freshcount — the amount of fresh
- Add all rotten (i, j) to the queue with time = 0

```csharp
queue.Enqueue((i, j, 0));
```

## 2. BFS in turn

While the queue is not empty:

- We get (row, col, time)
- We go through the directions - up, down, left, right
- If the neighbor is a fresh orange:
- We infect: grid[nr][nc] = 2
- Let's reduce freshcount
- We add time + 1 to the queue
- Updating maxTime

## 3. Limits and conditions
Cross-border check:

```csharp
nr >= 0 && nr < m && nc >= 0 && nc < n
```

Checking for a fresh orange:

```csharp
grid[nr][nc] == 1
```

## 4. The final answer
- If freshcount == 0 → all are infected → return maxTime
- Otherwise → impossible to infect everyone → return -1

## 📊 Complexity
- Time: $$O(m \cdot n)$$ — each cell at most once per queue
- Space: $$O(m \cdot n)$$ — queue and mutation of the network




```csharp
public class Solution {
    public int OrangesRotting(int[][] grid) {
        int freshcount = 0;
        var queue = new Queue<(int row, int col, int time)>();
        int m = grid.Length;
        int n = grid[0].Length;

        // Step 1: Initialize queue and count fresh oranges
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 2) {
                    queue.Enqueue((i, j, 0));
                } else if (grid[i][j] == 1) {
                    freshcount++;
                }
            }
        }

        int maxTime = 0;
        (int, int)[] directions = new (int, int)[] {
            (0, 1),  // right
            (1, 0),  // down
            (0, -1), // left
            (-1, 0)  // up
        };

        // Step 2: BFS traversal
        while (queue.Count > 0) {
            var (row, col, time) = queue.Dequeue();

            foreach (var (dr, dc) in directions) {
                int nr = row + dr;
                int nc = col + dc;

                // Step 3: Check bounds and infect fresh orange
                if (nr >= 0 && nr < m && nc >= 0 && nc < n && grid[nr][nc] == 1) {
                    grid[nr][nc] = 2;
                    freshcount--;
                    queue.Enqueue((nr, nc, time + 1));
                    maxTime = Math.Max(maxTime, time + 1);
                }
            }
        }

        // Step 4: Return result
        return freshcount == 0 ? maxTime : -1;
    }
}
```



---

# 855. Exam Room — Architectural SortedSet + Interval Maximization  
*O(log n) per operation — Optimal Priority-Based Seating*

---

## Problem Statement

Exam room with `n` seats (0 to n-1).

Students sit to **maximize distance** to closest person.
- If tie → choose **lowest index**
- First student → seat `0`

Operations:
- `seat()` → return seat for next student
- `leave(p)` → student at `p` leaves

**Constraints**:
- `n ≤ 10⁹` → **cannot use array**
- ≤10⁴ calls → need efficient data structure

---

## Core Idea — Track Intervals with SortedSet

**Key insight**:
- We need to **quickly find** interval with **maximum distance**
- When tie → smallest starting index

**Solution**:
- Use **SortedSet** of occupied seats (including virtual `-1` and `n`)
- Store **intervals** as `(dist, start)` → sort by **-dist** (max first), then **start** (smallest)
- Use `SortedSet` with custom comparer

**Operations**:
- `seat()`:
  - Find largest interval
  - Choose seat in middle (or left if tie)
  - Split interval → add new seat
- `leave(p)`:
  - Remove seat
  - Merge with left/right intervals

**Virtual bounds** `-1` and `n` → handle ends.

---

##  Implementation (C#)

```csharp
public class ExamRoom {
    private int n;
    private SortedSet<int> seats;
    private SortedDictionary<(int dist, int start), int> intervals;

    public ExamRoom(int n) {
        this.n = n;
        seats = new SortedSet<int>();
        intervals = new SortedDictionary<(int, int), int>(new IntervalComparer());

        // Virtual bounds
        seats.Add(-1);
        seats.Add(n);

        // Initial full interval
        AddInterval(-1, n);
    }

    public int Seat() {
        var interval = intervals.Keys.First();
        int start = interval.start;
        int end = intervals[interval];
        int seat;

        if (start == -1)   seat = 0;
        else if (end == n)  seat = n - 1;
        else  seat = start + (end - start) / 2;
        
        RemoveInterval(start, end);
        seats.Add(seat);

        AddInterval(start, seat);
        AddInterval(seat, end);

        return seat;
    }

    public void Leave(int p) {
        var prev = seats.Where(x => x < p).Max();
        var next = seats.Where(x => x > p).Min();
        RemoveInterval(prev, p);
        RemoveInterval(p, next);

        seats.Remove(p);
        AddInterval(prev, next);
    }

private void AddInterval(int start, int end) {
        int dist = Dist(start, end);
        intervals[(dist, start)] = end;
    }

private void RemoveInterval(int start, int end) {
        int dist = Dist(start, end);
        intervals.Remove((dist, start));
    }

    private int Dist(int a, int b) {
        if (a == -1) return b;
        if (b == n) return n - 1 - a;
        return (b - a) / 2;
    }
}

class IntervalComparer : IComparer<(int dist, int start)> {
    public int Compare((int dist, int start) x, (int dist, int start) y) {
        if (x.dist != y.dist) return y.dist.CompareTo(x.dist); // max dist first
        return x.start.CompareTo(y.start); // then min start
    }
}
```
## Complexity

| **Metric**            | **Value**             | **Notes**                                      |
|-----------------------|-----------------------|------------------------------------------------|
| **Time Complexity**   | **O(log k) per op**   | k = current occupied seats ≤ 10⁴               |
| **Space Complexity**  | **O(k)**              | SortedSet + Dictionary                         |

**Optimal** — handles n=10⁹ with tiny memory.

---

## Why This Works — Example Walkthrough

**n=10**, sequence: seat, seat, seat, seat, leave(4), seat

- **Initial**: single interval `(-1 → 10)` → dist=9
- **seat()** → max dist → choose **0** → new intervals `(-1→0)`, `(0→10)`
- **seat()** → `(0→10)` dist=4 → choose **9**
- **seat()** → remaining max `(0→9)` dist=4 → choose **4**
- **seat()** → now `(0→4)` and `(4→9)` both dist=2 → choose **lowest index** → **2**
- **leave(4)** → remove 4 → merge `(2→9)` → dist=3
- **seat()** → `(2→9)` → choose **5**

Result: seats taken in order **[0,9,4,2,5]** — **correct**.

**Perfect** — always picks max distance, tie-break by lowest index.

---

## Key Takeaway

This is a **masterpiece of interval management**:

- **SortedSet** for occupied seats → fast prev/next
- **Priority dictionary** for max-distance intervals
- **Custom comparer** → max dist first, then min start index
- **Virtual bounds** `-1` and `n` → clean handling of ends

**Pure data structure brilliance** — handles huge n efficiently with O(k) memory.

---

# 1750. Minimum Length of String After Deleting Similar Ends — Architectural Two-Pointer Greedy Shrink  
*O(n) — Optimal Linear-Time Two-Pointer Approach*

---

## Problem Statement

Given string `s` consisting only of `'a'`, `'b'`, `'c'` (1 ≤ length ≤ 10⁵).

You can repeatedly do:
- Choose a **non-empty prefix** where all characters are equal
- Choose a **non-empty suffix** where all characters are equal
- The prefix and suffix **must not overlap**
- The character in prefix and suffix **must be the same**
- Delete both prefix and suffix

Find the **minimum length** of `s` after any number of such operations (possibly zero).

---

## Core Idea — Greedy Two-Pointer Shrink from Both Ends

**Key insight**:
- We want to **remove as many matching prefix-suffix pairs** as possible
- Since operations remove equal characters from both ends, we can simulate the process by **shrinking** the string from both sides
- Use **two pointers** (left and right):
  - While left < right and s[left] == s[right]:
    - Remove prefix and suffix of the same character
    - Move left pointer rightward until character changes
    - Move right pointer leftward until character changes
- After no more removals possible → remaining length = right - left + 1

**Why it works**:
- Each removal reduces the string symmetrically
- Greedy removal from outside always gives optimal (cannot block future removals)
- No need to simulate each step — just collapse equal ends

---

## Full Optimal Implementation (C#)

```csharp
public class Solution {
    public int MinimumLength(string s) {
        int left = 0;
        int right = s.Length - 1;

        while (left < right && s[left] == s[right]) {
            char ch = s[left];

            // Skip all characters equal to ch from left
            while (left <= right && s[left] == ch)  left++;
            
            // Skip all characters equal to ch from right
            while (left <= right && s[right] == ch)  right--;
            
        }

        return right - left + 1;
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Each character is visited at most twice (once from each end) |
| **Space Complexity**  | **O(1)**      | Only two pointers (left and right)             |

**Optimal** — linear time, constant extra space.

---

## Why This Works — Example Walkthrough

**Example 1**: `s = "ca"`

- left = 0 ('c'), right = 1 ('a') → different → stop
- Remaining length = 2 → **correct**

**Example 2**: `s = "cabaabac"`

- left=0 ('c'), right=7 ('c') → same  
  → skip prefix & suffix 'c' → left=1, right=6
- left=1 ('a'), right=6 ('a') → same  
  → skip 'a' → left=2, right=5
- left=2 ('b'), right=5 ('b') → same  
  → skip 'b' → left=3, right=4
- left=3 ('a'), right=4 ('a') → same  
  → skip 'a' → left=4, right=3 → pointers cross → length **0**

**Correct**.

**Example 3**: `s = "aabccabba"`

- left=0 ('a'), right=8 ('a') → same  
  → skip prefix "aa", suffix "a" → left=2, right=7
- left=2 ('b'), right=7 ('b') → same  
  → skip 'b' and "bb" → left=3, right=5
- left=3 ('c'), right=5 ('c') → same  
  → skip 'c' and 'c' → left=4, right=4
- left=4 ('c') == right → single 'c' → length **3**

**Correct**.

The two-pointer approach simulates removing matching equal-character prefix/suffix pairs from both ends until no more removals are possible.

---

## Pitfalls & Edge Cases

- **All characters the same** → can remove everything (even length) or leave one (odd length)
- **Length 1** → cannot remove anything → return **1**
- **Alternating characters** (e.g., "abcabc") → may remove nothing
- **Large n (≤10⁵)** → O(n) is efficient
- **No possible removal** → return original length

All handled perfectly.

---

## Key Takeaway

This is a **beautifully greedy** two-pointer shrink:

- While **both ends match** → remove the entire run of that character from both sides
- Move pointers inward → continue skipping matching characters
- Remaining length = `right - left + 1` after maximal shrinking

**Pure, clean, optimal** — perfect minimum length after deleting similar ends.

---

# 519. Random Flip Matrix — Architectural Solution

---

##  Problem Statement
We are given an `m x n` binary matrix initialized with all zeros.  
We need to design an algorithm that:
- **flip()**: randomly selects a cell `(i, j)` where the value is `0`, returns it, and flips it to `1`.  
- **reset()**: resets all cells back to `0`.  

Constraints:
- 1 ≤ m, n ≤ 10⁴  
- At most 1000 calls to `flip()` and `reset()`  
- Each available cell must be equally likely to be chosen.

---

## Core Idea
Instead of storing the entire matrix (which could be huge), we:
- Flatten the matrix into a **1D array of length `m * n`**.  
- Maintain a **mapping (hash map)** to simulate "swapping" chosen indices with the last available index.  
- Each `flip()` picks a random index in `[0, total-1]`, where `total` is the number of remaining zeros.  
- After selection, we decrement `total` and update the map to avoid duplicates.  
- Convert the chosen 1D index back into `(row, col)` coordinates.  

This approach ensures:
- **Uniform randomness**  
- **O(1) time per operation**  
- **O(k) space**, where `k` is the number of flips performed.

---

##  Implementation (C#)
```csharp
using System;
using System.Collections.Generic;

public class Solution {
    private int m, n;
    private int total;
    private Random rand;
    private Dictionary<int, int> map;

    public Solution(int m, int n) {
        this.m = m;
        this.n = n;
        this.total = m * n;
        this.rand = new Random();
        this.map = new Dictionary<int, int>();
    }
    
    public int[] Flip() {
        int r = rand.Next(total);
        total--;

        int x = map.ContainsKey(r) ? map[r] : r;

        if (map.ContainsKey(total)) {
            map[r] = map[total];
        } else {
            map[r] = total;
        }

        return new int[] { x / n, x % n };
    }
    
    public void Reset() {
        total = m * n;
        map.Clear();
    }
}
```


##  Complexity Analysis
- **Time Complexity**
  - `flip()`: O(1) — constant-time random selection and dictionary update.
  - `reset()`: O(1) — clear state and restore total count.
- **Space Complexity**
  - O(k), where *k* = number of flips performed (≤ 1000 by constraint).  
  - No need to store the entire matrix of size `m * n`.

---

## Pitfalls & Edge Cases
- **Index conversion**  
  Must correctly map flattened 1D index → `(row, col)` using:
```
row = x / n
col = x % n
```


- **Random bias**  
Cannot simply pick random `(i, j)` and retry if already flipped — that introduces skew.  
The swap‑map approach ensures uniform probability.
- **Large matrix**  
Directly storing `m * n` cells is infeasible for large dimensions.  
Hash map swap trick is essential to keep memory proportional to flips.
- **Reset correctness**  
Must clear the map and restore `total = m * n` to guarantee all cells are available again.

---

##  Conclusion
This solution leverages a **flattened index space + hash map swap simulation**.  
It achieves uniform random selection with **O(1)** operations and minimal memory overhead.  

Architecturally, the design is clean:
- **Flatten** for simplicity of random selection.  
- **Hash map** for dynamic remapping of chosen indices.  
- **Reset** for state management and reuse.  

This design scales to very large matrices while staying efficient, elegant, and mathematically fair.

---



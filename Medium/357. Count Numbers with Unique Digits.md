## 🧩 Problem: Count Numbers with Unique Digits

### 📘 Description
Given an integer `n`, return the count of all numbers with **unique digits** `x`, where `0 <= x < 10ⁿ`.

---

### 📌 Constraints
- `0 <= n <= 8`
- We're counting numbers with **no repeated digits**
- Range is from `0` to `10ⁿ - 1`
- Leading zeros are allowed in the number (e.g. `01` is treated as `1`), but uniqueness is enforced across digits

---

### 🧠 What the problem gives us

#### Base Cases:
- `n = 0` → Only `0` is valid → return `1`
- `n = 1` → Digits `0–9` → all unique → return `10`

#### For `n = 2`:
- First digit: `9` options (`1–9`) — can't start with `0`
- Second digit: `9` options (excluding the first digit)
- Total 2-digit unique numbers: `9 × 9 = 81`
- Add base case: `10 + 81 = 91`

#### For `n = 3`:
- First digit: `9` options
- Second digit: `9` options
- Third digit: `8` options
- Total: `9 × 9 × 8 = 648`
- Cumulative: `10 + 81 + 648 = 739`

---

### 💡 Architectural Insight

This is **combinatorics with prefix simulation**, not DP.

We simulate the number of unique-digit numbers for each digit length `k` from `1` to `n`:

- For `k = 1`: `10` options (`0–9`)
- For `k = 2`: `9 × 9`
- For `k = 3`: `9 × 9 × 8`
- For `k = 4`: `9 × 9 × 8 × 7`
- ...
- For `k = n`: `9 × (10 - 1) × (10 - 2) × ... × (10 - (k - 1))`

We accumulate these into a running total `sum`.

---

### 🧾 Code Template

```csharp
public class Solution {
    public int CountNumbersWithUniqueDigits(int n) {
        if (n == 0) return 1;

        int sum = 10;     // Base case: n = 1 → 10 digits
        int prod = 9;     // First digit: 1–9

        for (int i = 1; i < n; i++) {
            prod *= (10 - i);  // Remaining digit choices
            sum += prod;
        }

        return sum;
    }
}
```


## 🔍 Detailed Breakdown: Count Numbers with Unique Digits

| **Component**        | **Purpose**                                                                                          | **Architectural Role**                                                                 |
|----------------------|------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|
| `sum = 10`           | Base case: all 1-digit numbers (`0–9`) are valid and unique                                          | Initializes total count for `n = 1`, anchors simulation                                |
| `prod = 9`           | First digit of multi-digit numbers can't be `0` → 9 options (`1–9`)                                  | Seeds the combinatorial chain for `n ≥ 2`                                              |
| `prod *= (10 - i)`   | At each step, reduce available digits (excluding already used ones)                                  | Simulates digit-wise uniqueness constraint via multiplicative chaining                 |
| `sum += prod`        | Accumulate count of valid numbers for current digit length                                           | Aggregates valid permutations into total count                                         |
| `return sum`         | Final count of all valid numbers in range `0 <= x < 10ⁿ`                                              | Terminates simulation and returns architectural invariant result                       |

---

## 💡 Core Idea

This is a **combinatorial simulation** problem, not dynamic programming.  
We simulate the number of valid numbers with unique digits for each digit length `k` from `1` to `n`.

### 🔢 Combinatoric Logic

For each digit length `k`:
- First digit: `9` options (`1–9`)
- Remaining digits: choose from unused digits in `0–9`
- Total permutations:  
  `9 × (10 - 1) × (10 - 2) × ... × (10 - (k - 1))`

This forms a **multiplicative chain** that reflects digit uniqueness.

---

## 🧠 Engineering Pattern

### 🧩 Pattern: Unique Digit Enumeration via Prefix Simulation

**Use Case**: Count numbers with non-repeating digits in a bounded range.

**Core Steps**:
1. Handle base case `n = 0` → return `1`
2. Initialize `sum = 10` for `n = 1`
3. Set `prod = 9` for first digit (excluding `0`)
4. Loop from `i = 1` to `n - 1`:
   - Multiply `prod *= (10 - i)` to simulate digit uniqueness
   - Accumulate `sum += prod`
5. Return `sum`

---

## 🧰 Reusable Insights

| **Pattern Element**              | **Generalization**                                                                 |
|----------------------------------|-------------------------------------------------------------------------------------|
| `prod *= (10 - i)`               | Permutation-based enumeration with decreasing choices                             |
| `sum += prod`                    | Aggregation of valid configurations across digit lengths                          |
| First digit ≠ `0`                | Common constraint in number generation problems                                   |
| Base case anchoring              | Ensures correctness for minimal input (`n = 0`, `n = 1`)                          |
| Loop over digit length           | Scalable simulation for bounded combinatoric spaces                               |

---

## ✅ Conclusions

- This task reinforces **prefix-based combinatoric simulation** with digit constraints.
- You now have a reusable template for:
  - Unique digit counting
  - Permutation-based enumeration
  - Overflow-safe simulation without recursion or DP
- This pattern generalizes to:
  - Generating actual numbers (via backtracking)
  - Counting numbers with exactly `k` unique digits
  - Applying similar logic to letters, symbols, or custom alphabets

**Architectural Signal**:  
The multiplicative chain `prod *= (10 - i)` is your invariant for uniqueness.  
The accumulation `sum += prod` is your structural aggregation.

This is a clean, scalable simulation — ideal for problems where **choices shrink with each step**.



---

# 1144. Decrease Elements To Make Array Zigzag — Architectural Greedy Two-Pattern Check  
*O(n) — Optimal Single Pass for Two Cases*

---

## Problem Statement

Given array `nums` of length n (1 ≤ n ≤ 1000).

A **move** = decrease any element by 1 (to ≥0? — no limit, but ≥1 originally).

**Zigzag array**:
- **Even-peak**: A[0] > A[1] < A[2] > A[3] < ...
- **Odd-peak**: A[0] < A[1] > A[2] < A[3] > ...

Return **minimum moves** to make `nums` zigzag (either pattern).

---

## Core Idea — Try Both Patterns, Take Min Cost

**Key insight**:
- Only **two possible** zigzag patterns
- For each pattern → compute **minimum moves** to satisfy all inequalities
- Greedy: for each position that violates → decrease to **just below** neighbor

**Two cases**:
1. **Even indices high** (0,2,4... > neighbors)
2. **Odd indices high** (1,3,5... > neighbors)

**For each case**:
- Iterate i from 0 to n-1
- If i even (for case 1) or odd (for case 2):
  - Must be > left and > right neighbor
  - If not → moves += max(0, max(left,right) - nums[i] + 1)
- Else (low position):
  - Must be < both neighbors → but we only decrease → only care about high positions

**Actually**: we only need to ensure **high positions** are greater than adjacent.

We **decrease only high positions** if needed.

---

##  Implementation (C#)

```csharp
public class Solution {
    public int MovesToMakeZigzag(int[] nums) {
        return Math.Min(Help(nums, 0), Help(nums, 1));
    }

    private int Help(int[] nums, int pos) {
        int res = 0;
        for (int i = pos; i < nums.Length; i += 2) {
            int a = (i > 0 ? nums[i - 1] : 1001);
            int b = (i + 1 < nums.Length ? nums[i + 1] : 1001);
            res += Math.Max(0, nums[i] - Math.Min(a, b) + 1);
        }
        return res;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Two passes over array                          |
| **Space Complexity**  | **O(1)**      | Only variables                                 |

**Optimal** — linear time.

---

## Why This Works — Example Walkthrough

**Input**: `nums = [9,6,1,6,2]`

- **Even peaks** (indices 0,2,4 should be > neighbors):
  - i=0: 9 > 6 → ok (0 moves)
  - i=2: 1 ≤ min(6,6)=6 → need at least 7 → moves += **6**
  - i=4: 2 (end, only left neighbor 6) → 2 ≤ 6 → need 7 → moves += **5**
  - Total even = **11**

- **Odd peaks** (indices 1,3 should be > neighbors):
  - i=1: 6 ≥ min(9,1) → ok
  - i=3: 6 ≥ min(1,2) → ok
  - No moves needed? Wait — but we decrease only peaks if needed
  - Actually: to make low positions < peaks → decrease lows? No — we only decrease peaks
  - Correct calc: for odd peaks → decrease even positions if needed
  - i=0: 9 → neighbors 6 → 9 > 6 → ok
  - i=2: 1 → neighbors 6,6 → 1 < 6 → ok (low)
  - i=4: 2 → neighbor 6 → 2 < 6 → ok
  - Total odd = **0**? Wait — example says 4

**Correct calculation** (standard):

- **Even high**: decrease odd positions to be < both neighbors
- **Odd high**: decrease even positions

**Real**:
- For **even peaks** → decrease odd i to be < min(left,right peak)
- For **odd peaks** → decrease even i

**Example**:
- Odd peaks: decrease even positions:
  - i=0: 9 → right 6 → need <6 → decrease to 5 → **4 moves**
  - i=2: 1 → left 6, right 6 → need <6 → already 1 → 0
  - i=4: 2 → left 6 → need <6 → already → 0
- Total **4**

**Correct** — 4 moves.

---

## Key Takeaway

This is a **beautifully greedy** dual-pattern problem:

- **Two independent cases** → even or odd indices as peaks
- **For each case** → decrease the **low** positions to be strictly less than both adjacent peaks
- **Take minimum** cost
**Pure, clean, optimal** — perfect zigzag transformation.

---

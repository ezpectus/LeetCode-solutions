# 2182. Construct String With Repeat Limit  
*O(n log 26) — Greedy + Frequency Count + Max-Heap / Sorted Approach*

---

## Problem Statement

You are given a string `s` and an integer `repeatLimit`.  

Construct a new string `repeatLimitedString` using the characters from `s` (you do **not** have to use all of them) such that:

- No letter appears **more than `repeatLimit` times consecutively**
- The resulting string is **lexicographically largest** possible

Return this string.  
If impossible (e.g. only one character and repeatLimit=0), any valid string is acceptable, but in practice the greedy always works.

**Examples**:

**Example 1**: s = "cczazcc", repeatLimit = 3  
Output: **"zzcccac"**  
- 'z' ×2, 'c' ×3, 'a' ×1, 'c' ×1  
- No letter exceeds 3 in a row, lexicographically maximal

**Example 2**: s = "aababab", repeatLimit = 2  
Output: **"bbabaa"**  
- Uses some characters, 'b'×2, 'a'×2, 'b'×1, 'a'×2 — valid and maximal

**Constraints**:
- 1 ≤ repeatLimit ≤ s.length ≤ 10⁵
- s contains only lowercase English letters

---

## Core Idea — Greedy: Always Pick Largest Possible Letter (with repeat limit)

**Key insight**:
- To get the **lexicographically largest** string → always prefer the **largest available letter** at each step
- But cannot place the same letter more than `repeatLimit` times in a row
- Use a **frequency count** (array or map) of remaining characters
- At each position:
  - Try the **largest letter** that still has count > 0
  - If it would exceed repeatLimit streak → try the **next largest**, and so on
  - Decrease its count after placing

**Efficient way**:
- Count frequency of each letter (array of size 26)
- Build result string greedily:
  - Track current streak letter and count
  - Always try from 'z' down to 'a'
  - Skip if count=0 or same as current streak and streak==repeatLimit
  - Place the first valid one, update streak

**Time**: O(n × 26) → O(n) since 26 is constant  
**Space**: O(1) extra (fixed 26 letters)

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public string RepeatLimitedString(string s, int repeatLimit){
        // Frequency count of each letter
        int[] freq = new int[26];
        foreach (char c in s) freq[c - 'a']++;
        
        StringBuilder result = new StringBuilder();
        char lastChar = '\0';
        int streak = 0;

        while (result.Length < s.Length){
            bool placed = false;

            // Try from 'z' down to 'a'
            for (int i = 25; i >= 0; i--){
                if (freq[i] == 0) continue;
                char candidate = (char)('a' + i);

                // Can place this letter?
                if (candidate == lastChar && streak >= repeatLimit) continue; // cannot continue streak

                // Place it
                result.Append(candidate);
                freq[i]--;

                if (candidate == lastChar) streak++;
                else{
                    lastChar = candidate;
                    streak = 1;
                }

                placed = true;
                break;
            }

            // If no letter could be placed → impossible to continue (but problem guarantees possible)
            if (!placed) break;
        }

        return result.ToString();
    }
}
```

## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n × 26) ≈ O(n)** | Building frequency count: O(n)<br>Main loop runs at most n times<br>Each iteration scans up to 26 letters in worst case → total O(26n) = O(n) |
| **Space Complexity**  | **O(1)**      | Fixed-size frequency array (26 letters)<br>StringBuilder for result (output space not counted) |

**Optimal** — linear time, constant extra space — perfect and extremely efficient for n ≤ 10⁵.

---

## Why This Works — Example Walkthrough

**Example 1**: s = "cczazcc", repeatLimit = 3

**Frequency**: a:1, c:4, z:2

**Greedy construction** (always pick largest possible letter without breaking streak limit):

- Start: lastChar = none, streak = 0
- Try 'z' → place 'z' → result = "z", z:1 left, streak=1
- Try 'z' → place 'z' → result = "zz", z:0 left, streak=2
- Try 'c' → place 'c' → result = "zzc", c:3 left, streak=1 (new char)
- Try 'c' → place 'c' → result = "zzcc", c:2 left, streak=2
- Try 'c' → place 'c' → result = "zzccc", c:1 left, streak=3
- Try 'a' → place 'a' → result = "zzccca", a:0 left, streak=1 (new char)
- Try 'c' → place 'c' → result = "zzcccac", c:0 left, streak=1

Final: **"zzcccac"** → correct, lexicographically largest, no letter repeats >3 times consecutively.

**Correct** —  
At every position, we **greedily choose the largest possible letter** (from 'z' to 'a') that:
- Still has remaining count > 0
- Does not violate the repeatLimit when continuing the current streak

This ensures we always push the **highest possible character** as early as possible while respecting the constraint.

---

## Key Takeaway

This is a **classic greedy lexicographical construction** problem with a repeat constraint:

* Count frequency of each character (array of size 26)
* Build result string **greedily** from left to right
* At each step:
  * Try letters from **'z' down to 'a'**
  * Skip if no more occurrences left (count=0)
  * Skip if same as previous letter and streak would exceed repeatLimit
  * Place the first valid letter, update count & streak
* This always produces the **lexicographically largest** valid string

**Pure, clean, optimal** — O(n) time, O(1) extra space (fixed 26 letters), very fast, intuitive, and guaranteed correct.

---

# 1145. Binary Tree Coloring Game — Architectural Subtree Size Analysis  
*O(n) — Optimal Single DFS Pass*

---

## Problem Statement

Given odd-sized binary tree with unique values 1 to n.

Two players:
- Player 1 picks node `x` → colors it **red**
- Player 2 (you) picks node `y ≠ x` → colors it **blue**

Players alternate coloring **uncolored adjacent** nodes (parent/left/right).

Player unable to move — passes.  
Both pass → game ends.

**Winner** = player with **more colored nodes**.

You are **Player 2** — return `true` if you can **guarantee a win** by choosing optimal `y`.

---

## Core Idea — Win Condition via Subtree Control

**Key insight**:
- Total nodes = n (odd) → majority = (n+1)/2
- Player 2 wins if can control **at least (n+1)/2** nodes
- The tree is split by node `x` into:
  - **Left subtree** of x
  - **Right subtree** of x
  - **Parent side** (rest of tree above x)

**Player 2 wins** if can pick `y` such that:
- `y` is **root** of one of these three parts
- That part has **size ≥ (n+1)/2**

Because:
- Player 2 starts in that component → can color all of it (opponent cannot enter without connection)
- If size ≥ majority → Player 2 wins

**So**: just find sizes of left/right/parent components of `x` → check if any ≥ (n+1)/2

---

##  Implementation (C#)

```csharp
public class Solution {
    private int leftSize, rightSize;

 public bool BtreeGameWinningMove(TreeNode root, int n, int x) {
        CountSubtree(root, x);

        int parentSide = n - (leftSize + rightSize + 1);
        int maxComp = Math.Max(leftSize, Math.Max(rightSize, parentSide));

        return maxComp > n / 2;
    }

private int CountSubtree(TreeNode node, int x) {
        if (node == null) return 0;

        int left = CountSubtree(node.left, x);
        int right = CountSubtree(node.right, x);

        if (node.val == x) {
            leftSize = left;
            rightSize = right;
        }

        return left + right + 1;
    }
}
```
## Complexity

| **Metric**            | **Value**     | **Notes**                                      |
|-----------------------|---------------|------------------------------------------------|
| **Time Complexity**   | **O(n)**      | Single DFS traversal                           |
| **Space Complexity**  | **O(h)**      | Recursion stack (h = tree height ≤ n)          |

**Optimal** — one pass to compute all subtree sizes.

---

## Why This Works — Example Walkthrough

**Input**: `root = [1,2,3,4,5,6,7,8,9,10,11]`, `n=11`, `x=3`

- DFS computes subtree sizes:
  - Left of 3: size **4** (nodes 4,5,8,9)
  - Right of 3: size **2** (nodes 6,7)
  - Node 3 itself: **1**
- Parent side = total n - (left + right + 1) = 11 - (4 + 2 + 1) = **4**

- Three possible components Player 2 can control:
  - Left subtree of x: **4**
  - Right subtree of x: **2**
  - Parent side (everything above x): **4**

- Majority needed = (11+1)/2 = **6**
- Max component = **4** < 6 → Player 2 **cannot** take a component with ≥6 nodes

Standard example tree:
```
1
/ \
2   3
/ \   \
4   5   6
/ \     / 
7   8   9  10
/
11
```

- x=3 → left empty, right=6 (with 9,10)
- Actual sizes depend on tree structure.
If **any** of them has size ≥ (n+1)/2 → Player 2 picks the **root** of that component (parent of x, or root of left/right subtree) → controls the entire component → wins.


---

## Pitfalls & Edge Cases

- **Root is x** → parent side = 0
- **Leaf is x** → subtrees small, parent side large
- **n=3** → majority 2 → easy win for Player 2
- **Balanced tree** → often no win

All handled perfectly.

---

## Key Takeaway

This is a **beautifully simple** game theory insight:

- Removing node `x` splits tree into **exactly three** components
- Player 2 wins if can **start** in a component with **majority** nodes
- **One DFS** → compute left/right subtree sizes → parent side = n - (left + right + 1)
- Check if max ≥ (n+1)/2

**Pure, clean, optimal** — perfect tree game analysis.

---

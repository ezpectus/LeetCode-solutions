# 2217. Find Palindrome With Fixed Length  
*O(queries.length + log(10^intLength)) — Math Construction + Digit Manipulation*

---

## Problem Statement

Given an integer array `queries` and a positive integer `intLength`, return an array `answer` where:

- `answer[i]` = the `queries[i]`-th smallest **positive palindrome** of **exactly** length `intLength`
- or `-1` if no such palindrome exists

**Palindrome** — number that reads the same forwards and backwards, **no leading zeros**.

**Examples**:

**Example 1**  
queries = [1,2,3,4,5,90], intLength = 3  
Output: [101,111,121,131,141,999]

**Example 2**  
queries = [2,4,6], intLength = 4  
Output: [1111,1331,1551]

**Constraints**:
- 1 ≤ queries.length ≤ 5·10⁴
- 1 ≤ queries[i] ≤ 10⁹
- 1 ≤ intLength ≤ 15

---

## Core Idea — Math Construction of Palindromes

**Key insight**:
- Palindromes of fixed length `intLength` are completely determined by their **first half** (including middle for odd length)
- No leading zeros → first digit 1–9
- For even length: first half mirrors to second half
- For odd length: first half (including middle) mirrors around center

**Number of palindromes of length L**:
- Even L = 2k: first k digits (first ≠0) → 9×10^(k-1)
- Odd L = 2k+1: first k+1 digits (first ≠0) → 9×10^k

We can **generate the k-th palindrome** directly using math (no enumeration).

**Algorithm** (for each query independently):
1. If `intLength == 1`:
   - 1st to 9th: "1" to "9"
   - >9 → -1
2. Compute half length:
   - `halfLen = (intLength + 1) / 2`
3. The **first half** (including middle for odd) ranges from `10^(halfLen-1)` to `10^halfLen - 1` (first digit 1–9)
4. Number of valid palindromes = `9 × 10^(halfLen-1)`
5. If `query > number of palindromes` → -1
6. Else:
   - Find the `query`-th half number: `start = 10^(halfLen-1)` + query - 1
   - Convert `start` to string → mirror to form full palindrome
   - For odd length: remove last digit before mirroring

**Time**: O(queries.length × intLength) — string operations are small (≤15)
**Space**: O(1) per query

---

## Clean Implementation (C#)

```csharp
public class Solution{
    public long[] KthPalindrome(int[] queries, int intLength){
        long[] answer = new long[queries.Length];

        // Number of palindromes of this length
        int halfLen = (intLength + 1) / 2;
        long totalPalindromes = 9L * (long)Math.Pow(10, halfLen - 1);

        for (int q = 0; q < queries.Length; q++){
            long k = queries[q];

            // If query too large
            if (k > totalPalindromes){
                answer[q] = -1;
                continue;
            }

            // The k-th half (1-based) starts from 10^(halfLen-1)
            long firstHalf = (long)Math.Pow(10, halfLen - 1) + k - 1;

            // Build the palindrome
            string left = firstHalf.ToString();
            string right = new string(left.Reverse().ToArray());

            // For odd length, remove the last digit from right (middle is already in left)
            if (intLength % 2 == 1) right = right.Substring(1);
            
            string palindromeStr = left + right;

            // Convert to long
            answer[q] = long.Parse(palindromeStr);
        }

        return answer;
    }
}
```

## Complexity

| **Metric**            | **Value**                  | **Notes**                                                                 |
|-----------------------|----------------------------|---------------------------------------------------------------------------|
| **Time Complexity**   | **O(queries.length × intLength)** | For each query: generating the half string and mirroring takes O(intLength)<br>intLength ≤ 15 → very fast |
| **Space Complexity**  | **O(1)**                   | Only a few variables + temporary strings of length ≤ 15 (constant space)  |

**Optimal** — extremely fast even for maximum constraints (5·10⁴ queries × 15 = ~7.5·10⁵ operations).

---

## Why This Works — Example Walkthrough

**Example 1**: queries = [1,2,3,4,5,90], intLength = 3

- halfLen = (3+1)/2 = **2**
- totalPalindromes = 9 × 10^(2-1) = **90**
- First valid half starts at **10** (for k=1)

Step-by-step:

- k=1 → firstHalf = 10 → string "10" → mirror "01" → odd length → remove last digit of mirror → "1" → result **"101"**
- k=2 → firstHalf = 11 → "11" → mirror "11" → remove last → "1" → **"111"**
- k=3 → 12 → "12" → mirror "21" → remove last → "2" → **"121"**
- k=4 → 13 → "13" → mirror "31" → remove last → "3" → **"131"**
- k=5 → 14 → "14" → mirror "41" → remove last → "4" → **"141"**
- k=90 → 99 → "99" → mirror "99" → remove last → "9" → **"999"**

All results match the example perfectly.

**Correct** —  
We mathematically construct the k-th palindrome directly:
- Compute how many digits in the first half (including middle for odd length)
- Start from smallest valid first half (10^(halfLen-1))
- Take the k-th such number
- Convert to string → mirror → for odd length, exclude the last digit of the mirrored part (middle is already included)
- This ensures **no leading zeros**, **exact length**, and correct ordering

---

## Key Takeaway

This is a **beautiful mathematical palindrome construction** problem:

* For fixed length L, total palindromes = **9 × 10^((L+1)/2 - 1)**
* The k-th palindrome is built from the k-th valid **first half** number, starting from **10^((L+1)/2 - 1)**
* Steps:
  1. Compute halfLen = (L + 1) / 2
  2. firstHalf = 10^(halfLen-1) + k - 1
  3. Convert firstHalf to string
  4. Mirror it → for odd L, remove last digit of mirrored part
  5. Concatenate → get the palindrome
* If k > total palindromes → return -1

**Pure, clean, optimal** — O(queries × L) time, O(1) space, blazing fast, elegant math solution, handles odd/even lengths, large k, and intLength=1 perfectly.

---
